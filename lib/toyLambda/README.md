# Toy Lambda Calculus
Contains a lexer, parser, interpreter and an application of the First and Second Futamura projections on the interpreter. 
* The lexer tokenises and checks for incorrect syntax.
* The parser takes a string of code representing a program and produces an abstract syntax tree.
* The interpreter takes a string representing a lambda calculus program and goes through the parse tree generated by the parser to evaluate the value returned by the lambda term.
* The first Futamura projection works based on the interpreter above, by running Prepack on the source code.
* The second Futamura projection has been attempted in two ways: by running Prepack on a bundle of Prepack and the interpreter (which fails due to Prepack limitation), or by running Google Closure on a bundle of Prepack and the interpreter.

## About the language
The toy language is an implementation of lambda calculus, allowing I/O and returning lambda abstractions (i.e. functions in JavaScript). It allows the following:

* Lambda application: `(λx.x+1) @ 1` (evaluates to 1)
* Nested lambda abstractions: `(λx.(λy. x < y)) @ 1 @ 2` (evaluates to `true`)
* Defined lambdas: `let incr = λx.x+1 in (λx. incr @ x) @ 1` (evaluates to 2)
* Exporting abstractions: `let incr = λx. x + 1 in incr`
* Printing: `(λx.print @ x) @ 1` (prints 1 but evaluates to `true`)
* Reading: `(λx.x) @ read` (evaluates to whatever **number** the user has provided)
* Recursion: `let rec f = λx. λsum. (x < 10 && (f @ (x + 1)) @ (sum + x)) || sum in (f @ 1) @ 0`  (evaluates to 45)

Amongst the examples available in the `../input/toyLambda` folder there are fourteen programs displaying the capabilities of the language.

## CLI functionality
1. Parser: `-p <filePath>`.
2. Interpreter: `-i <filePath>`.
3. Compiler: `-c <filePath> [-s value]`.
4. Generate specialised interpreter with the help of the First Futamura Projection: `-1 <filePath> [-s value]`.
5. Generate a compiler with the help of the Second Futamura Projection: `-2 -o`.