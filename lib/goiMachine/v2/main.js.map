{"version":3,"sources":["webpack://Machine/webpack/bootstrap","webpack://Machine/../viz/CBV-with-CBV-embedding/js/goi-machine.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/graph.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/group.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/link.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/node.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/atom.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/contract.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/op.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/and.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/bool.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/equals.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/if.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/int.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/not.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/or.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/plus.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/ops/times.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/nodes/start.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/parser/ast.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/parser/lexer.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/parser/parser.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/parser/token.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/term.js","webpack://Machine/../viz/CBV-with-CBV-embedding/js/token.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;;AAEA,mCACC;AACD,aAAa,mBAAO,CAAC,wDAAO;;AAE5B,iBAAiB,mBAAO,CAAC,+DAAS;AAClC,kBAAkB,mBAAO,CAAC,qEAAe;AACzC,gBAAgB,mBAAO,CAAC,mEAAa;AACrC,kBAAkB,mBAAO,CAAC,qEAAe;AACzC,cAAc,mBAAO,CAAC,iEAAW;;AAEjC,cAAc,mBAAO,CAAC,sEAAc;AACpC,eAAe,mBAAO,CAAC,wEAAe;;AAEtC,qBAAqB,mBAAO,CAAC,wDAAO;AACpC,aAAa,mBAAO,CAAC,sDAAM;;AAE3B,cAAc,mBAAO,CAAC,wDAAO;AAC7B,cAAc,mBAAO,CAAC,wDAAO;AAC7B,aAAa,mBAAO,CAAC,sDAAM;;AAE3B,aAAa,mBAAO,CAAC,kEAAY;AACjC,iBAAiB,mBAAO,CAAC,0EAAgB;AACzC,cAAc,mBAAO,CAAC,oEAAa;AACnC,WAAW,mBAAO,CAAC,8DAAU;;AAE7B,cAAc,mBAAO,CAAC,wEAAe;AACrC,eAAe,mBAAO,CAAC,0EAAgB;AACvC,eAAe,mBAAO,CAAC,0EAAgB;AACvC,gBAAgB,mBAAO,CAAC,4EAAiB;AACzC,cAAc,mBAAO,CAAC,wEAAe;AACrC,aAAa,mBAAO,CAAC,sEAAc;AACnC,cAAc,mBAAO,CAAC,wEAAe;AACrC,iBAAiB,mBAAO,CAAC,8EAAkB;AAC3C,aAAa,mBAAO,CAAC,sEAAc;;AAEnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE;AAAA,oGACD;;;;;;;;;;;;AC9PD;AACA,mCAAO;;AAEP,aAAa,mBAAO,CAAC,wDAAO;;AAE5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB;AACxB,iDAAiD;AACjD;AACA,iDAAiD;AACjD,6BAA6B;AAC7B,0BAA0B;AAC1B,yBAAyB;AACzB;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACzEF;AACA,mCAAgB;;AAEhB,YAAY,mBAAO,CAAC,sDAAM;;AAE1B;;AAEA;AACA,2BAA2B;AAC3B;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,EAAE;;AAEZ;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACnDF,qEAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA,0BAA0B;AAC1B,+BAA+B;AAC/B,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACtHF;;AAEA,mCAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACxGF,qEAAO;;AAEP,YAAY,mBAAO,CAAC,wDAAO;AAC3B,YAAY,mBAAO,CAAC,sDAAM;;AAE1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AChBF,qEAAwB;;AAExB,YAAY,mBAAO,CAAC,wDAAO;AAC3B,YAAY,mBAAO,CAAC,sDAAM;AAC1B,YAAY,mBAAO,CAAC,kEAAY;AAChC,UAAU,mBAAO,CAAC,8DAAU;AAC5B,YAAY,mBAAO,CAAC,sDAAM;AAC1B,YAAY,mBAAO,CAAC,sDAAM;AAC1B,aAAa,mBAAO,CAAC,wDAAO;;AAE5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA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ACvFF,qEAAO;;AAEP,aAAa,mBAAO,CAAC,sEAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,6BAA6B,KAAK,WAAW,iBAAiB;AAC9F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACzLF,qEAAO;;AAEP,aAAa,mBAAO,CAAC,sEAAc;AACnC,WAAW,mBAAO,CAAC,+DAAS;AAC5B,iBAAiB,mBAAO,CAAC,qEAAe;AACxC,eAAe,mBAAO,CAAC,mEAAa;AACpC,iBAAiB,mBAAO,CAAC,qEAAe;AACxC,aAAa,mBAAO,CAAC,iEAAW;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACpIF,qEAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACzCF;;AAEA,mCAAe;;AAEf,aAAa,mBAAO,CAAC,wDAAO;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,uCAAuC;AACvC;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AChDF,qEAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"../viz/CBV-with-CBV-embedding/js/goi-machine.js\");\n","var graph = null;\n\ndefine('goi-machine',\n\tfunction(require) {\n\t\tvar Flag = require('token').RewriteFlag();\n\n\t\tvar Variable = require('ast/var');\n\t\tvar Operation = require('ast/operation');\n\t\tvar Binding = require('ast/binding');\n\t\tvar Reference = require('ast/reference');\n\t\tvar Thunk = require('ast/thunk');\n\n\t\tvar Lexer = require('parser/lexer');\n\t\tvar Parser = require('parser/parser');\n\n\t\tvar MachineToken = require('token');\n\t\tvar Link = require('link');\n\n\t\tvar Graph = require('graph');\n\t\tvar Group = require('group');\n\t\tvar Term = require('term');\n\n\t\tvar Atom = require('nodes/atom');\n\t\tvar Contract = require('nodes/contract');\n\t\tvar Start = require('nodes/start');\n\t\tvar Op = require('nodes/op');\n\n\t\tvar IntOp = require('nodes/ops/int');\n\t\tvar BoolOp = require('nodes/ops/bool');\n\t\tvar PlusOp = require('nodes/ops/plus');\n\t\tvar TimesOp = require('nodes/ops/times');\n\t\tvar AndOp = require('nodes/ops/and');\n\t\tvar OrOp = require('nodes/ops/or');\n\t\tvar NotOp = require('nodes/ops/not');\n\t\tvar EqualsOp = require('nodes/ops/equals');\n\t\tvar IfOp = require('nodes/ops/if');\n\n\t\tclass GoIMachine {\n\n\t\t\tconstructor() {\n\t\t\t\tthis.setMachine(new Graph(),new MachineToken(),0);\n\t\t\t}\n\n\t\t\tsetMachine(graphSet,tokenSet,countSet) {\n\t\t\t\tthis.graph = graphSet;\n\t\t\t\tgraph = this.graph; // cheating!\n\t\t\t\tthis.token = tokenSet;\n\t\t\t\tthis.count = countSet;\n\t\t\t}\n\n\t\t\tcompile(source) {\n\t\t\t\tconst lexer = new Lexer(source + '\\0');\n\t\t\t\tconst parser = new Parser(lexer);\n\t\t\t\tconst ast = parser.parse();\n\t\t\t\tthis.count = 0;\n\n\t\t\t\tthis.graph.clear();\n\t\t\t\tvar start = new Start().addToGroup(this.graph.child);\n\t\t\t\tvar term = this.toGraph(ast, this.graph.child, false);\n\t\t\t\tvar link = new Link(start.key, term.prin.key, \"_\", \"_\").addToGroup(this.graph.child);\n\t\t\t\tthis.token.reset(link);\n\t\t\t}\n\n\t\t\t// translation\n\t\t\ttoGraph(ast, group) {\n\t\t\t\tvar graph = this.graph;\n\n\t\t\t\tvar term = new Term().addToGroup(group);\n\t\t\t\tif (ast instanceof Thunk) {\n\t\t\t\t\tterm.box();\n\t\t\t\t\tast = ast.inner;\n\t\t\t\t}\n\n\t\t\t\t// VARIABLES & ATOMS\n\t\t\t\tif (ast instanceof Variable) {\n\t\t\t\t\tvar auxs = [];\n\t\t\t\t\tfor (var i = 0; i < ast.ctx.length; i++) {\n\t\t\t\t\t\tvar c = new Contract().addToGroup(term);\n\t\t\t\t\t\tauxs.push(c);\n\t\t\t\t\t\tif ((ast.ctx[i]).name == ast.name)\n\t\t\t\t\t\t \tvar prin = c;\n\t\t\t\t\t}\n\t\t\t\t\tterm.set(prin, auxs);\n\n\t\t\t\t// BINDINGS & REFERENCES\n\t\t\t\t} else if ((ast instanceof Binding) || (ast instanceof Reference))  {\n\t\t\t\t\tvar body = this.toGraph(ast.body, term, false).addToGroup(term);\n\t\t\t\t\tvar param = this.toGraph(ast.param, term, false).addToGroup(term);\n\n\t\t\t\t\tvar auxs = body.auxs;\n\t\t\t\t\tvar auxNode = auxs[0];\n\t\t\t\t\tauxs.splice(0,1)\n\t\t\t\t\tauxs = auxs.concat(param.auxs);\n\n\t\t\t\t\tif (ast instanceof Reference) {\n\t\t\t\t\t\tvar atomNode = new Atom(\"a\").addToGroup(param);\n\t\t\t\t\t\tnew Link(atomNode.key, param.prin.key, \"_\", \"_\").addToGroup(param);\n\t\t\t\t\t\tparam.prin = atomNode;\n\t\t\t\t\t}\n\t\t\t\t\tnew Link(auxNode.key, param.prin.key, \"_\", \"_\").addToGroup(term);\n\n\t\t\t\t\tauxs = Contract.createDNet(ast.ctx.length, auxs, term);\n\t\t\t\t\tterm.set(body.prin, auxs);\n\n\t\t\t\t// OPERATIONS\n\t\t\t\t} else if (ast instanceof Operation) {\n\t\t\t\t\tvar op = this.toOp(ast.name,ast.active).addToGroup(term);\n\n\t\t\t\t\tvar auxs = [];\n\n\t\t\t\t\tvar next;\n\t\t\t\t\tfor (var i = 0; i < ast.sig[0]; i++) {\n\t\t\t\t\t\tnext = this.toGraph(ast.eas[i], term).addToGroup(term);\n\t\t\t\t\t\tnew Link(op.key, next.prin.key, \"_\", \"_\").addToGroup(term);\n\t\t\t\t\t\tauxs = auxs.concat(next.auxs);\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = 0; i < ast.sig[1]; i++) {\n\t\t\t\t\t\tnext = this.toGraph(ast.das[i], term).addToGroup(term);\n\t\t\t\t\t\tvar link = new Link(op.key, next.prin.key, \"_\", \"_\");\n\t\t\t\t\t\tlink.visited = true; // hacking\n\t\t\t\t\t\tlink.addToGroup(term);\n\t\t\t\t\t\tauxs = auxs.concat(next.auxs);\n\t\t\t\t\t}\n\n\t\t\t\t\tauxs = Contract.createDNet(ast.ctx.length, auxs, term, op);\n\t\t\t\t\tterm.set(op, auxs);\n\t\t\t\t}\n\t\t\t\treturn term;\n\t\t\t}\n\n\t\t\ttoOp(name,active) {\n\t\t\t\tif (Number.isInteger(parseInt(name))) {\n\t\t\t\t\treturn new IntOp(name);\n\t\t\t\t} else if (name == \"true\" || name == \"false\") {\n\t\t\t\t\treturn new BoolOp(name);\n\t\t\t\t} else if (name == \"+\") {\n\t\t\t\t\treturn new PlusOp();\n\t\t\t\t} else if (name == \"*\") {\n\t\t\t\t\treturn new TimesOp();\n\t\t\t\t} else if (name == \"∧\") {\n\t\t\t\t\treturn new AndOp();\n\t\t\t\t} else if (name == \"∨\") {\n\t\t\t\t\treturn new OrOp();\n\t\t\t\t} else if (name == \"¬\") {\n\t\t\t\t\treturn new NotOp();\n\t\t\t\t} else if (name == \"==\") {\n\t\t\t\t\treturn new EqualsOp();\n\t\t\t\t} else if (name == \"if\") {\n\t\t\t\t\treturn new IfOp();\n\t\t\t\t} else {\n\t\t\t\t\treturn new Op(name,active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tquotieningRules() {\n\t\t\t\t// TODO\n\t\t\t\t// Loop through all links in the graph\n\t\t\t\t// Perform quotiening rules\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// machine step\n\t\t\ttransition(graphTxt, linkTxt, flagTxt) {\n\t\t\t\tif (!finished) {\n\t\t\t\t\tthis.count++;\n\t\t\t\t\tvar node = this.graph.findNodeByKey(this.token.link.to);\n\n\t\t\t\t\tvar nextLink;\n\t\t\t\t\tif (this.token.rewriteFlag == Flag.REWRITE) {\n\t\t\t\t\t\tnextLink = node.rewrite(this.token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextLink = this.pass(this.token);\n\t\t\t\t\t}\n\t\t\t\t\tif (nextLink != null) {\n\t\t\t\t\t\tthis.token.setLink(nextLink);\n\t\t\t\t\t\tthis.printHistory(graphTxt, linkTxt, flagTxt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.token.setLink(null);\n\t\t\t\t\t\tplay = false;\n\t\t\t\t\t\tplaying = false;\n\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintHistory(graphTxt, linkTxt, flagTxt) {\n\t\t\t\tgraphTxt.val(this.graph.draw().replace(/\\n/g, \"\") + '\\n' + graphTxt.val());\n\t\t\t\tlinkTxt.val(this.token.link + '\\n' + linkTxt.val());\n\t\t\t\tflagTxt.val(this.token.rewriteFlag + '\\n' + flagTxt.val());\n\t\t\t}\n\n\t\tpass(token) { // this needs cleaning up!\n\t\t\tvar link = token.link;\n\t\t\tif (token.rewriteFlag == Flag.SEARCH) {\n\t\t\t\tvar to = this.graph.findNodeByKey(link.to);\n\t\t\t\tvar outlinks = to.findLinksOutOf();\n\t\t\t\tif (to instanceof Atom) {\n\t\t\t\t\ttoken.rewriteFlag = Flag.RETURN;\n\t\t\t\t\treturn link;\n\t\t\t\t} else if (to instanceof Op) {\n\t\t\t\t\tif (outlinks.length == 0) {\n\t\t\t\t\t\tif (to.active) {\n\t\t\t\t\t\t\ttoken.rewriteFlag = Flag.REWRITE;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.rewriteFlag = Flag.RETURN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn link;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn outlinks[0];\n\t\t\t\t\t}\n\t\t\t\t} else if (to instanceof Contract) {\n\t\t\t\t\ttoken.rewriteFlag = Flag.REWRITE;\n\t\t\t\t\treturn link;\n\t\t\t\t}\n\t\t\t} else if (token.rewriteFlag == Flag.RETURN) {\n\t\t\t\tvar from = this.graph.findNodeByKey(link.from);\n\t\t\t\tvar outlinks = from.findLinksOutOf();\n\t\t\t\tif (this.doneVisiting(link,outlinks)) { // HACKING\n\t\t\t\t\tif (from.active) {\n\t\t\t\t\t\ttoken.rewriteFlag = Flag.REWRITE;\n\t\t\t\t\t\treturn from.findLinksInto()[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoken.rewriteFlag = Flag.RETURN;\n\t\t\t\t\t\treturn from.findLinksInto()[0];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\t\t\tvar j = this.findJ(link,outlinks);\n\t\t\t\t\treturn outlinks[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn link;\n\t\t}\n\n\t\tdoneVisiting(link, links) {\n\t\t\tfor (let l of links) {\n\t\t\t\tif ((!l.visited) && (l != link))\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\treturn true;\n\t\t\t}\n\n\t\tfindJ(link,list) {\n\t\t\tfor (var j = 0; j < list.length; j++) {\n\t\t\t\tif ((!list[j].visited) && (list[j] != link))\n\t\t\t\t\treturn j;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t\treturn GoIMachine;\n\t}\n);\n","// general graph\ndefine(function(require) {\n\n\tvar Group = require('group');\n\n\tclass Graph {\n\n\t\tconstructor() {\n\t\t\tthis.clear();\n\t\t}\n\n\t\tclear() {\n\t\t\tthis.key = 0;\n\t\t\tthis.linkKey = 0;\n\t\t\tthis.allNodes = new Map(); // for efficiency searching\n\t\t\tthis.allLinks = []; // for printing ONLY\n\t\t\tthis.child = new Group();\n\t\t}\n\n\t\t// give a key to a node and add it to allNodes\n\t\taddNode(node) {\n\t\t\tnode.key = 'nd' + this.key;\n\t\t\tthis.allNodes.set(node.key, node);\n\t\t\tthis.key++;\n\t\t}\n\n\t\t// also removes connected links\n\t\tremoveNode(node) {\n\t\t\tfor (let link of Array.from(node.findLinksConnected())) {\n\t\t\t\tlink.delete();\n\t\t\t}\n\t\t\treturn this.allNodes.delete(node.key);\n\t\t}\n\n\t\tfindNodeByKey(key) {\n\t\t\treturn this.allNodes.get(key);\n\t\t}\n\n\t\taddLink(link) {\n\t\t\tthis.allLinks.push(link);\n\t\t}\n\n\t\tremoveLink(link) {\n\t\t\tthis.allLinks.splice(this.allLinks.indexOf(link), 1);\n\t\t}\n\n\t\tfindLinkByKeys(from,to) {\n\t\t\tvar fromNode = this.findNodeByKey(from);\n\t\t\treturn fromNode.findLinksOutOf().filter(x => x.to == to)[0];\n\t\t}\n\n\t\tdraw(width, height) {\n\t\t\tvar str = this.child.draw('\\n  ');\n\t\t\tstr += '\\n';\n\t\t\tfor (let link of this.allLinks) {\n\t\t\t\tstr += link.draw('\\n  ');\n\t\t\t}\n\t\t\treturn 'digraph G {'\n\t\t\t   \t+'\\n  rankdir=BT;'\n\t\t\t   \t+'\\n  edge[arrowhead=none,arrowtail=none];'\n\t\t\t   \t+'\\n  node[fixedsize=true,shape=circle]'\n\t\t\t   \t+'\\n  size=\"' + width + ',' + height + '\";'\n\t\t\t   \t+'\\n  labeldistance=0;'\n\t\t\t   \t+'\\n  nodesep=.175;'\n\t  \t\t\t+'\\n  ranksep=.175;'\n\t\t\t\t+'\\n'\n\t\t\t\t+     str\n\t\t\t   \t+'\\n}';\n\t\t}\n\t}\n\n\treturn Graph;\n\n});\n","// general group in a graph (subgraph)\ndefine('group', function(require) {\n\n\tvar Node = require('node');\n\n\tclass Group extends Node {\n\n\t\tconstructor() {\n\t\t\tsuper(null, null, null); // shape, text, name\n\t\t\tthis.nodes = [];\n\t\t\tthis.links = []; // for copying\n\t\t}\n\n\t\taddNode(node) {\n\t\t\tthis.nodes.push(node);\n\t\t}\n\n\t\tremoveNode(node) {\n\t\t\treturn this.nodes.splice(this.nodes.indexOf(node), 1);\n\t\t}\n\n\t\taddLink(link) {\n\t\t\tthis.links.push(link);\n\t\t}\n\n\t\tremoveLink(link) {\n\t\t\tvar i = this.links.indexOf(link);\n\t\t\tif (i != -1)\n\t\t\t\tthis.links.splice(i, 1);\n\t\t}\n\n\t\tdelete() {\n\t\t\tfor (let node of Array.from(this.nodes)) {\n\t\t\t\tnode.delete();\n\t\t\t}\n\t\t\tsuper.delete();\n\t\t}\n\n\t\tdraw(level) {\n\t\t\tvar str = \"\";\n\t\t\tfor (let node of this.nodes) {\n\t\t\t\tstr += node.draw(level);\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tcopy() { } // should never be called as all groups are in terms\n\n\t}\n\n\treturn Group;\n});\n","define(function() {\n\n\tclass Link {\n\t\tconstructor(from, to, fromPort, toPort, colour) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.fromPort = fromPort;\n\t\t\tthis.toPort = toPort;\n\t\t\tthis.visited = false; // HACKING\n\n\t\t\tthis.reverse = false;\n\t\t\tthis.colour = colour;\n\t\t\tthis.penWidth = null;\n\t\t\tthis.addToGraph(graph); // cheating\n\t\t\tif (colour != \"lightgrey\") { // cheating\n\t\t\t\tthis.addToNode(); // cheating\n\t\t\t}\n\t\t}\n\n\t\taddToNode() {\n\t\t\tvar fromNode = this.graph.findNodeByKey(this.from);\n\t\t\tfromNode.links.push(this);\n\t\t\tvar toNode = this.graph.findNodeByKey(this.to);\n\t\t\ttoNode.links.push(this);\n\t\t}\n\n\t\taddToGraph(graph) {\n\t\t\tif (graph != null)\n\t\t\t\tgraph.addLink(this);\n\t\t\tthis.graph = graph;\n\t\t\treturn this; // to provide chain operation\n\t\t}\n\n\t\taddToGroup(group) {\n\t\t\tgroup.addLink(this);\n\t\t\tthis.group = group;\n\t\t\treturn this; // to provide chain operation\n\t\t}\n\n\t\tchangeToGroup(group) {\n\t\t\tthis.group.removeLink(this);\n\t\t\tthis.addToGroup(group);\n\t\t\treturn this;\n\t\t}\n\n\t\tchangeFrom(key, port) {\n\t\t\tvar fromNode = this.graph.findNodeByKey(this.from);\n\t\t\tfromNode.links.splice(fromNode.links.indexOf(this), 1);\n\n\t\t\tthis.from = key;\n\t\t\tthis.fromPort = port;\n\t\t\tfromNode = this.graph.findNodeByKey(this.from);\n\t\t\tfromNode.links.push(this);\n\t\t}\n\n\t\tchangeTo(key, port) {\n\t\t\tvar toNode = this.graph.findNodeByKey(this.to);\n\t\t\ttoNode.links.splice(toNode.links.indexOf(this), 1);\n\n\t\t\tthis.to = key;\n\t\t\tthis.toPort = port;\n\t\t\ttoNode = this.graph.findNodeByKey(this.to);\n\t\t\ttoNode.links.push(this);\n\t\t}\n\n\t\tfocus(colour) {\n\t\t\tthis.colour = colour;\n\t\t\tthis.penWidth = \"20\";\n\t\t}\n\n\t\tclearFocus() {\n\t\t\tthis.colour = null;\n\t\t\tthis.penWidth = null;\n\t\t\tthis.visited = true; // HACKING\n\t\t}\n\n\t\tdelete() {\n\t\t\tvar fromNode = this.graph.findNodeByKey(this.from);\n\t\t\tfromNode.links.splice(fromNode.links.indexOf(this), 1);\n\t\t\tvar toNode = this.graph.findNodeByKey(this.to);\n\t\t\ttoNode.links.splice(toNode.links.indexOf(this), 1);\n\t\t\tthis.group.removeLink(this);\n\t\t\tthis.graph.removeLink(this);\n\t\t}\n\n\t\ttoString() {\n\t\t\treturn this.from + \"->\" + this.to;\n\t\t}\n\n\t\tdraw(level) {\n\t\t\tvar str = level;\n\n\t\t\tif (!this.reverse) {\n\t\t\t\tstr += this.from + '->' + this.to + '[';\n\t\t\t\tif (this.fromPort != null)\n\t\t\t\t\tstr += 'tailport=' + this.fromPort;\n\t\t\t\tif (this.toPort != null)\n\t\t\t\t\tstr += ',headport=' + this.toPort;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstr += this.to + '->' + this.from + '[dir=back';\n\t\t\t\tif (this.fromPort != null)\n\t\t\t\t\tstr += ',headport=' + this.fromPort;\n\t\t\t\tif (this.toPort != null)\n\t\t\t\t\tstr += ',tailport=' + this.toPort;\n\t\t\t}\n\n\t\t\tif (this.colour != null)\n\t\t\t\tstr += ',color=' + this.colour;\n\t\t\tif (this.penWidth != null)\n\t\t\t\tstr += ',penwidth=' + this.penWidth;\n\n\t\t\tstr += '];';\n\t\t\treturn str;\n\t\t}\n\t}\n\n\treturn Link;\n});\n","var showKey = false;\n\ndefine(function(require) {\n\n\tclass Node {\n\t\tconstructor(shape, text, name) {\n\t\t\tthis.key = null;\n\t\t\tthis.shape = shape;\n\t\t\tthis.text = text;\n\t\t\tthis.name = name; // identifier name or constant name if any\n\t\t\tthis.graph = null;\n\t\t\tthis.group = null;\n\t\t\tthis.width = 0.3;\n\t\t\tthis.height = 0.3;\n\t\t\tthis.links = [];\n\t\t\tthis.addToGraph(graph); // cheating!\n\t\t}\n\n\t\taddToGraph(graph) {\n\t\t\tif (graph != null)\n\t\t\t\tgraph.addNode(this);\n\t\t\tthis.graph = graph;\n\t\t\treturn this; // to provide chain operation\n\t\t}\n\n\t\taddToGroup(group) {\n\t\t\tgroup.addNode(this);\n\t\t\tthis.group = group;\n\t\t\treturn this; // to provide chain operation\n\t\t}\n\n\t\tchangeToGroup(group) {\n\t\t\tthis.group.removeNode(this);\n\t\t\tthis.addToGroup(group);\n\t\t\treturn this;\n\t\t}\n\n\t\tfindLinksConnected() {\n\t\t\treturn this.links;\n\t\t}\n\n\t\tfindLinksInto() {\n\t\t\tvar links = [];\n\t\t\tfor (let link of this.links) {\n\t\t\t\tif (link.to == this.key)\n\t\t\t\t\tlinks.push(link);\n\t\t\t}\n\t\t\treturn links;\n\t\t}\n\n\t\tfindLinksOutOf() {\n\t\t\tvar links = [];\n\t\t\tfor (let link of this.links) {\n\t\t\t\tif (link.from == this.key)\n\t\t\t\t\tlinks.push(link);\n\t\t\t}\n\t\t\treturn links;\n\t\t}\n\n\t\tfindNodesOutOf() {\n\t\t\tvar links = this.findLinksOutOf()\n\t\t\tvar nodeKeys = links.map(l => l.to)\n\t\t\treturn nodeKeys.map(k => this.graph.findNodeByKey(k));\n\t\t}\n\n\t\tcopy(graph) {\n\t\t\tvar newNode = new Node(this.shape, this.text, this.name).addToGraph(graph);\n\t\t\tnewNode.width = this.width;\n\t\t\tnewNode.height = this.height;\n\t\t\treturn newNode;\n\t\t}\n\n\t\t// also delete any connected links\n\t\tdelete() {\n\t\t\tthis.group.removeNode(this);\n\t\t\tthis.graph.removeNode(this);\n\t\t}\n\n\t\tdraw(level) {\n\t\t\tvar str = level + this.key + '[label=\"' + this.text;\n\t\t\tif (showKey)\n\t\t\t\tstr += ':' + this.key;\n\t\t\tstr += '\"';\n\t\t\tif (this.shape != null)\n\t\t\t\tstr += ',shape=' + this.shape;\n\t\t\tif (this.width != null)\n\t\t\t\tstr += ',width=' + this.width;\n\t\t\tif (this.height != null)\n\t\t\t\tstr += ',height=' + this.height;\n\t\t\treturn str += '];'\n\t\t}\n\n\t\t// machine instructions\n\t\ttransition(token, link) {\n\t\t\treturn link;\n\t\t}\n\n\t\trewrite(token, nextLink) {\n\t\t\ttoken.rewrite = false;\n\t\t\treturn nextLink;\n\t\t}\n\t}\n\n\treturn Node;\n});\n","define(function(require) {\n\n\tvar Flag = require('token').RewriteFlag();\n\tvar Node = require('node');\n\n\tclass Atom extends Node {\n\n\t\tconstructor(name) {\n\t\t\tsuper(\"circle\", \"\", name);\n\t\t\tthis.height = 0.1;\n\t\t\tthis.width = 0.1;\n\t\t}\n\n\t}\n\n\treturn Atom;\n});\n","define('nodes/contract',function(require) {\n\n\tvar Flag = require('token').RewriteFlag();\n\tvar Node = require('node');\n\tvar Atom = require('nodes/atom');\n\tvar Op = require('nodes/op');\n\tvar Term = require('term');\n\tvar Link = require('link');\n\tvar Group = require('group');\n\n\tclass Contract extends Node {\n\n\t\tconstructor(name) {\n\t\t\tsuper(\"point\", \"\", name);\n\t\t}\n\n\t\ttransition(token, link) {\n\t\t\tif (link.to == this.key) {\n\t\t\t\treturn this.findLinksOutOf(null)[0];\n\t\t\t}\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar link = token.link;\n\t\t\tvar inLinks = this.findLinksInto();\n\t\t\tvar outLinks = this.findLinksOutOf();\n\t\t\tvar nextLink = outLinks[0];\n\t\t\tvar nextNode = this.graph.findNodeByKey(nextLink.to);\n\n\t\t\tif (nextNode instanceof Contract || nextNode instanceof Atom) {\n\t\t\t\tinLinks.map(l => l.changeTo(nextNode.key,\"_\"));\n\t\t\t\tnextLink.delete();\n\t\t\t\tthis.delete();\n\t\t\t} else if (nextNode instanceof Op) {\n\t\t\t\tvar term = new Term().addToGroup(this.group);\n\t\t\t\tvar copy = nextNode.copy().addToGroup(term);\n\n\t\t\t\t// clean up here\n\t\t\t\tvar opLinks = nextNode.findLinksOutOf();\n\t\t\t\tvar auxs = Contract.createDNet(opLinks.length,[nextNode,nextNode,copy,copy],term);\n\t\t\t\tlink.changeTo(copy.key,\"_\");\n\t\t\t\tfor (var i = 0; i < opLinks.length; i++) {\n\t\t\t\t\topLinks[i].changeFrom(auxs[i].key,\"_\");\n\t\t\t\t}\n\n\t\t\t\tterm.set(copy,auxs);\n\t\t}\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn link;\n\t\t}\n\n\t\tstatic createDNet(cs, inputs, originalGroup, op) {\n\t\t\tvar c;\n\t\t\tvar from;\n\t\t\tvar to;\n\t\t\tvar cList = [];\n\n\t\t\tvar group = new Group();\n\n\t\t\tfor (var n = 0; n < cs; n++) {\n\t\t\t\tc = new Contract().addToGroup(group);\n\t\t\t\tcList.push(c);\n\n\t\t\tif (inputs.length == 0) // maybe this needs to be \"more elegant\"\n\t\t\t\tnew Link(op.key, c.key, \"_\", \"_\", \"lightgrey\").addToGroup(group);\n\t\t\t}\n\n\t\t\tif (cList.length > 0) {\n\t\t\t\tfor (var i = 0; i < inputs.length; i++) {\n\t\t\t\t\tfrom = inputs[i]; to = cList[(i%(cs))];\n\t\t\t\t\tnew Link(from.key, to.key, \"_\", \"_\").addToGroup(group);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup.addToGroup(originalGroup);\n\n\t\t\treturn cList;\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new Contract(this.name);\n\t\t}\n\n\t\tdraw(level) {\n\t\t\treturn level + this.key + '[shape=' + this.shape + '];';\n\t\t}\n\t}\n\n\treturn Contract;\n});\n","define(function(require) {\n\n\tvar Flag = require('token').RewriteFlag();\n\tvar Node = require('node');\n\tvar Link = require('link');\n\n\tclass Op extends Node {\n\n\t\tconstructor(name, active) {\n\t\t\tsuper(null, name, name);\n\t\t\tthis.active = active;\n\t\t}\n\n\t\trewrite(token) { } // default none for passive ops\n\n\t\tcopy() { \n\t\t\treturn new Op(this.name,this.active);\n\t\t}\n\n\t}\n\n\treturn Op;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\tvar BoolOp = require('nodes/ops/bool');\n\tvar Link = require('link');\n\tvar Flag = require('token').RewriteFlag();\n\n\tclass AndOp extends Op {\n\n\t\tconstructor() {\n\t\t\tsuper(\"∧\", true);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new AndOp();\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar inLink = this.findLinksInto()[0];\n\t\t\tvar outLinks = this.findLinksOutOf();\n\t\t\t\n\t\t\tvar b = outLinks.reduce((sum,x) => sum && BoolOp.parseBoolean(this.graph.findNodeByKey(x.to).name), true);\n\n\t\t\tvar newNode = new BoolOp(b,false).addToGroup(this.group);\n\t\t\tvar newLink = new Link(inLink.from,newNode.key,\"_\",\"_\").addToGroup(this.group);\n\n\t\t\toutLinks.map(x => x.delete());\n\t\t\toutLinks.map(x => this.graph.findNodeByKey(x.to).delete());\n\t\t\tthis.delete();\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn newLink;\n\t\t}\n\n\t}\n\n\treturn AndOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\n\tclass BoolOp extends Op {\n\n\t\tconstructor(b) {\n\t\t\tb = BoolOp.parseBoolean(b);\n\t\t\tsuper(b, false);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new BoolOp();\n\t\t}\n\n\t\tstatic parseBoolean(b) {\n\t\t\tif (b == \"false\" || b == 0) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn BoolOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\tvar BoolOp = require('nodes/ops/bool');\n\tvar Link = require('link');\n\tvar Flag = require('token').RewriteFlag();\n\n\tclass EqualsOp extends Op {\n\n\t\tconstructor() {\n\t\t\tsuper(\"==\", true);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new EqualsOp();\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar inLink = this.findLinksInto()[0];\n\t\t\tvar outLinks = this.findLinksOutOf();\n\n\t\t\tvar left = this.graph.findNodeByKey(outLinks[0].to).name;\n\t\t\tvar right = this.graph.findNodeByKey(outLinks[1].to).name;\n\t\t\tvar b = (left == right);\n\n\t\t\tvar newNode = new BoolOp(b,false).addToGroup(this.group);\n\t\t\tvar newLink = new Link(inLink.from,newNode.key,\"_\",\"_\").addToGroup(this.group);\n\n\t\t\toutLinks.map(x => x.delete());\n\t\t\toutLinks.map(x => this.graph.findNodeByKey(x.to).delete());\n\t\t\tthis.delete();\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn newLink;\n\t\t}\n\n\t}\n\n\treturn EqualsOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\tvar BoolOp = require('nodes/ops/bool');\n\tvar Link = require('link');\n\tvar Flag = require('token').RewriteFlag();\n\n\tclass IfOp extends Op {\n\n\t\tconstructor() {\n\t\t\tsuper(\"if\", true);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new IfOp();\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar inLink = this.findLinksInto()[0];\n\t\t\tvar outLinks = this.findLinksOutOf();\n\n\t\t\tvar name = this.graph.findNodeByKey(outLinks[0].to).name;\n\t\t\tvar keep; var del;\n\t\t\tif (BoolOp.parseBoolean(name)) {\n\t\t\t\tkeep = 1; del = 2;\n\t\t\t} else {\n\t\t\t\tkeep = 2; del = 1;\n\t\t\t}\n\t\t\toutLinks[del].delete();\n\t\t\tvar newNode = this.graph.findNodeByKey(outLinks[keep].to).group.unbox();\n\t\t\tvar newLink = new Link(inLink.from,newNode.key,\"_\",\"_\").addToGroup(this.group);\n\n\t\t\toutLinks[0].delete();\n\t\t\tthis.graph.findNodeByKey(outLinks[0].to).delete();\n\t\t\tthis.delete();\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn newLink;\n\t\t}\n\n\t}\n\n\treturn IfOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\n\tclass IntOp extends Op {\n\n\t\tconstructor(n) {\n\t\t\tsuper(n, false);\n\t\t}\n\n\t}\n\n\treturn IntOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\tvar BoolOp = require('nodes/ops/bool');\n\tvar Link = require('link');\n\tvar Flag = require('token').RewriteFlag();\n\n\tclass NotOp extends Op {\n\n\t\tconstructor() {\n\t\t\tsuper(\"¬\", true);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new NotOp();\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar inLink = this.findLinksInto()[0];\n\t\t\tvar outLinks = this.findLinksOutOf();\n\t\t\t\n\t\t\tvar b = !BoolOp.parseBoolean(this.graph.findNodeByKey(outLinks[0].to).name);\n\n\t\t\tvar newNode = new BoolOp(b,false).addToGroup(this.group);\n\t\t\tvar newLink = new Link(inLink.from,newNode.key,\"_\",\"_\").addToGroup(this.group);\n\n\t\t\toutLinks.map(x => x.delete());\n\t\t\toutLinks.map(x => this.graph.findNodeByKey(x.to).delete());\n\t\t\tthis.delete();\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn newLink;\n\t\t}\n\n\t}\n\n\treturn NotOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\tvar BoolOp = require('nodes/ops/bool');\n\tvar Link = require('link');\n\tvar Flag = require('token').RewriteFlag();\n\n\tclass OrOp extends Op {\n\n\t\tconstructor() {\n\t\t\tsuper(\"∨\", true);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new OrOp();\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar inLink = this.findLinksInto()[0];\n\t\t\tvar outLinks = this.findLinksOutOf();\n\n\t\t\tvar b = outLinks.reduce((sum,x) => sum || BoolOp.parseBoolean(this.graph.findNodeByKey(x.to).name), false);\n\n\t\t\tvar newNode = new BoolOp(b,false).addToGroup(this.group);\n\t\t\tvar newLink = new Link(inLink.from,newNode.key,\"_\",\"_\").addToGroup(this.group);\n\n\t\t\toutLinks.map(x => x.delete());\n\t\t\toutLinks.map(x => this.graph.findNodeByKey(x.to).delete());\n\t\t\tthis.delete();\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn newLink;\n\t\t}\n\n\t}\n\n\treturn OrOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\tvar IntOp = require('nodes/ops/int');\n\tvar Link = require('link');\n\tvar Flag = require('token').RewriteFlag();\n\n\tclass PlusOp extends Op {\n\n\t\tconstructor() {\n\t\t\tsuper(\"+\", true);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new PlusOp();\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar inLink = this.findLinksInto()[0];\n\t\t\tvar outLinks = this.findLinksOutOf();\n\t\t\t\n\t\t\tvar n = outLinks.reduce((sum,x) => sum + this.graph.findNodeByKey(x.to).name, 0);\n\n\t\t\tvar newNode = new IntOp(n,false).addToGroup(this.group);\n\t\t\tvar newLink = new Link(inLink.from,newNode.key,\"_\",\"_\").addToGroup(this.group);\n\n\t\t\toutLinks.map(x => x.delete());\n\t\t\toutLinks.map(x => this.graph.findNodeByKey(x.to).delete());\n\t\t\tthis.delete();\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn newLink;\n\t\t}\n\n\t}\n\n\treturn PlusOp;\n});\n","define(function(require) {\n\n\tvar Op = require('nodes/op');\n\tvar IntOp = require('nodes/ops/int');\n\tvar Link = require('link');\n\tvar Flag = require('token').RewriteFlag();\n\n\tclass TimesOp extends Op {\n\n\t\tconstructor() {\n\t\t\tsuper(\"*\", true);\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new TimesOp();\n\t\t}\n\n\t\trewrite(token) {\n\t\t\tvar inLink = this.findLinksInto()[0];\n\t\t\tvar outLinks = this.findLinksOutOf();\n\t\t\t\n\t\t\tvar n = outLinks.reduce((sum,x) => sum * this.graph.findNodeByKey(x.to).name, 1);\n\n\t\t\tvar newNode = new IntOp(n,false).addToGroup(this.group);\n\t\t\tvar newLink = new Link(inLink.from,newNode.key,\"_\",\"_\").addToGroup(this.group);\n\n\t\t\toutLinks.map(x => x.delete());\n\t\t\toutLinks.map(x => this.graph.findNodeByKey(x.to).delete());\n\t\t\tthis.delete();\n\n\t\t\ttoken.rewriteFlag = Flag.SEARCH;\n\t\t\treturn newLink;\n\t\t}\n\n\t}\n\n\treturn TimesOp;\n});\n","define(function(require) {\n\n\tvar Node = require('node');\n\tvar Flag = require('token').Flag;\n\n\tclass Start extends Node {\n\n\t\tconstructor() {\n\t\t\tsuper(\"point\", \"\");\n\t\t}\n\n\t\ttransition(token) {\n\t\t\treturn this.findLinksOutOf(null)[0];\n\t\t}\n\n\t\tcopy() {\n\t\t\treturn new Start();\n\t\t}\n\n\t\tdraw(level) {\n\t\t\treturn level + this.key + '[shape=' + this.shape + '];';\n\t\t}\n\n\t}\n\n\treturn Start;\n});\n","// edited by todd\n\ndefine('ast/term', function() {\n  class Term {\n    constructor(ctx) {\n      this.ctx = ctx;\n    }\n  }\n  return Term;\n});\n\ndefine('ast/var', function(require) {\n  var Term = require('ast/term');\n    /**\n     * name is the string matched for this identifier.\n     */\n  class Var extends Term {\n    constructor(ctx, name) {\n      super(ctx);\n      this.name = name;\n    }\n  }\n  return Var;\n});\n\ndefine('ast/operation', function(require) {\n  var Term = require('ast/term');\n\n  class Operation extends Term {\n    constructor(ctx, sig, name, active, eas, das) {\n      super(ctx);\n      this.sig = sig;\n      this.name = name;\n      this.active = active;\n      this.eas = eas;\n      this.das = das;\n    }\n  }\n  return Operation;\n});\n\ndefine('ast/thunk', function(require) {\n  var Term = require('ast/term');\n\n  class Thunk extends Term {\n    constructor(ctx, inner) {\n      super(ctx);\n      this.inner = inner;\n    }\n  }\n  return Thunk;\n});\n\ndefine('ast/binding', function(require) {\n  var Term = require('ast/term');\n    /**\n     * param here is the name of the variable of the abstraction. Body is the\n     * subtree  representing the body of the abstraction.\n     */\n\n  class Binding extends Term {\n    constructor(ctx, id, param, body) {\n      super(ctx);\n      this.id = id;\n      this.param = param;\n      this.body = body;\n    }\n  }\n  return Binding;\n});\n\ndefine('ast/reference', function(require) {\n  var Term = require('ast/term');\n    /**\n     * param here is the name of the variable of the reference. Body is the\n     * subtree  representing the body of the abstraction.\n     */\n\n  class Reference extends Term {\n    constructor(ctx, id, param, body) {\n      super(ctx);\n      this.id = id;\n      this.param = param;\n      this.body = body;\n    }\n  }\n  return Reference;\n});\n","define(function(require) {\n\n\tvar Token = require('parser/token');\n\n\tclass Lexer {\n\t\tconstructor(input) {\n\t\t\tthis._input = input;\n\t\t\tthis._index = 0;\n\t\t\tthis._token = undefined;\n\t\t\tthis._nextToken();\n\t\t}\n\n\t\t/**\n\t\t * Return the next char of the input or '\\0' if we've reached the end\n\t\t */\n\t\t_nextChar() {\n\t\t\tif (this._index >= this._input.length) {\n\t\t\t\treturn '\\0';\n\t\t\t}\n\n\t\t\treturn this._input[this._index++];\n\t\t}\n\n\t\t/**\n\t\t * Set this._token based on the remaining of the input\n\t\t *\n\t\t * This method is meant to be private, it doesn't return a token, just sets\n\t\t * up the state for the helper functions.\n\t\t */\n\t\t_nextToken() {\n\t\t\tlet c;\n\t\t\tdo {\n\t\t\t\tc = this._nextChar();\n\t\t\t} while (/\\s/.test(c));\n\n\t\t\tswitch (c) {\n\t\t\tcase ',':\n\t\t\t\tthis._token = new Token(Token.COMMA);\n\t\t\t\tbreak;\n\n\t\t\tcase ';':\n\t\t\t\tthis._token = new Token(Token.SEMIC);\n\t\t\t\tbreak;\n\n\t\t\tcase '(':\n\t\t\t\tthis._token = new Token(Token.LPAREN);\n\t\t\t\tbreak;\n\n\t\t\tcase ')':\n\t\t\t\tthis._token = new Token(Token.RPAREN);\n\t\t\t\tbreak;\n\n\t\t\tcase '\\0':\n\t\t\t\tthis._token = new Token(Token.EOF);\n\t\t\t\tbreak;\n\n\t\t\tcase '=':\n\t\t\t\tthis._token = new Token(Token.DEF);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// text for string\n\t\t\t\tif (/[a-zA-Z]|'/.test(c)) {\n\t\t\t\t\tlet str = '';\n\t\t\t\t\tdo {\n\t\t\t\t\t\tstr += c;\n\t\t\t\t\t\tc = this._nextChar();\n\n\t\t\t\t\t} while (/[a-zA-Z]|'|_/.test(c));\n\n\t\t\t\t\t// put back the last char which is not part of the identifier\n\t\t\t\t\tthis._index--;\n\n\t\t\t\t\tif (str == \"bind\")\n\t\t\t\t\t\tthis._token = new Token(Token.BIND);\n\t\t\t\t\telse if (str == \"in\")\n\t\t\t\t\t\tthis._token = new Token(Token.IN);\n\t\t\t\t\telse if (str == \"new\")\n\t\t\t\t\t\tthis._token = new Token(Token.NEW);\n\t\t\t\t\telse if (str == \"PLUS\")\n\t\t\t\t\t\tthis._token = new Token(Token.PLUS);\n\t\t\t\t\telse if (str == \"TIMES\")\n\t\t\t\t\t\tthis._token = new Token(Token.TIMES);\n\t\t\t\t\telse if (str == \"AND\")\n\t\t\t\t\t\tthis._token = new Token(Token.AND);\n\t\t\t\t\telse if (str == \"OR\")\n\t\t\t\t\t\tthis._token = new Token(Token.OR);\n\t\t\t\t\telse if (str == \"NOT\")\n\t\t\t\t\t\tthis._token = new Token(Token.NOT);\n\t\t\t\t\telse if (str == \"EQUALS\")\n\t\t\t\t\t\tthis._token = new Token(Token.EQUALS);\n\t\t\t\t\telse if (str == \"IF\")\n\t\t\t\t\t\tthis._token = new Token(Token.IF);\n\t\t\t\t\telse if (str == \"TRUE\")\n\t\t\t\t\t\tthis._token = new Token(Token.TRUE, true);\n\t\t\t\t\telse if (str == \"FALSE\")\n\t\t\t\t\t\tthis._token = new Token(Token.FALSE, false);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._token = new Token(Token.LCID, str);\n\t\t\t\t}\n\n\t\t\t\t// text for numbers\n\t\t\t\telse if (/[0-9]/.test(c)) {\n\t\t\t\t\tlet str = '';\n\t\t\t\t\tdo {\n\t\t\t\t\t\tstr += c;\n\t\t\t\t\t\tc = this._nextChar();\n\t\t\t\t\t} while (/[0-9]/.test(c));\n\n\t\t\t\t\t// put back the last char which is not part of the identifier\n\t\t\t\t\tthis._index--;\n\t\t\t\t\tthis._token = new Token(Token.INT, parseInt(str));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.fail();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Assert that the next token has the given type, return it, and skip to the\n\t\t * next token.\n\t\t */\n\t\ttoken(type) {\n\t\t\tif (!type) {\n\t\t\t\treturn this._token.value;\n\t\t\t}\n\n\t\t\tconst token = this._token;\n\t\t\tthis.match(type);\n\t\t\treturn token.value;\n\t\t}\n\n\t\tvalue() {\n\t\t\treturn this._token.value;\n\t\t}\n\n\t\tlookahead() {\n\t\t\treturn this._token;\n\t\t}\n\n\t\tlookaheadType() {\n\t\t\treturn this._token.type;\n\t\t}\n\n\t\t/**\n\t\t * Throw an unexpected token error - ideally this would print the source\n\t\t * location\n\t\t */\n\t\tfail() {\n\t\t\tthrow new Error(`Unexpected token at offset ${this._index}`);\n\t\t}\n\n\t\t/**\n\t\t * Returns a boolean indicating whether the next token has the given type.\n\t\t */\n\t\tnext(type) {\n\t\t\treturn this._token.type == type;\n\t\t}\n\n\t\t/**\n\t\t * Assert that the next token has the given type and skip it.\n\t\t */\n\t\tmatch(type) {\n\t\t\tif (this.next(type)) {\n\t\t\t\tthis._nextToken();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconsole.error(`${this._index}: Invalid token: Expected '${type}' found '${this._token.type}'`);\n\t\t\tthrow new Error('Parse Error');\n\t\t}\n\n\t\t/**\n\t\t * Same as `next`, but skips the token if it matches the expected type.\n\t\t */\n\t\tskip(type) {\n\t\t\tif (this.next(type)) {\n\t\t\t\tthis._nextToken();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn Lexer;\n});\n","define(function(require) {\n\n\tvar Token = require('parser/token');\n\tvar Var = require('ast/var');\n\tvar Operation = require('ast/operation');\n\tvar Binding = require('ast/binding');\n\tvar Reference = require('ast/reference');\n\tvar Thunk = require('ast/thunk');\n\n\tclass Parser {\n\t\tconstructor(lexer) {\n\t\t\tthis.lexer = lexer;\n\t\t}\n\n\t\tparse() {\n\t\t\tconst result = this.term2([]);\n\t\t\t// make sure we consumed all the program, otherwise there was a syntax error\n\t\t\tthis.lexer.match(Token.EOF);\n\t\t\treturn result;\n\t\t}\n\n\t\t//  T ::= BIND LCID DEF term IN term  (BIND x = PARAM in BODY)\n\t\t//      | NEW  LCID IN term           (NEW x = PARAM in BODY)\n\t\t//      | op? ( EAS ; DAS )\n\n\t\tterm2(ctx,thunk) {\n\t\t\tif (thunk) {\n\t\t\t\tconst inner = this.term2(ctx);\n\t\t\t\treturn new Thunk(ctx,inner);\n\t\t\t} else {\n\t\t\t\tif (this.lexer.skip(Token.BIND)) {\n\t\t\t\t\tconst id = this.term2(ctx);\n\t\t\t\t\tid.ctx = [id].concat(id.ctx);\n\t\t\t\t\tthis.lexer.match(Token.DEF);\n\t\t\t\t\tconst P = this.term2(ctx);\n\t\t\t\t\tthis.lexer.match(Token.IN);\n\t\t\t\t\tconst B = this.term2([id].concat(ctx));\n\t\t\t\t\treturn new Binding(ctx,id,P,B);\n\t\t\t\t} else if (this.lexer.skip(Token.NEW)) {\n\t\t\t\t\tconst id = this.term2(ctx);\n\t\t\t\t\tid.ctx = [id].concat(id.ctx);\n\t\t\t\t\tthis.lexer.match(Token.DEF);\n\t\t\t\t\tconst P = this.term2(ctx);\n\t\t\t\t\tthis.lexer.match(Token.IN);\n\t\t\t\t\tconst B = this.term2([id].concat(ctx));\n\t\t\t\t\treturn new Reference(ctx,id,P,B);\n\t\t\t\t} else {\n\t\t\t\t\treturn this.atom(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// atom ::= LPAREN term RPAREN\n\t\t//        | LCID\n\t\tatom(ctx) {\n\t\t\tif (this.lexer.skip(Token.LPAREN)) {\n\t\t\t\tconst term = this.term2(ctx);\n\t\t\t\tthis.lexer.match(Token.RPAREN);\n\t\t\t\treturn term;\n\t\t\t} else if (this.lexer.next(Token.LCID)) {\n\t\t\t\tconst id = this.lexer.token(Token.LCID);\n\t\t\t\treturn new Var(ctx, id);\n\t\t\t} else {\n\t\t\t\treturn this.operation(ctx);\n\t\t\t}\n\t\t}\n\n\t\t// BUILT-IN OPERATIONS\n\t\toperation(ctx) {\n\t\t\tvar name; var sig; var active;\n\t\t\tvar eas = [];\n\t\t\tvar das = [];\n\n\t\t\tvar token = this.lexer.lookaheadType();\n\t\t\tswitch(token) {\n\t\t\t\tcase Token.PLUS:\n\t\t\t\t\tname = \"+\"; sig = [2,0]; active = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Token.TIMES:\n\t\t\t\t\tname = \"*\"; sig = [2,0]; active = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Token.AND:\n\t\t\t\t\tname = \"∧\"; sig = [2,0]; active = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Token.OR:\n\t\t\t\t\tname = \"∨\"; sig = [2,0]; active = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Token.NOT:\n\t\t\t\t\tname = \"¬\"; sig = [1,0]; active = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Token.EQUALS:\n\t\t\t\t\tname = \"==\"; sig = [2,0]; active = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Token.IF:\n\t\t\t\t\tname = \"if\"; sig = [1,2]; active = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tname = this.lexer.value(); sig = [0,0]; active = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.lexer.match(token);\n\t\t\tif (sig[0] > 0) {\n\t\t\t\tthis.lexer.match(Token.LPAREN);\n\t\t\t\teas = this.gatherArgs(ctx,sig[0],false);\n\t\t\t\tif (sig[1] == 0)\n\t\t\t\t\tthis.lexer.match(Token.RPAREN);\n\t\t\t}\n\t\t\tif (sig[1] > 0) {\n\t\t\t\tif (sig[0] == 0)\n\t\t\t\t\tthis.lexer.match(Token.LPAREN);\n\t\t\t\tthis.lexer.match(Token.SEMIC);\n\t\t\t\tdas = this.gatherArgs(ctx,sig[1],true);\n\t\t\t\tthis.lexer.match(Token.RPAREN);\n\t\t\t}\n\t\t\treturn new Operation(ctx,sig,name,active,eas,das);\n\t\t}\n\n\t\tgatherArgs(ctx,type,thunk) {\n\t\t\tvar args = [];\n\t\t\tfor (var i = 0; i < type; i++) {\n\t\t\t\tconst term = this.term2(ctx,thunk);\n\t\t\t\targs.push(term);\n\t\t\t\tif (this.lexer.next(Token.COMMA)) {\n\t\t\t\t\tthis.lexer.match(Token.COMMA);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn args;\n\t\t}\n\n\t}\n\n\treturn Parser;\n});\n","define(function() {\n  class Token {\n    /**\n     * type should be one of the valid token types list below, and value is an\n     * optional value that can carry any extra information necessary for a given\n     * token type. (e.g. the matched string for an identifier)\n     */\n    constructor(type, value, pred) {\n      this.type = type;\n      this.value = value;\n      this.pred = pred;\n    }\n  }\n\n  [\n    'EOF', // we augment the tokens with EOF, to indicate the end of the input.\n    'LCID',\n\n    'LPAREN',\n    'RPAREN',\n    'SEMIC',\n\n    'BIND',\n    'NEW',\n    'DEF',\n    'IN',\n\n    'PLUS',\n    'TIMES',\n    'INT',\n    'AND',\n    'OR',\n    'NOT',\n    'TRUE',\n    'FALSE',\n    'EQUALS',\n\n    'IF'\n  ].forEach(token => Token[token] = token);\n\n  return Token;\n});\n","// specific group for a term in the calculus\n\ndefine('term', function(require) {\n\n\tvar Group = require('group');\n\n\tclass Term extends Group {\n\n\t\tconstructor(prin, auxs) {\n\t\t\tsuper();\n\t\t\tthis.prin = null;\n\t\t\tthis.set(prin, auxs)\n\t\t\tthis.boxed = false;\n\t\t}\n\n\t\tset(prin, auxs) {\n\t\t\tthis.prin = prin;\n\t\t\tthis.auxs = auxs;\n\t\t\treturn this;\n\t\t}\n\n\t\tbox() {\n\t\t\tthis.boxed = true;\n\t\t\treturn this.prin;\n\t\t}\n\n\t\tunbox() {\n\t\t\tthis.boxed = false;\n\t\t\treturn this.prin;\n\t\t}\n\n\t\tdraw(level) {\n\t\t\tif (this.boxed) {\n\t\t\t\tvar str = \"\";\n\t\t\t\tfor (let node of this.nodes) {\n\t\t\t\t\tstr += node.draw(level + '  ');\n\t\t\t\t}\n\t\t\t\treturn level + 'subgraph cluster_' + this.key + ' {'\n\t\t\t\t\t + level + '  graph[style=dotted];'\n\t\t\t\t\t + str\n\t\t\t\t\t + level + '};';\n\t\t\t }\n\t\treturn super.draw(level);\n\t\t}\n\n}\n\n\treturn Term;\n});\n","define(function(require) {\n\n\tvar Flag = {\n\t\tSEARCH:  '?',\n\t\tREWRITE: '↯',\n\t\tRETURN:\t '✓',\n\t}\n\n\tclass MachineToken {\n\n\t\tstatic RewriteFlag() {\n\t\t\treturn Flag;\n\t\t}\n\n\t\tconstructor() {\n\t\t\tthis.link = null;\n\t\t\tthis.rewriteFlag = null;\n\t\t\tthis.reset();\n\t\t}\n\n\t\tsetLink(link) {\n\t\t\tif (this.link != null)\n\t\t\t\tthis.link.clearFocus();\n\t\t\tthis.link = link;\n\t\t\tif (this.link != null) {\n\t\t\t\tthis.link.focus(\"red\");\n\t\t\t}\n\t\t}\n\n\t\treset(link) {\n\t\t\tthis.setLink(link);\n\t\t\tthis.rewriteFlag = Flag.SEARCH;\n\t\t}\n\t}\n\n\treturn MachineToken;\n});\n"],"sourceRoot":""}