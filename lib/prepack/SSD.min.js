(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("os"), require("tty"), require("util"), (function webpackLoadOptionalExternalModule() { try { return require("crypto"); } catch(e) {} }()), require("fs"), require("path"));
	else if(typeof define === 'function' && define.amd)
		define(["os", "tty", "util", "crypto", "fs", "path"], factory);
	else if(typeof exports === 'object')
		exports["compiler"] = factory(require("os"), require("tty"), require("util"), (function webpackLoadOptionalExternalModule() { try { return require("crypto"); } catch(e) {} }()), require("fs"), require("path"));
	else
		root["compiler"] = factory(root["os"], root["tty"], root["util"], root["crypto"], root["fs"], root["path"]);
})(global, function(__WEBPACK_EXTERNAL_MODULE__263__, __WEBPACK_EXTERNAL_MODULE__302__, __WEBPACK_EXTERNAL_MODULE__303__, __WEBPACK_EXTERNAL_MODULE__406__, __WEBPACK_EXTERNAL_MODULE__653__, __WEBPACK_EXTERNAL_MODULE__656__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname) {var Prepack = __webpack_require__(1);

var fs = __webpack_require__(653);

var path = __webpack_require__(656);

var prepackOptions = {
  filename: 'interpreter',
  compatibility: 'node-react',
  inlineExpressions: true,
  logStatistics: false,
  internalDebug: false,
  timeout: Infinity,
  maxStackDepth: 1000,
  mathRandomSeed: "rnd"
};

var callback = function callback(err, result) {
  if (err) {
    throw err;
  }

  console.log(result.toString());
  module.exports = result;
};

function compiler(maxTermCalls, outputFile, inputFile) {
  var program;

  if (!global.__residual) {
    __dirname = path.resolve(path.dirname(''));
    program = fs.readFileSync(path.join(__dirname, inputFile), 'utf8');
  } else {
    program = global.__residual("object", function (__dirname, path, fs, inputFile) {
      __dirname = path.resolve(path.dirname(''));
      return fs.readFileSync(path.join(__dirname, inputFile), 'utf8');
    }, __dirname, path, fs, inputFile);
  }

  var interpreter = fs.readFileSync(path.join(__dirname, 'lib/SSD/interpreter.js'), 'utf8').replace('exports["SSD"] =', 'const SSD ='); // the arguments will be the program, callback function and max term calls

  var code = Prepack.prepackSources([{
    filePath: "./interpreter.js",
    fileContents: "".concat(interpreter, "\nSSD(").concat(JSON.stringify(program), ", callback.toString() ").concat(maxTermCalls, ");")
  }], prepackOptions).code;

  if (!global.__residual) {
    fs.writeFileSync(path.join(__dirname, outputFile), code);
  } else {
    global.__residual("void", function (__dirname, path, fs, outputFile) {
      fs.writeFileSync(path.join(__dirname, outputFile), code);
    }, __dirname, path, fs, outputFile);
  }
}

module.exports = compiler;
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  prepackStdin: true,
  prepackFile: true,
  prepackFileSync: true
};
exports.prepackStdin = prepackStdin;
exports.prepackFile = prepackFile;
exports.prepackFileSync = prepackFileSync;

var _options = __webpack_require__(2);

var _errors = __webpack_require__(3);

var _prepackStandalone = __webpack_require__(4);

var _types = __webpack_require__(19);

var _DebugChannel = __webpack_require__(651);

var _FileIOWrapper = __webpack_require__(652);

var _statistics = __webpack_require__(407);

var _fs = _interopRequireDefault(__webpack_require__(653));

var _path = _interopRequireDefault(__webpack_require__(656));

var _prepackStandalone2 = __webpack_require__(4);

Object.keys(_prepackStandalone2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _prepackStandalone2[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*
 Prepack API functions that require Node as the execution environment for Prepack.
 */
function createStatistics(options) {
  let gc = global.gc; // eslint-disable-line no-undef

  return options.profile !== undefined ? new _statistics.SerializerStatistics(() => Date.now(), () => {
    if (gc) gc();
    return process.memoryUsage().heapUsed;
  }, !!gc) : new _statistics.SerializerStatistics();
}

function prepackStdin(options = _options.defaultOptions, processSerializedCode, printDiagnostics) {
  let sourceMapFilename = options.inputSourceMapFilenames && options.inputSourceMapFilenames.length > 0 ? options.inputSourceMapFilenames[0] : "";
  process.stdin.setEncoding("utf8");
  process.stdin.resume();
  process.stdin.on("data", function (code) {
    _fs.default.readFile(sourceMapFilename, "utf8", function (mapErr, sourceMap = "") {
      if (mapErr) {
        //if no sourcemap was provided we silently ignore
        if (sourceMapFilename !== "") console.warn(`No sourcemap found at ${sourceMapFilename}.`);
      }

      let filename = "no-filename-specified";
      let serialized;
      let success;

      try {
        serialized = (0, _prepackStandalone.prepackSources)([{
          filePath: filename,
          fileContents: code,
          sourceMapContents: sourceMap
        }], options, createStatistics(options));
        processSerializedCode(serialized);
        success = printDiagnostics(false);
      } catch (err) {
        printDiagnostics(err instanceof _errors.FatalError);

        if (!(err instanceof _errors.FatalError)) {
          // if it is not a FatalError, it means prepack failed, and we should display the Prepack stack trace.
          console.error(err.stack);
        }

        success = false;
      }

      if (!success) process.exit(1);
    });
  });
}

function getSourceMapFilename(filename, options) {
  if (options.inputSourceMapFilenames !== undefined) {
    // The convention is that the source map has the same basename as the javascript
    // source file, except that .map is appended. We look for a match with the
    // supplied source file names.
    for (let sourceMapFilename of options.inputSourceMapFilenames) {
      if (_path.default.basename(filename) + ".map" === _path.default.basename(sourceMapFilename)) {
        return [sourceMapFilename, true];
      }
    }
  }

  return [filename + ".map", false];
}

function prepackFile(filename, options = _options.defaultOptions, callback, fileErrorHandler) {
  let [sourceMapFilename] = getSourceMapFilename(filename, options);

  _fs.default.readFile(filename, "utf8", function (fileErr, code) {
    if (fileErr) {
      if (fileErrorHandler) fileErrorHandler(fileErr);
      return;
    }

    _fs.default.readFile(sourceMapFilename, "utf8", function (mapErr, _sourceMap) {
      let sourceMap = _sourceMap;

      if (mapErr) {
        console.warn(`No sourcemap found at ${sourceMapFilename}.`);
        sourceMap = "";
      }

      let serialized;

      try {
        serialized = (0, _prepackStandalone.prepackSources)([{
          filePath: filename,
          fileContents: code,
          sourceMapContents: sourceMap
        }], options, createStatistics(options));
      } catch (err) {
        callback(err, null);
        return;
      }

      callback(null, serialized);
    });
  });
}

function getSourceFileCollection(filenames, options) {
  const sourceFiles = filenames.map(filename => {
    let code = _fs.default.readFileSync(filename, "utf8");

    let sourceMap = "";
    let [sourceMapFilename, matchedSourceMapFilename] = getSourceMapFilename(filename, options);

    try {
      sourceMap = _fs.default.readFileSync(sourceMapFilename, "utf8");
      if (matchedSourceMapFilename) console.info(`Matching sourcemap found at ${sourceMapFilename}.`);
    } catch (_e) {
      if (matchedSourceMapFilename) console.warn(`No sourcemap found at ${sourceMapFilename}.`);
    }

    return {
      filePath: filename,
      fileContents: code,
      sourceMapContents: sourceMap,
      sourceMapFilename: sourceMapFilename
    };
  });
  return new _types.SourceFileCollection(sourceFiles);
}

function prepackFileSync(filenames, options = _options.defaultOptions) {
  let sourceFileCollection = getSourceFileCollection(filenames, options); // Filter to not include sourcemaps that weren't found

  let filterValidSourceMaps = a => a.filter(sf => sf.sourceMapContents !== ""); // The existence of debug[In/Out]FilePath represents the desire to use the debugger.


  if (options.debugInFilePath !== undefined && options.debugOutFilePath !== undefined) {
    if (options.debuggerConfigArgs === undefined) options.debuggerConfigArgs = {};
    let debuggerConfigArgs = options.debuggerConfigArgs;
    let ioWrapper = new _FileIOWrapper.FileIOWrapper(false, options.debugInFilePath, options.debugOutFilePath);
    debuggerConfigArgs.debugChannel = new _DebugChannel.DebugChannel(ioWrapper);
    debuggerConfigArgs.sourcemaps = filterValidSourceMaps(sourceFileCollection.toArray());
  }

  let debugReproArgs = options.debugReproArgs;
  if (debugReproArgs) debugReproArgs.sourcemaps = filterValidSourceMaps(sourceFileCollection.toArray());
  return (0, _prepackStandalone.prepackSources)(sourceFileCollection, options, createStatistics(options));
}
//# sourceMappingURL=prepack-node.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultOptions = exports.ReactOutputValues = exports.DiagnosticSeverityValues = exports.InvariantModeValues = exports.CompatibilityValues = void 0;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
const CompatibilityValues = ["browser", "jsc-600-1-4-17", "mobile", "node-source-maps", "fb-www", "node-react"];
exports.CompatibilityValues = CompatibilityValues;
const InvariantModeValues = ["throw", "console.info", "console.warn", "console.error", "nativeLoggingHook+0", "nativeLoggingHook+1", "nativeLoggingHook+2", "nativeLoggingHook+3"];
exports.InvariantModeValues = InvariantModeValues;
const DiagnosticSeverityValues = ["FatalError", "RecoverableError", "Warning", "Information"];
exports.DiagnosticSeverityValues = DiagnosticSeverityValues;
const ReactOutputValues = ["create-element", "jsx", "bytecode"];
exports.ReactOutputValues = ReactOutputValues;
const defaultOptions = {};
exports.defaultOptions = defaultOptions;
//# sourceMappingURL=options.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NestedOptimizedFunctionSideEffect = exports.InvariantError = exports.InfeasiblePathError = exports.FatalError = exports.CompilerDiagnostic = void 0;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
// Information: Just an informative message with no semantic implications whatsoever.
// Warning: Prepack will produce code that matches the behavior of the original code, but the original code might have an error.
// RecoverableError: Prepack might produce code that deviates in behavior from the original code, if the original code is not well behaved.
// FatalError: Prepack is unable to produce code that could possibly match the behavior of the original code.
// This is the error format used to report errors to the caller-supplied
// error-handler
class CompilerDiagnostic extends Error {
  constructor(message, location, errorCode, severity, sourceFilePaths) {
    super(message);
    this.location = location;
    this.severity = severity;
    this.errorCode = errorCode;
    this.sourceFilePaths = sourceFilePaths;
  }

} // This error is thrown to exit Prepack when an ErrorHandler returns 'FatalError'
// This should just be a class but Babel classes doesn't work with
// built-in super classes.


exports.CompilerDiagnostic = CompilerDiagnostic;

class FatalError extends Error {
  constructor(message) {
    super(message === undefined ? "A fatal error occurred while prepacking." : message);
  }

} // This error is thrown when exploring a path whose entry conditon implies that an earlier path conditon must be false.
// Such paths are infeasible (dead) and must be elided from the evaluation.


exports.FatalError = FatalError;

class InfeasiblePathError extends Error {
  constructor() {
    super("Infeasible path explored");
  }

} // This error is thrown when a false invariant is encountered. This error should never be swallowed.


exports.InfeasiblePathError = InfeasiblePathError;

class InvariantError extends Error {
  constructor(message) {
    super(message);
  }

}

exports.InvariantError = InvariantError;

// When a side-effect occurs when evaluating a pure nested optimized function, we stop execution of that function
// and catch the error to properly handle the according logic (either bail-out or report the error).
// Ideally this should extend FatalError, but that will mean re-working every call-site that catches FatalError
// and make it treat NestedOptimizedFunctionSideEffect errors differently, which isn't ideal so maybe a better
// FatalError catching/handling process is needed throughout the codebase at some point.
class NestedOptimizedFunctionSideEffect extends Error {}

exports.NestedOptimizedFunctionSideEffect = NestedOptimizedFunctionSideEffect;
//# sourceMappingURL=errors.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepackSources = prepackSources;
exports.prepackVersion = void 0;

var _index = _interopRequireDefault(__webpack_require__(5));

var _construct_realm = _interopRequireDefault(__webpack_require__(449));

var _globals = _interopRequireDefault(__webpack_require__(630));

var _index2 = __webpack_require__(232);

var _prepackOptions = __webpack_require__(649);

var _errors = __webpack_require__(3);

var _types = __webpack_require__(19);

var _completions = __webpack_require__(18);

var _options = __webpack_require__(2);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _package = __webpack_require__(650);

var _statistics = __webpack_require__(407);

var _ResidualHeapVisitor = __webpack_require__(423);

var _modules = __webpack_require__(411);

var _logger = __webpack_require__(412);

var _generator = __webpack_require__(237);

var _index3 = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/* APIs for running Prepack for code where a model of the environment is supplied as part of the code. */
function prepackSources(sourceFileCollection, options = _options.defaultOptions, statistics = undefined) {
  if (Array.isArray(sourceFileCollection)) sourceFileCollection = new _types.SourceFileCollection(sourceFileCollection);
  let realmOptions = (0, _prepackOptions.getRealmOptions)(options);
  realmOptions.errorHandler = options.errorHandler;
  let realm = (0, _construct_realm.default)(realmOptions, options.debuggerConfigArgs, statistics || new _statistics.SerializerStatistics(), options.debugReproArgs);
  (0, _globals.default)(realm);

  if (typeof options.additionalGlobals === "function") {
    options.additionalGlobals(realm);
  }

  if (options.check) {
    realm.generator = new _generator.Generator(realm, "main", realm.pathConditions);
    let logger = new _logger.Logger(realm, !!options.internalDebug);
    let modules = new _modules.Modules(realm, logger, !!options.logModules);
    let [result] = realm.$GlobalEnv.executeSources(sourceFileCollection.toArray());
    if (result instanceof _completions.AbruptCompletion) throw result;
    (0, _invariant.default)(options.check);
    checkResidualFunctions(modules, options.check[0], options.check[1]);
    return {
      code: "",
      map: undefined
    };
  } else {
    let serializer = new _index.default(realm, (0, _prepackOptions.getSerializerOptions)(options));
    let serialized = serializer.init(sourceFileCollection, options.sourceMaps, options.onParse, options.onExecute); //Turn off the debugger if there is one

    if (realm.debuggerInstance) {
      realm.debuggerInstance.shutdown();
    }

    if (!serialized) {
      throw new _errors.FatalError("serializer failed");
    }

    if (realm.debugReproManager) {
      let localManager = realm.debugReproManager;
      let sourcePaths = {
        sourceFiles: localManager.getSourceFilePaths(),
        sourceMaps: localManager.getSourceMapPaths()
      };
      serialized.sourceFilePaths = sourcePaths;
    }

    return serialized;
  }
}

function checkResidualFunctions(modules, startFunc, totalToAnalyze) {
  let realm = modules.realm;
  let env = realm.$GlobalEnv;
  realm.$GlobalObject.makeSimple();
  let errorHandler = realm.errorHandler;
  if (!errorHandler) errorHandler = (diag, suppressDiagnostics) => realm.handleError(diag);

  realm.errorHandler = (diag, suppressDiagnostics) => {
    (0, _invariant.default)(errorHandler);
    if (diag.severity === "FatalError") return errorHandler(diag, realm.suppressDiagnostics);else return "Recover";
  };

  modules.resolveInitializedModules();
  let residualHeapVisitor = new _ResidualHeapVisitor.ResidualHeapVisitor(realm, modules.logger, modules, new Map());
  residualHeapVisitor.visitRoots();
  if (modules.logger.hasErrors()) return;
  let totalFunctions = 0;
  let nonFatalFunctions = 0;

  for (let fi of residualHeapVisitor.functionInstances.values()) {
    totalFunctions++;
    if (totalFunctions <= startFunc) continue;
    let fv = fi.functionValue;
    console.log("analyzing: " + totalFunctions);
    let thisValue = realm.intrinsics.null;
    let n = fv.getLength() || 0;
    let args = [];

    for (let i = 0; i < n; i++) {
      let name = "dummy parameter";

      let ob = _index3.AbstractValue.createFromType(realm, _index3.ObjectValue, name);

      ob.makeSimple("transitive");
      ob.intrinsicName = name;
      args[i] = ob;
    } // todo: eventually join these effects, apply them to the global state and iterate to a fixed point


    try {
      realm.evaluateForEffectsInGlobalEnv(() => (0, _index2.EvaluateDirectCallWithArgList)(modules.realm, true, env, fv, fv, thisValue, args));
      nonFatalFunctions++;
    } catch (e) {}

    if (totalFunctions >= startFunc + totalToAnalyze) break;
  }

  console.log(`Analyzed ${totalToAnalyze} functions starting at ${startFunc} of which ${nonFatalFunctions} did not have fatal errors.`);
}

const prepackVersion = _package.version;
exports.prepackVersion = prepackVersion;
//# sourceMappingURL=prepack-standalone.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _serializer = __webpack_require__(6);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
var _default = _serializer.Serializer;
exports.default = _default;
//# sourceMappingURL=index.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Serializer = void 0;

var _realm = __webpack_require__(7);

var _errors = __webpack_require__(3);

var _types = __webpack_require__(19);

var _completions = __webpack_require__(18);

var _generator = __webpack_require__(237);

var _generator2 = _interopRequireDefault(__webpack_require__(335));

var _traverseFast = _interopRequireDefault(__webpack_require__(279));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _statistics = __webpack_require__(407);

var _types2 = __webpack_require__(408);

var _functions = __webpack_require__(409);

var _logger = __webpack_require__(412);

var _modules = __webpack_require__(411);

var _flow = __webpack_require__(421);

var _LoggingTracer = __webpack_require__(422);

var _ResidualHeapVisitor = __webpack_require__(423);

var _ResidualHeapSerializer = __webpack_require__(433);

var _ResidualHeapValueIdentifiers = __webpack_require__(441);

var _LazyObjectsSerializer = __webpack_require__(445);

var t = _interopRequireWildcard(__webpack_require__(21));

var _ResidualHeapRefCounter = __webpack_require__(446);

var _ResidualHeapGraphGenerator = __webpack_require__(447);

var _Referentializer = __webpack_require__(439);

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _descriptors = __webpack_require__(268);

var _ResidualOptimizedFunctions = __webpack_require__(448);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class Serializer {
  constructor(realm, serializerOptions = {}) {
    (0, _invariant.default)(realm.useAbstractInterpretation); // Start tracking mutations

    realm.generator = new _generator.Generator(realm, "main", realm.pathConditions);
    this.realm = realm;
    this.logger = new _logger.Logger(this.realm, !!serializerOptions.internalDebug);
    this.modules = new _modules.Modules(this.realm, this.logger, !!serializerOptions.logModules);
    this.functions = new _functions.Functions(this.realm, this.modules.moduleTracer);

    if (serializerOptions.trace) {
      let loggingTracer = new _LoggingTracer.LoggingTracer(this.realm);
      this.realm.tracers.push(loggingTracer);
    }

    this.options = serializerOptions;
  }

  _execute(sourceFileCollection, sourceMaps = false, onParse) {
    let realm = this.realm;
    let [res, code] = realm.$GlobalEnv.executeSources(sourceFileCollection.toArray(), "script", ast => {
      let realmPreludeGenerator = realm.preludeGenerator;
      (0, _invariant.default)(realmPreludeGenerator);
      let forbiddenNames = realmPreludeGenerator.nameGenerator.forbiddenNames;
      (0, _traverseFast.default)(ast, node => {
        if (!t.isIdentifier(node)) return false;
        forbiddenNames.add(node.name);
        return true;
      });
      if (onParse) onParse(ast);
    }); // Release memory of source files and their source maps

    sourceFileCollection.destroy();

    if (res instanceof _completions.AbruptCompletion) {
      let context = new _realm.ExecutionContext();
      realm.pushContext(context);

      try {
        this.logger.logCompletion(res);
      } finally {
        realm.popContext(context);
      }

      let diagnostic = new _errors.CompilerDiagnostic("Global code may end abruptly", res.location, "PP0016", "FatalError");
      realm.handleError(diagnostic);
      throw new _errors.FatalError();
    }

    return code;
  } // When global.__output is an object, then this function replaces the global generator
  // with one that declares global variables corresponding to the key-value pairs in the __output object,
  // effectively rewriting the roots for visiting/serialization.


  processOutputEntries() {
    let realm = this.realm;
    let output = this.logger.tryQuery(() => (0, _index.Get)(realm, realm.$GlobalObject, "__output"), realm.intrinsics.undefined);
    if (!(output instanceof _index2.ObjectValue)) return false;
    let generator = realm.generator;
    let preludeGenerator = realm.preludeGenerator;
    if (generator === undefined || preludeGenerator === undefined) return false;
    generator._entries.length = 0;
    preludeGenerator.declaredGlobals.clear();

    for (let name of _singletons.Properties.GetOwnPropertyKeysArray(realm, output, false, false)) {
      let property = output.properties.get(name);
      if (!property) continue;
      let value = property.descriptor instanceof _descriptors.PropertyDescriptor && property.descriptor.value;
      if (!(value instanceof _index2.Value)) continue;
      generator.emitGlobalDeclaration(name, value);
    }

    return true;
  }

  init(sourceFileCollection, sourceMaps = false, onParse, onExecute) {
    let realmStatistics = this.realm.statistics;
    (0, _invariant.default)(realmStatistics instanceof _statistics.SerializerStatistics, "serialization requires SerializerStatistics");
    let statistics = realmStatistics;
    let result = statistics.total.measure(() => {
      // Phase 1: Let's interpret.
      if (this.realm.react.verbose) {
        this.logger.logInformation(`Evaluating initialization path...`);
      }

      let code = this._execute(sourceFileCollection, sourceMaps, onParse);

      if (this.logger.hasErrors()) return undefined;

      if (!this.processOutputEntries()) {
        statistics.resolveInitializedModules.measure(() => this.modules.resolveInitializedModules());
      }

      statistics.checkThatFunctionsAreIndependent.measure(() => this.functions.checkThatFunctionsAreIndependent());
      let reactStatistics;

      if (this.realm.react.enabled) {
        statistics.optimizeReactComponentTreeRoots.measure(() => {
          reactStatistics = new _types2.ReactStatistics();
          this.functions.optimizeReactComponentTreeRoots(reactStatistics);
        });
      }

      statistics.processCollectedNestedOptimizedFunctions.measure(() => this.functions.processCollectedNestedOptimizedFunctions());
      statistics.dumpIR.measure(() => {
        if (onExecute !== undefined) {
          let optimizedFunctions = new Map();

          for (let [functionValue, additionalFunctionEffects] of this.functions.getAdditionalFunctionValuesToEffects()) optimizedFunctions.set(functionValue, additionalFunctionEffects.generator);

          onExecute(this.realm, optimizedFunctions);
        }
      });
      let modulesToInitialize = this.options.modulesToInitialize;

      if (modulesToInitialize) {
        statistics.modulesToInitialize.measure(() => this.modules.initializeMoreModules(modulesToInitialize));
        if (this.logger.hasErrors()) return undefined;
      }

      let heapGraph;

      let ast = (() => {
        // We wrap the following in an anonymous function declaration to ensure
        // that all local variables are locally scoped, and allocated memory cannot
        // get released when this function returns.
        let additionalFunctionValuesAndEffects = this.functions.getAdditionalFunctionValuesToEffects(); // Deep traversal of the heap to identify the necessary scope of residual functions

        let preludeGenerator = this.realm.preludeGenerator;
        (0, _invariant.default)(preludeGenerator !== undefined);

        if (this.realm.react.verbose) {
          this.logger.logInformation(`Visiting evaluated nodes...`);
        }

        let [residualHeapInfo, generatorTree, inspector] = (() => {
          let residualHeapVisitor = new _ResidualHeapVisitor.ResidualHeapVisitor(this.realm, this.logger, this.modules, additionalFunctionValuesAndEffects);
          statistics.deepTraversal.measure(() => residualHeapVisitor.visitRoots());
          return [residualHeapVisitor.toInfo(), residualHeapVisitor.generatorTree, residualHeapVisitor.inspector];
        })();

        if (this.logger.hasErrors()) return undefined;
        let residualOptimizedFunctions = new _ResidualOptimizedFunctions.ResidualOptimizedFunctions(generatorTree, additionalFunctionValuesAndEffects, residualHeapInfo.values);
        let referentializer = new _Referentializer.Referentializer(this.realm, this.options, preludeGenerator.createNameGenerator("__scope_"), preludeGenerator.createNameGenerator("__get_scope_binding_"), preludeGenerator.createNameGenerator("__leaked_"), residualOptimizedFunctions);
        statistics.referentialization.measure(() => {
          for (let instance of residualHeapInfo.functionInstances.values()) referentializer.referentialize(instance);
        });

        if (this.realm.react.verbose) {
          this.logger.logInformation(`Serializing evaluated nodes...`);
        }

        const realmPreludeGenerator = this.realm.preludeGenerator;
        (0, _invariant.default)(realmPreludeGenerator);
        const residualHeapValueIdentifiers = new _ResidualHeapValueIdentifiers.ResidualHeapValueIdentifiers(residualHeapInfo.values.keys(), realmPreludeGenerator);

        if (this.options.heapGraphFormat) {
          const heapRefCounter = new _ResidualHeapRefCounter.ResidualHeapRefCounter(this.realm, this.logger, this.modules, additionalFunctionValuesAndEffects);
          heapRefCounter.visitRoots();
          const heapGraphGenerator = new _ResidualHeapGraphGenerator.ResidualHeapGraphGenerator(this.realm, this.logger, this.modules, additionalFunctionValuesAndEffects, residualHeapValueIdentifiers, heapRefCounter.getResult());
          heapGraphGenerator.visitRoots();
          (0, _invariant.default)(this.options.heapGraphFormat);
          heapGraph = heapGraphGenerator.generateResult(this.options.heapGraphFormat);
        } // Phase 2: Let's serialize the heap and generate code.
        // Serialize for the first time in order to gather reference counts


        if (this.options.inlineExpressions) {
          residualHeapValueIdentifiers.initPass1();
          statistics.referenceCounts.measure(() => {
            new _ResidualHeapSerializer.ResidualHeapSerializer(this.realm, this.logger, this.modules, residualHeapValueIdentifiers, inspector, residualHeapInfo, this.options, additionalFunctionValuesAndEffects, referentializer, generatorTree, residualOptimizedFunctions).serialize();
          });
          if (this.logger.hasErrors()) return undefined;
          residualHeapValueIdentifiers.initPass2();
        } // Serialize for a second time, using reference counts to minimize number of generated identifiers


        const TargetSerializer = this.options.lazyObjectsRuntime != null ? _LazyObjectsSerializer.LazyObjectsSerializer : _ResidualHeapSerializer.ResidualHeapSerializer;
        statistics.resetBeforePass();
        return statistics.serializePass.measure(() => new TargetSerializer(this.realm, this.logger, this.modules, residualHeapValueIdentifiers, inspector, residualHeapInfo, this.options, additionalFunctionValuesAndEffects, referentializer, generatorTree, residualOptimizedFunctions).serialize());
      })();

      (0, _invariant.default)(ast !== undefined);

      if (this.realm.stripFlow) {
        (0, _flow.stripFlowTypeAnnotations)(ast);
      } // the signature for generate is not complete, hence the any


      let generated = statistics.babelGenerate.measure(() => (0, _generator2.default)(ast, {
        sourceMaps: sourceMaps
      }, code));
      (0, _invariant.default)(!this.logger.hasErrors());
      return {
        code: generated.code,
        map: generated.map,
        statistics,
        reactStatistics,
        heapGraph
      };
    });

    if (this.options.logStatistics) {
      statistics.log();
      statistics.logSerializerPerformanceTrackers("time statistics", statistics.forcingGC ? "Time statistics are skewed because of forced garbage collections; remove --expose-gc flag from node.js invocation to disable forced garbage collections." : undefined, pf => `${pf.time}ms`);
      statistics.logSerializerPerformanceTrackers("memory statistics", statistics.forcingGC ? undefined : "Memory statistics are unreliable because garbage collections could not be forced; pass --expose-gc to node.js to enable forced garbage collections.", pf => `${pf.memory > 0 ? "+" : ""}${Math.round(pf.memory / 1024 / 1024)}MB`);
    }

    return result;
  }

}

exports.Serializer = Serializer;
//# sourceMappingURL=serializer.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.construct_empty_effects = construct_empty_effects;
exports.Realm = exports.ExecutionContext = exports.Tracer = exports.Effects = void 0;

var _statistics = __webpack_require__(8);

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(15);

var _environment = __webpack_require__(20);

var _index3 = __webpack_require__(232);

var _completions = __webpack_require__(18);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _seedrandom = _interopRequireDefault(__webpack_require__(396));

var _generator = __webpack_require__(237);

var _PreludeGenerator = __webpack_require__(238);

var _singletons = __webpack_require__(236);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

let effects_uid = 0;

class Effects {
  constructor(result, generator, bindings, propertyBindings, createdObjects) {
    this.result = result;
    this.generator = generator;
    this.modifiedBindings = bindings;
    this.modifiedProperties = propertyBindings;
    this.createdObjects = createdObjects;
    this.canBeApplied = true;
    this._id = effects_uid++;
  }

  shallowCloneWithResult(result) {
    return new Effects(result, this.generator, this.modifiedBindings, this.modifiedProperties, this.createdObjects);
  }

  toDisplayString() {
    return _singletons.Utils.jsonToDisplayString(this, 10);
  }

  toDisplayJson(depth = 1) {
    if (depth <= 0) return `Effects ${this._id}`;
    return _singletons.Utils.verboseToDisplayJson(this, depth);
  }

}

exports.Effects = Effects;

class Tracer {
  beginEvaluateForEffects(state) {}

  endEvaluateForEffects(state, effects) {}

  detourCall(F, thisArgument, argumentsList, newTarget, performCall) {}

  beforeCall(F, thisArgument, argumentsList, newTarget) {}

  afterCall(F, thisArgument, argumentsList, newTarget, result) {}

  beginOptimizingFunction(optimizedFunctionId, functionValue) {}

  endOptimizingFunction(optimizedFunctionId) {}

}

exports.Tracer = Tracer;

class ExecutionContext {
  setCaller(context) {
    this.caller = context;
  }

  setFunction(F) {
    if (F instanceof _index.ECMAScriptSourceFunctionValue) this.isStrict = F.$Strict;
    this.function = F;
  }

  setLocation(loc) {
    if (!loc) return;
    this.loc = loc;
  }

  setRealm(realm) {
    this.realm = realm;
  }
  /*
   Read-only envs disallow:
   - creating bindings in their scope
   - creating or modifying objects when they are current running context
  */


  setReadOnly(value) {
    let oldReadOnly = this.isReadOnly;
    if (this.variableEnvironment) this.variableEnvironment.environmentRecord.isReadOnly = value;
    if (this.lexicalEnvironment) this.lexicalEnvironment.environmentRecord.isReadOnly = value;
    this.isReadOnly = value;
    return oldReadOnly;
  }

  suspend() {// TODO #712: suspend
  }

  resume() {
    // TODO #712: resume
    return this.realm.intrinsics.undefined;
  }

}

exports.ExecutionContext = ExecutionContext;

function construct_empty_effects(realm, c = new _completions.SimpleNormalCompletion(realm.intrinsics.empty)) {
  return new Effects(c, new _generator.Generator(realm, "construct_empty_effects", realm.pathConditions), new Map(), new Map(), new Set());
}

class Realm {
  constructor(opts, statistics) {
    _defineProperty(this, "contextStack", []);

    _defineProperty(this, "MOBILE_JSC_VERSION", "jsc-600-1-4-17");

    _defineProperty(this, "suppressDiagnostics", false);

    _defineProperty(this, "objectCount", 0);

    _defineProperty(this, "symbolCount", 867501803871088);

    _defineProperty(this, "functionBodyUniqueTagSeed", 1);

    _defineProperty(this, "nextGeneratorId", 0);

    this.statistics = statistics;
    this.isReadOnly = false;
    this.useAbstractInterpretation = opts.serialize === true || Array.isArray(opts.check);
    this.ignoreLeakLogic = false;
    this.isInPureTryStatement = false;

    if (opts.mathRandomSeed !== undefined) {
      this.mathRandomGenerator = (0, _seedrandom.default)(opts.mathRandomSeed);
    }

    this.strictlyMonotonicDateNow = !!opts.strictlyMonotonicDateNow; // 0 = disabled

    this.abstractValueImpliesMax = opts.abstractValueImpliesMax !== undefined ? opts.abstractValueImpliesMax : 0;
    this.abstractValueImpliesCounter = 0;
    this.inSimplificationPath = false;
    this.timeout = opts.timeout;

    if (this.timeout !== undefined) {
      // We'll call Date.now for every this.timeoutCounterThreshold'th AST node.
      // The threshold is there to reduce the cost of the surprisingly expensive Date.now call.
      this.timeoutCounter = this.timeoutCounterThreshold = 1024;
    }

    this.start = Date.now();
    this.compatibility = opts.compatibility !== undefined ? opts.compatibility : "browser";
    this.remainingCalls = opts.maxStackDepth || 112;
    this.invariantLevel = opts.invariantLevel || 0;
    this.invariantMode = opts.invariantMode || "throw";
    this.emitConcreteModel = !!opts.emitConcreteModel;
    this.$TemplateMap = [];
    this.pathConditions = (0, _singletons.createPathConditions)();

    if (this.useAbstractInterpretation) {
      this.preludeGenerator = new _PreludeGenerator.PreludeGenerator(opts.debugNames, opts.uniqueSuffix);

      _index.ObjectValue.setupTrackedPropertyAccessors(_index.ObjectValue.trackedPropertyNames);

      _index.ObjectValue.setupTrackedPropertyAccessors(_index.NativeFunctionValue.trackedPropertyNames);

      _index.ObjectValue.setupTrackedPropertyAccessors(_index.ProxyValue.trackedPropertyNames);
    }

    this.collectedNestedOptimizedFunctionEffects = new Map();
    this.tracers = []; // These get initialized in construct_realm to avoid the dependency

    this.intrinsics = {};
    this.$GlobalObject = {};
    this.evaluators = Object.create(null);
    this.$GlobalEnv = undefined;
    this.derivedIds = new Map();
    this.temporalEntryArgToEntries = new Map();
    this.temporalEntryCounter = 0;
    this.instantRender = {
      enabled: opts.instantRender || false
    };
    this.react = {
      abstractHints: new WeakMap(),
      activeReconciler: undefined,
      classComponentMetadata: new Map(),
      currentOwner: undefined,
      defaultPropsHelper: undefined,
      emptyArray: undefined,
      emptyObject: undefined,
      enabled: opts.reactEnabled || false,
      failOnUnsupportedSideEffects: opts.reactFailOnUnsupportedSideEffects === false ? false : true,
      hoistableFunctions: new WeakMap(),
      hoistableReactElements: new WeakMap(),
      noopFunction: undefined,
      optimizeNestedFunctions: opts.reactOptimizeNestedFunctions || false,
      output: opts.reactOutput || "create-element",
      propsWithNoPartialKeyOrRef: new WeakSet(),
      reactElements: new WeakMap(),
      reactElementStringTypeReferences: new Map(),
      reactProps: new WeakSet(),
      symbols: new Map(),
      usedReactElementKeys: new Set(),
      verbose: opts.reactVerbose || false
    };
    this.reportSideEffectCallbacks = new Set();
    this.alreadyDescribedLocations = new WeakMap();
    this.stripFlow = opts.stripFlow || false;
    this.fbLibraries = {
      other: new Map(),
      react: undefined,
      reactDom: undefined,
      reactDomServer: undefined,
      reactNative: undefined,
      reactRelay: undefined
    };
    this.errorHandler = opts.errorHandler;
    this.globalSymbolRegistry = [];
    this.activeLexicalEnvironments = new Set();
    this._abstractValuesDefined = new Set(); // A set of nameStrings to ensure abstract values have unique names

    this.debugNames = opts.debugNames;
    this._checkedObjectIds = new Map();
    this.optimizedFunctions = new Map();
    this.arrayNestedOptimizedFunctionsEnabled = opts.arrayNestedOptimizedFunctionsEnabled || opts.instantRender || false;
  }

  // to force flow to type the annotations
  isCompatibleWith(compatibility) {
    return compatibility === this.compatibility;
  } // Checks if there is a let binding at global scope with the given name
  // returning it if so


  getGlobalLetBinding(key) {
    let globrec = this.$GlobalEnv.environmentRecord; // GlobalEnv should have a GlobalEnvironmentRecord

    (0, _invariant.default)(globrec instanceof _environment.GlobalEnvironmentRecord);
    let dclrec = globrec.$DeclarativeRecord;

    try {
      return dclrec.HasBinding(key) ? dclrec.GetBindingValue(key, false) : undefined;
    } catch (e) {
      if (e instanceof _errors.FatalError) return undefined;
      throw e;
    }
  }
  /*
   Read only realms disallow:
   - using console.log
   - creating bindings in any existing scopes
   - modifying object properties in any existing scopes
   Setting a realm read-only sets all contained environments to read-only, but
   all new environments (e.g. new ExecutionContexts) will be writeable.
   */


  setReadOnly(readOnlyValue) {
    let oldReadOnly = this.isReadOnly;
    this.isReadOnly = readOnlyValue;
    this.$GlobalEnv.environmentRecord.isReadOnly = readOnlyValue;
    this.contextStack.forEach(ctx => {
      ctx.setReadOnly(readOnlyValue);
    });
    return oldReadOnly;
  }

  testTimeout() {
    let timeout = this.timeout;

    if (timeout !== undefined && ! --this.timeoutCounter) {
      this.timeoutCounter = this.timeoutCounterThreshold;
      let total = Date.now() - this.start;

      if (total > timeout) {
        let error = new _errors.CompilerDiagnostic(`total time has exceeded the timeout time: ${timeout}`, this.currentLocation, "PP0036", "FatalError");
        this.handleError(error);
        throw new _errors.FatalError("Timed out");
      }
    }
  }

  hasRunningContext() {
    return this.contextStack.length !== 0;
  }

  getRunningContext() {
    let context = this.contextStack[this.contextStack.length - 1];
    (0, _invariant.default)(context, "There's no running execution context");
    return context;
  }

  clearBlockBindings(modifiedBindings, environmentRecord) {
    if (modifiedBindings === undefined) return;

    for (let b of modifiedBindings.keys()) {
      if (b.mightHaveBeenCaptured) continue;
      if (environmentRecord.bindings[b.name] && environmentRecord.bindings[b.name] === b) modifiedBindings.delete(b);
    }
  } // Call when a scope falls out of scope and should be destroyed.
  // Clears the Bindings corresponding to the disappearing Scope from ModifiedBindings


  onDestroyScope(lexicalEnvironment) {
    (0, _invariant.default)(this.activeLexicalEnvironments.has(lexicalEnvironment));
    let modifiedBindings = this.modifiedBindings;

    if (modifiedBindings) {
      // Don't undo things to global scope because it's needed past its destruction point (for serialization)
      let environmentRecord = lexicalEnvironment.environmentRecord;

      if (environmentRecord instanceof _environment.DeclarativeEnvironmentRecord) {
        this.clearBlockBindings(modifiedBindings, environmentRecord);
      }
    } // Ensures if we call onDestroyScope too early, there will be a failure.


    this.activeLexicalEnvironments.delete(lexicalEnvironment);
    lexicalEnvironment.destroy();
  }

  startCall() {
    if (this.remainingCalls === 0) {
      let error = new _errors.CompilerDiagnostic("Maximum stack depth exceeded", this.currentLocation, "PP0045", "FatalError");
      this.handleError(error);
      throw new _errors.FatalError();
    }

    this.remainingCalls--;
  }

  endCall() {
    this.remainingCalls++;
  }

  pushContext(context) {
    this.contextStack.push(context);
  }

  markVisibleLocalBindingsAsPotentiallyCaptured() {
    let context = this.getRunningContext();
    if (context.function === undefined) return;
    let lexEnv = context.lexicalEnvironment;

    while (lexEnv != null) {
      let envRec = lexEnv.environmentRecord;

      if (envRec instanceof _environment.DeclarativeEnvironmentRecord) {
        let bindings = envRec.bindings;

        for (let name in bindings) {
          let binding = bindings[name];
          binding.mightHaveBeenCaptured = true;
        }
      }

      lexEnv = lexEnv.parent;
    }
  }

  clearFunctionBindings(modifiedBindings, funcVal) {
    if (modifiedBindings === undefined) return;

    for (let b of modifiedBindings.keys()) {
      if (b.mightHaveBeenCaptured) continue;
      if (b.environment instanceof _environment.FunctionEnvironmentRecord && b.environment.$FunctionObject === funcVal) modifiedBindings.delete(b);
    }
  }

  popContext(context) {
    let funcVal = context.function;

    if (funcVal) {
      this.clearFunctionBindings(this.modifiedBindings, funcVal);
    }

    let c = this.contextStack.pop();
    (0, _invariant.default)(c === context);
  }

  wrapInGlobalEnv(callback) {
    let context = new ExecutionContext();
    context.isStrict = this.isStrict;
    context.lexicalEnvironment = this.$GlobalEnv;
    context.variableEnvironment = this.$GlobalEnv;
    context.realm = this;
    this.pushContext(context);

    try {
      return callback();
    } finally {
      this.popContext(context);
    }
  }

  assignToGlobal(name, value) {
    this.wrapInGlobalEnv(() => this.$GlobalEnv.assignToGlobal(name, value));
  }

  deleteGlobalBinding(name) {
    this.$GlobalEnv.environmentRecord.DeleteBinding(name);
  }

  neverCheckProperty(object, P) {
    return P.startsWith("__") || object === this.$GlobalObject && P === "global" || object.intrinsicName !== undefined && object.intrinsicName.startsWith("__");
  }

  _getCheckedBindings() {
    let globalObject = this.$GlobalObject;
    (0, _invariant.default)(globalObject instanceof _index.ObjectValue);
    let binding = globalObject.properties.get("__checkedBindings");
    (0, _invariant.default)(binding !== undefined);
    let checkedBindingsObject = binding.descriptor && binding.descriptor.throwIfNotConcrete(this).value;
    (0, _invariant.default)(checkedBindingsObject instanceof _index.ObjectValue);
    return checkedBindingsObject;
  }

  markPropertyAsChecked(object, P) {
    (0, _invariant.default)(!this.neverCheckProperty(object, P));

    let objectId = this._checkedObjectIds.get(object);

    if (objectId === undefined) this._checkedObjectIds.set(object, objectId = this._checkedObjectIds.size);
    let id = `__propertyHasBeenChecked__${objectId}:${P}`;

    let checkedBindings = this._getCheckedBindings();

    checkedBindings.$Set(id, this.intrinsics.true, checkedBindings);
  }

  hasBindingBeenChecked(object, P) {
    if (this.neverCheckProperty(object, P)) return true;

    let objectId = this._checkedObjectIds.get(object);

    if (objectId === undefined) return false;
    let id = `__propertyHasBeenChecked__${objectId}:${P}`;

    let binding = this._getCheckedBindings().properties.get(id);

    if (binding === undefined) return false;
    let value = binding.descriptor && binding.descriptor.throwIfNotConcrete(this).value;
    return value instanceof _index.Value && !value.mightNotBeTrue();
  } // Evaluate a context as if it won't have any side-effects outside of any objects
  // that it created itself. This promises that any abstract functions inside of it
  // also won't have effects on any objects or bindings that weren't created in this
  // call.


  evaluatePure(f, bubbleSideEffectReports, reportSideEffectFunc) {
    let saved_createdObjectsTrackedForLeaks = this.createdObjectsTrackedForLeaks;
    let saved_reportSideEffectCallbacks; // Track all objects (including function closures) created during
    // this call. This will be used to make the assumption that every
    // *other* object is unchanged (pure). These objects are marked
    // as leaked if they're passed to abstract functions.

    this.createdObjectsTrackedForLeaks = new Set();

    if (reportSideEffectFunc !== null) {
      if (!bubbleSideEffectReports) {
        saved_reportSideEffectCallbacks = this.reportSideEffectCallbacks;
        this.reportSideEffectCallbacks = new Set();
      }

      this.reportSideEffectCallbacks.add(reportSideEffectFunc);
    }

    try {
      return f();
    } finally {
      if (saved_createdObjectsTrackedForLeaks === undefined) {
        this.createdObjectsTrackedForLeaks = undefined;
      } else {
        // Add any created objects from the child evaluatePure's tracked objects set to the
        // current tracked objects set.
        if (this.createdObjectsTrackedForLeaks !== undefined) {
          for (let obj of this.createdObjectsTrackedForLeaks) {
            saved_createdObjectsTrackedForLeaks.add(obj);
          }
        }

        this.createdObjectsTrackedForLeaks = saved_createdObjectsTrackedForLeaks;
      }

      if (reportSideEffectFunc !== null) {
        if (!bubbleSideEffectReports && saved_reportSideEffectCallbacks !== undefined) {
          this.reportSideEffectCallbacks = saved_reportSideEffectCallbacks;
        }

        this.reportSideEffectCallbacks.delete(reportSideEffectFunc);
      }
    }
  }

  isInPureScope() {
    return !!this.createdObjectsTrackedForLeaks;
  }

  evaluateWithoutLeakLogic(f) {
    (0, _invariant.default)(!this.ignoreLeakLogic, "Nesting evaluateWithoutLeakLogic() calls is not supported.");
    this.ignoreLeakLogic = true;

    try {
      return f();
    } finally {
      this.ignoreLeakLogic = false;
    }
  } // Evaluate some code that might generate temporal values knowing that it might end in an abrupt
  // completion. We only need to support ThrowCompletion for now but this can be expanded to support other
  // abrupt completions.


  evaluateWithPossibleThrowCompletion(f, thrownTypes, thrownValues) {
    // The cases when we need this are only when we might invoke unknown code such as abstract
    // funtions, getters, custom coercion etc. It is possible we can use this in other cases
    // where something might throw a built-in error but can never issue arbitrary code such as
    // calling something that might not be a function. For now we only use it in pure functions.
    (0, _invariant.default)(this.isInPureScope(), "only abstract abrupt completion in pure functions"); // TODO(1264): We should create a new generator for this scope and wrap it in a try/catch.
    // We could use the outcome of that as the join condition for a JoinedNormalAndAbruptCompletions.
    // We should then compose that with the saved completion and move on to the normal route.
    // Currently we just issue a recoverable error instead if this might matter.

    let value = f();

    if (this.isInPureTryStatement) {
      let diag = new _errors.CompilerDiagnostic("Possible throw inside try/catch is not yet supported", this.currentLocation, "PP0021", "RecoverableError");
      if (this.handleError(diag) !== "Recover") throw new _errors.FatalError();
    }

    return value;
  } // Evaluate the given ast in a sandbox and return the evaluation results
  // in the form of a completion, a code generator, a map of changed variable
  // bindings and a map of changed property bindings.


  evaluateNodeForEffects(ast, strictCode, env, state, generatorName = "evaluateNodeForEffects") {
    return this.evaluateForEffects(() => env.evaluateCompletionDeref(ast, strictCode), state, generatorName);
  }

  evaluateForEffectsInGlobalEnv(func, state, generatorName = "evaluateForEffectsInGlobalEnv") {
    return this.wrapInGlobalEnv(() => this.evaluateForEffects(func, state, generatorName));
  } // NB: does not apply generators because there's no way to cleanly revert them.
  // func should not return undefined


  withEffectsAppliedInGlobalEnv(func, effects) {
    let result;
    this.evaluateForEffectsInGlobalEnv(() => {
      try {
        this.applyEffects(effects, "", false);
        result = func(effects);
        return this.intrinsics.undefined;
      } finally {
        this.restoreBindings(effects.modifiedBindings);
        this.restoreProperties(effects.modifiedProperties);
        (0, _invariant.default)(!effects.canBeApplied);
        effects.canBeApplied = true;
      }
    });
    (0, _invariant.default)(result !== undefined, "If we get here, func must have returned undefined.");
    return result;
  }

  withNewOptimizedFunction(func, optimizedFunction) {
    let result;
    let previousOptimizedFunction = this.currentOptimizedFunction;
    this.currentOptimizedFunction = optimizedFunction;

    try {
      result = func();
    } finally {
      this.currentOptimizedFunction = previousOptimizedFunction;
    }

    return result;
  }

  evaluateNodeForEffectsInGlobalEnv(node, state, generatorName) {
    return this.wrapInGlobalEnv(() => this.evaluateNodeForEffects(node, false, this.$GlobalEnv, state, generatorName));
  } // Use this to evaluate code for internal purposes, so that the tracked state does not get polluted


  evaluateWithoutEffects(f) {
    // Save old state and set up undefined state
    let savedGenerator = this.generator;
    let savedBindings = this.modifiedBindings;
    let savedProperties = this.modifiedProperties;
    let savedCreatedObjects = this.createdObjects;
    let saved_completion = this.savedCompletion;

    try {
      this.generator = new _generator.Generator(this, "evaluateIgnoringEffects", this.pathConditions);
      this.modifiedBindings = undefined;
      this.modifiedProperties = undefined;
      this.createdObjects = undefined;
      this.savedCompletion = undefined;
      return f();
    } finally {
      this.generator = savedGenerator;
      this.modifiedBindings = savedBindings;
      this.modifiedProperties = savedProperties;
      this.createdObjects = savedCreatedObjects;
      this.savedCompletion = saved_completion;
    }
  }

  evaluateForEffects(f, state, generatorName) {
    // Save old state and set up empty state
    let [savedBindings, savedProperties] = this.getAndResetModifiedMaps();
    let saved_generator = this.generator;
    let saved_createdObjects = this.createdObjects;
    let saved_completion = this.savedCompletion;
    let saved_abstractValuesDefined = this._abstractValuesDefined;
    this.generator = new _generator.Generator(this, generatorName, this.pathConditions);
    this.createdObjects = new Set();
    this.savedCompletion = undefined; // while in this call, we only explore the normal path.

    this._abstractValuesDefined = new Set(saved_abstractValuesDefined);
    let result;

    try {
      for (let t1 of this.tracers) t1.beginEvaluateForEffects(state);

      let c;

      try {
        try {
          c = f();
          if (c instanceof _environment.Reference) c = _singletons.Environment.GetValue(this, c);else if (c instanceof _completions.SimpleNormalCompletion) c = c.value;
        } catch (e) {
          if (e instanceof _completions.AbruptCompletion) c = e;else throw e;
        } // This is a join point for any normal completions inside realm.savedCompletion


        c = _singletons.Functions.incorporateSavedCompletion(this, c);
        (0, _invariant.default)(c !== undefined);
        (0, _invariant.default)(this.generator !== undefined);
        (0, _invariant.default)(this.modifiedBindings !== undefined);
        (0, _invariant.default)(this.modifiedProperties !== undefined);
        (0, _invariant.default)(this.createdObjects !== undefined);
        let astGenerator = this.generator;
        let astBindings = this.modifiedBindings;
        let astProperties = this.modifiedProperties;
        let astCreatedObjects = this.createdObjects;
        /* TODO #1615: The following invariant should hold.
         // Check invariant that modified bindings to not refer to environment record belonging to
        // newly created closure objects.
        for (let binding of astBindings.keys())
          if (binding.environment instanceof FunctionEnvironmentRecord)
            invariant(!astCreatedObjects.has(binding.environment.$FunctionObject));
        */
        // Return the captured state changes and evaluation result

        if (c instanceof _index.Value) c = new _completions.SimpleNormalCompletion(c);
        result = new Effects(c, astGenerator, astBindings, astProperties, astCreatedObjects);
        return result;
      } finally {
        // Roll back the state changes
        if (result !== undefined) {
          this.restoreBindings(result.modifiedBindings);
          this.restoreProperties(result.modifiedProperties);
        } else {
          this.restoreBindings(this.modifiedBindings);
          this.restoreProperties(this.modifiedProperties);
          let completion = this.savedCompletion;

          while (completion !== undefined) {
            const {
              savedEffects
            } = completion;

            if (savedEffects !== undefined) {
              this.restoreBindings(savedEffects.modifiedBindings);
              this.restoreProperties(savedEffects.modifiedProperties);
            }

            completion = completion.composedWith;
          }
        }

        this.generator = saved_generator;
        this.modifiedBindings = savedBindings;
        this.modifiedProperties = savedProperties;
        this.createdObjects = saved_createdObjects;
        this.savedCompletion = saved_completion;
        this._abstractValuesDefined = saved_abstractValuesDefined;
      }
    } finally {
      for (let t2 of this.tracers) t2.endEvaluateForEffects(state, result);
    }
  }

  evaluateWithUndo(f, defaultValue = this.intrinsics.undefined) {
    if (!this.useAbstractInterpretation) return f();
    let oldErrorHandler = this.errorHandler;

    this.errorHandler = d => {
      if (d.severity === "Information" || d.severity === "Warning") return "Recover";
      return "Fail";
    };

    try {
      let effects = this.evaluateForEffects(() => {
        try {
          return f();
        } catch (e) {
          if (e instanceof _completions.Completion) {
            return defaultValue;
          } else if (e instanceof _errors.FatalError) {
            return defaultValue;
          } else {
            throw e;
          }
        }
      }, undefined, "evaluateWithUndo");
      return effects.result instanceof _completions.SimpleNormalCompletion ? effects.result.value : defaultValue;
    } finally {
      this.errorHandler = oldErrorHandler;
    }
  }

  evaluateWithUndoForDiagnostic(f) {
    if (!this.useAbstractInterpretation) return f();
    let savedHandler = this.errorHandler;
    let diagnostic;

    try {
      this.errorHandler = d => {
        diagnostic = d;
        return "Fail";
      };

      let effects = this.evaluateForEffects(f, undefined, "evaluateWithUndoForDiagnostic");
      this.applyEffects(effects);
      let resultVal = effects.result;
      if (resultVal instanceof _completions.AbruptCompletion) throw resultVal;
      return resultVal.value;
    } catch (e) {
      if (diagnostic !== undefined) return diagnostic;
      throw e;
    } finally {
      this.errorHandler = savedHandler;
    }
  }

  evaluateForFixpointEffects(iteration) {
    try {
      let test;

      let f = () => {
        let result;
        [test, result] = iteration();
        if (!(test instanceof _index.AbstractValue)) throw new _errors.FatalError("loop terminates before fixed point");
        (0, _invariant.default)(result instanceof _completions.Completion);
        return result;
      };

      let effects1 = this.evaluateForEffects(f, undefined, "evaluateForFixpointEffects/1");

      while (true) {
        this.restoreBindings(effects1.modifiedBindings);
        this.restoreProperties(effects1.modifiedProperties);
        let effects2 = this.evaluateForEffects(f, undefined, "evaluateForFixpointEffects/2");
        this.restoreBindings(effects1.modifiedBindings);
        this.restoreProperties(effects1.modifiedProperties);

        if (_singletons.Widen.containsEffects(effects1, effects2)) {
          // effects1 includes every value present in effects2, so doing another iteration using effects2 will not
          // result in any more values being added to abstract domains and hence a fixpoint has been reached.
          // Generate code using effects2 because its expressions have not been widened away.
          const e2 = effects2;

          this._applyPropertiesToNewlyCreatedObjects(e2.modifiedProperties, e2.createdObjects);

          this._emitPropertyAssignments(e2.generator, e2.modifiedProperties, e2.createdObjects);

          this._emitLocalAssignments(e2.generator, e2.modifiedBindings, e2.createdObjects);

          (0, _invariant.default)(test instanceof _index.AbstractValue);
          let cond = e2.generator.deriveAbstract(test.types, test.values, [test], (0, _generator.createOperationDescriptor)("SINGLE_ARG"), {
            skipInvariant: true
          });
          return [effects1, effects2, cond];
        }

        effects1 = _singletons.Widen.widenEffects(this, effects1, effects2);
      }
    } catch (e) {
      if (e instanceof _errors.FatalError) return undefined;
      throw e;
    }
  }

  evaluateWithAbstractConditional(condValue, consequentEffectsFunc, alternateEffectsFunc) {
    let effects;

    if (_singletons.Path.implies(condValue)) {
      effects = consequentEffectsFunc();
    } else if (_singletons.Path.impliesNot(condValue)) {
      effects = alternateEffectsFunc();
    } else {
      // Join effects
      let effects1;

      try {
        effects1 = _singletons.Path.withCondition(condValue, consequentEffectsFunc);
      } catch (e) {
        if (!(e instanceof _errors.InfeasiblePathError)) throw e;
      }

      let effects2;

      try {
        effects2 = _singletons.Path.withInverseCondition(condValue, alternateEffectsFunc);
      } catch (e) {
        if (!(e instanceof _errors.InfeasiblePathError)) throw e;
      }

      if (effects1 === undefined || effects2 === undefined) {
        if (effects1 === undefined && effects2 === undefined) throw new _errors.InfeasiblePathError();
        effects = effects1 || effects2;
        (0, _invariant.default)(effects !== undefined);
      } else {
        // Join the effects, creating an abstract view of what happened, regardless
        // of the actual value of condValue.
        effects = _singletons.Join.joinEffects(condValue, effects1, effects2);
      }
    }

    this.applyEffects(effects);
    return condValue.$Realm.returnOrThrowCompletion(effects.result);
  }

  _applyPropertiesToNewlyCreatedObjects(modifiedProperties, newlyCreatedObjects) {
    if (modifiedProperties === undefined) return;
    modifiedProperties.forEach((desc, propertyBinding, m) => {
      if (newlyCreatedObjects.has(propertyBinding.object)) {
        propertyBinding.descriptor = desc;
      }
    });
  } // populate the loop body generator with assignments that will update the phiNodes


  _emitLocalAssignments(gen, bindings, newlyCreatedObjects) {
    let tvalFor = new Map();
    bindings.forEach((binding, key, map) => {
      let val = binding.value;

      if (val instanceof _index.AbstractValue) {
        (0, _invariant.default)(val.operationDescriptor !== undefined);
        let tval = gen.deriveAbstract(val.types, val.values, [val], (0, _generator.createOperationDescriptor)("SINGLE_ARG"));
        tvalFor.set(key, tval);
      }
    });
    bindings.forEach((binding, key, map) => {
      let val = binding.value;

      if (val instanceof _index.AbstractValue) {
        let phiNode = key.phiNode;
        let tval = tvalFor.get(key);
        (0, _invariant.default)(tval !== undefined);
        gen.emitStatement([tval], (0, _generator.createOperationDescriptor)("LOCAL_ASSIGNMENT", {
          value: phiNode
        }));
      }

      if (val instanceof _index.ObjectValue && newlyCreatedObjects.has(val)) {
        let phiNode = key.phiNode;
        gen.emitStatement([val], (0, _generator.createOperationDescriptor)("LOCAL_ASSIGNMENT", {
          value: phiNode
        }));
      }
    });
  } // populate the loop body generator with assignments that will update properties modified inside the loop


  _emitPropertyAssignments(gen, pbindings, newlyCreatedObjects) {
    let tvalFor = new Map();
    pbindings.forEach((val, key, map) => {
      if (newlyCreatedObjects.has(key.object) || key.object.refuseSerialization) {
        return;
      }

      let value = val && val.throwIfNotConcrete(this).value;

      if (value instanceof _index.AbstractValue) {
        (0, _invariant.default)(value.operationDescriptor !== undefined);
        let tval = gen.deriveAbstract(value.types, value.values, [key.object, value], (0, _generator.createOperationDescriptor)("LOGICAL_PROPERTY_ASSIGNMENT", {
          propertyBinding: key,
          value
        }), {
          skipInvariant: true
        });
        tvalFor.set(key, tval);
      }
    });
    pbindings.forEach((val, key, map) => {
      if (newlyCreatedObjects.has(key.object) || key.object.refuseSerialization) {
        return;
      }

      let path = key.pathNode;
      let tval = tvalFor.get(key);
      (0, _invariant.default)(val !== undefined);
      let value = val.throwIfNotConcrete(this).value;
      (0, _invariant.default)(value instanceof _index.Value);
      let keyKey = key.key;

      if (typeof keyKey === "string") {
        if (path !== undefined) {
          gen.emitStatement([key.object, tval || value, this.intrinsics.empty, new _index.StringValue(this, keyKey)], (0, _generator.createOperationDescriptor)("CONDITIONAL_PROPERTY_ASSIGNMENT", {
            path,
            value
          }));
        } else {// RH value was not widened, so it must have been a constant. We don't need to assign that inside the loop.
          // Note, however, that if the LH side is a property of an intrinsic object, then an assignment will
          // have been emitted to the generator.
        }
      } else {
        // TODO: What if keyKey is undefined?
        (0, _invariant.default)(keyKey instanceof _index.Value);
        gen.emitStatement([key.object, keyKey, tval || value, this.intrinsics.empty], (0, _generator.createOperationDescriptor)("PROPERTY_ASSIGNMENT", {
          path
        }));
      }
    });
  }

  returnOrThrowCompletion(completion) {
    if (completion instanceof _index.Value) completion = new _completions.SimpleNormalCompletion(completion);

    if (completion instanceof _completions.AbruptCompletion) {
      let c = _singletons.Functions.incorporateSavedCompletion(this, completion);

      (0, _invariant.default)(c instanceof _completions.Completion);
      completion = c;
    }

    let cc = this.composeWithSavedCompletion(completion);
    if (cc instanceof _completions.AbruptCompletion) throw cc;
    return cc.value;
  }

  composeWithSavedCompletion(completion) {
    if (this.savedCompletion === undefined) {
      if (completion instanceof _completions.JoinedNormalAndAbruptCompletions) {
        this.savedCompletion = completion;
        this.pushPathConditionsLeadingToNormalCompletions(completion);
        this.captureEffects(completion);
      }

      return completion;
    } else {
      let cc = _singletons.Join.composeCompletions(this.savedCompletion, completion);

      if (cc instanceof _completions.JoinedNormalAndAbruptCompletions) {
        this.savedCompletion = cc;
        this.pushPathConditionsLeadingToNormalCompletions(completion);
        if (cc.savedEffects === undefined) this.captureEffects(cc);
      } else {
        this.savedCompletion = undefined;
      }

      return cc;
    }
  }

  pushPathConditionsLeadingToNormalCompletions(completion) {
    let realm = this;
    let bottomValue = realm.intrinsics.__bottomValue; // Note that if a completion of type CompletionType has a value is that is bottom, that completion is unreachable
    // and pushing its corresponding path condition would cause an InfeasiblePathError to be thrown.

    if (completion instanceof _completions.JoinedNormalAndAbruptCompletions && completion.composedWith !== undefined) this.pushPathConditionsLeadingToNormalCompletions(completion.composedWith);

    if (completion instanceof _completions.JoinedAbruptCompletions || completion instanceof _completions.JoinedNormalAndAbruptCompletions) {
      let jc = completion.joinCondition;

      if (completion.consequent.value === bottomValue || allPathsAreOfType(_completions.AbruptCompletion, completion.consequent)) {
        if (completion.alternate.value === bottomValue || allPathsAreOfType(_completions.AbruptCompletion, completion.alternate)) return;

        _singletons.Path.pushInverseAndRefine(completion.joinCondition);

        this.pushPathConditionsLeadingToNormalCompletions(completion.alternate);
      } else if (completion.alternate.value === bottomValue || allPathsAreOfType(_completions.AbruptCompletion, completion.alternate)) {
        if (completion.consequent.value === bottomValue) return;

        _singletons.Path.pushAndRefine(completion.joinCondition);

        this.pushPathConditionsLeadingToNormalCompletions(completion.consequent);
      } else if (allPathsAreOfType(_completions.NormalCompletion, completion.consequent)) {
        if (!allPathsAreOfType(_completions.NormalCompletion, completion.alternate)) {
          let alternatePC = getNormalPathConditions(completion.alternate);

          let disjunct = _index.AbstractValue.createFromLogicalOp(realm, "||", jc, alternatePC, undefined, true, true);

          _singletons.Path.pushAndRefine(disjunct);
        }
      } else if (allPathsAreOfType(_completions.NormalCompletion, completion.alternate)) {
        let consequentPC = getNormalPathConditions(completion.consequent);

        let inverse = _index.AbstractValue.createFromUnaryOp(realm, "!", jc, true, undefined, true, true);

        let disjunct = _index.AbstractValue.createFromLogicalOp(realm, "||", inverse, consequentPC, undefined, true, true);

        _singletons.Path.pushAndRefine(disjunct);
      } else {
        let cpc = _index.AbstractValue.createFromLogicalOp(realm, "&&", jc, getNormalPathConditions(completion.consequent), undefined, true, true);

        let ijc = _index.AbstractValue.createFromUnaryOp(realm, "!", jc, true, undefined, true, true);

        let apc = _index.AbstractValue.createFromLogicalOp(realm, "&&", ijc, getNormalPathConditions(completion.alternate), undefined, true, true);

        let disjunct = _index.AbstractValue.createFromLogicalOp(realm, "||", cpc, apc, undefined, true, true);

        _singletons.Path.pushAndRefine(disjunct);
      }
    }

    return;

    function allPathsAreOfType(CompletionType, c) {
      if (c instanceof _completions.JoinedNormalAndAbruptCompletions) {
        if (c.composedWith !== undefined && !allPathsAreOfType(CompletionType, c.composedWith)) return false;
        return allPathsAreOfType(CompletionType, c.consequent) && allPathsAreOfType(CompletionType, c.alternate);
      } else if (c instanceof _completions.JoinedAbruptCompletions) {
        return allPathsAreOfType(CompletionType, c.consequent) && allPathsAreOfType(CompletionType, c.alternate);
      } else {
        return c instanceof CompletionType;
      }
    }

    function getNormalPathConditions(c) {
      let pathCondToComposeWith;
      if (c instanceof _completions.JoinedNormalAndAbruptCompletions && c.composedWith !== undefined) pathCondToComposeWith = getNormalPathConditions(c.composedWith);

      if (!(c instanceof _completions.JoinedAbruptCompletions || c instanceof _completions.JoinedNormalAndAbruptCompletions)) {
        return c instanceof _completions.AbruptCompletion ? realm.intrinsics.false : realm.intrinsics.true;
      }

      let pathCond;

      if (c.consequent.value === bottomValue || allPathsAreOfType(_completions.AbruptCompletion, c.consequent)) {
        if (!allPathsAreOfType(_completions.AbruptCompletion, c.alternate)) {
          let inverse = _index.AbstractValue.createFromUnaryOp(realm, "!", c.joinCondition, true, undefined, true, true);

          if (allPathsAreOfType(_completions.NormalCompletion, c.alternate)) pathCond = inverse;else pathCond = _index.AbstractValue.createFromLogicalOp(realm, "&&", inverse, getNormalPathConditions(c.alternate), undefined, true, true);
        }
      } else if (c.alternate.value === bottomValue || allPathsAreOfType(_completions.AbruptCompletion, c.alternate)) {
        if (!allPathsAreOfType(_completions.AbruptCompletion, c.consequent)) {
          if (allPathsAreOfType(_completions.NormalCompletion, c.consequent)) {
            pathCond = c.joinCondition;
          } else {
            let jc = c.joinCondition;
            pathCond = _index.AbstractValue.createFromLogicalOp(realm, "&&", jc, getNormalPathConditions(c.consequent), undefined, true, true);
          }
        }
      } else {
        let jc = c.joinCondition;

        let consequentPC = _index.AbstractValue.createFromLogicalOp(realm, "&&", jc, getNormalPathConditions(c.consequent), undefined, true, true);

        let ijc = _index.AbstractValue.createFromUnaryOp(realm, "!", jc, true, undefined, true, true);

        let alternatePC = _index.AbstractValue.createFromLogicalOp(realm, "&&", ijc, getNormalPathConditions(c.alternate), undefined, true, true);

        pathCond = _index.AbstractValue.createFromLogicalOp(realm, "||", consequentPC, alternatePC, undefined, true, true);
      }

      if (pathCondToComposeWith === undefined && pathCond === undefined) return realm.intrinsics.false;

      if (pathCondToComposeWith === undefined) {
        (0, _invariant.default)(pathCond !== undefined);
        return pathCond;
      }

      if (pathCond === undefined) return pathCondToComposeWith;
      return _index.AbstractValue.createFromLogicalOp(realm, "&&", pathCondToComposeWith, pathCond, undefined, true, true);
    }
  }

  captureEffects(completion) {
    (0, _invariant.default)(completion.savedEffects === undefined);
    completion.savedEffects = new Effects(new _completions.SimpleNormalCompletion(this.intrinsics.undefined), this.generator, this.modifiedBindings, this.modifiedProperties, this.createdObjects);
    this.generator = new _generator.Generator(this, "captured", this.pathConditions);
    this.modifiedBindings = new Map();
    this.modifiedProperties = new Map();
    this.createdObjects = new Set();
  }

  getCapturedEffects(v = this.intrinsics.undefined) {
    (0, _invariant.default)(this.generator !== undefined);
    (0, _invariant.default)(this.modifiedBindings !== undefined);
    (0, _invariant.default)(this.modifiedProperties !== undefined);
    (0, _invariant.default)(this.createdObjects !== undefined);
    return new Effects(v instanceof _completions.Completion ? v : new _completions.SimpleNormalCompletion(v), this.generator, this.modifiedBindings, this.modifiedProperties, this.createdObjects);
  }

  stopEffectCaptureAndUndoEffects(completion) {
    // Roll back the state changes
    this.restoreBindings(this.modifiedBindings);
    this.restoreProperties(this.modifiedProperties); // Restore saved state

    if (completion.savedEffects !== undefined) {
      const savedEffects = completion.savedEffects;
      completion.savedEffects = undefined;
      this.generator = savedEffects.generator;
      this.modifiedBindings = savedEffects.modifiedBindings;
      this.modifiedProperties = savedEffects.modifiedProperties;
      this.createdObjects = savedEffects.createdObjects;
    } else {
      (0, _invariant.default)(false);
    }
  } // Apply the given effects to the global state


  applyEffects(effects, leadingComment = "", appendGenerator = true) {
    (0, _invariant.default)(effects.canBeApplied, "Effects have been applied and not properly reverted. It is not safe to apply them a second time.");
    effects.canBeApplied = false;
    let {
      generator,
      modifiedBindings,
      modifiedProperties,
      createdObjects
    } = effects; // Add generated code for property modifications

    if (appendGenerator) this.appendGenerator(generator, leadingComment); // Restore modifiedBindings

    this.restoreBindings(modifiedBindings);
    this.restoreProperties(modifiedProperties); // track modifiedBindings

    let realmModifiedBindings = this.modifiedBindings;

    if (realmModifiedBindings !== undefined) {
      modifiedBindings.forEach((val, key, m) => {
        (0, _invariant.default)(realmModifiedBindings !== undefined);

        if (!realmModifiedBindings.has(key)) {
          realmModifiedBindings.set(key, val);
        }
      });
    }

    let realmModifiedProperties = this.modifiedProperties;

    if (realmModifiedProperties !== undefined) {
      modifiedProperties.forEach((desc, propertyBinding, m) => {
        (0, _invariant.default)(realmModifiedProperties !== undefined);

        if (!realmModifiedProperties.has(propertyBinding)) {
          realmModifiedProperties.set(propertyBinding, desc);
        }
      });
    } // add created objects


    if (createdObjects.size > 0) {
      let realmCreatedObjects = this.createdObjects;
      if (realmCreatedObjects === undefined) this.createdObjects = new Set(createdObjects);else {
        createdObjects.forEach((ob, a) => {
          (0, _invariant.default)(realmCreatedObjects !== undefined);
          realmCreatedObjects.add(ob);
        });
      }
    }
  }

  outputToConsole(method, args) {
    if (this.isReadOnly) {
      // This only happens during speculative execution and is reported elsewhere
      throw new _errors.FatalError("Trying to create console output in read-only realm");
    }

    if (this.useAbstractInterpretation) {
      (0, _invariant.default)(this.generator !== undefined);
      this.generator.emitConsoleLog(method, args);
    } else {
      // $FlowFixMe: Flow doesn't have type data for all the console methods yet
      console[method](getString(this, args));
    }

    function getString(realm, values) {
      let res = "";

      while (values.length) {
        let next = values.shift();

        let nextString = _singletons.To.ToString(realm, next);

        res += nextString;
      }

      return res;
    }
  } // Record the current value of binding in this.modifiedBindings unless
  // there is already an entry for binding.


  recordModifiedBinding(binding, value) {
    const isDefinedInsidePureFn = root => {
      let context = this.getRunningContext();
      let {
        lexicalEnvironment: env
      } = context;

      while (env !== null) {
        if (env.environmentRecord === root) {
          // We can look at whether the lexical environment of the binding was destroyed to
          // determine if it was defined outside the current pure running context.
          return !env.destroyed;
        }

        env = env.parent;
      }

      return false;
    };

    if (this.modifiedBindings !== undefined && !this.modifiedBindings.has(binding) && value !== undefined && this.isInPureScope()) {
      let env = binding.environment;

      if (!(env instanceof _environment.DeclarativeEnvironmentRecord) || env instanceof _environment.DeclarativeEnvironmentRecord && !isDefinedInsidePureFn(env)) {
        for (let callback of this.reportSideEffectCallbacks) {
          callback("MODIFIED_BINDING", binding, value.expressionLocation);
        }
      }
    }

    if (binding.environment.isReadOnly) {
      // This only happens during speculative execution and is reported elsewhere
      throw new _errors.FatalError("Trying to modify a binding in read-only realm");
    }

    if (this.modifiedBindings !== undefined && !this.modifiedBindings.has(binding)) {
      this.modifiedBindings.set(binding, {
        hasLeaked: binding.hasLeaked,
        value: binding.value
      });
    }

    return binding;
  }

  callReportObjectGetOwnProperties(ob) {
    if (this.reportObjectGetOwnProperties !== undefined) {
      this.reportObjectGetOwnProperties(ob);
    }
  }

  callReportPropertyAccess(binding, isWrite) {
    if (this.reportPropertyAccess !== undefined) {
      this.reportPropertyAccess(binding, isWrite);
    }
  } // Record the current value of binding in this.modifiedProperties unless
  // there is already an entry for binding.


  recordModifiedProperty(binding) {
    if (binding === undefined) return;

    if (this.isInPureScope()) {
      let object = binding.object;
      (0, _invariant.default)(object instanceof _index.ObjectValue);
      const createdObjectsTrackedForLeaks = this.createdObjectsTrackedForLeaks;

      if (createdObjectsTrackedForLeaks !== undefined && !createdObjectsTrackedForLeaks.has(object) && ( // __markPropertyAsChecked__ is set by realm.markPropertyAsChecked
      typeof binding.key !== "string" || !binding.key.includes("__propertyHasBeenChecked__")) && binding.key !== "_temporalAlias") {
        if (binding.object === this.$GlobalObject) {
          for (let callback of this.reportSideEffectCallbacks) {
            callback("MODIFIED_GLOBAL", binding, object.expressionLocation);
          }
        } else {
          for (let callback of this.reportSideEffectCallbacks) {
            callback("MODIFIED_PROPERTY", binding, object.expressionLocation);
          }
        }
      }
    }

    if (this.isReadOnly && (this.getRunningContext().isReadOnly || !this.isNewObject(binding.object))) {
      // This only happens during speculative execution and is reported elsewhere
      throw new _errors.FatalError("Trying to modify a property in read-only realm");
    }

    this.callReportPropertyAccess(binding, true);

    if (this.modifiedProperties !== undefined && !this.modifiedProperties.has(binding)) {
      let clone;
      let desc = binding.descriptor;

      if (desc === undefined) {
        clone = undefined;
      } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
        clone = new _descriptors.AbstractJoinedDescriptor(desc.joinCondition, desc.descriptor1, desc.descriptor2);
      } else if (desc instanceof _descriptors.PropertyDescriptor) {
        clone = (0, _descriptors.cloneDescriptor)(desc);
      } else if (desc instanceof _descriptors.InternalSlotDescriptor) {
        clone = new _descriptors.InternalSlotDescriptor(desc.value);
      } else {
        (0, _invariant.default)(false, "unknown descriptor");
      }

      this.modifiedProperties.set(binding, clone);
    }
  }

  isNewObject(object) {
    if (object instanceof _index.AbstractObjectValue) return false;
    return this.createdObjects === undefined || this.createdObjects.has(object);
  }

  recordNewObject(object) {
    if (this.createdObjects !== undefined) {
      this.createdObjects.add(object);
    }

    if (this.createdObjectsTrackedForLeaks !== undefined) {
      this.createdObjectsTrackedForLeaks.add(object);
    }
  } // Returns the current values of modifiedBindings and modifiedProperties
  // and then assigns new empty maps to them.


  getAndResetModifiedMaps() {
    let result = [this.modifiedBindings, this.modifiedProperties];
    this.modifiedBindings = new Map();
    this.modifiedProperties = new Map();
    return result;
  } // Restores each Binding in the given map to the value it
  // had when it was entered into the map and updates the map to record
  // the value the Binding had just before the call to this method.


  restoreBindings(modifiedBindings) {
    if (modifiedBindings === undefined) return;
    modifiedBindings.forEach(({
      hasLeaked,
      value
    }, binding, m) => {
      let l = binding.hasLeaked;
      let v = binding.value;
      binding.hasLeaked = hasLeaked;
      binding.value = value;
      m.set(binding, {
        hasLeaked: l,
        value: v
      });
    });
  } // Restores each PropertyBinding in the given map to the value it
  // had when it was entered into the map and updates the map to record
  // the value the Binding had just before the call to this method.


  restoreProperties(modifiedProperties) {
    if (modifiedProperties === undefined) return;
    modifiedProperties.forEach((desc, propertyBinding, m) => {
      let d = propertyBinding.descriptor;
      propertyBinding.descriptor = desc;
      m.set(propertyBinding, d);
    });
  } // Provide the realm with maps in which to track modifications.
  // A map can be set to undefined if no tracking is required.


  setModifiedMaps(modifiedBindings, modifiedProperties) {
    this.modifiedBindings = modifiedBindings;
    this.modifiedProperties = modifiedProperties;
  }

  rebuildObjectProperty(object, key, propertyValue, path) {
    if (!(propertyValue instanceof _index.AbstractValue)) return;

    if (propertyValue.kind === "abstractConcreteUnion") {
      (0, _invariant.default)(propertyValue.args.length >= 2);
      let absVal = propertyValue.args[0];
      (0, _invariant.default)(absVal instanceof _index.AbstractValue);
      propertyValue = absVal;
    }

    if (!propertyValue.isIntrinsic()) {
      propertyValue.intrinsicName = `${path}.${key}`;
      propertyValue.kind = "rebuiltProperty";
      propertyValue.args = [object, new _index.StringValue(this, key)];
      propertyValue.operationDescriptor = (0, _generator.createOperationDescriptor)("REBUILT_OBJECT");
      let intrinsicName = propertyValue.intrinsicName;
      (0, _invariant.default)(intrinsicName !== undefined);
      this.rebuildNestedProperties(propertyValue, intrinsicName);
    }
  }

  rebuildNestedProperties(abstractValue, path) {
    if (!(abstractValue instanceof _index.AbstractObjectValue)) return;
    if (abstractValue.values.isTop()) return;
    let template = abstractValue.getTemplate();
    (0, _invariant.default)(!template.intrinsicName || template.intrinsicName === path);
    template.intrinsicName = path;
    template.intrinsicNameGenerated = true;

    for (let [key, binding] of template.properties) {
      if (binding === undefined || binding.descriptor === undefined) continue; // deleted

      (0, _invariant.default)(binding.descriptor !== undefined);
      let desc = binding.descriptor.throwIfNotConcrete(this);
      let value = desc.value;

      _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc);

      if (value === undefined) {
        _index.AbstractValue.reportIntrospectionError(abstractValue, key);

        throw new _errors.FatalError();
      }

      (0, _invariant.default)(value instanceof _index.Value);
      this.rebuildObjectProperty(abstractValue, key, value, path);
    }
  }

  createExecutionContext() {
    let context = new ExecutionContext();
    let loc = this.nextContextLocation;

    if (loc) {
      context.setLocation(loc);
      this.nextContextLocation = null;
    }

    return context;
  }

  setNextExecutionContextLocation(loc) {
    let previousValue = this.nextContextLocation;
    this.nextContextLocation = loc;
    return previousValue;
  }
  /* Since it makes strong assumptions, Instant Render is likely to have a large
  number of unsupported scenarios. We group all associated compiler diagnostics here. */


  instantRenderBailout(message, loc) {
    if (loc === undefined) loc = this.currentLocation;
    let error = new _errors.CompilerDiagnostic(message, loc, "PP0039", "RecoverableError");
    if (this.handleError(error) === "Fail") throw new _errors.FatalError();
  }

  reportIntrospectionError(message) {
    if (message === undefined) message = "";
    if (typeof message === "string") message = new _index.StringValue(this, message);
    (0, _invariant.default)(message instanceof _index.StringValue);
    this.nextContextLocation = this.currentLocation;
    let error = new _errors.CompilerDiagnostic(message.value, this.currentLocation, "PP0001", "FatalError");
    this.handleError(error);
  }

  createErrorThrowCompletion(type, message) {
    (0, _invariant.default)(type !== this.intrinsics.__IntrospectionError);
    if (message === undefined) message = "";
    if (typeof message === "string") message = new _index.StringValue(this, message);
    (0, _invariant.default)(message instanceof _index.StringValue);
    this.nextContextLocation = this.currentLocation;
    return new _completions.ThrowCompletion((0, _index3.Construct)(this, type, [message]), this.currentLocation);
  }

  appendGenerator(generator, leadingComment = "") {
    let realmGenerator = this.generator;

    if (realmGenerator === undefined) {
      (0, _invariant.default)(generator.empty());
      return;
    }

    realmGenerator.appendGenerator(generator, leadingComment);
  } // This function gets the evaluated effects with a collection of
  // prior nested affects applied (and their canBeApplied flag reset)
  // We can safely do this as we've wrapped the effects in evaluated
  // effects, meaning all the effects applied to Realm get restored


  evaluateForEffectsWithPriorEffects(priorEffects, f, generatorName) {
    return this.evaluateForEffects(() => {
      for (let priorEffect of priorEffects) this.applyEffects(priorEffect);

      try {
        return f();
      } finally {
        for (let priorEffect of priorEffects) {
          (0, _invariant.default)(!priorEffect.canBeApplied);
          priorEffect.canBeApplied = true;
        }
      }
    }, undefined, generatorName);
  }

  evaluateWithIncreasedMaxStackDepth(increaseRemainingCallsBy, f) {
    (0, _invariant.default)(increaseRemainingCallsBy > 0);
    this.remainingCalls += increaseRemainingCallsBy;

    try {
      return f();
    } finally {
      this.remainingCalls -= increaseRemainingCallsBy;
    }
  } // Pass the error to the realm's error-handler
  // Return value indicates whether the caller should try to recover from the error or not.


  handleError(diagnostic) {
    if (!diagnostic.callStack && this.contextStack.length > 0) {
      let error = this.evaluateWithIncreasedMaxStackDepth(1, () => this.evaluateWithoutEffects(() => (0, _index3.Construct)(this, this.intrinsics.Error).throwIfNotConcreteObject()));

      let stack = error._SafeGetDataPropertyValue("stack");

      if (stack instanceof _index.StringValue) diagnostic.callStack = stack.value;
    } // If debugger is attached, give it a first crack so that it can
    // stop execution for debugging before PP exits.


    if (this.debuggerInstance && this.debuggerInstance.shouldStopForSeverity(diagnostic.severity)) {
      this.debuggerInstance.handlePrepackError(diagnostic);
    } // If we're creating a DebugRepro, attach the sourceFile names to the error that is returned.


    if (this.debugReproManager !== undefined) {
      let manager = this.debugReproManager;
      let sourcePaths = {
        sourceFiles: manager.getSourceFilePaths(),
        sourceMaps: manager.getSourceMapPaths()
      };
      diagnostic.sourceFilePaths = sourcePaths;
    } // Default behaviour is to bail on the first error


    let errorHandler = this.errorHandler;

    if (!errorHandler) {
      let msg = `${diagnostic.errorCode}: ${diagnostic.message}`;

      if (diagnostic.location) {
        let loc_start = diagnostic.location.start;
        let loc_end = diagnostic.location.end;
        msg += ` at ${loc_start.line}:${loc_start.column} to ${loc_end.line}:${loc_end.column}`;
      }

      try {
        switch (diagnostic.severity) {
          case "Information":
            console.log(`Info: ${msg}`);
            return "Recover";

          case "Warning":
            console.warn(`Warn: ${msg}`);
            return "Recover";

          case "RecoverableError":
            console.error(`Error: ${msg}`);
            return "Fail";

          case "FatalError":
            console.error(`Fatal Error: ${msg}`);
            return "Fail";

          default:
            (0, _invariant.default)(false, "Unexpected error type");
        }
      } finally {
        console.log(diagnostic.callStack);
      }
    }

    return errorHandler(diagnostic, this.suppressDiagnostics);
  }

  saveNameString(nameString) {
    this._abstractValuesDefined.add(nameString);
  }

  isNameStringUnique(nameString) {
    return !this._abstractValuesDefined.has(nameString);
  }

  getTemporalOperationEntryFromDerivedValue(value) {
    let name = value.intrinsicName;

    if (!name) {
      return undefined;
    }

    let temporalOperationEntry = value.$Realm.derivedIds.get(name);
    return temporalOperationEntry;
  }

  getTemporalGeneratorEntriesReferencingArg(arg) {
    return this.temporalEntryArgToEntries.get(arg);
  }

  saveTemporalGeneratorEntryArgs(temporalOperationEntry) {
    let args = temporalOperationEntry.args;

    for (let arg of args) {
      let temporalEntries = this.temporalEntryArgToEntries.get(arg);

      if (temporalEntries === undefined) {
        temporalEntries = new Set();
        this.temporalEntryArgToEntries.set(arg, temporalEntries);
      }

      temporalEntries.add(temporalOperationEntry);
    }
  }

}

exports.Realm = Realm;
//# sourceMappingURL=realm.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PerformanceTracker = exports.RealmStatistics = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class RealmStatistics {
  constructor(getTime, getMemory) {
    this.simplifications = 0;
    this.simplificationAttempts = 0;
    this.evaluatedNodes = 0;
    this.parsing = new PerformanceTracker(getTime, getMemory);
    this.fixupSourceLocations = new PerformanceTracker(getTime, getMemory);
    this.fixupFilenames = new PerformanceTracker(getTime, getMemory);
    this.evaluation = new PerformanceTracker(getTime, getMemory);
  }

  // legacy projection
  getRealmStatistics() {
    return {
      simplifications: this.simplifications,
      simplificationAttempts: this.simplificationAttempts,
      evaluatedNodes: this.evaluatedNodes
    };
  }

  projectPerformanceTrackers(suffix, projection) {
    let res = {};

    for (let key of Object.keys(this)) {
      let value = this[key];
      if (value instanceof PerformanceTracker) res[key + suffix] = projection(value);
    }

    return res;
  }

  log() {
    console.log(`=== realm statistics`);
    console.log(`${this.evaluatedNodes} AST nodes evaluated.`);
    console.log(`${this.simplifications} abstract values simplified after ${this.simplificationAttempts} attempts.`);
  }

  logPerformanceTrackers(format) {
    console.log(`${format(this.parsing)} parsing, ${format(this.fixupSourceLocations)} fixing source locations, ${format(this.fixupFilenames)} fixing filenames, ${format(this.evaluation)} evaluating global code`);
  }

}

exports.RealmStatistics = RealmStatistics;

class PerformanceTracker {
  constructor(getTime, getMemory) {
    this.time = this.memory = 0;
    this._getTime = getTime;
    this._getMemory = getMemory;
    this._running = false;
  }

  start() {
    (0, _invariant.default)(this._running === false);
    if (this._getTime !== undefined) this.time = this._getTime() - this.time;
    if (this._getMemory !== undefined) this.memory = this._getMemory() - this.memory;
    this._running = true;
  }

  stop() {
    (0, _invariant.default)(this._running === true);
    if (this._getTime !== undefined) this.time = this._getTime() - this.time;
    if (this._getMemory !== undefined) this.memory = this._getMemory() - this.memory;
    this._running = false;
  }

  measure(action) {
    this.start();

    try {
      return action();
    } finally {
      this.stop();
    }
  }

}

exports.PerformanceTracker = PerformanceTracker;
//# sourceMappingURL=statistics.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invariant;

var _errors = __webpack_require__(3);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
function invariant(condition, format = "") {
  if (condition) return;
  const message = `${format}
This is likely a bug in Prepack, not your code. Feel free to open an issue on GitHub.`;
  let error = new _errors.InvariantError(message);
  error.name = "Invariant Violation";
  throw error;
}
//# sourceMappingURL=invariant.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Value", {
  enumerable: true,
  get: function () {
    return _Value.default;
  }
});
Object.defineProperty(exports, "ConcreteValue", {
  enumerable: true,
  get: function () {
    return _ConcreteValue.default;
  }
});
Object.defineProperty(exports, "PrimitiveValue", {
  enumerable: true,
  get: function () {
    return _PrimitiveValue.default;
  }
});
Object.defineProperty(exports, "ObjectValue", {
  enumerable: true,
  get: function () {
    return _ObjectValue.default;
  }
});
Object.defineProperty(exports, "FunctionValue", {
  enumerable: true,
  get: function () {
    return _FunctionValue.default;
  }
});
Object.defineProperty(exports, "ECMAScriptFunctionValue", {
  enumerable: true,
  get: function () {
    return _ECMAScriptFunctionValue.default;
  }
});
Object.defineProperty(exports, "ECMAScriptSourceFunctionValue", {
  enumerable: true,
  get: function () {
    return _ECMAScriptSourceFunctionValue.default;
  }
});
Object.defineProperty(exports, "BoundFunctionValue", {
  enumerable: true,
  get: function () {
    return _BoundFunctionValue.default;
  }
});
Object.defineProperty(exports, "NativeFunctionValue", {
  enumerable: true,
  get: function () {
    return _NativeFunctionValue.default;
  }
});
Object.defineProperty(exports, "NativeFunctionCallback", {
  enumerable: true,
  get: function () {
    return _NativeFunctionValue.NativeFunctionCallback;
  }
});
Object.defineProperty(exports, "ArrayValue", {
  enumerable: true,
  get: function () {
    return _ArrayValue.default;
  }
});
Object.defineProperty(exports, "UndefinedValue", {
  enumerable: true,
  get: function () {
    return _UndefinedValue.default;
  }
});
Object.defineProperty(exports, "EmptyValue", {
  enumerable: true,
  get: function () {
    return _EmptyValue.default;
  }
});
Object.defineProperty(exports, "NullValue", {
  enumerable: true,
  get: function () {
    return _NullValue.default;
  }
});
Object.defineProperty(exports, "NumberValue", {
  enumerable: true,
  get: function () {
    return _NumberValue.NumberValue;
  }
});
Object.defineProperty(exports, "IntegralValue", {
  enumerable: true,
  get: function () {
    return _NumberValue.IntegralValue;
  }
});
Object.defineProperty(exports, "ProxyValue", {
  enumerable: true,
  get: function () {
    return _ProxyValue.default;
  }
});
Object.defineProperty(exports, "StringExotic", {
  enumerable: true,
  get: function () {
    return _StringExotic.default;
  }
});
Object.defineProperty(exports, "ArgumentsExotic", {
  enumerable: true,
  get: function () {
    return _ArgumentsExotic.default;
  }
});
Object.defineProperty(exports, "IntegerIndexedExotic", {
  enumerable: true,
  get: function () {
    return _IntegerIndexedExotic.default;
  }
});
Object.defineProperty(exports, "BooleanValue", {
  enumerable: true,
  get: function () {
    return _BooleanValue.default;
  }
});
Object.defineProperty(exports, "StringValue", {
  enumerable: true,
  get: function () {
    return _StringValue.default;
  }
});
Object.defineProperty(exports, "SymbolValue", {
  enumerable: true,
  get: function () {
    return _SymbolValue.default;
  }
});
Object.defineProperty(exports, "AbstractValue", {
  enumerable: true,
  get: function () {
    return _AbstractValue.default;
  }
});
Object.defineProperty(exports, "AbstractObjectValue", {
  enumerable: true,
  get: function () {
    return _AbstractObjectValue.default;
  }
});

var _Value = _interopRequireDefault(__webpack_require__(11));

var _ConcreteValue = _interopRequireDefault(__webpack_require__(12));

var _PrimitiveValue = _interopRequireDefault(__webpack_require__(13));

var _ObjectValue = _interopRequireDefault(__webpack_require__(14));

var _FunctionValue = _interopRequireDefault(__webpack_require__(376));

var _ECMAScriptFunctionValue = _interopRequireDefault(__webpack_require__(377));

var _ECMAScriptSourceFunctionValue = _interopRequireDefault(__webpack_require__(378));

var _BoundFunctionValue = _interopRequireDefault(__webpack_require__(379));

var _NativeFunctionValue = _interopRequireWildcard(__webpack_require__(380));

var _ArrayValue = _interopRequireDefault(__webpack_require__(381));

var _UndefinedValue = _interopRequireDefault(__webpack_require__(382));

var _EmptyValue = _interopRequireDefault(__webpack_require__(383));

var _NullValue = _interopRequireDefault(__webpack_require__(384));

var _NumberValue = __webpack_require__(385);

var _ProxyValue = _interopRequireDefault(__webpack_require__(386));

var _StringExotic = _interopRequireDefault(__webpack_require__(387));

var _ArgumentsExotic = _interopRequireDefault(__webpack_require__(388));

var _IntegerIndexedExotic = _interopRequireDefault(__webpack_require__(389));

var _BooleanValue = _interopRequireDefault(__webpack_require__(391));

var _StringValue = _interopRequireDefault(__webpack_require__(392));

var _SymbolValue = _interopRequireDefault(__webpack_require__(393));

var _AbstractValue = _interopRequireDefault(__webpack_require__(394));

var _AbstractObjectValue = _interopRequireDefault(__webpack_require__(395));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class Value {
  constructor(realm, intrinsicName) {
    (0, _invariant.default)(realm, "realm required");
    this.$Realm = realm;
    this.intrinsicName = intrinsicName;
    this.expressionLocation = realm.currentLocation;
  } // Name from original source if existant


  toDisplayString() {
    return "[" + this.constructor.name + " originally; " + (this.__originalName ? this.__originalName : "undefined") + "]";
  }

  equals(x) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  getHash() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  getType() {
    return this.constructor;
  }

  static isTypeCompatibleWith(type, Constructor) {
    return type.prototype instanceof Constructor || type.prototype === Constructor.prototype;
  }

  // this => val. A false value does not imply that !(this => val).
  implies(val, depth = 0) {
    if (!this.mightNotBeFalse()) return true;
    if (this.equals(val)) return true;
    return false;
  } // this => !val. A false value does not imply that !(this => !val).


  impliesNot(val, depth = 0) {
    if (!this.mightNotBeFalse()) return true;
    if (this.equals(val)) return false;
    return false;
  }

  isIntrinsic() {
    return !!this.intrinsicName;
  }

  isTemporal() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  isPartialObject() {
    return false;
  }

  isSimpleObject() {
    return false;
  }

  mightBeFalse() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightNotBeFalse() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightBeNull() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightNotBeNull() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightBeNumber() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightNotBeNumber() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightNotBeObject() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightBeObject() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightBeString() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightNotBeString() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightBeTrue() {
    return this.mightNotBeFalse();
  }

  mightNotBeTrue() {
    return this.mightBeFalse();
  }

  mightBeUndefined() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightNotBeUndefined() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  mightHaveBeenDeleted() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  promoteEmptyToUndefined() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  throwIfNotConcrete() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  throwIfNotConcreteNumber() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  throwIfNotConcreteString() {
    throw new Error("abstract method; please override");
  }

  throwIfNotConcreteBoolean() {
    throw new Error("abstract method; please override");
  }

  throwIfNotConcreteSymbol() {
    throw new Error("abstract method; please override");
  }

  throwIfNotConcreteObject() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  throwIfNotConcretePrimitive() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  throwIfNotObject() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  serialize(stack = new Map()) {
    if (stack.has(this)) {
      return stack.get(this);
    } else {
      let set = val => {
        stack.set(this, val);
        return val;
      };

      return set(this._serialize(set, stack));
    }
  }

  _serialize(set, stack) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  getDebugName() {
    return this.intrinsicName || this.__originalName;
  }

}

exports.default = Value;
//# sourceMappingURL=Value.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class ConcreteValue extends _index.Value {
  constructor(realm, intrinsicName) {
    (0, _invariant.default)(realm, "realm required");
    super(realm, intrinsicName);
  }

  isTemporal() {
    return false;
  }

  mightNotBeFalse() {
    return !this.mightBeFalse();
  }

  mightBeNull() {
    return this instanceof _index.NullValue;
  }

  mightNotBeNull() {
    return !(this instanceof _index.NullValue);
  }

  mightBeNumber() {
    return this instanceof _index.NumberValue;
  }

  mightNotBeNumber() {
    return !(this instanceof _index.NumberValue);
  }

  mightNotBeObject() {
    return !(this instanceof _index.ObjectValue);
  }

  mightBeObject() {
    return this instanceof _index.ObjectValue;
  }

  mightBeString() {
    return this instanceof _index.StringValue;
  }

  mightNotBeString() {
    return !(this instanceof _index.StringValue);
  }

  mightBeUndefined() {
    return this instanceof _index.UndefinedValue;
  }

  mightNotBeUndefined() {
    return !(this instanceof _index.UndefinedValue);
  }

  mightHaveBeenDeleted() {
    return this instanceof _index.EmptyValue;
  }

  promoteEmptyToUndefined() {
    if (this instanceof _index.EmptyValue) return this.$Realm.intrinsics.undefined;
    return this;
  }

  throwIfNotConcrete() {
    return this;
  }

  throwIfNotConcreteNumber() {
    (0, _invariant.default)(false, "expected this to be a number if concrete");
  }

  throwIfNotConcreteString() {
    (0, _invariant.default)(false, "expected this to be a string if concrete");
  }

  throwIfNotConcreteBoolean() {
    (0, _invariant.default)(false, "expected this to be a boolean if concrete");
  }

  throwIfNotConcreteSymbol() {
    (0, _invariant.default)(false, "expected this to be a symbol if concrete");
  }

  throwIfNotConcreteObject() {
    return this.throwIfNotObject();
  }

  throwIfNotConcretePrimitive() {
    (0, _invariant.default)(false, "expected this to be a primitive value if concrete");
  }

  throwIfNotObject() {
    (0, _invariant.default)(false, "expected this to be an object if concrete");
  }

}

exports.default = ConcreteValue;
//# sourceMappingURL=ConcreteValue.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class PrimitiveValue extends _index.ConcreteValue {
  constructor(realm, intrinsicName) {
    (0, _invariant.default)(realm, "realm required");
    super(realm, intrinsicName);
  }

  throwIfNotConcretePrimitive() {
    return this;
  }

  toDisplayString() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

}

exports.default = PrimitiveValue;
//# sourceMappingURL=PrimitiveValue.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(15);

var _errors = __webpack_require__(3);

var _index2 = __webpack_require__(10);

var _utils = __webpack_require__(291);

var _index3 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _generator = __webpack_require__(237);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ObjectValue extends _index2.ConcreteValue {
  constructor(realm, proto, intrinsicName, refuseSerialization = false) {
    super(realm, intrinsicName);
    realm.recordNewObject(this);
    if (realm.useAbstractInterpretation) this.setupBindings(this.getTrackedPropertyNames());
    this.$Prototype = proto || realm.intrinsics.null;
    this.$Extensible = realm.intrinsics.true;
    this._isPartial = realm.intrinsics.false;
    this._isLeaked = realm.intrinsics.false;
    this._isSimple = realm.intrinsics.false;
    this._simplicityIsTransitive = realm.intrinsics.false;
    this._isFinal = realm.intrinsics.false;
    this.properties = new Map();
    this.symbols = new Map();
    this.refuseSerialization = refuseSerialization; // this.$IsClassPrototype should be the last thing that gets initialized,
    // as other code checks whether this.$IsClassPrototype === undefined
    // as a proxy for whether initialization is still ongoing.

    this.$IsClassPrototype = false;
  }

  getTrackedPropertyNames() {
    return ObjectValue.trackedPropertyNames;
  }

  setupBindings(propertyNames) {
    for (let propName of propertyNames) {
      let propBindingName = ObjectValue.trackedPropertyBindingNames.get(propName);
      (0, _invariant.default)(propBindingName !== undefined);
      this[propBindingName] = undefined;
    }
  }

  static setupTrackedPropertyAccessors(propertyNames) {
    for (let propName of propertyNames) {
      let propBindingName = ObjectValue.trackedPropertyBindingNames.get(propName);
      if (propBindingName === undefined) ObjectValue.trackedPropertyBindingNames.set(propName, propBindingName = propName + "_binding");
      Object.defineProperty(ObjectValue.prototype, propName, {
        configurable: true,
        get: function () {
          let binding = this[propBindingName];
          (0, _invariant.default)(binding === undefined || binding.descriptor instanceof _descriptors.InternalSlotDescriptor);
          return binding === undefined ? undefined : binding.descriptor.value;
        },
        set: function (v) {
          // Let's make sure that the object is not leaked.
          // To that end, we'd like to call this.isLeakedObject().
          // However, while the object is still being initialized,
          // properties may be set, but this.isLeakedObject() may not be called yet.
          // To check if we are still initializing, guard the call by looking at
          // whether this.$IsClassPrototype has been initialized as a proxy for
          // object initialization in general.
          (0, _invariant.default)( // We're still initializing so we can set a property.
          this.$IsClassPrototype === undefined || // It's not leaked so we can set a property.
          this.mightNotBeLeakedObject() || // Object.assign() implementation needs to temporarily
          // make potentially leaked objects non-partial and back.
          // We don't gain anything from checking whether it's leaked
          // before calling makePartial() so we'll whitelist this property.
          propBindingName === "_isPartial_binding", "cannot mutate a leaked object");
          let binding = this[propBindingName];

          if (binding === undefined) {
            let desc = new _descriptors.InternalSlotDescriptor(undefined);
            this[propBindingName] = binding = {
              descriptor: desc,
              object: this,
              key: propName,
              internalSlot: true
            };
          }

          this.$Realm.recordModifiedProperty(binding);
          binding.descriptor.value = v;
        }
      });
    }
  }

  // Checks whether effects are properly applied.
  isValid() {
    return this._isPartial !== undefined;
  }

  equals(x) {
    return this === x;
  }

  getHash() {
    if (!this.hashValue) {
      this.hashValue = ++this.$Realm.objectCount;
    }

    return this.hashValue;
  }

  get temporalAlias() {
    return this._temporalAlias;
  }

  set temporalAlias(value) {
    this._temporalAlias = value;
  }

  hasStringOrSymbolProperties() {
    for (let prop of this.properties.values()) {
      if (prop.descriptor === undefined) continue;
      return true;
    }

    for (let prop of this.symbols.values()) {
      if (prop.descriptor === undefined) continue;
      return true;
    }

    return false;
  }

  mightBeFalse() {
    return false;
  }

  mightNotBeObject() {
    return false;
  }

  throwIfNotObject() {
    return this;
  }

  makePartial() {
    this._isPartial = this.$Realm.intrinsics.true;
  }

  makeSimple(option) {
    this._isSimple = this.$Realm.intrinsics.true;
    this._simplicityIsTransitive = new _index2.BooleanValue(this.$Realm, option === "transitive" || option instanceof _index2.StringValue && option.value === "transitive");
  }

  makeFinal() {
    this._isFinal = this.$Realm.intrinsics.true;
  }

  makeNotFinal() {
    this._isFinal = this.$Realm.intrinsics.false;
  }

  isPartialObject() {
    return this._isPartial.mightBeTrue();
  } // When this object was created in an evaluateForEffects context and the effects have not been applied, the
  // value is not valid (and we shouldn't try to access any properties on it). isPartial should always be set
  // except when reverted by effects.


  isValid() {
    return this._isPartial !== undefined;
  }

  mightBeFinalObject() {
    return this._isFinal.mightBeTrue();
  }

  mightNotBeFinalObject() {
    return this._isFinal.mightNotBeTrue();
  }

  leak() {
    this._isLeaked = this.$Realm.intrinsics.true;
  }

  mightBeLeakedObject() {
    return this._isLeaked.mightBeTrue();
  }

  mightNotBeLeakedObject() {
    return this._isLeaked.mightNotBeTrue();
  }

  isSimpleObject() {
    if (this === this.$Realm.intrinsics.ObjectPrototype) return true;
    if (!this._isSimple.mightNotBeTrue()) return true;
    if (this.isPartialObject()) return false;
    if (this.symbols.size > 0) return false;

    for (let propertyBinding of this.properties.values()) {
      let desc = propertyBinding.descriptor;
      if (desc === undefined) continue; // deleted

      if (!(0, _index3.IsDataDescriptor)(this.$Realm, desc)) return false;
      if (!desc.writable) return false;
    }

    if (this.$Prototype instanceof _index2.NullValue) return true;
    (0, _invariant.default)(this.$Prototype);
    return this.$Prototype.isSimpleObject();
  }

  isTransitivelySimple() {
    return !this._simplicityIsTransitive.mightNotBeTrue();
  }

  getExtensible() {
    return this.$Extensible.throwIfNotConcreteBoolean().value;
  }

  setExtensible(v) {
    this.$Extensible = v ? this.$Realm.intrinsics.true : this.$Realm.intrinsics.false;
  }

  getKind() {
    // we can deduce the natural prototype by checking whether the following internal slots are present
    if (this.$SymbolData !== undefined) return "Symbol";
    if (this.$StringData !== undefined) return "String";
    if (this.$NumberData !== undefined) return "Number";
    if (this.$BooleanData !== undefined) return "Boolean";
    if (this.$DateValue !== undefined) return "Date";
    if (this.$RegExpMatcher !== undefined) return "RegExp";
    if (this.$SetData !== undefined) return "Set";
    if (this.$MapData !== undefined) return "Map";
    if (this.$DataView !== undefined) return "DataView";
    if (this.$ArrayBufferData !== undefined) return "ArrayBuffer";
    if (this.$WeakMapData !== undefined) return "WeakMap";
    if (this.$WeakSetData !== undefined) return "WeakSet";
    if ((0, _utils.isReactElement)(this) && this.$Realm.react.enabled) return "ReactElement";
    if (this.$TypedArrayName !== undefined) return this.$TypedArrayName; // TODO #26 #712: Promises. All kinds of iterators. Generators.

    return "Object";
  }

  defineNativeMethod(name, length, callback, desc) {
    let intrinsicName;

    if (typeof name === "string") {
      if (this.intrinsicName) intrinsicName = `${this.intrinsicName}.${name}`;
    } else if (name instanceof _index2.SymbolValue) {
      if (this.intrinsicName && name.intrinsicName) intrinsicName = `${this.intrinsicName}[${name.intrinsicName}]`;
    } else {
      (0, _invariant.default)(false);
    }

    let fnValue = new _index2.NativeFunctionValue(this.$Realm, intrinsicName, name, length, callback, false);
    this.defineNativeProperty(name, fnValue, desc);
    return fnValue;
  }

  defineNativeProperty(name, value, desc) {
    (0, _invariant.default)(!value || value instanceof _index2.Value);
    this.$DefineOwnProperty(name, new _descriptors.PropertyDescriptor(_objectSpread({
      value,
      writable: true,
      enumerable: false,
      configurable: true
    }, desc)));
  }

  defineNativeGetter(name, callback, desc) {
    let intrinsicName, funcName;

    if (typeof name === "string") {
      funcName = `get ${name}`;
      if (this.intrinsicName) intrinsicName = `${this.intrinsicName}.${name}`;
    } else if (name instanceof _index2.SymbolValue) {
      funcName = name.$Description instanceof _index2.Value ? `get [${name.$Description.throwIfNotConcreteString().value}]` : `get [${"?"}]`;
      if (this.intrinsicName && name.intrinsicName) intrinsicName = `${this.intrinsicName}[${name.intrinsicName}]`;
    } else {
      (0, _invariant.default)(false);
    }

    let func = new _index2.NativeFunctionValue(this.$Realm, intrinsicName, funcName, 0, callback);
    this.$DefineOwnProperty(name, new _descriptors.PropertyDescriptor(_objectSpread({
      get: func,
      set: this.$Realm.intrinsics.undefined,
      enumerable: false,
      configurable: true
    }, desc)));
  }

  defineNativeConstant(name, value, desc) {
    (0, _invariant.default)(!value || value instanceof _index2.Value);
    this.$DefineOwnProperty(name, new _descriptors.PropertyDescriptor(_objectSpread({
      value,
      writable: false,
      enumerable: false,
      configurable: false
    }, desc)));
  } // Note that internal properties will not be copied to the snapshot, nor will they be removed.


  getSnapshot(options) {
    try {
      if (this.temporalAlias !== undefined) return this.temporalAlias;
      let realm = this.$Realm;
      let template = new ObjectValue(this.$Realm, this.$Realm.intrinsics.ObjectPrototype);

      let keys = _singletons.Properties.GetOwnPropertyKeysArray(realm, this, false, true);

      this.copyKeys(keys, this, template); // The snapshot is an immutable object snapshot

      template.makeFinal(); // The original object might be a React props object, thus
      // if it is, we need to ensure we mark it with the same rules

      if (realm.react.enabled && realm.react.reactProps.has(this)) {
        realm.react.reactProps.add(template);
      }

      let operationDescriptor = (0, _generator.createOperationDescriptor)("SINGLE_ARG");

      let result = _index2.AbstractValue.createTemporalFromBuildFunction(this.$Realm, ObjectValue, [template], operationDescriptor, {
        skipInvariant: true,
        isPure: true
      });

      (0, _invariant.default)(result instanceof _index2.AbstractObjectValue);
      result.values = new _index.ValuesDomain(template);
      return result;
    } finally {
      if (options && options.removeProperties) {
        this.properties = new Map();
        this.symbols = new Map();
        this.unknownProperty = undefined;
      }
    }
  }

  copyKeys(keys, from, to) {
    // c. Repeat for each element nextKey of keys in List order,
    for (let nextKey of keys) {
      // i. Let desc be ? from.[[GetOwnProperty]](nextKey).
      let desc = from.$GetOwnProperty(nextKey); // ii. If desc is not undefined and desc.[[Enumerable]] is true, then

      if (desc && desc.throwIfNotConcrete(this.$Realm).enumerable) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc); // 1. Let propValue be ? Get(from, nextKey).


        let propValue = (0, _index3.Get)(this.$Realm, from, nextKey); // 2. Perform ? Set(to, nextKey, propValue, true).

        _singletons.Properties.Set(this.$Realm, to, nextKey, propValue, true);
      }
    }
  }

  _serialize(set, stack) {
    let obj = set({});

    for (let [key, propertyBinding] of this.properties) {
      let desc = propertyBinding.descriptor;
      if (desc === undefined) continue; // deleted

      _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc);

      desc = desc.throwIfNotConcrete(this.$Realm);
      let serializedDesc = {
        enumerable: desc.enumerable,
        configurable: desc.configurable
      };

      if (desc.value) {
        serializedDesc.writable = desc.writable;
        (0, _invariant.default)(desc.value instanceof _index2.Value);
        serializedDesc.value = desc.value.serialize(stack);
      } else {
        (0, _invariant.default)(desc.get !== undefined);
        serializedDesc.get = desc.get.serialize(stack);
        (0, _invariant.default)(desc.set !== undefined);
        serializedDesc.set = desc.set.serialize(stack);
      }

      Object.defineProperty(obj, key, serializedDesc);
    }

    return obj;
  } // Whether [[{Get,Set}PrototypeOf]] delegate to Ordinary{Get,Set}PrototypeOf.
  // E.g. ProxyValue overrides this to return false.
  // See ECMA262 9.1.2.1 for an algorithm where this is relevant


  usesOrdinaryObjectInternalPrototypeMethods() {
    return true;
  } // ECMA262 9.1.1


  $GetPrototypeOf() {
    return this.$Prototype;
  } // ECMA262 9.1.2


  $SetPrototypeOf(V) {
    // 1. Return ! OrdinarySetPrototypeOf(O, V).
    return _singletons.Properties.OrdinarySetPrototypeOf(this.$Realm, this, V);
  } // ECMA262 9.1.3


  $IsExtensible() {
    // 1. Return ! OrdinaryIsExtensible(O).
    return (0, _index3.OrdinaryIsExtensible)(this.$Realm, this);
  } // ECMA262 9.1.4


  $PreventExtensions() {
    // 1. Return ! OrdinaryPreventExtensions(O).
    return (0, _index3.OrdinaryPreventExtensions)(this.$Realm, this);
  } // ECMA262 9.1.5


  $GetOwnProperty(P) {
    // 1. Return ! OrdinaryGetOwnProperty(O, P).
    return _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, this, P);
  } // ECMA262 9.1.6


  $DefineOwnProperty(P, Desc) {
    // 1. Return ? OrdinaryDefineOwnProperty(O, P, Desc).
    return _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, this, P, Desc);
  } // ECMA262 9.1.7


  $HasProperty(P) {
    if (this.unknownProperty !== undefined && this.$GetOwnProperty(P) === undefined) {
      _index2.AbstractValue.reportIntrospectionError(this, P);

      throw new _errors.FatalError();
    }

    return (0, _index3.OrdinaryHasProperty)(this.$Realm, this, P);
  } // ECMA262 9.1.8


  $Get(P, Receiver) {
    // 1. Return ? OrdinaryGet(O, P, Receiver).
    return (0, _index3.OrdinaryGet)(this.$Realm, this, P, Receiver);
  }

  _SafeGetDataPropertyValue(P) {
    let savedInvariantLevel = this.$Realm.invariantLevel;

    try {
      this.$Realm.invariantLevel = 0;
      let desc = this.$GetOwnProperty(P);

      if (desc === undefined) {
        return this.$Realm.intrinsics.undefined;
      }

      desc = desc.throwIfNotConcrete(this.$Realm);
      return desc.value ? desc.value : this.$Realm.intrinsics.undefined;
    } finally {
      this.$Realm.invariantLevel = savedInvariantLevel;
    }
  }

  $GetPartial(P, Receiver) {
    return (0, _index3.OrdinaryGetPartial)(this.$Realm, this, P, Receiver);
  } // ECMA262 9.1.9


  $Set(P, V, Receiver) {
    // 1. Return ? OrdinarySet(O, P, V, Receiver).
    return _singletons.Properties.OrdinarySet(this.$Realm, this, P, V, Receiver);
  }

  $SetPartial(P, V, Receiver) {
    return _singletons.Properties.OrdinarySetPartial(this.$Realm, this, P, V, Receiver);
  } // ECMA262 9.1.10


  $Delete(P) {
    if (this.unknownProperty !== undefined) {
      // TODO #946: generate a delete from the object
      _index2.AbstractValue.reportIntrospectionError(this, P);

      throw new _errors.FatalError();
    } // 1. Return ? OrdinaryDelete(O, P).


    return _singletons.Properties.OrdinaryDelete(this.$Realm, this, P);
  } // ECMA262 9.1.11


  $OwnPropertyKeys(getOwnPropertyKeysEvenIfPartial = false) {
    return (0, _index3.OrdinaryOwnPropertyKeys)(this.$Realm, this, getOwnPropertyKeysEvenIfPartial);
  }

  static refuseSerializationOnPropertyBinding(pb) {
    if (pb.object.refuseSerialization) return true;
    if (pb.internalSlot && typeof pb.key === "string" && pb.key[0] === "_") return true;
    return false;
  }

  static isIntrinsicDerivedObject(obj) {
    return obj instanceof ObjectValue && obj.intrinsicName !== undefined && obj.isScopedTemplate !== undefined;
  }

}

exports.default = ObjectValue;

_defineProperty(ObjectValue, "trackedPropertyNames", ["_isPartial", "_isLeaked", "_isSimple", "_isFinal", "_simplicityIsTransitive", "_temporalAlias", "$ArrayIteratorNextIndex", "$DateValue", "$Extensible", "$IteratedList", "$IteratedObject", "$IteratedSet", "$IteratedString", "$Map", "$MapData", "$MapNextIndex", "$Prototype", "$SetData", "$SetNextIndex", "$StringIteratorNextIndex", "$WeakMapData", "$WeakSetData"]);

_defineProperty(ObjectValue, "trackedPropertyBindingNames", new Map());
//# sourceMappingURL=ObjectValue.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "TypesDomain", {
  enumerable: true,
  get: function () {
    return _TypesDomain.default;
  }
});
Object.defineProperty(exports, "ValuesDomain", {
  enumerable: true,
  get: function () {
    return _ValuesDomain.default;
  }
});

var _TypesDomain = _interopRequireDefault(__webpack_require__(16));

var _ValuesDomain = _interopRequireDefault(__webpack_require__(17));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/* An abstract domain for the type of value a variable might have.  */
class TypesDomain {
  constructor(type) {
    (0, _invariant.default)(type !== _index.ConcreteValue, "Concrete values must be specific");
    this._type = type === _index.Value ? undefined : type;
  }

  isBottom() {
    return this._type instanceof _index.EmptyValue;
  }

  isTop() {
    return this._type === undefined;
  }

  getType() {
    return this._type || _index.Value;
  } // return the type of the result in the case where there is no exception


  static binaryOp(op, left, right) {
    if (left.isBottom() || right.isBottom()) return TypesDomain.bottomVal;
    let lType = left._type;
    let rType = right._type;
    let resultType = _index.Value;

    switch (op) {
      case "+":
        if (lType === undefined || rType === undefined) return TypesDomain.topVal;

        if (_index.Value.isTypeCompatibleWith(lType, _index.StringValue) || _index.Value.isTypeCompatibleWith(rType, _index.StringValue)) {
          resultType = _index.StringValue;
          break;
        }

      // eslint-disable-line no-fallthrough

      case "-":
        if (lType === undefined || rType === undefined) return TypesDomain.topVal;
        if (lType === _index.IntegralValue && rType === _index.IntegralValue) resultType = _index.IntegralValue;else if (_index.Value.isTypeCompatibleWith(lType, _index.NumberValue) && _index.Value.isTypeCompatibleWith(rType, _index.NumberValue)) resultType = _index.NumberValue;
        break;

      case "<":
      case ">":
      case ">=":
      case "<=":
      case "!=":
      case "==":
      case "!==":
      case "===":
      case "in":
      case "instanceof":
        resultType = _index.BooleanValue;
        break;

      case ">>>":
      case "<<":
      case ">>":
      case "&":
      case "|":
      case "^":
        resultType = _index.IntegralValue;
        break;

      case "**":
      case "%":
      case "/":
      case "*":
        resultType = _index.NumberValue;
        break;

      default:
        (0, _invariant.default)(false);
    }

    return new TypesDomain(resultType);
  }

  static joinValues(v1, v2) {
    if (v1 === undefined && v2 === undefined) return new TypesDomain(_index.UndefinedValue);
    if (v1 === undefined || v2 === undefined) return TypesDomain.topVal;
    if (v1 instanceof _index.AbstractValue) return v1.types.joinWith(v2.getType());
    if (v2 instanceof _index.AbstractValue) return v2.types.joinWith(v1.getType());
    return new TypesDomain(v1.getType()).joinWith(v2.getType());
  }

  joinWith(t) {
    if (this.isBottom()) return t === _index.EmptyValue ? TypesDomain.bottomVal : new TypesDomain(t);
    let type = this.getType();
    if (type === t || t instanceof _index.EmptyValue) return this;

    if (_index.Value.isTypeCompatibleWith(type, _index.NumberValue) && _index.Value.isTypeCompatibleWith(t, _index.NumberValue)) {
      return new TypesDomain(_index.NumberValue);
    }

    if (_index.Value.isTypeCompatibleWith(type, _index.FunctionValue) && _index.Value.isTypeCompatibleWith(t, _index.FunctionValue)) {
      return new TypesDomain(_index.FunctionValue);
    }

    if (_index.Value.isTypeCompatibleWith(type, _index.ObjectValue) && _index.Value.isTypeCompatibleWith(t, _index.ObjectValue)) {
      return new TypesDomain(_index.ObjectValue);
    }

    if (_index.Value.isTypeCompatibleWith(type, _index.PrimitiveValue) && _index.Value.isTypeCompatibleWith(t, _index.PrimitiveValue)) {
      return new TypesDomain(_index.PrimitiveValue);
    }

    return TypesDomain.topVal;
  }

  static logicalOp(op, left, right) {
    return left.joinWith(right.getType());
  } // return the type of the result in the case where there is no exception
  // note that the type of the operand has no influence on the type of the non exceptional result


  static unaryOp(op, operand) {
    if (operand.isBottom()) return TypesDomain.bottomVal;
    const type = operand._type;
    let resultType = _index.Value;

    switch (op) {
      case "-":
      case "+":
        resultType = type === _index.IntegralValue ? _index.IntegralValue : _index.NumberValue;
        break;

      case "~":
        resultType = _index.IntegralValue;
        break;

      case "!":
      case "delete":
        resultType = _index.BooleanValue;
        break;

      case "typeof":
        resultType = _index.StringValue;
        break;

      case "void":
        resultType = _index.UndefinedValue;
        break;

      default:
        (0, _invariant.default)(false);
    }

    return new TypesDomain(resultType);
  }

}

exports.default = TypesDomain;
//# sourceMappingURL=TypesDomain.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _completions = __webpack_require__(18);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _index2 = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/* An abstract domain that collects together a set of concrete values
   that might be the value of a variable at runtime.
   Initially, every variable has the value undefined.
   A property that has been weakly deleted will have more than
   one value, one of which will by the EmptyValue.  */
class ValuesDomain {
  constructor(_values) {
    let values = _values;

    if (values instanceof _index2.ConcreteValue) {
      let valueSet = new Set();
      valueSet.add(values);
      values = valueSet;
    }

    this._elements = values;
  }

  contains(x) {
    let elems = this._elements;
    let xelems = x._elements;
    if (elems === xelems) return true;
    if (elems === undefined) return true;
    if (xelems === undefined) return false;
    if (elems.size < xelems.size) return false;

    for (let e of xelems) {
      if (!elems.has(e)) return false;
    }

    return true;
  }

  containsValue(x) {
    let elems = this._elements;
    if (elems === undefined) return true; // Top contains everything

    if (x instanceof _index2.AbstractValue) return this.contains(x.values);
    (0, _invariant.default)(x instanceof _index2.ConcreteValue);
    return elems.has(x);
  }

  isBottom() {
    return this._elements !== undefined && this._elements.size === 0;
  }

  isTop() {
    return this._elements === undefined;
  }

  getElements() {
    (0, _invariant.default)(this._elements !== undefined);
    return this._elements;
  } // return a set of values that may be result of performing the given operation on each pair in the
  // Cartesian product of the value sets of the operands.


  static binaryOp(realm, op, left, right) {
    if (left.isBottom() || right.isBottom()) return ValuesDomain.bottomVal;
    let leftElements = left._elements;
    let rightElements = right._elements; // Return top if left and/or right are top or if the size of the value set would get to be quite large.
    // Note: the larger the set of values, the less we know and therefore the less we get value from computing
    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.

    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100) return ValuesDomain.topVal;
    let resultSet = new Set();
    let savedHandler = realm.errorHandler;
    let savedIsReadOnly = realm.isReadOnly;
    realm.isReadOnly = true;

    try {
      realm.errorHandler = () => {
        throw new _errors.FatalError();
      };

      for (let leftElem of leftElements) {
        for (let rightElem of rightElements) {
          let result = ValuesDomain.computeBinary(realm, op, leftElem, rightElem);

          if (result instanceof _index2.ConcreteValue) {
            resultSet.add(result);
          } else {
            (0, _invariant.default)(result instanceof _index2.AbstractValue);

            if (result.values.isTop()) {
              return ValuesDomain.topVal;
            }

            for (let subResult of result.values.getElements()) {
              resultSet.add(subResult);
            }
          }
        }
      }
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) return ValuesDomain.topVal;
    } finally {
      realm.errorHandler = savedHandler;
      realm.isReadOnly = savedIsReadOnly;
    }

    return new ValuesDomain(resultSet);
  } // Note that calling this can result in user code running, which can side-effect the heap.
  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.


  static computeBinary(realm, op, lval, rval) {
    if (op === "+") {
      // ECMA262 12.8.3 The Addition Operator
      let lprim = _singletons.To.ToPrimitiveOrAbstract(realm, lval);

      let rprim = _singletons.To.ToPrimitiveOrAbstract(realm, rval);

      if (lprim instanceof _index2.AbstractValue || rprim instanceof _index2.AbstractValue) {
        return _index2.AbstractValue.createFromBinaryOp(realm, op, lprim, rprim);
      }

      if (lprim instanceof _index2.StringValue || rprim instanceof _index2.StringValue) {
        let lstr = _singletons.To.ToString(realm, lprim);

        let rstr = _singletons.To.ToString(realm, rprim);

        return new _index2.StringValue(realm, lstr + rstr);
      }

      let lnum = _singletons.To.ToNumber(realm, lprim);

      let rnum = _singletons.To.ToNumber(realm, rprim);

      return (0, _index.Add)(realm, lnum, rnum);
    } else if (op === "<" || op === ">" || op === ">=" || op === "<=") {
      // ECMA262 12.10.3
      if (op === "<") {
        let r = (0, _index.AbstractRelationalComparison)(realm, lval, rval, true, op);

        if (r instanceof _index2.UndefinedValue) {
          return realm.intrinsics.false;
        } else {
          return r;
        }
      } else if (op === "<=") {
        let r = (0, _index.AbstractRelationalComparison)(realm, rval, lval, false, op);

        if (r instanceof _index2.UndefinedValue || r instanceof _index2.BooleanValue && r.value) {
          return realm.intrinsics.false;
        } else if (r instanceof _index2.AbstractValue) {
          return r;
        } else {
          return realm.intrinsics.true;
        }
      } else if (op === ">") {
        let r = (0, _index.AbstractRelationalComparison)(realm, rval, lval, false, op);

        if (r instanceof _index2.UndefinedValue) {
          return realm.intrinsics.false;
        } else {
          return r;
        }
      } else if (op === ">=") {
        let r = (0, _index.AbstractRelationalComparison)(realm, lval, rval, true, op);

        if (r instanceof _index2.UndefinedValue || r instanceof _index2.BooleanValue && r.value) {
          return realm.intrinsics.false;
        } else if (r instanceof _index2.AbstractValue) {
          return r;
        } else {
          return realm.intrinsics.true;
        }
      }
    } else if (op === ">>>") {
      // ECMA262 12.9.5.1
      let lnum = _singletons.To.ToUint32(realm, lval);

      let rnum = _singletons.To.ToUint32(realm, rval);

      return _index2.IntegralValue.createFromNumberValue(realm, lnum >>> rnum);
    } else if (op === "<<" || op === ">>") {
      let lnum = _singletons.To.ToInt32(realm, lval);

      let rnum = _singletons.To.ToUint32(realm, rval);

      if (op === "<<") {
        // ECMA262 12.9.3.1
        return _index2.IntegralValue.createFromNumberValue(realm, lnum << rnum);
      } else if (op === ">>") {
        // ECMA262 12.9.4.1
        return _index2.IntegralValue.createFromNumberValue(realm, lnum >> rnum);
      }
    } else if (op === "**") {
      // ECMA262 12.6.3
      // 5. Let base be ? ToNumber(leftValue).
      let base = _singletons.To.ToNumberOrAbstract(realm, lval); // 6. Let exponent be ? ToNumber(rightValue).


      let exponent = _singletons.To.ToNumberOrAbstract(realm, rval);

      if (base instanceof _index2.AbstractValue || exponent instanceof _index2.AbstractValue) {
        const baseVal = base instanceof _index2.AbstractValue ? base : new _index2.NumberValue(realm, base);
        const exponentVal = exponent instanceof _index2.AbstractValue ? exponent : new _index2.NumberValue(realm, exponent);
        return _index2.AbstractValue.createFromBinaryOp(realm, op, baseVal, exponentVal);
      } // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.


      return new _index2.NumberValue(realm, Math.pow(base, exponent));
    } else if (op === "%" || op === "/" || op === "*" || op === "-") {
      // ECMA262 12.7.3
      let lnum = _singletons.To.ToNumberOrAbstract(realm, lval);

      let rnum = _singletons.To.ToNumberOrAbstract(realm, rval);

      if (lnum instanceof _index2.AbstractValue || rnum instanceof _index2.AbstractValue) {
        const lnumVal = lnum instanceof _index2.AbstractValue ? lnum : new _index2.NumberValue(realm, lnum);
        const rnumVal = rnum instanceof _index2.AbstractValue ? rnum : new _index2.NumberValue(realm, rnum);
        return _index2.AbstractValue.createFromBinaryOp(realm, op, lnumVal, rnumVal);
      }

      if (isNaN(rnum)) return realm.intrinsics.NaN;
      if (isNaN(lnum)) return realm.intrinsics.NaN;

      if (op === "-") {
        return (0, _index.Add)(realm, lnum, rnum, true);
      } else if (op === "%") {
        // The sign of the result equals the sign of the dividend.
        // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
        // If the dividend is finite and the divisor is an infinity, the result equals the dividend.
        // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.
        return new _index2.NumberValue(realm, lnum % rnum);
      } else if (op === "/") {
        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
        // Division of an infinity by an infinity results in NaN.
        // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.
        // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.
        // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.
        // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.
        // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.
        return new _index2.NumberValue(realm, lnum / rnum);
      } else if (op === "*") {
        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.
        // Multiplication of an infinity by a zero results in NaN.
        // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.
        // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.
        return new _index2.NumberValue(realm, lnum * rnum);
      }
    } else if (op === "!==") {
      return new _index2.BooleanValue(realm, !(0, _index.StrictEqualityComparison)(realm, lval, rval));
    } else if (op === "===") {
      return new _index2.BooleanValue(realm, (0, _index.StrictEqualityComparison)(realm, lval, rval));
    } else if (op === "!=" || op === "==") {
      return (0, _index.AbstractEqualityComparison)(realm, lval, rval, op);
    } else if (op === "&" || op === "|" || op === "^") {
      // ECMA262 12.12.3
      let lnum = _singletons.To.ToInt32(realm, lval); // 6. Let rnum be ? ToInt32(rval).


      let rnum = _singletons.To.ToInt32(realm, rval); // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.


      if (op === "&") {
        return _index2.IntegralValue.createFromNumberValue(realm, lnum & rnum);
      } else if (op === "|") {
        return _index2.IntegralValue.createFromNumberValue(realm, lnum | rnum);
      } else if (op === "^") {
        return _index2.IntegralValue.createFromNumberValue(realm, lnum ^ rnum);
      }
    } else if (op === "in") {
      // ECMA262 12.10.3
      // 5. If Type(rval) is not Object, throw a TypeError exception.
      if (!(rval instanceof _index2.ObjectValue)) {
        throw new _errors.FatalError();
      } // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).


      return new _index2.BooleanValue(realm, (0, _index.HasProperty)(realm, rval, _singletons.To.ToPropertyKey(realm, lval)));
    } else if (op === "instanceof") {
      // ECMA262 12.10.3
      // 5. Return ? InstanceofOperator(lval, rval).;
      return new _index2.BooleanValue(realm, (0, _index.InstanceofOperator)(realm, lval, rval));
    }

    (0, _invariant.default)(false, "unimplemented " + op);
  }

  static logicalOp(realm, op, left, right) {
    let leftElements = left._elements;
    let rightElements = right._elements; // Return top if left and/or right are top or if the size of the value set would get to be quite large.
    // Note: the larger the set of values, the less we know and therefore the less we get value from computing
    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.

    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100) return ValuesDomain.topVal;
    let resultSet = new Set();
    let savedHandler = realm.errorHandler;
    let savedIsReadOnly = realm.isReadOnly;
    realm.isReadOnly = true;

    try {
      realm.errorHandler = () => {
        throw new _errors.FatalError();
      };

      for (let leftElem of leftElements) {
        for (let rightElem of rightElements) {
          let result = ValuesDomain.computeLogical(realm, op, leftElem, rightElem);
          resultSet.add(result);
        }
      }
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) return ValuesDomain.topVal;
    } finally {
      realm.errorHandler = savedHandler;
      realm.isReadOnly = savedIsReadOnly;
    }

    return new ValuesDomain(resultSet);
  } // Note that calling this can result in user code running, which can side-effect the heap.
  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.


  static computeLogical(realm, op, lval, rval) {
    let lbool = _singletons.To.ToBoolean(realm, lval);

    if (op === "&&") {
      // ECMA262 12.13.3
      if (lbool === false) return lval;
    } else if (op === "||") {
      // ECMA262 12.13.3
      if (lbool === true) return lval;
    }

    return rval;
  } // Note that calling this can result in user code running, which can side-effect the heap.
  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.


  static computeUnary(realm, op, value) {
    if (op === "+") {
      // ECMA262 12.5.6.1
      // 1. Let expr be the result of evaluating UnaryExpression.
      // 2. Return ? ToNumber(? GetValue(expr)).
      return _index2.IntegralValue.createFromNumberValue(realm, _singletons.To.ToNumber(realm, value));
    } else if (op === "-") {
      // ECMA262 12.5.7.1
      // 1. Let expr be the result of evaluating UnaryExpression.
      // 2. Let oldValue be ? ToNumber(? GetValue(expr)).
      let oldValue = _singletons.To.ToNumber(realm, value); // 3. If oldValue is NaN, return NaN.


      if (isNaN(oldValue)) {
        return realm.intrinsics.NaN;
      } // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.


      return _index2.IntegralValue.createFromNumberValue(realm, -oldValue);
    } else if (op === "~") {
      // ECMA262 12.5.8
      // 1. Let expr be the result of evaluating UnaryExpression.
      // 2. Let oldValue be ? ToInt32(? GetValue(expr)).
      let oldValue = _singletons.To.ToInt32(realm, value); // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.


      return _index2.IntegralValue.createFromNumberValue(realm, ~oldValue);
    } else if (op === "!") {
      // ECMA262 12.6.9
      // 1. Let expr be the result of evaluating UnaryExpression.
      // 2. Let oldValue be ToBoolean(? GetValue(expr)).
      let oldValue = _singletons.To.ToBoolean(realm, value); // 3. If oldValue is true, return false.


      if (oldValue === true) return realm.intrinsics.false; // 4. Return true.

      return realm.intrinsics.true;
    } else if (op === "void") {
      // 1. Let expr be the result of evaluating UnaryExpression.
      // 2. Perform ? GetValue(expr).
      // 3. Return undefined.
      return realm.intrinsics.undefined;
    } else if (op === "typeof") {
      // ECMA262 12.6.5
      // 1. Let val be the result of evaluating UnaryExpression.
      // 2. If Type(val) is Reference, then
      // 3. Let val be ? GetValue(val).
      let val = value; // 4. Return a String according to Table 35.

      let typeString = _singletons.Utils.typeToString(val.getType());

      (0, _invariant.default)(typeString !== undefined);
      return new _index2.StringValue(realm, typeString);
    } else {
      (0, _invariant.default)(false, `${op} is a state update, not a pure operation, so we don't support it`);
    }
  }

  static unaryOp(realm, op, operandValues) {
    if (operandValues.isBottom()) return ValuesDomain.bottomVal;
    let operandElements = operandValues._elements;
    if (operandElements === undefined) return ValuesDomain.topVal;
    let resultSet = new Set();
    let savedHandler = realm.errorHandler;
    let savedIsReadOnly = realm.isReadOnly;
    realm.isReadOnly = true;

    try {
      realm.errorHandler = () => {
        throw new _errors.FatalError();
      };

      for (let operandElem of operandElements) {
        let result = ValuesDomain.computeUnary(realm, op, operandElem);

        if (result instanceof _index2.ConcreteValue) {
          resultSet.add(result);
        } else {
          (0, _invariant.default)(result instanceof _index2.AbstractValue);

          if (result.values.isTop()) {
            return ValuesDomain.topVal;
          }

          for (let subResult of result.values.getElements()) {
            resultSet.add(subResult);
          }
        }
      }
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) return ValuesDomain.topVal;
    } finally {
      realm.errorHandler = savedHandler;
      realm.isReadOnly = savedIsReadOnly;
    }

    return new ValuesDomain(resultSet);
  }

  includesValueNotOfType(type) {
    (0, _invariant.default)(!this.isTop());

    for (let cval of this.getElements()) {
      if (!(cval instanceof type)) return true;
    }

    return false;
  }

  includesValueOfType(type) {
    (0, _invariant.default)(!this.isTop());

    for (let cval of this.getElements()) {
      if (cval instanceof type) return true;
    }

    return false;
  }

  mightBeFalse() {
    (0, _invariant.default)(!this.isTop());

    for (let cval of this.getElements()) {
      if (cval.mightBeFalse()) return true;
    }

    return false;
  }

  mightNotBeFalse() {
    (0, _invariant.default)(!this.isTop());

    for (let cval of this.getElements()) {
      if (cval.mightNotBeFalse()) return true;
    }

    return false;
  }

  static joinValues(realm, v1 = realm.intrinsics.undefined, v2 = realm.intrinsics.undefined) {
    if (v1 instanceof _index2.AbstractValue) return v1.values.joinWith(v2);
    if (v2 instanceof _index2.AbstractValue) return v2.values.joinWith(v1);
    let union = new Set();
    (0, _invariant.default)(v1 instanceof _index2.ConcreteValue);
    union.add(v1);
    (0, _invariant.default)(v2 instanceof _index2.ConcreteValue);
    union.add(v2);
    return new ValuesDomain(union);
  }

  joinWith(y) {
    if (this.isTop()) return this;
    let union = new Set(this.getElements());

    if (y instanceof _index2.AbstractValue) {
      if (y.values.isTop()) return y.values;
      y.values.getElements().forEach(v => union.add(v));
    } else {
      (0, _invariant.default)(y instanceof _index2.ConcreteValue);
      union.add(y);
    }

    if (union.size === 0) return ValuesDomain.bottomVal;
    return new ValuesDomain(union);
  }

  static meetValues(realm, v1 = realm.intrinsics.undefined, v2 = realm.intrinsics.undefined) {
    if (v1 instanceof _index2.AbstractValue) return v1.values.meetWith(v2);
    if (v2 instanceof _index2.AbstractValue) return v2.values.meetWith(v1);
    let intersection = new Set();
    (0, _invariant.default)(v1 instanceof _index2.ConcreteValue);
    (0, _invariant.default)(v2 instanceof _index2.ConcreteValue);
    if (v1 === v2) intersection.add(v1);
    if (intersection.size === 0) return ValuesDomain.bottomVal;
    return new ValuesDomain(intersection);
  }

  meetWith(y) {
    let intersection = new Set();
    let elements = this._elements;

    if (y instanceof _index2.AbstractValue) {
      if (y.values.isTop()) return this;
      y.values.getElements().forEach(v => {
        if (elements === undefined || elements.has(v)) intersection.add(v);
      });
    } else {
      (0, _invariant.default)(y instanceof _index2.ConcreteValue);
      if (elements === undefined || elements.has(y)) intersection.add(y);
    }

    if (intersection.size === 0) return ValuesDomain.bottomVal;
    return new ValuesDomain(intersection);
  }

  promoteEmptyToUndefined() {
    if (this.isTop() || this.isBottom()) return this;
    let newSet = new Set();

    for (let cval of this.getElements()) {
      if (cval instanceof _index2.EmptyValue) newSet.add(cval.$Realm.intrinsics.undefined);else newSet.add(cval);
    }

    return new ValuesDomain(newSet);
  }

}

exports.default = ValuesDomain;
//# sourceMappingURL=ValuesDomain.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JoinedNormalAndAbruptCompletions = exports.JoinedAbruptCompletions = exports.ReturnCompletion = exports.BreakCompletion = exports.ContinueCompletion = exports.ThrowCompletion = exports.AbruptCompletion = exports.SimpleNormalCompletion = exports.NormalCompletion = exports.Completion = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _types = __webpack_require__(19);

var _index = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class Completion {
  constructor(value, location, target) {
    this.value = value;
    this.target = target;
    this.location = location;
    (0, _invariant.default)(this.constructor !== Completion, "Completion is an abstract base class");
  }

  containsSelectedCompletion(selector) {
    return selector(this);
  }

  shallowClone() {
    (0, _invariant.default)(false, "abstract base method");
  }

  toDisplayString() {
    return "[" + this.constructor.name + " value " + (this.value ? this.value.toDisplayString() : "undefined") + "]";
  }

  static makeAllNormalCompletionsResultInUndefined(completion) {
    let undefinedVal = completion.value.$Realm.intrinsics.undefined;
    if (completion instanceof SimpleNormalCompletion) completion.value = undefinedVal;else if (completion instanceof JoinedNormalAndAbruptCompletions) {
      if (completion.composedWith !== undefined) Completion.makeAllNormalCompletionsResultInUndefined(completion.composedWith);
      Completion.makeAllNormalCompletionsResultInUndefined(completion.consequent);
      Completion.makeAllNormalCompletionsResultInUndefined(completion.alternate);
    }
  }

  static makeSelectedCompletionsInfeasible(selector, completion) {
    let bottomValue = completion.value.$Realm.intrinsics.__bottomValue;
    if (selector(completion)) completion.value = bottomValue;else if (completion instanceof JoinedNormalAndAbruptCompletions || completion instanceof JoinedAbruptCompletions) {
      if (completion instanceof JoinedNormalAndAbruptCompletions && completion.composedWith !== undefined) Completion.makeSelectedCompletionsInfeasible(selector, completion.composedWith);
      Completion.makeSelectedCompletionsInfeasible(selector, completion.consequent);
      Completion.makeSelectedCompletionsInfeasible(selector, completion.alternate);
    }
  }

  static makeSelectedCompletionsInfeasibleInCopy(selector, completion) {
    let bottomValue = completion.value.$Realm.intrinsics.__bottomValue;
    let clone = completion.shallowClone();
    if (selector(clone)) clone.value = bottomValue;else if (clone instanceof JoinedNormalAndAbruptCompletions || clone instanceof JoinedAbruptCompletions) {
      clone.consequent = Completion.makeSelectedCompletionsInfeasibleInCopy(selector, clone.consequent);
      clone.alternate = Completion.makeSelectedCompletionsInfeasibleInCopy(selector, clone.alternate);

      if (clone.consequent.value === bottomValue) {
        return clone.alternate;
      }

      if (clone.alternate.value === bottomValue) {
        return clone.consequent;
      }
    }
    return clone;
  }

  static normalizeSelectedCompletions(selector, completion) {
    if (selector(completion)) return new SimpleNormalCompletion(completion.value);
    let normalizedComposedWith;

    if (completion instanceof JoinedNormalAndAbruptCompletions) {
      (0, _invariant.default)(completion.savedEffects === undefined); // caller should not used a still saved completion for this

      if (completion.composedWith !== undefined) normalizedComposedWith = Completion.normalizeSelectedCompletions(selector, completion.composedWith);
    }

    if (completion instanceof JoinedNormalAndAbruptCompletions || completion instanceof JoinedAbruptCompletions) {
      let nc = Completion.normalizeSelectedCompletions(selector, completion.consequent);
      let na = Completion.normalizeSelectedCompletions(selector, completion.alternate);

      if (normalizedComposedWith === undefined) {
        if (nc === completion.consequent && na === completion.alternate) return completion;
        if (nc instanceof AbruptCompletion && na instanceof AbruptCompletion) return completion;
        if (nc instanceof SimpleNormalCompletion && na instanceof SimpleNormalCompletion) return new SimpleNormalCompletion(_index.AbstractValue.createFromConditionalOp(completion.value.$Realm, completion.joinCondition, nc.value, na.value));
        (0, _invariant.default)(nc instanceof AbruptCompletion || nc instanceof NormalCompletion);
        (0, _invariant.default)(na instanceof AbruptCompletion || na instanceof NormalCompletion);
        return new JoinedNormalAndAbruptCompletions(completion.joinCondition, nc, na);
      }

      (0, _invariant.default)(nc instanceof AbruptCompletion || nc instanceof NormalCompletion);
      (0, _invariant.default)(na instanceof AbruptCompletion || na instanceof NormalCompletion);
      let result = new JoinedNormalAndAbruptCompletions(completion.joinCondition, nc, na);
      if (normalizedComposedWith instanceof JoinedNormalAndAbruptCompletions) result.composedWith = normalizedComposedWith;
      return result;
    }

    return completion;
  }

} // Normal completions are returned just like spec completions


exports.Completion = Completion;

class NormalCompletion extends Completion {
  constructor(value, location, target) {
    super(value, location, target);
    (0, _invariant.default)(this.constructor !== NormalCompletion, "NormalCompletion is an abstract base class");
  }

} // SimpleNormalCompletions are returned just like spec completions.
// They chiefly exist for use in joined completions.


exports.NormalCompletion = NormalCompletion;

class SimpleNormalCompletion extends NormalCompletion {
  shallowClone() {
    return new SimpleNormalCompletion(this.value, this.location, this.target);
  }

} // Abrupt completions are thrown as exeptions, to make it a easier
// to quickly get to the matching high level construct.


exports.SimpleNormalCompletion = SimpleNormalCompletion;

class AbruptCompletion extends Completion {
  constructor(value, location, target) {
    super(value, location, target);
    (0, _invariant.default)(this.constructor !== AbruptCompletion, "AbruptCompletion is an abstract base class");
  }

}

exports.AbruptCompletion = AbruptCompletion;

class ThrowCompletion extends AbruptCompletion {
  constructor(value, location, nativeStack, emitWarning = true) {
    super(value, location);
    this.nativeStack = nativeStack || new Error().stack;
  }

  shallowClone() {
    return new ThrowCompletion(this.value, this.location, this.nativeStack, false);
  }

}

exports.ThrowCompletion = ThrowCompletion;

class ContinueCompletion extends AbruptCompletion {
  constructor(value, location, target) {
    super(value, location, target || null);
  }

  shallowClone() {
    return new ContinueCompletion(this.value, this.location, this.target);
  }

}

exports.ContinueCompletion = ContinueCompletion;

class BreakCompletion extends AbruptCompletion {
  constructor(value, location, target) {
    super(value, location, target || null);
  }

  shallowClone() {
    return new BreakCompletion(this.value, this.location, this.target);
  }

}

exports.BreakCompletion = BreakCompletion;

class ReturnCompletion extends AbruptCompletion {
  constructor(value, location) {
    super(value, location);

    if (value instanceof _index.EmptyValue) {
      this.value = value.$Realm.intrinsics.undefined;
    }
  }

  shallowClone() {
    return new ReturnCompletion(this.value, this.location);
  }

}

exports.ReturnCompletion = ReturnCompletion;

class JoinedAbruptCompletions extends AbruptCompletion {
  constructor(joinCondition, consequent, alternate) {
    super(joinCondition.$Realm.intrinsics.empty, consequent.location);
    this.joinCondition = joinCondition;
    this.consequent = consequent;
    this.alternate = alternate;
  }

  containsSelectedCompletion(selector) {
    if (selector(this.consequent)) return true;
    if (selector(this.alternate)) return true;

    if (this.consequent instanceof JoinedAbruptCompletions) {
      if (this.consequent.containsSelectedCompletion(selector)) return true;
    }

    if (this.alternate instanceof JoinedAbruptCompletions) {
      if (this.alternate.containsSelectedCompletion(selector)) return true;
    }

    return false;
  }

  shallowClone() {
    return new JoinedAbruptCompletions(this.joinCondition, this.consequent, this.alternate);
  }

  toDisplayString() {
    let superString = super.toDisplayString().slice(0, -1);
    return superString + " c: [" + this.consequent.toDisplayString() + "] a: [" + this.alternate.toDisplayString() + "]]";
  }

} // This should never be thrown, therefore it is treated as a NormalCompletion even though it is also Abrupt.


exports.JoinedAbruptCompletions = JoinedAbruptCompletions;

class JoinedNormalAndAbruptCompletions extends NormalCompletion {
  constructor(joinCondition, consequent, alternate) {
    super(consequent instanceof NormalCompletion ? consequent.value : alternate.value, consequent.location);
    this.joinCondition = joinCondition;
    this.consequent = consequent;
    this.alternate = alternate;
    this.pathConditionsAtCreation = joinCondition.$Realm.pathConditions;
  }

  containsSelectedCompletion(selector) {
    if (this.composedWith !== undefined && this.composedWith.containsSelectedCompletion(selector)) return true;
    if (selector(this.consequent)) return true;
    if (selector(this.alternate)) return true;

    if (this.consequent instanceof JoinedAbruptCompletions || this.consequent instanceof JoinedNormalAndAbruptCompletions) {
      if (this.consequent.containsSelectedCompletion(selector)) return true;
    }

    if (this.alternate instanceof JoinedAbruptCompletions || this.alternate instanceof JoinedNormalAndAbruptCompletions) {
      if (this.alternate.containsSelectedCompletion(selector)) return true;
    }

    return false;
  }

  shallowClone() {
    let clone = new JoinedNormalAndAbruptCompletions(this.joinCondition, this.consequent, this.alternate);
    clone.composedWith = this.composedWith;
    clone.pathConditionsAtCreation = this.pathConditionsAtCreation;
    return clone;
  }

  toDisplayString() {
    let superString = super.toDisplayString().slice(0, -1);
    return superString + " c: [" + this.consequent.toDisplayString() + "] a: [" + this.alternate.toDisplayString() + "]]";
  }

}

exports.JoinedNormalAndAbruptCompletions = JoinedNormalAndAbruptCompletions;
//# sourceMappingURL=completions.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PathConditions = exports.SourceFileCollection = exports.ElementSize = void 0;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const ElementSize = {
  Float32: 4,
  Float64: 8,
  Int8: 1,
  Int16: 2,
  Int32: 4,
  Uint8: 1,
  Uint16: 2,
  Uint32: 4,
  Uint8Clamped: 1
};
exports.ElementSize = ElementSize;

class SourceFileCollection {
  constructor(sourceFiles) {
    this._sourceFiles = sourceFiles;
  }

  toArray() {
    (0, _invariant.default)(this._sourceFiles !== undefined);
    return this._sourceFiles;
  }

  destroy() {
    this._sourceFiles = undefined;
  }

}

exports.SourceFileCollection = SourceFileCollection;

class PathConditions {
  add(c) {} // this => val. A false value does not imply that !(this => val).


  implies(e, depth = 0) {
    return false;
  } // this => !val. A false value does not imply that !(this => !val).


  impliesNot(e, depth = 0) {
    return false;
  }

  isEmpty() {
    return false;
  }

  isReadOnly() {
    return false;
  }

  getLength() {
    return 0;
  }

  getAssumedConditions() {
    return new Set();
  }

  refineBaseConditons(realm, depth = 0) {}

}

exports.PathConditions = PathConditions;
//# sourceMappingURL=types.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.materializeBinding = materializeBinding;
exports.leakBinding = leakBinding;
exports.isValidBaseValue = isValidBaseValue;
exports.mightBecomeAnObject = mightBecomeAnObject;
exports.Reference = exports.LexicalEnvironment = exports.GlobalEnvironmentRecord = exports.FunctionEnvironmentRecord = exports.ObjectEnvironmentRecord = exports.DeclarativeEnvironmentRecord = exports.EnvironmentRecord = void 0;

var t = _interopRequireWildcard(__webpack_require__(21));

var _completions = __webpack_require__(18);

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _parse = _interopRequireDefault(__webpack_require__(227));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _traverseFast = _interopRequireDefault(__webpack_require__(279));

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _index3 = __webpack_require__(15);

var _PrimitiveValue = _interopRequireDefault(__webpack_require__(13));

var _generator = __webpack_require__(237);

var _sourceMap = __webpack_require__(280);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function deriveGetBinding(realm, binding) {
  let types = _index3.TypesDomain.topVal;
  let values = _index3.ValuesDomain.topVal;
  (0, _invariant.default)(realm.generator !== undefined);
  return realm.generator.deriveAbstract(types, values, [], (0, _generator.createOperationDescriptor)("GET_BINDING", {
    binding
  }));
}

function materializeBinding(realm, binding) {
  let realmGenerator = realm.generator;
  (0, _invariant.default)(realmGenerator !== undefined);
  let value = binding.value;
  if (value !== undefined && value !== realm.intrinsics.undefined) realmGenerator.emitBindingAssignment(binding, value);
}

function leakBinding(binding) {
  let realm = binding.environment.realm;

  if (!binding.hasLeaked) {
    if (binding.mutable) {
      realm.recordModifiedBinding(binding).hasLeaked = true;
    } else {
      binding.hasLeaked = true;
    }

    materializeBinding(realm, binding);
  } // Havoc the binding


  if (binding.mutable === true) {
    // For mutable, i.e. non-const bindings, the actual value is no longer directly available.
    // Thus, we reset the value to undefined to prevent any use of the last known value.
    binding.value = undefined;
  }
} // ECMA262 8.1.1


class EnvironmentRecord {
  constructor(realm) {
    (0, _invariant.default)(realm, "expected realm");
    this.realm = realm;
    this.isReadOnly = false;
    this.id = EnvironmentRecord.nextId++;
    this.creatingOptimizedFunction = realm.currentOptimizedFunction;
  }

  HasBinding(N) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  CreateMutableBinding(N, D, isGlobal) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  CreateImmutableBinding(N, S, isGlobal, skipRecord) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  InitializeBinding(N, V, skipRecord) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  SetMutableBinding(N, V, S) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  GetBindingValue(N, S) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  DeleteBinding(N) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  HasThisBinding() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  GetThisBinding() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  HasSuperBinding() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  WithBaseObject() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  BindThisValue(V) {
    (0, _invariant.default)(false, "abstract method; please override");
  }

}

exports.EnvironmentRecord = EnvironmentRecord;

_defineProperty(EnvironmentRecord, "nextId", 0);

// ECMA262 8.1.1.1
class DeclarativeEnvironmentRecord extends EnvironmentRecord {
  constructor(realm) {
    super(realm);
    this.bindings = Object.create(null);
    this.frozen = false;
  }

  // ECMA262 8.1.1.1.1
  HasBinding(N) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    let envRec = this; // 2. If envRec has a binding for the name that is the value of N, return true.

    if (envRec.bindings[N]) return true; // 3. Return false.

    return false;
  } // ECMA262 8.1.1.1.2


  CreateMutableBinding(N, D, isGlobal = false) {
    (0, _invariant.default)(!this.frozen);
    let realm = this.realm; // 1. Let envRec be the declarative Environment Record for which the method was invoked.

    let envRec = this; // 2. Assert: envRec does not already have a binding for N.

    (0, _invariant.default)(!envRec.bindings[N], `shouldn't have the binding ${N}`); // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.

    this.bindings[N] = realm.recordModifiedBinding({
      initialized: false,
      mutable: true,
      deletable: D,
      environment: envRec,
      name: N,
      isGlobal: isGlobal,
      mightHaveBeenCaptured: false,
      hasLeaked: false
    }); // 4. Return NormalCompletion(empty).

    return realm.intrinsics.undefined;
  } // ECMA262 8.1.1.1.3


  CreateImmutableBinding(N, S, isGlobal = false, skipRecord = false) {
    (0, _invariant.default)(!this.frozen);
    let realm = this.realm; // 1. Let envRec be the declarative Environment Record for which the method was invoked.

    let envRec = this; // 2. Assert: envRec does not already have a binding for N.

    (0, _invariant.default)(!envRec.bindings[N], `shouldn't have the binding ${N}`); // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.

    let binding = {
      initialized: false,
      strict: S,
      deletable: false,
      environment: envRec,
      name: N,
      isGlobal: isGlobal,
      mightHaveBeenCaptured: false,
      hasLeaked: false
    };
    this.bindings[N] = skipRecord ? binding : realm.recordModifiedBinding(binding); // 4. Return NormalCompletion(empty).

    return realm.intrinsics.undefined;
  } // ECMA262 8.1.1.1.4


  InitializeBinding(N, V, skipRecord = false) {
    // 1. Let envRec be the declarative Environment Record for which the method was invoked.
    let envRec = this;
    let binding = envRec.bindings[N]; // 2. Assert: envRec must have an uninitialized binding for N.

    (0, _invariant.default)(binding && binding.initialized !== true, `shouldn't have the binding ${N}`); // 3. Set the bound value for N in envRec to V.

    if (!skipRecord) this.realm.recordModifiedBinding(binding, V).value = V;else binding.value = V; // 4. Record that the binding for N in envRec has been initialized.

    binding.initialized = true; // 5. Return NormalCompletion(empty).

    return this.realm.intrinsics.empty;
  } // ECMA262 8.1.1.1.5


  SetMutableBinding(N, V, _S) {
    let S = _S; // We can mutate frozen bindings because of captured bindings.

    let realm = this.realm; // 1. Let envRec be the declarative Environment Record for which the method was invoked.

    let envRec = this;
    let binding = envRec.bindings[N]; // 2. If envRec does not have a binding for N, then

    if (!binding) {
      // a. If S is true, throw a ReferenceError exception.
      if (S) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);
      } // b. Perform envRec.CreateMutableBinding(N, true).


      envRec.CreateMutableBinding(N, true); // c. Perform envRec.InitializeBinding(N, V).

      envRec.InitializeBinding(N, V); // d. Return NormalCompletion(empty).

      return this.realm.intrinsics.empty;
    } // 3. If the binding for N in envRec is a strict binding, let S be true.


    if (binding.strict === true) S = true; // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.

    if (binding.initialized !== true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);
    } else if (binding.mutable) {
      // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.
      if (binding.hasLeaked) {
        _singletons.Leak.value(realm, V);

        (0, _invariant.default)(realm.generator);
        realm.generator.emitBindingAssignment(binding, V);
      } else {
        realm.recordModifiedBinding(binding, V).value = V;
      }
    } else {
      // 6. Else,
      // a. Assert: This is an attempt to change the value of an immutable binding.
      // b. If S is true, throw a TypeError exception.
      if (S) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "attempt to change immutable binding");
      }
    } // 7. Return NormalCompletion(empty).


    return this.realm.intrinsics.empty;
  } // ECMA262 8.1.1.1.6


  GetBindingValue(N, S) {
    let realm = this.realm; // 1. Let envRec be the declarative Environment Record for which the method was invoked.

    let envRec = this;
    let binding = envRec.bindings[N]; // 2. Assert: envRec has a binding for N.

    (0, _invariant.default)(binding, "expected binding"); // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.

    if (!binding.initialized) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
    } // 4. Return the value currently bound to N in envRec.


    if (binding.hasLeaked && binding.mutable) {
      return deriveGetBinding(realm, binding);
    }

    (0, _invariant.default)(binding.value);
    return binding.value;
  } // ECMA262 8.1.1.1.7


  DeleteBinding(N) {
    (0, _invariant.default)(!this.frozen); // 1. Let envRec be the declarative Environment Record for which the method was invoked.

    let envRec = this; // 2. Assert: envRec has a binding for the name that is the value of N.

    (0, _invariant.default)(envRec.bindings[N], "expected binding to exist"); // 3. If the binding for N in envRec cannot be deleted, return false.

    if (!envRec.bindings[N].deletable) return false; // 4. Remove the binding for N from envRec.

    this.realm.recordModifiedBinding(envRec.bindings[N]).value = undefined;
    delete envRec.bindings[N]; // 5. Return true.

    return true;
  } // ECMA262 8.1.1.1.8


  HasThisBinding() {
    // 1. Return false.
    return false;
  } // ECMA262 8.1.1.1.9


  HasSuperBinding() {
    // 1. Return false.
    return false;
  } // ECMA262 8.1.1.1.10


  WithBaseObject() {
    // 1. Return undefined.
    return this.realm.intrinsics.undefined;
  }

} // ECMA262 8.1.1.2


exports.DeclarativeEnvironmentRecord = DeclarativeEnvironmentRecord;

class ObjectEnvironmentRecord extends EnvironmentRecord {
  constructor(realm, obj) {
    super(realm);
    this.object = obj;
  } // ECMA262 8.1.1.2.1


  HasBinding(N) {
    let realm = this.realm; // 1. Let envRec be the object Environment Record for which the method was invoked.

    let envRec = this; // 2. Let bindings be the binding object for envRec.

    let bindings = this.object; // 3. Let foundBinding be ? HasProperty(bindings, N).

    let foundBinding = (0, _index2.HasProperty)(realm, bindings, N); // 4. If foundBinding is false, return false.

    if (!foundBinding) return false; // 5. If the withEnvironment flag of envRec is false, return true.

    if (!envRec.withEnvironment) return true; // 6. Let unscopables be ? Get(bindings, @@unscopables).

    let unscopables = (0, _index2.Get)(realm, bindings, realm.intrinsics.SymbolUnscopables); // 7. If Type(unscopables) is Object, then

    if (unscopables instanceof _index.ObjectValue || unscopables instanceof _index.AbstractObjectValue) {
      // a. Let blocked be ToBoolean(? Get(unscopables, N)).
      let blocked = _singletons.To.ToBooleanPartial(realm, (0, _index2.Get)(realm, unscopables, N)); // b. If blocked is true, return false.


      if (blocked) return false;
    }

    unscopables.throwIfNotConcrete(); // 8. Return true.

    return true;
  } // ECMA262 8.1.1.2.2


  CreateMutableBinding(N, D) {
    let realm = this.realm; // 1. Let envRec be the object Environment Record for which the method was invoked.

    let envRec = this; // 2. Let bindings be the binding object for envRec.

    let bindings = envRec.object; // 3. If D is true, let configValue be true; otherwise let configValue be false.

    let configValue = D ? true : false; // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).

    return new _index.BooleanValue(realm, _singletons.Properties.DefinePropertyOrThrow(realm, bindings, N, new _descriptors.PropertyDescriptor({
      value: realm.intrinsics.undefined,
      writable: true,
      enumerable: true,
      configurable: configValue
    })));
  } // ECMA262 8.1.1.2.3


  CreateImmutableBinding(N, S) {
    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.
    (0, _invariant.default)(false);
  } // ECMA262 8.1.1.2.4


  InitializeBinding(N, V) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    let envRec = this; // 2. Assert: envRec must have an uninitialized binding for N.
    // 3. Record that the binding for N in envRec has been initialized.
    // 4. Return ? envRec.SetMutableBinding(N, V, false).

    return envRec.SetMutableBinding(N, V, false);
  } // ECMA262 8.1.1.2.5


  SetMutableBinding(N, V, S) {
    let realm = this.realm; // 1. Let envRec be the object Environment Record for which the method was invoked.

    let envRec = this; // 2. Let bindings be the binding object for envRec.

    let bindings = envRec.object; // 3. Return ? Set(bindings, N, V, S).

    return new _index.BooleanValue(realm, _singletons.Properties.Set(realm, bindings, N, V, S));
  } // ECMA262 8.1.1.2.6


  GetBindingValue(N, S) {
    let realm = this.realm; // 1. Let envRec be the object Environment Record for which the method was invoked.

    let envRec = this; // 2. Let bindings be the binding object for envRec.

    let bindings = envRec.object; // 3. Let value be ? HasProperty(bindings, N).

    let value = (0, _index2.HasProperty)(realm, bindings, N); // 4. If value is false, then

    if (!value) {
      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.
      if (!S) {
        return realm.intrinsics.undefined;
      } else {
        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
      }
    } // 5. Return ? Get(bindings, N).


    return (0, _index2.Get)(realm, bindings, N);
  } // ECMA262 8.1.1.2.7


  DeleteBinding(N) {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    let envRec = this; // 2. Let bindings be the binding object for envRec.

    let bindings = envRec.object; // 3. Return ? bindings.[[Delete]](N).

    return bindings.$Delete(N);
  } // ECMA262 8.1.1.2.8


  HasThisBinding() {
    // 1. Return false.
    return false;
  } // ECMA262 8.1.1.2.9


  HasSuperBinding() {
    // 1. Return false.
    return false;
  } // ECMA262 8.1.1.2.10


  WithBaseObject() {
    // 1. Let envRec be the object Environment Record for which the method was invoked.
    let envRec = this; // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.

    if (envRec.withEnvironment) return envRec.object; // 3. Otherwise, return undefined.

    return this.realm.intrinsics.undefined;
  }

} // ECMA262 8.1.1.3


exports.ObjectEnvironmentRecord = ObjectEnvironmentRecord;

class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {
  // ECMA262 8.1.1.3.1
  BindThisValue(V) {
    let realm = this.realm; // 1. Let envRec be the function Environment Record for which the method was invoked.

    let envRec = this; // 2. Assert: envRec.[[ThisBindingStatus]] is not "lexical".

    (0, _invariant.default)(envRec.$ThisBindingStatus !== "lexical", "this binding status shouldn't be lexical"); // 3. If envRec.[[ThisBindingStatus]] is "initialized", throw a ReferenceError exception.

    if (envRec.$ThisBindingStatus === "initialized") {
      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
    } // 4. Set envRec.[[ThisValue]] to V.


    envRec.$ThisValue = V; // 5. Set envRec.[[ThisBindingStatus]] to "initialized".

    envRec.$ThisBindingStatus = "initialized"; // 6. Return V.

    return V;
  } // ECMA262 8.1.1.3.2


  HasThisBinding() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    let envRec = this; // 2. If envRec.[[ThisBindingStatus]] is "lexical", return false; otherwise, return true.

    return envRec.$ThisBindingStatus === "lexical" ? false : true;
  } // ECMA262 8.1.1.3.3


  HasSuperBinding() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    let envRec = this; // 2. If envRec.[[ThisBindingStatus]] is "lexical", return false.

    if (envRec.$ThisBindingStatus === "lexical") return false; // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.

    if (envRec.$HomeObject === undefined) {
      return false;
    } else {
      return true;
    }
  } // ECMA262 8.1.1.3.4


  GetThisBinding() {
    let realm = this.realm; // 1. Let envRec be the function Environment Record for which the method was invoked.

    let envRec = this; // 2. Assert: envRec.[[ThisBindingStatus]] is not "lexical".

    (0, _invariant.default)(envRec.$ThisBindingStatus !== "lexical", "this binding status shouldn't be lexical"); // 3. If envRec.[[ThisBindingStatus]] is "uninitialized", throw a ReferenceError exception.

    if (envRec.$ThisBindingStatus === "uninitialized") {
      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
    } // 4. Return envRec.[[ThisValue]].


    return envRec.$ThisValue;
  } // ECMA262 8.1.1.3.5


  GetSuperBase() {
    // 1. Let envRec be the function Environment Record for which the method was invoked.
    let envRec = this; // 2. Let home be the value of envRec.[[HomeObject]].

    let home = envRec.$HomeObject; // 3. If home has the value undefined, return undefined.

    if (home === undefined) return this.realm.intrinsics.undefined; // 4. Assert: Type(home) is Object.

    (0, _invariant.default)(home instanceof _index.ObjectValue, "expected object value"); // 5. Return ? home.[[GetPrototypeOf]]().

    return home.$GetPrototypeOf();
  }

} // ECMA262 8.1.1.4


exports.FunctionEnvironmentRecord = FunctionEnvironmentRecord;

class GlobalEnvironmentRecord extends EnvironmentRecord {
  // ECMA262 8.1.1.4.1
  HasBinding(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, return true.

    if (DclRec.HasBinding(N)) return true; // 4. Let ObjRec be envRec.[[ObjectRecord]].

    let ObjRec = envRec.$ObjectRecord; // 5. Return ? ObjRec.HasBinding(N).

    return ObjRec.HasBinding(N);
  } // ECMA262 8.1.1.4.2


  CreateMutableBinding(N, D) {
    let realm = this.realm; // 1. Let envRec be the global Environment Record for which the method was invoked.

    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.

    if (DclRec.HasBinding(N)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Return DclRec.CreateMutableBinding(N, D).


    return DclRec.CreateMutableBinding(N, D, true);
  } // ECMA262 8.1.1.4.3


  CreateImmutableBinding(N, S) {
    let realm = this.realm; // 1. Let envRec be the global Environment Record for which the method was invoked.

    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.

    if (DclRec.HasBinding(N)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Return DclRec.CreateImmutableBinding(N, S).


    return DclRec.CreateImmutableBinding(N, S, true);
  } // ECMA262 8.1.1.4.4


  InitializeBinding(N, V) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, then

    if (DclRec.HasBinding(N)) {
      // a. Return DclRec.InitializeBinding(N, V).
      return DclRec.InitializeBinding(N, V);
    } // 4. Assert: If the binding exists, it must be in the object Environment Record.
    // 5. Let ObjRec be envRec.[[ObjectRecord]].


    let ObjRec = envRec.$ObjectRecord; // 6. Return ? ObjRec.InitializeBinding(N, V).

    return ObjRec.InitializeBinding(N, V);
  } // ECMA262 8.1.1.4.5


  SetMutableBinding(N, V, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, then

    if (DclRec.HasBinding(N)) {
      // a. Return DclRec.SetMutableBinding(N, V, S).
      return DclRec.SetMutableBinding(N, V, S);
    } // 4. Let ObjRec be envRec.[[ObjectRecord]].


    let ObjRec = envRec.$ObjectRecord; // 5. Return ? ObjRec.SetMutableBinding(N, V, S).

    return ObjRec.SetMutableBinding(N, V, S);
  } // ECMA262 8.1.1.4.6


  GetBindingValue(N, S) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, then

    if (DclRec.HasBinding(N)) {
      // a. Return DclRec.GetBindingValue(N, S).
      return DclRec.GetBindingValue(N, S);
    } // 4. Let ObjRec be envRec.[[ObjectRecord]].


    let ObjRec = envRec.$ObjectRecord; // 5. Return ? ObjRec.GetBindingValue(N, S).

    return ObjRec.GetBindingValue(N, S);
  } // ECMA262 8.1.1.4.7


  DeleteBinding(N) {
    let realm = this.realm; // 1. Let envRec be the global Environment Record for which the method was invoked.

    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. If DclRec.HasBinding(N) is true, then

    if (DclRec.HasBinding(N)) {
      // a. Return DclRec.DeleteBinding(N).
      return DclRec.DeleteBinding(N);
    } // 4. Let ObjRec be envRec.[[ObjectRecord]].


    let ObjRec = envRec.$ObjectRecord; // 5. Let globalObject be the binding object for ObjRec.

    let globalObject = ObjRec.object; // 6. Let existingProp be ? HasOwnProperty(globalObject, N).

    let existingProp = (0, _index2.HasOwnProperty)(realm, globalObject, N); // 7. If existingProp is true, then

    if (existingProp) {
      // a. Let status be ? ObjRec.DeleteBinding(N).
      let status = ObjRec.DeleteBinding(N); // b. If status is true, then

      if (status) {
        // i. Let varNames be envRec.[[VarNames]].
        let varNames = envRec.$VarNames; // ii. If N is an element of varNames, remove that element from the varNames.

        if (varNames.indexOf(N) >= 0) {
          varNames.splice(varNames.indexOf(N), 1);
        }
      } // c. Return status.


      return status;
    } // 8. Return true.


    return true;
  } // ECMA262 8.1.1.4.8


  HasThisBinding() {
    // 1. Return true.
    return true;
  } // ECMA262 8.1.1.4.9


  HasSuperBinding() {
    // 1. Return true.
    return true;
  } // ECMA262 8.1.1.4.10


  WithBaseObject() {
    // 1. Return undefined.
    return this.realm.intrinsics.undefined;
  } // ECMA262 8.1.1.4.11


  GetThisBinding() {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this;
    (0, _invariant.default)(envRec.$GlobalThisValue); // 2. Return envRec.[[GlobalThisValue]].

    return envRec.$GlobalThisValue;
  } // ECMA262 8.1.1.4.12


  HasVarDeclaration(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let varDeclaredNames be envRec.[[VarNames]].

    let varDeclaredNames = envRec.$VarNames; // 3. If varDeclaredNames contains the value of N, return true.

    if (varDeclaredNames.indexOf(N) >= 0) return true; // 4. Return false.

    return false;
  } // ECMA262 8.1.1.4.13


  HasLexicalDeclaration(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let DclRec be envRec.[[DeclarativeRecord]].

    let DclRec = envRec.$DeclarativeRecord; // 3. Return DclRec.HasBinding(N).

    return DclRec.HasBinding(N);
  } // ECMA262 8.1.1.4.14


  HasRestrictedGlobalProperty(N) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    let ObjRec = envRec.$ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    let globalObject = ObjRec.object; // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).

    let existingProp = globalObject.$GetOwnProperty(N); // 5. If existingProp is undefined, return false.

    if (!existingProp) return false;

    _singletons.Properties.ThrowIfMightHaveBeenDeleted(existingProp);

    existingProp = existingProp.throwIfNotConcrete(globalObject.$Realm); // 6. If existingProp.[[Configurable]] is true, return false.

    if (existingProp.configurable) return false; // 7. Return true.

    return true;
  } // ECMA262 8.1.1.4.15


  CanDeclareGlobalVar(N) {
    let realm = this.realm; // 1. Let envRec be the global Environment Record for which the method was invoked.

    let envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    let ObjRec = envRec.$ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    let globalObject = ObjRec.object; // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).

    let hasProperty = (0, _index2.HasOwnProperty)(realm, globalObject, N); // 5. If hasProperty is true, return true.

    if (hasProperty) return true; // 6. Return ? IsExtensible(globalObject).

    return (0, _index2.IsExtensible)(realm, globalObject);
  } // ECMA262 8.1.1.4.16


  CanDeclareGlobalFunction(N) {
    let realm = this.realm; // 1. Let envRec be the global Environment Record for which the method was invoked.

    let envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    let ObjRec = envRec.$ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    let globalObject = ObjRec.object; // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).

    let existingProp = globalObject.$GetOwnProperty(N); // 5. If existingProp is undefined, return ? IsExtensible(globalObject).

    if (!existingProp) return (0, _index2.IsExtensible)(realm, globalObject);

    _singletons.Properties.ThrowIfMightHaveBeenDeleted(existingProp);

    existingProp = existingProp.throwIfNotConcrete(globalObject.$Realm); // 6. If existingProp.[[Configurable]] is true, return true.

    if (existingProp.configurable) return true; // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.

    if ((0, _index2.IsDataDescriptor)(realm, existingProp) && existingProp.writable && existingProp.enumerable) {
      return true;
    } // 8. Return false.


    return false;
  } // ECMA262 8.1.1.4.17


  CreateGlobalVarBinding(N, D) {
    let realm = this.realm; // 1. Let envRec be the global Environment Record for which the method was invoked.

    let envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    let ObjRec = envRec.$ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    let globalObject = ObjRec.object; // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).

    let hasProperty = (0, _index2.HasOwnProperty)(realm, globalObject, N); // 5. Let extensible be ? IsExtensible(globalObject).

    let extensible = (0, _index2.IsExtensible)(realm, globalObject); // 6. If hasProperty is false and extensible is true, then

    if (!hasProperty && extensible) {
      // a. Perform ? ObjRec.CreateMutableBinding(N, D).
      ObjRec.CreateMutableBinding(N, D); // b. Perform ? ObjRec.InitializeBinding(N, undefined).

      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);
    } // 7. Let varDeclaredNames be envRec.[[VarNames]].


    let varDeclaredNames = envRec.$VarNames; // 8. If varDeclaredNames does not contain the value of N, then

    if (varDeclaredNames.indexOf(N) < 0) {
      // a. Append N to varDeclaredNames.
      varDeclaredNames.push(N);
    } // 9. Return NormalCompletion(empty).

  } // ECMA262 8.1.1.4.18


  CreateGlobalFunctionBinding(N, V, D) {
    // 1. Let envRec be the global Environment Record for which the method was invoked.
    let envRec = this; // 2. Let ObjRec be envRec.[[ObjectRecord]].

    let ObjRec = envRec.$ObjectRecord; // 3. Let globalObject be the binding object for ObjRec.

    let globalObject = ObjRec.object; // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).

    let existingProp = globalObject.$GetOwnProperty(N);

    if (existingProp) {
      existingProp = existingProp.throwIfNotConcrete(globalObject.$Realm);
    } // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then


    let desc;

    if (!existingProp || existingProp.configurable) {
      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.
      desc = new _descriptors.PropertyDescriptor({
        value: V,
        writable: true,
        enumerable: true,
        configurable: D
      });
    } else {
      // 6. Else,
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(existingProp); // a. Let desc be the PropertyDescriptor{[[Value]]: V }.


      desc = new _descriptors.PropertyDescriptor({
        value: V
      });
    } // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).


    _singletons.Properties.DefinePropertyOrThrow(this.realm, globalObject, N, desc); // 8. Record that the binding for N in ObjRec has been initialized.
    // 9. Perform ? Set(globalObject, N, V, false).


    _singletons.Properties.Set(this.realm, globalObject, N, V, false); // 10. Let varDeclaredNames be envRec.[[VarNames]].


    let varDeclaredNames = envRec.$VarNames; // 11. If varDeclaredNames does not contain the value of N, then

    if (varDeclaredNames.indexOf(N) < 0) {
      // a. Append N to varDeclaredNames.
      varDeclaredNames.push(N);
    } // 12. Return NormalCompletion(empty).

  }

} // ECMA262 8.1


exports.GlobalEnvironmentRecord = GlobalEnvironmentRecord;
let uid = 0;

class LexicalEnvironment {
  constructor(realm) {
    (0, _invariant.default)(realm, "expected realm");
    this.realm = realm;
    this.destroyed = false;
    this._uid = uid++;
  } // For debugging it is convenient to have an ID for each of these.


  destroy() {
    this.destroyed = true; // Once the containing environment is destroyed, we can no longer add or remove entries from the environmentRecord
    // (but we can update existing values).

    if (this.environmentRecord instanceof DeclarativeEnvironmentRecord) {
      this.environmentRecord.frozen = true;
    }
  }

  assignToGlobal(globalAst, rvalue) {
    let globalValue = this.evaluate(globalAst, false);

    _singletons.Properties.PutValue(this.realm, globalValue, rvalue);
  }

  evaluateCompletionDeref(ast, strictCode, metadata) {
    let result = this.evaluateCompletion(ast, strictCode, metadata);
    if (result instanceof Reference) result = _singletons.Environment.GetValue(this.realm, result);
    return result;
  }

  evaluateCompletion(ast, strictCode, metadata) {
    try {
      return this.evaluate(ast, strictCode, metadata);
    } catch (err) {
      if (err instanceof _completions.AbruptCompletion) return err;
      if (err instanceof Error) // rethrowing Error should preserve stack trace
        throw err; // let's wrap into a proper Error to create stack trace

      throw new _errors.FatalError(err);
    }
  }

  evaluateAbstractCompletion(ast, strictCode, metadata) {
    try {
      return this.evaluateAbstract(ast, strictCode, metadata);
    } catch (err) {
      if (err instanceof _completions.Completion) return err;
      if (err instanceof Error) // rethrowing Error should preserve stack trace
        throw err; // let's wrap into a proper Error to create stack trace

      if (err instanceof Object) throw new _errors.FatalError(err.constructor.name + ": " + err);
      throw new _errors.FatalError(err);
    }
  }

  concatenateAndParse(sources, sourceType = "script") {
    let asts = [];
    let code = {};
    let directives = [];

    for (let source of sources) {
      try {
        let node = this.realm.statistics.parsing.measure(() => (0, _parse.default)(this.realm, source.fileContents, source.filePath, sourceType));
        let sourceMapContents = source.sourceMapContents;

        if (sourceMapContents && sourceMapContents.length > 0) {
          this.realm.statistics.fixupSourceLocations.measure(() => this.fixupSourceLocations(node, sourceMapContents));
        }

        this.realm.statistics.fixupFilenames.measure(() => this.fixupFilenames(node));
        asts = asts.concat(node.program.body);
        code[source.filePath] = source.fileContents;
        directives = directives.concat(node.program.directives);
      } catch (e) {
        if (e instanceof _completions.ThrowCompletion) {
          let error = e.value;

          if (error instanceof _index.ObjectValue) {
            let message = error._SafeGetDataPropertyValue("message");

            if (message instanceof _index.StringValue) {
              message.value = `Syntax error: ${message.value}`;
              e.location.source = source.filePath; // the position was not located properly on the
              // syntax errors happen on one given position, so start position = end position

              e.location.start = {
                line: e.location.line,
                column: e.location.column
              };
              e.location.end = {
                line: e.location.line,
                column: e.location.column
              };
              let diagnostic = new _errors.CompilerDiagnostic(message.value, e.location, "PP1004", "FatalError");
              this.realm.handleError(diagnostic);
              throw new _errors.FatalError(message.value);
            }
          }
        }

        throw e;
      }
    }

    return [t.file(t.program(asts, directives)), code];
  }

  executeSources(sources, sourceType = "script", onParse = undefined) {
    let context = new _realm.ExecutionContext();
    context.lexicalEnvironment = this;
    context.variableEnvironment = this;
    context.realm = this.realm;
    this.realm.pushContext(context);
    let res, code;

    try {
      let ast;
      [ast, code] = this.concatenateAndParse(sources, sourceType);
      if (onParse) onParse(ast);
      res = this.realm.statistics.evaluation.measure(() => this.evaluateCompletion(ast, false));
    } finally {
      this.realm.popContext(context);
      this.realm.onDestroyScope(context.lexicalEnvironment);
      if (!this.destroyed) this.realm.onDestroyScope(this);
      (0, _invariant.default)(this.realm.activeLexicalEnvironments.size === 0, `expected 0 active lexical environments, got ${this.realm.activeLexicalEnvironments.size}`);
    }

    if (res instanceof _completions.AbruptCompletion) return [res, code];
    return [_singletons.Environment.GetValue(this.realm, res), code];
  }

  execute(code, filename, map = "", sourceType = "script", onParse = undefined) {
    let context = new _realm.ExecutionContext();
    context.lexicalEnvironment = this;
    context.variableEnvironment = this;
    context.realm = this.realm;
    this.realm.pushContext(context);
    let ast, res;

    try {
      try {
        ast = (0, _parse.default)(this.realm, code, filename, sourceType);
      } catch (e) {
        if (e instanceof _completions.ThrowCompletion) return e;
        throw e;
      }

      if (onParse) onParse(ast);
      if (map.length > 0) this.fixupSourceLocations(ast, map);
      this.fixupFilenames(ast);
      res = this.evaluateCompletion(ast, false);
    } finally {
      this.realm.popContext(context); // Avoid destroying "this" scope as execute may be called many times.

      if (context.lexicalEnvironment !== this) this.realm.onDestroyScope(context.lexicalEnvironment);
      (0, _invariant.default)(this.realm.activeLexicalEnvironments.size === 1, `expected 1 active lexical environment, got ${this.realm.activeLexicalEnvironments.size}`);
    }

    if (res instanceof _completions.AbruptCompletion) return res;
    return _singletons.Environment.GetValue(this.realm, res);
  }

  fixupSourceLocations(ast, map) {
    (0, _invariant.default)(ast.loc);
    const source = ast.loc.source;
    (0, _invariant.default)(source !== undefined);
    const positionInfos = new Map();
    const smc = new _sourceMap.SourceMapConsumer(map);
    (0, _traverseFast.default)(ast, node => {
      fixupLocation(node.loc);
      fixupComments(node.leadingComments);
      fixupComments(node.innerComments);
      fixupComments(node.trailingComments);
      return false;
    });

    function getPositionInfo(position) {
      let info = positionInfos.get(position);
      if (info === undefined) positionInfos.set(position, info = {
        originalPosition: smc.originalPositionFor(position),
        newLine: position.line,
        newColumn: position.column,
        rewritten: false
      });
      return info;
    }

    function fixupPosition(pos, posInfo, otherInfo) {
      if (posInfo.rewritten) return;
      let posOriginalPosition = posInfo.originalPosition;

      if (posOriginalPosition.source == null) {
        (0, _invariant.default)(otherInfo.originalPosition.source != null);
        let deltaLine = posInfo.newLine - otherInfo.newLine;
        pos.line = Math.max(1, otherInfo.originalPosition.line + deltaLine);
        let deltaColumn = posInfo.newColumn - otherInfo.newColumn;
        pos.column = Math.max(0, otherInfo.originalPosition.column + deltaColumn);
      } else {
        (0, _invariant.default)(typeof posOriginalPosition.line === "number");
        pos.line = posOriginalPosition.line;
        (0, _invariant.default)(typeof posOriginalPosition.column === "number");
        pos.column = posOriginalPosition.column;
      }

      posInfo.rewritten = true;
    }

    function fixupLocation(loc) {
      if (loc == null) return; // Bail out when location already got fixed up or doesn't have source

      if (loc.source === undefined || loc.source !== source) return;
      let locStart = loc.start;
      let locEnd = loc.end;
      let startInfo = getPositionInfo(locStart);
      let endInfo = getPositionInfo(locEnd);
      let startOriginalPosition = startInfo.originalPosition;
      let endOriginalPosition = endInfo.originalPosition; // Sanity checks on the positions supplied directly by the Babel parser

      (0, _invariant.default)(startInfo.newLine <= endInfo.newLine);
      (0, _invariant.default)(startInfo.newLine !== endInfo.newLine || startInfo.newColumn <= endInfo.newColumn);
      let originalSource = startOriginalPosition.source || endOriginalPosition.source;

      if (originalSource) {
        fixupPosition(locStart, startInfo, endInfo);
        fixupPosition(locEnd, endInfo, startInfo); // NOTE: Babel only persists the start position of most nodes in source maps
        // (only block statements also get their end positions persisted).
        // Thus, end positions tend to be mostly wrong (in fact often so wrong
        // that they point before the start position).
        // The best way to deal with that is to never print end positions in user-facing
        // messages, or use them for any reason.

        (0, _invariant.default)(loc.source !== originalSource);
        loc.source = originalSource;
      }
    }

    function fixupComments(comments) {
      if (!comments) return;

      for (let c of comments) fixupLocation(c.loc);
    }
  }

  fixupFilenames(ast) {
    (0, _traverseFast.default)(ast, node => {
      let loc = node.loc;
      if (loc && loc.source) loc.filename = loc.source;else node.loc = null;
      fixupComments(node.leadingComments);
      fixupComments(node.innerComments);
      fixupComments(node.trailingComments);
      return false;
    });

    function fixupComments(comments) {
      if (!comments) return;

      for (let c of comments) {
        let loc = c.loc;
        if (loc && loc.source) loc.filename = loc.source;else c.loc = null;
      }
    }
  }

  evaluate(ast, strictCode, metadata) {
    if (this.realm.debuggerInstance) {
      this.realm.debuggerInstance.checkForActions(ast);
    }

    if (this.realm.debugReproManager) {
      if (ast.loc !== undefined && ast.loc !== null && ast.loc.source) {
        this.realm.debugReproManager.addSourceFile(ast.loc.source);
      }
    }

    let res = this.evaluateAbstract(ast, strictCode, metadata);
    (0, _invariant.default)(res instanceof _index.Value || res instanceof Reference, ast.type);
    return res;
  }

  evaluateAbstract(ast, strictCode, metadata) {
    this.realm.currentLocation = ast.loc;
    this.realm.testTimeout();
    let evaluator = this.realm.evaluators[ast.type];

    if (evaluator) {
      this.realm.statistics.evaluatedNodes++;
      let result = evaluator(ast, strictCode, this, this.realm, metadata);
      return result;
    }

    throw new TypeError(`Unsupported node type ${ast.type}`);
  }

  evaluateDeref(ast, strictCode, metadata) {
    let result = this.evaluate(ast, strictCode, metadata);
    if (result instanceof Reference) result = _singletons.Environment.GetValue(this.realm, result);
    return result;
  }

} // ECMA262 6.2.3
// A Reference is a resolved name or property binding. A Reference consists of three components, the base value,
// the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object,
// a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value of undefined indicates that the
// Reference could not be resolved to a binding. The referenced name is a String or Symbol value.


exports.LexicalEnvironment = LexicalEnvironment;

function isValidBaseValue(val) {
  return val instanceof _index.AbstractValue || val instanceof _index.ObjectValue || mightBecomeAnObject(val);
}

function mightBecomeAnObject(base) {
  let type = base.getType(); // The top Value type might be able to become an object. We let it
  // pass and error later if it can't.

  return type === _index.Value || type === _PrimitiveValue.default || type === _index.BooleanValue || type === _index.StringValue || type === _index.SymbolValue || type === _index.NumberValue || type === _index.IntegralValue;
}

class Reference {
  constructor(base, refName, strict, thisValue) {
    (0, _invariant.default)(base instanceof _index.AbstractObjectValue || base === undefined || base instanceof _index.ObjectValue || base instanceof EnvironmentRecord || mightBecomeAnObject(base));
    this.base = base;
    this.referencedName = refName;
    (0, _invariant.default)(!(refName instanceof _index.AbstractValue) || !(refName.mightNotBeString() && refName.mightNotBeNumber() && !refName.isSimpleObject()) || refName.$Realm.isInPureScope());
    this.strict = strict;
    this.thisValue = thisValue;
    (0, _invariant.default)(thisValue === undefined || !(base instanceof EnvironmentRecord));
  }

}

exports.Reference = Reference;
//# sourceMappingURL=environment.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  react: true,
  assertNode: true,
  createTypeAnnotationBasedOnTypeof: true,
  createUnionTypeAnnotation: true,
  cloneNode: true,
  clone: true,
  cloneDeep: true,
  cloneWithoutLoc: true,
  addComment: true,
  addComments: true,
  inheritInnerComments: true,
  inheritLeadingComments: true,
  inheritsComments: true,
  inheritTrailingComments: true,
  removeComments: true,
  ensureBlock: true,
  toBindingIdentifierName: true,
  toBlock: true,
  toComputedKey: true,
  toExpression: true,
  toIdentifier: true,
  toKeyAlias: true,
  toSequenceExpression: true,
  toStatement: true,
  valueToNode: true,
  appendToMemberExpression: true,
  inherits: true,
  prependToMemberExpression: true,
  removeProperties: true,
  removePropertiesDeep: true,
  removeTypeDuplicates: true,
  getBindingIdentifiers: true,
  getOuterBindingIdentifiers: true,
  traverse: true,
  traverseFast: true,
  shallowEqual: true,
  is: true,
  isBinding: true,
  isBlockScoped: true,
  isImmutable: true,
  isLet: true,
  isNode: true,
  isNodesEquivalent: true,
  isReferenced: true,
  isScope: true,
  isSpecifierDefault: true,
  isType: true,
  isValidES3Identifier: true,
  isValidIdentifier: true,
  isVar: true,
  matchesPattern: true,
  validate: true,
  buildMatchMemberExpression: true
};
Object.defineProperty(exports, "assertNode", {
  enumerable: true,
  get: function () {
    return _assertNode.default;
  }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function () {
    return _createTypeAnnotationBasedOnTypeof.default;
  }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _createUnionTypeAnnotation.default;
  }
});
Object.defineProperty(exports, "cloneNode", {
  enumerable: true,
  get: function () {
    return _cloneNode.default;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _clone.default;
  }
});
Object.defineProperty(exports, "cloneDeep", {
  enumerable: true,
  get: function () {
    return _cloneDeep.default;
  }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
  enumerable: true,
  get: function () {
    return _cloneWithoutLoc.default;
  }
});
Object.defineProperty(exports, "addComment", {
  enumerable: true,
  get: function () {
    return _addComment.default;
  }
});
Object.defineProperty(exports, "addComments", {
  enumerable: true,
  get: function () {
    return _addComments.default;
  }
});
Object.defineProperty(exports, "inheritInnerComments", {
  enumerable: true,
  get: function () {
    return _inheritInnerComments.default;
  }
});
Object.defineProperty(exports, "inheritLeadingComments", {
  enumerable: true,
  get: function () {
    return _inheritLeadingComments.default;
  }
});
Object.defineProperty(exports, "inheritsComments", {
  enumerable: true,
  get: function () {
    return _inheritsComments.default;
  }
});
Object.defineProperty(exports, "inheritTrailingComments", {
  enumerable: true,
  get: function () {
    return _inheritTrailingComments.default;
  }
});
Object.defineProperty(exports, "removeComments", {
  enumerable: true,
  get: function () {
    return _removeComments.default;
  }
});
Object.defineProperty(exports, "ensureBlock", {
  enumerable: true,
  get: function () {
    return _ensureBlock.default;
  }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function () {
    return _toBindingIdentifierName.default;
  }
});
Object.defineProperty(exports, "toBlock", {
  enumerable: true,
  get: function () {
    return _toBlock.default;
  }
});
Object.defineProperty(exports, "toComputedKey", {
  enumerable: true,
  get: function () {
    return _toComputedKey.default;
  }
});
Object.defineProperty(exports, "toExpression", {
  enumerable: true,
  get: function () {
    return _toExpression.default;
  }
});
Object.defineProperty(exports, "toIdentifier", {
  enumerable: true,
  get: function () {
    return _toIdentifier.default;
  }
});
Object.defineProperty(exports, "toKeyAlias", {
  enumerable: true,
  get: function () {
    return _toKeyAlias.default;
  }
});
Object.defineProperty(exports, "toSequenceExpression", {
  enumerable: true,
  get: function () {
    return _toSequenceExpression.default;
  }
});
Object.defineProperty(exports, "toStatement", {
  enumerable: true,
  get: function () {
    return _toStatement.default;
  }
});
Object.defineProperty(exports, "valueToNode", {
  enumerable: true,
  get: function () {
    return _valueToNode.default;
  }
});
Object.defineProperty(exports, "appendToMemberExpression", {
  enumerable: true,
  get: function () {
    return _appendToMemberExpression.default;
  }
});
Object.defineProperty(exports, "inherits", {
  enumerable: true,
  get: function () {
    return _inherits.default;
  }
});
Object.defineProperty(exports, "prependToMemberExpression", {
  enumerable: true,
  get: function () {
    return _prependToMemberExpression.default;
  }
});
Object.defineProperty(exports, "removeProperties", {
  enumerable: true,
  get: function () {
    return _removeProperties.default;
  }
});
Object.defineProperty(exports, "removePropertiesDeep", {
  enumerable: true,
  get: function () {
    return _removePropertiesDeep.default;
  }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function () {
    return _removeTypeDuplicates.default;
  }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getOuterBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function () {
    return _traverse.default;
  }
});
Object.defineProperty(exports, "traverseFast", {
  enumerable: true,
  get: function () {
    return _traverseFast.default;
  }
});
Object.defineProperty(exports, "shallowEqual", {
  enumerable: true,
  get: function () {
    return _shallowEqual.default;
  }
});
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function () {
    return _is.default;
  }
});
Object.defineProperty(exports, "isBinding", {
  enumerable: true,
  get: function () {
    return _isBinding.default;
  }
});
Object.defineProperty(exports, "isBlockScoped", {
  enumerable: true,
  get: function () {
    return _isBlockScoped.default;
  }
});
Object.defineProperty(exports, "isImmutable", {
  enumerable: true,
  get: function () {
    return _isImmutable.default;
  }
});
Object.defineProperty(exports, "isLet", {
  enumerable: true,
  get: function () {
    return _isLet.default;
  }
});
Object.defineProperty(exports, "isNode", {
  enumerable: true,
  get: function () {
    return _isNode.default;
  }
});
Object.defineProperty(exports, "isNodesEquivalent", {
  enumerable: true,
  get: function () {
    return _isNodesEquivalent.default;
  }
});
Object.defineProperty(exports, "isReferenced", {
  enumerable: true,
  get: function () {
    return _isReferenced.default;
  }
});
Object.defineProperty(exports, "isScope", {
  enumerable: true,
  get: function () {
    return _isScope.default;
  }
});
Object.defineProperty(exports, "isSpecifierDefault", {
  enumerable: true,
  get: function () {
    return _isSpecifierDefault.default;
  }
});
Object.defineProperty(exports, "isType", {
  enumerable: true,
  get: function () {
    return _isType.default;
  }
});
Object.defineProperty(exports, "isValidES3Identifier", {
  enumerable: true,
  get: function () {
    return _isValidES3Identifier.default;
  }
});
Object.defineProperty(exports, "isValidIdentifier", {
  enumerable: true,
  get: function () {
    return _isValidIdentifier.default;
  }
});
Object.defineProperty(exports, "isVar", {
  enumerable: true,
  get: function () {
    return _isVar.default;
  }
});
Object.defineProperty(exports, "matchesPattern", {
  enumerable: true,
  get: function () {
    return _matchesPattern.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
  enumerable: true,
  get: function () {
    return _buildMatchMemberExpression.default;
  }
});
exports.react = void 0;

var _isReactComponent = _interopRequireDefault(__webpack_require__(22));

var _isCompatTag = _interopRequireDefault(__webpack_require__(27));

var _buildChildren = _interopRequireDefault(__webpack_require__(28));

var _assertNode = _interopRequireDefault(__webpack_require__(160));

var _generated = __webpack_require__(162);

Object.keys(_generated).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated[key];
    }
  });
});

var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(__webpack_require__(163));

var _createUnionTypeAnnotation = _interopRequireDefault(__webpack_require__(164));

var _generated2 = __webpack_require__(30);

Object.keys(_generated2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated2[key];
    }
  });
});

var _cloneNode = _interopRequireDefault(__webpack_require__(166));

var _clone = _interopRequireDefault(__webpack_require__(167));

var _cloneDeep = _interopRequireDefault(__webpack_require__(168));

var _cloneWithoutLoc = _interopRequireDefault(__webpack_require__(169));

var _addComment = _interopRequireDefault(__webpack_require__(170));

var _addComments = _interopRequireDefault(__webpack_require__(171));

var _inheritInnerComments = _interopRequireDefault(__webpack_require__(172));

var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(189));

var _inheritsComments = _interopRequireDefault(__webpack_require__(190));

var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(191));

var _removeComments = _interopRequireDefault(__webpack_require__(192));

var _generated3 = __webpack_require__(193);

Object.keys(_generated3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated3[key];
    }
  });
});

var _constants = __webpack_require__(149);

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constants[key];
    }
  });
});

var _ensureBlock = _interopRequireDefault(__webpack_require__(194));

var _toBindingIdentifierName = _interopRequireDefault(__webpack_require__(196));

var _toBlock = _interopRequireDefault(__webpack_require__(195));

var _toComputedKey = _interopRequireDefault(__webpack_require__(198));

var _toExpression = _interopRequireDefault(__webpack_require__(199));

var _toIdentifier = _interopRequireDefault(__webpack_require__(197));

var _toKeyAlias = _interopRequireDefault(__webpack_require__(200));

var _toSequenceExpression = _interopRequireDefault(__webpack_require__(204));

var _toStatement = _interopRequireDefault(__webpack_require__(207));

var _valueToNode = _interopRequireDefault(__webpack_require__(208));

var _definitions = __webpack_require__(141);

Object.keys(_definitions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _definitions[key];
    }
  });
});

var _appendToMemberExpression = _interopRequireDefault(__webpack_require__(212));

var _inherits = _interopRequireDefault(__webpack_require__(213));

var _prependToMemberExpression = _interopRequireDefault(__webpack_require__(214));

var _removeProperties = _interopRequireDefault(__webpack_require__(203));

var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(201));

var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(165));

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(206));

var _getOuterBindingIdentifiers = _interopRequireDefault(__webpack_require__(215));

var _traverse = _interopRequireDefault(__webpack_require__(216));

var _traverseFast = _interopRequireDefault(__webpack_require__(202));

var _shallowEqual = _interopRequireDefault(__webpack_require__(26));

var _is = _interopRequireDefault(__webpack_require__(151));

var _isBinding = _interopRequireDefault(__webpack_require__(217));

var _isBlockScoped = _interopRequireDefault(__webpack_require__(218));

var _isImmutable = _interopRequireDefault(__webpack_require__(220));

var _isLet = _interopRequireDefault(__webpack_require__(219));

var _isNode = _interopRequireDefault(__webpack_require__(161));

var _isNodesEquivalent = _interopRequireDefault(__webpack_require__(221));

var _isReferenced = _interopRequireDefault(__webpack_require__(222));

var _isScope = _interopRequireDefault(__webpack_require__(223));

var _isSpecifierDefault = _interopRequireDefault(__webpack_require__(224));

var _isType = _interopRequireDefault(__webpack_require__(152));

var _isValidES3Identifier = _interopRequireDefault(__webpack_require__(225));

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(144));

var _isVar = _interopRequireDefault(__webpack_require__(226));

var _matchesPattern = _interopRequireDefault(__webpack_require__(24));

var _validate = _interopRequireDefault(__webpack_require__(159));

var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(23));

var _generated4 = __webpack_require__(25);

Object.keys(_generated4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated4[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const react = {
  isReactComponent: _isReactComponent.default,
  isCompatTag: _isCompatTag.default,
  buildChildren: _buildChildren.default
};
exports.react = react;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(23));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildMatchMemberExpression;

var _matchesPattern = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildMatchMemberExpression(match, allowPartial) {
  const parts = match.split(".");
  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matchesPattern;

var _generated = __webpack_require__(25);

function matchesPattern(member, match, allowPartial) {
  if (!(0, _generated.isMemberExpression)(member)) return false;
  const parts = Array.isArray(match) ? match : match.split(".");
  const nodes = [];
  let node;

  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
    nodes.push(node.property);
  }

  nodes.push(node);
  if (nodes.length < parts.length) return false;
  if (!allowPartial && nodes.length > parts.length) return false;

  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    const node = nodes[j];
    let value;

    if ((0, _generated.isIdentifier)(node)) {
      value = node.name;
    } else if ((0, _generated.isStringLiteral)(node)) {
      value = node.value;
    } else {
      return false;
    }

    if (parts[i] !== value) return false;
  }

  return true;
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayExpression = isArrayExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isBinaryExpression = isBinaryExpression;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isBlockStatement = isBlockStatement;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isExpressionStatement = isExpressionStatement;
exports.isFile = isFile;
exports.isForInStatement = isForInStatement;
exports.isForStatement = isForStatement;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isLabeledStatement = isLabeledStatement;
exports.isStringLiteral = isStringLiteral;
exports.isNumericLiteral = isNumericLiteral;
exports.isNullLiteral = isNullLiteral;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isMemberExpression = isMemberExpression;
exports.isNewExpression = isNewExpression;
exports.isProgram = isProgram;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMethod = isObjectMethod;
exports.isObjectProperty = isObjectProperty;
exports.isRestElement = isRestElement;
exports.isReturnStatement = isReturnStatement;
exports.isSequenceExpression = isSequenceExpression;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isThisExpression = isThisExpression;
exports.isThrowStatement = isThrowStatement;
exports.isTryStatement = isTryStatement;
exports.isUnaryExpression = isUnaryExpression;
exports.isUpdateExpression = isUpdateExpression;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isArrayPattern = isArrayPattern;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportSpecifier = isExportSpecifier;
exports.isForOfStatement = isForOfStatement;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isMetaProperty = isMetaProperty;
exports.isClassMethod = isClassMethod;
exports.isObjectPattern = isObjectPattern;
exports.isSpreadElement = isSpreadElement;
exports.isSuper = isSuper;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isYieldExpression = isYieldExpression;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isClassImplements = isClassImplements;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXText = isJSXText;
exports.isJSXFragment = isJSXFragment;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isNoop = isNoop;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isAwaitExpression = isAwaitExpression;
exports.isBindExpression = isBindExpression;
exports.isClassProperty = isClassProperty;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isImport = isImport;
exports.isDecorator = isDecorator;
exports.isDoExpression = isDoExpression;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isPrivateName = isPrivateName;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSArrayType = isTSArrayType;
exports.isTSTupleType = isTSTupleType;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSRestType = isTSRestType;
exports.isTSUnionType = isTSUnionType;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSInferType = isTSInferType;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSMappedType = isTSMappedType;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSImportType = isTSImportType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isExpression = isExpression;
exports.isBinary = isBinary;
exports.isScopable = isScopable;
exports.isBlockParent = isBlockParent;
exports.isBlock = isBlock;
exports.isStatement = isStatement;
exports.isTerminatorless = isTerminatorless;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isLoop = isLoop;
exports.isWhile = isWhile;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFor = isFor;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionParent = isFunctionParent;
exports.isPureish = isPureish;
exports.isDeclaration = isDeclaration;
exports.isPatternLike = isPatternLike;
exports.isLVal = isLVal;
exports.isTSEntityName = isTSEntityName;
exports.isLiteral = isLiteral;
exports.isImmutable = isImmutable;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isMethod = isMethod;
exports.isObjectMember = isObjectMember;
exports.isProperty = isProperty;
exports.isUnaryLike = isUnaryLike;
exports.isPattern = isPattern;
exports.isClass = isClass;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isFlow = isFlow;
exports.isFlowType = isFlowType;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isJSX = isJSX;
exports.isPrivate = isPrivate;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSType = isTSType;
exports.isNumberLiteral = isNumberLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestProperty = isRestProperty;
exports.isSpreadProperty = isSpreadProperty;

var _shallowEqual = _interopRequireDefault(__webpack_require__(26));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isArrayExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterpreterDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBreakStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCatchClause(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditionalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isContinueStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDebuggerStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForInStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLabeledStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumericLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegExpLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLogicalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNewExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProgram(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isReturnStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSequenceExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchCase(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThrowStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTryStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUpdateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclarator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWithStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForOfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMetaProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSuper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isYieldExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassImplements(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareInterface(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModule(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareVariable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInferredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceExtends(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeCastExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariance(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXText(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAwaitExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBindExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineTopicExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineBareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelinePrimaryTopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImport(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDecorator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivateName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBigIntLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParameterProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSQualifiedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSPropertySignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMethodSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSStringKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNullKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSThisType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSFunctionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructorType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypePredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeQuery(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSArrayType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTupleType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSOptionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSRestType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSRestType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIntersectionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConditionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInferType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeOperator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMappedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSLiteralType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAsExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExportAssignment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "ParenthesizedExpression" === nodeType || "AwaitExpression" === nodeType || "BindExpression" === nodeType || "OptionalMemberExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "OptionalCallExpression" === nodeType || "Import" === nodeType || "DoExpression" === nodeType || "BigIntLiteral" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinary(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isScopable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTerminatorless(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCompletionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditional(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionWrapper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "TypeCastExpression" === nodeType || "ParenthesizedExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForXStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPureish(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType || "BigIntLiteral" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPatternLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLVal(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEntityName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImmutable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Immutable" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "BigIntLiteral" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUserWhitespacable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Class" || "ClassDeclaration" === nodeType || "ClassExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlow(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSX(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEqual;

function shallowEqual(actual, expected) {
  const keys = Object.keys(expected);

  for (const key of keys) {
    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCompatTag;

function isCompatTag(tagName) {
  return !!tagName && /^[a-z]/.test(tagName);
}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildChildren;

var _generated = __webpack_require__(25);

var _cleanJSXElementLiteralChild = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildChildren(node) {
  const elements = [];

  for (let i = 0; i < node.children.length; i++) {
    let child = node.children[i];

    if ((0, _generated.isJSXText)(child)) {
      (0, _cleanJSXElementLiteralChild.default)(child, elements);
      continue;
    }

    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
    if ((0, _generated.isJSXEmptyExpression)(child)) continue;
    elements.push(child);
  }

  return elements;
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanJSXElementLiteralChild;

var _generated = __webpack_require__(30);

function cleanJSXElementLiteralChild(child, args) {
  const lines = child.value.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  let str = "";

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    let trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push((0, _generated.stringLiteral)(str));
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayExpression = exports.ArrayExpression = ArrayExpression;
exports.assignmentExpression = exports.AssignmentExpression = AssignmentExpression;
exports.binaryExpression = exports.BinaryExpression = BinaryExpression;
exports.interpreterDirective = exports.InterpreterDirective = InterpreterDirective;
exports.directive = exports.Directive = Directive;
exports.directiveLiteral = exports.DirectiveLiteral = DirectiveLiteral;
exports.blockStatement = exports.BlockStatement = BlockStatement;
exports.breakStatement = exports.BreakStatement = BreakStatement;
exports.callExpression = exports.CallExpression = CallExpression;
exports.catchClause = exports.CatchClause = CatchClause;
exports.conditionalExpression = exports.ConditionalExpression = ConditionalExpression;
exports.continueStatement = exports.ContinueStatement = ContinueStatement;
exports.debuggerStatement = exports.DebuggerStatement = DebuggerStatement;
exports.doWhileStatement = exports.DoWhileStatement = DoWhileStatement;
exports.emptyStatement = exports.EmptyStatement = EmptyStatement;
exports.expressionStatement = exports.ExpressionStatement = ExpressionStatement;
exports.file = exports.File = File;
exports.forInStatement = exports.ForInStatement = ForInStatement;
exports.forStatement = exports.ForStatement = ForStatement;
exports.functionDeclaration = exports.FunctionDeclaration = FunctionDeclaration;
exports.functionExpression = exports.FunctionExpression = FunctionExpression;
exports.identifier = exports.Identifier = Identifier;
exports.ifStatement = exports.IfStatement = IfStatement;
exports.labeledStatement = exports.LabeledStatement = LabeledStatement;
exports.stringLiteral = exports.StringLiteral = StringLiteral;
exports.numericLiteral = exports.NumericLiteral = NumericLiteral;
exports.nullLiteral = exports.NullLiteral = NullLiteral;
exports.booleanLiteral = exports.BooleanLiteral = BooleanLiteral;
exports.regExpLiteral = exports.RegExpLiteral = RegExpLiteral;
exports.logicalExpression = exports.LogicalExpression = LogicalExpression;
exports.memberExpression = exports.MemberExpression = MemberExpression;
exports.newExpression = exports.NewExpression = NewExpression;
exports.program = exports.Program = Program;
exports.objectExpression = exports.ObjectExpression = ObjectExpression;
exports.objectMethod = exports.ObjectMethod = ObjectMethod;
exports.objectProperty = exports.ObjectProperty = ObjectProperty;
exports.restElement = exports.RestElement = RestElement;
exports.returnStatement = exports.ReturnStatement = ReturnStatement;
exports.sequenceExpression = exports.SequenceExpression = SequenceExpression;
exports.switchCase = exports.SwitchCase = SwitchCase;
exports.switchStatement = exports.SwitchStatement = SwitchStatement;
exports.thisExpression = exports.ThisExpression = ThisExpression;
exports.throwStatement = exports.ThrowStatement = ThrowStatement;
exports.tryStatement = exports.TryStatement = TryStatement;
exports.unaryExpression = exports.UnaryExpression = UnaryExpression;
exports.updateExpression = exports.UpdateExpression = UpdateExpression;
exports.variableDeclaration = exports.VariableDeclaration = VariableDeclaration;
exports.variableDeclarator = exports.VariableDeclarator = VariableDeclarator;
exports.whileStatement = exports.WhileStatement = WhileStatement;
exports.withStatement = exports.WithStatement = WithStatement;
exports.assignmentPattern = exports.AssignmentPattern = AssignmentPattern;
exports.arrayPattern = exports.ArrayPattern = ArrayPattern;
exports.arrowFunctionExpression = exports.ArrowFunctionExpression = ArrowFunctionExpression;
exports.classBody = exports.ClassBody = ClassBody;
exports.classDeclaration = exports.ClassDeclaration = ClassDeclaration;
exports.classExpression = exports.ClassExpression = ClassExpression;
exports.exportAllDeclaration = exports.ExportAllDeclaration = ExportAllDeclaration;
exports.exportDefaultDeclaration = exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
exports.exportNamedDeclaration = exports.ExportNamedDeclaration = ExportNamedDeclaration;
exports.exportSpecifier = exports.ExportSpecifier = ExportSpecifier;
exports.forOfStatement = exports.ForOfStatement = ForOfStatement;
exports.importDeclaration = exports.ImportDeclaration = ImportDeclaration;
exports.importDefaultSpecifier = exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
exports.importNamespaceSpecifier = exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
exports.importSpecifier = exports.ImportSpecifier = ImportSpecifier;
exports.metaProperty = exports.MetaProperty = MetaProperty;
exports.classMethod = exports.ClassMethod = ClassMethod;
exports.objectPattern = exports.ObjectPattern = ObjectPattern;
exports.spreadElement = exports.SpreadElement = SpreadElement;
exports.super = exports.Super = Super;
exports.taggedTemplateExpression = exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.templateElement = exports.TemplateElement = TemplateElement;
exports.templateLiteral = exports.TemplateLiteral = TemplateLiteral;
exports.yieldExpression = exports.YieldExpression = YieldExpression;
exports.anyTypeAnnotation = exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.arrayTypeAnnotation = exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.booleanTypeAnnotation = exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.booleanLiteralTypeAnnotation = exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.nullLiteralTypeAnnotation = exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.classImplements = exports.ClassImplements = ClassImplements;
exports.declareClass = exports.DeclareClass = DeclareClass;
exports.declareFunction = exports.DeclareFunction = DeclareFunction;
exports.declareInterface = exports.DeclareInterface = DeclareInterface;
exports.declareModule = exports.DeclareModule = DeclareModule;
exports.declareModuleExports = exports.DeclareModuleExports = DeclareModuleExports;
exports.declareTypeAlias = exports.DeclareTypeAlias = DeclareTypeAlias;
exports.declareOpaqueType = exports.DeclareOpaqueType = DeclareOpaqueType;
exports.declareVariable = exports.DeclareVariable = DeclareVariable;
exports.declareExportDeclaration = exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.declareExportAllDeclaration = exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.declaredPredicate = exports.DeclaredPredicate = DeclaredPredicate;
exports.existsTypeAnnotation = exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.functionTypeAnnotation = exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.functionTypeParam = exports.FunctionTypeParam = FunctionTypeParam;
exports.genericTypeAnnotation = exports.GenericTypeAnnotation = GenericTypeAnnotation;
exports.inferredPredicate = exports.InferredPredicate = InferredPredicate;
exports.interfaceExtends = exports.InterfaceExtends = InterfaceExtends;
exports.interfaceDeclaration = exports.InterfaceDeclaration = InterfaceDeclaration;
exports.interfaceTypeAnnotation = exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.intersectionTypeAnnotation = exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.mixedTypeAnnotation = exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.emptyTypeAnnotation = exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.nullableTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.numberLiteralTypeAnnotation = exports.NumberLiteralTypeAnnotation = NumberLiteralTypeAnnotation;
exports.numberTypeAnnotation = exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.objectTypeAnnotation = exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.objectTypeInternalSlot = exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.objectTypeCallProperty = exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.objectTypeIndexer = exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.objectTypeProperty = exports.ObjectTypeProperty = ObjectTypeProperty;
exports.objectTypeSpreadProperty = exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.opaqueType = exports.OpaqueType = OpaqueType;
exports.qualifiedTypeIdentifier = exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
exports.stringLiteralTypeAnnotation = exports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;
exports.stringTypeAnnotation = exports.StringTypeAnnotation = StringTypeAnnotation;
exports.thisTypeAnnotation = exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.tupleTypeAnnotation = exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.typeofTypeAnnotation = exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.typeAlias = exports.TypeAlias = TypeAlias;
exports.typeAnnotation = exports.TypeAnnotation = TypeAnnotation;
exports.typeCastExpression = exports.TypeCastExpression = TypeCastExpression;
exports.typeParameter = exports.TypeParameter = TypeParameter;
exports.typeParameterDeclaration = exports.TypeParameterDeclaration = TypeParameterDeclaration;
exports.typeParameterInstantiation = exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.unionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.variance = exports.Variance = Variance;
exports.voidTypeAnnotation = exports.VoidTypeAnnotation = VoidTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = exports.JSXAttribute = JSXAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = exports.JSXClosingElement = JSXClosingElement;
exports.jSXElement = exports.jsxElement = exports.JSXElement = JSXElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = exports.JSXEmptyExpression = JSXEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = exports.JSXExpressionContainer = JSXExpressionContainer;
exports.jSXSpreadChild = exports.jsxSpreadChild = exports.JSXSpreadChild = JSXSpreadChild;
exports.jSXIdentifier = exports.jsxIdentifier = exports.JSXIdentifier = JSXIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = exports.JSXMemberExpression = JSXMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = exports.JSXNamespacedName = JSXNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = exports.JSXOpeningElement = JSXOpeningElement;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = exports.JSXSpreadAttribute = JSXSpreadAttribute;
exports.jSXText = exports.jsxText = exports.JSXText = JSXText;
exports.jSXFragment = exports.jsxFragment = exports.JSXFragment = JSXFragment;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = exports.JSXOpeningFragment = JSXOpeningFragment;
exports.jSXClosingFragment = exports.jsxClosingFragment = exports.JSXClosingFragment = JSXClosingFragment;
exports.noop = exports.Noop = Noop;
exports.parenthesizedExpression = exports.ParenthesizedExpression = ParenthesizedExpression;
exports.awaitExpression = exports.AwaitExpression = AwaitExpression;
exports.bindExpression = exports.BindExpression = BindExpression;
exports.classProperty = exports.ClassProperty = ClassProperty;
exports.optionalMemberExpression = exports.OptionalMemberExpression = OptionalMemberExpression;
exports.pipelineTopicExpression = exports.PipelineTopicExpression = PipelineTopicExpression;
exports.pipelineBareFunction = exports.PipelineBareFunction = PipelineBareFunction;
exports.pipelinePrimaryTopicReference = exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
exports.optionalCallExpression = exports.OptionalCallExpression = OptionalCallExpression;
exports.classPrivateProperty = exports.ClassPrivateProperty = ClassPrivateProperty;
exports.classPrivateMethod = exports.ClassPrivateMethod = ClassPrivateMethod;
exports.import = exports.Import = Import;
exports.decorator = exports.Decorator = Decorator;
exports.doExpression = exports.DoExpression = DoExpression;
exports.exportDefaultSpecifier = exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
exports.exportNamespaceSpecifier = exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
exports.privateName = exports.PrivateName = PrivateName;
exports.bigIntLiteral = exports.BigIntLiteral = BigIntLiteral;
exports.tSParameterProperty = exports.tsParameterProperty = exports.TSParameterProperty = TSParameterProperty;
exports.tSDeclareFunction = exports.tsDeclareFunction = exports.TSDeclareFunction = TSDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = exports.TSDeclareMethod = TSDeclareMethod;
exports.tSQualifiedName = exports.tsQualifiedName = exports.TSQualifiedName = TSQualifiedName;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
exports.tSPropertySignature = exports.tsPropertySignature = exports.TSPropertySignature = TSPropertySignature;
exports.tSMethodSignature = exports.tsMethodSignature = exports.TSMethodSignature = TSMethodSignature;
exports.tSIndexSignature = exports.tsIndexSignature = exports.TSIndexSignature = TSIndexSignature;
exports.tSAnyKeyword = exports.tsAnyKeyword = exports.TSAnyKeyword = TSAnyKeyword;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = exports.TSUnknownKeyword = TSUnknownKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = exports.TSNumberKeyword = TSNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = exports.TSObjectKeyword = TSObjectKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = exports.TSBooleanKeyword = TSBooleanKeyword;
exports.tSStringKeyword = exports.tsStringKeyword = exports.TSStringKeyword = TSStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = exports.TSSymbolKeyword = TSSymbolKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = exports.TSVoidKeyword = TSVoidKeyword;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = exports.TSUndefinedKeyword = TSUndefinedKeyword;
exports.tSNullKeyword = exports.tsNullKeyword = exports.TSNullKeyword = TSNullKeyword;
exports.tSNeverKeyword = exports.tsNeverKeyword = exports.TSNeverKeyword = TSNeverKeyword;
exports.tSThisType = exports.tsThisType = exports.TSThisType = TSThisType;
exports.tSFunctionType = exports.tsFunctionType = exports.TSFunctionType = TSFunctionType;
exports.tSConstructorType = exports.tsConstructorType = exports.TSConstructorType = TSConstructorType;
exports.tSTypeReference = exports.tsTypeReference = exports.TSTypeReference = TSTypeReference;
exports.tSTypePredicate = exports.tsTypePredicate = exports.TSTypePredicate = TSTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = exports.TSTypeQuery = TSTypeQuery;
exports.tSTypeLiteral = exports.tsTypeLiteral = exports.TSTypeLiteral = TSTypeLiteral;
exports.tSArrayType = exports.tsArrayType = exports.TSArrayType = TSArrayType;
exports.tSTupleType = exports.tsTupleType = exports.TSTupleType = TSTupleType;
exports.tSOptionalType = exports.tsOptionalType = exports.TSOptionalType = TSOptionalType;
exports.tSRestType = exports.tsRestType = exports.TSRestType = TSRestType;
exports.tSUnionType = exports.tsUnionType = exports.TSUnionType = TSUnionType;
exports.tSIntersectionType = exports.tsIntersectionType = exports.TSIntersectionType = TSIntersectionType;
exports.tSConditionalType = exports.tsConditionalType = exports.TSConditionalType = TSConditionalType;
exports.tSInferType = exports.tsInferType = exports.TSInferType = TSInferType;
exports.tSParenthesizedType = exports.tsParenthesizedType = exports.TSParenthesizedType = TSParenthesizedType;
exports.tSTypeOperator = exports.tsTypeOperator = exports.TSTypeOperator = TSTypeOperator;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = exports.TSIndexedAccessType = TSIndexedAccessType;
exports.tSMappedType = exports.tsMappedType = exports.TSMappedType = TSMappedType;
exports.tSLiteralType = exports.tsLiteralType = exports.TSLiteralType = TSLiteralType;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
exports.tSInterfaceBody = exports.tsInterfaceBody = exports.TSInterfaceBody = TSInterfaceBody;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
exports.tSAsExpression = exports.tsAsExpression = exports.TSAsExpression = TSAsExpression;
exports.tSTypeAssertion = exports.tsTypeAssertion = exports.TSTypeAssertion = TSTypeAssertion;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = exports.TSEnumDeclaration = TSEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = exports.TSEnumMember = TSEnumMember;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = exports.TSModuleDeclaration = TSModuleDeclaration;
exports.tSModuleBlock = exports.tsModuleBlock = exports.TSModuleBlock = TSModuleBlock;
exports.tSImportType = exports.tsImportType = exports.TSImportType = TSImportType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = exports.TSExternalModuleReference = TSExternalModuleReference;
exports.tSNonNullExpression = exports.tsNonNullExpression = exports.TSNonNullExpression = TSNonNullExpression;
exports.tSExportAssignment = exports.tsExportAssignment = exports.TSExportAssignment = TSExportAssignment;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = exports.TSTypeAnnotation = TSTypeAnnotation;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = exports.TSTypeParameterDeclaration = TSTypeParameterDeclaration;
exports.tSTypeParameter = exports.tsTypeParameter = exports.TSTypeParameter = TSTypeParameter;
exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
exports.restProperty = exports.RestProperty = RestProperty;
exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

var _builder = _interopRequireDefault(__webpack_require__(31));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ArrayExpression(...args) {
  return (0, _builder.default)("ArrayExpression", ...args);
}

function AssignmentExpression(...args) {
  return (0, _builder.default)("AssignmentExpression", ...args);
}

function BinaryExpression(...args) {
  return (0, _builder.default)("BinaryExpression", ...args);
}

function InterpreterDirective(...args) {
  return (0, _builder.default)("InterpreterDirective", ...args);
}

function Directive(...args) {
  return (0, _builder.default)("Directive", ...args);
}

function DirectiveLiteral(...args) {
  return (0, _builder.default)("DirectiveLiteral", ...args);
}

function BlockStatement(...args) {
  return (0, _builder.default)("BlockStatement", ...args);
}

function BreakStatement(...args) {
  return (0, _builder.default)("BreakStatement", ...args);
}

function CallExpression(...args) {
  return (0, _builder.default)("CallExpression", ...args);
}

function CatchClause(...args) {
  return (0, _builder.default)("CatchClause", ...args);
}

function ConditionalExpression(...args) {
  return (0, _builder.default)("ConditionalExpression", ...args);
}

function ContinueStatement(...args) {
  return (0, _builder.default)("ContinueStatement", ...args);
}

function DebuggerStatement(...args) {
  return (0, _builder.default)("DebuggerStatement", ...args);
}

function DoWhileStatement(...args) {
  return (0, _builder.default)("DoWhileStatement", ...args);
}

function EmptyStatement(...args) {
  return (0, _builder.default)("EmptyStatement", ...args);
}

function ExpressionStatement(...args) {
  return (0, _builder.default)("ExpressionStatement", ...args);
}

function File(...args) {
  return (0, _builder.default)("File", ...args);
}

function ForInStatement(...args) {
  return (0, _builder.default)("ForInStatement", ...args);
}

function ForStatement(...args) {
  return (0, _builder.default)("ForStatement", ...args);
}

function FunctionDeclaration(...args) {
  return (0, _builder.default)("FunctionDeclaration", ...args);
}

function FunctionExpression(...args) {
  return (0, _builder.default)("FunctionExpression", ...args);
}

function Identifier(...args) {
  return (0, _builder.default)("Identifier", ...args);
}

function IfStatement(...args) {
  return (0, _builder.default)("IfStatement", ...args);
}

function LabeledStatement(...args) {
  return (0, _builder.default)("LabeledStatement", ...args);
}

function StringLiteral(...args) {
  return (0, _builder.default)("StringLiteral", ...args);
}

function NumericLiteral(...args) {
  return (0, _builder.default)("NumericLiteral", ...args);
}

function NullLiteral(...args) {
  return (0, _builder.default)("NullLiteral", ...args);
}

function BooleanLiteral(...args) {
  return (0, _builder.default)("BooleanLiteral", ...args);
}

function RegExpLiteral(...args) {
  return (0, _builder.default)("RegExpLiteral", ...args);
}

function LogicalExpression(...args) {
  return (0, _builder.default)("LogicalExpression", ...args);
}

function MemberExpression(...args) {
  return (0, _builder.default)("MemberExpression", ...args);
}

function NewExpression(...args) {
  return (0, _builder.default)("NewExpression", ...args);
}

function Program(...args) {
  return (0, _builder.default)("Program", ...args);
}

function ObjectExpression(...args) {
  return (0, _builder.default)("ObjectExpression", ...args);
}

function ObjectMethod(...args) {
  return (0, _builder.default)("ObjectMethod", ...args);
}

function ObjectProperty(...args) {
  return (0, _builder.default)("ObjectProperty", ...args);
}

function RestElement(...args) {
  return (0, _builder.default)("RestElement", ...args);
}

function ReturnStatement(...args) {
  return (0, _builder.default)("ReturnStatement", ...args);
}

function SequenceExpression(...args) {
  return (0, _builder.default)("SequenceExpression", ...args);
}

function SwitchCase(...args) {
  return (0, _builder.default)("SwitchCase", ...args);
}

function SwitchStatement(...args) {
  return (0, _builder.default)("SwitchStatement", ...args);
}

function ThisExpression(...args) {
  return (0, _builder.default)("ThisExpression", ...args);
}

function ThrowStatement(...args) {
  return (0, _builder.default)("ThrowStatement", ...args);
}

function TryStatement(...args) {
  return (0, _builder.default)("TryStatement", ...args);
}

function UnaryExpression(...args) {
  return (0, _builder.default)("UnaryExpression", ...args);
}

function UpdateExpression(...args) {
  return (0, _builder.default)("UpdateExpression", ...args);
}

function VariableDeclaration(...args) {
  return (0, _builder.default)("VariableDeclaration", ...args);
}

function VariableDeclarator(...args) {
  return (0, _builder.default)("VariableDeclarator", ...args);
}

function WhileStatement(...args) {
  return (0, _builder.default)("WhileStatement", ...args);
}

function WithStatement(...args) {
  return (0, _builder.default)("WithStatement", ...args);
}

function AssignmentPattern(...args) {
  return (0, _builder.default)("AssignmentPattern", ...args);
}

function ArrayPattern(...args) {
  return (0, _builder.default)("ArrayPattern", ...args);
}

function ArrowFunctionExpression(...args) {
  return (0, _builder.default)("ArrowFunctionExpression", ...args);
}

function ClassBody(...args) {
  return (0, _builder.default)("ClassBody", ...args);
}

function ClassDeclaration(...args) {
  return (0, _builder.default)("ClassDeclaration", ...args);
}

function ClassExpression(...args) {
  return (0, _builder.default)("ClassExpression", ...args);
}

function ExportAllDeclaration(...args) {
  return (0, _builder.default)("ExportAllDeclaration", ...args);
}

function ExportDefaultDeclaration(...args) {
  return (0, _builder.default)("ExportDefaultDeclaration", ...args);
}

function ExportNamedDeclaration(...args) {
  return (0, _builder.default)("ExportNamedDeclaration", ...args);
}

function ExportSpecifier(...args) {
  return (0, _builder.default)("ExportSpecifier", ...args);
}

function ForOfStatement(...args) {
  return (0, _builder.default)("ForOfStatement", ...args);
}

function ImportDeclaration(...args) {
  return (0, _builder.default)("ImportDeclaration", ...args);
}

function ImportDefaultSpecifier(...args) {
  return (0, _builder.default)("ImportDefaultSpecifier", ...args);
}

function ImportNamespaceSpecifier(...args) {
  return (0, _builder.default)("ImportNamespaceSpecifier", ...args);
}

function ImportSpecifier(...args) {
  return (0, _builder.default)("ImportSpecifier", ...args);
}

function MetaProperty(...args) {
  return (0, _builder.default)("MetaProperty", ...args);
}

function ClassMethod(...args) {
  return (0, _builder.default)("ClassMethod", ...args);
}

function ObjectPattern(...args) {
  return (0, _builder.default)("ObjectPattern", ...args);
}

function SpreadElement(...args) {
  return (0, _builder.default)("SpreadElement", ...args);
}

function Super(...args) {
  return (0, _builder.default)("Super", ...args);
}

function TaggedTemplateExpression(...args) {
  return (0, _builder.default)("TaggedTemplateExpression", ...args);
}

function TemplateElement(...args) {
  return (0, _builder.default)("TemplateElement", ...args);
}

function TemplateLiteral(...args) {
  return (0, _builder.default)("TemplateLiteral", ...args);
}

function YieldExpression(...args) {
  return (0, _builder.default)("YieldExpression", ...args);
}

function AnyTypeAnnotation(...args) {
  return (0, _builder.default)("AnyTypeAnnotation", ...args);
}

function ArrayTypeAnnotation(...args) {
  return (0, _builder.default)("ArrayTypeAnnotation", ...args);
}

function BooleanTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanTypeAnnotation", ...args);
}

function BooleanLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...args);
}

function NullLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NullLiteralTypeAnnotation", ...args);
}

function ClassImplements(...args) {
  return (0, _builder.default)("ClassImplements", ...args);
}

function DeclareClass(...args) {
  return (0, _builder.default)("DeclareClass", ...args);
}

function DeclareFunction(...args) {
  return (0, _builder.default)("DeclareFunction", ...args);
}

function DeclareInterface(...args) {
  return (0, _builder.default)("DeclareInterface", ...args);
}

function DeclareModule(...args) {
  return (0, _builder.default)("DeclareModule", ...args);
}

function DeclareModuleExports(...args) {
  return (0, _builder.default)("DeclareModuleExports", ...args);
}

function DeclareTypeAlias(...args) {
  return (0, _builder.default)("DeclareTypeAlias", ...args);
}

function DeclareOpaqueType(...args) {
  return (0, _builder.default)("DeclareOpaqueType", ...args);
}

function DeclareVariable(...args) {
  return (0, _builder.default)("DeclareVariable", ...args);
}

function DeclareExportDeclaration(...args) {
  return (0, _builder.default)("DeclareExportDeclaration", ...args);
}

function DeclareExportAllDeclaration(...args) {
  return (0, _builder.default)("DeclareExportAllDeclaration", ...args);
}

function DeclaredPredicate(...args) {
  return (0, _builder.default)("DeclaredPredicate", ...args);
}

function ExistsTypeAnnotation(...args) {
  return (0, _builder.default)("ExistsTypeAnnotation", ...args);
}

function FunctionTypeAnnotation(...args) {
  return (0, _builder.default)("FunctionTypeAnnotation", ...args);
}

function FunctionTypeParam(...args) {
  return (0, _builder.default)("FunctionTypeParam", ...args);
}

function GenericTypeAnnotation(...args) {
  return (0, _builder.default)("GenericTypeAnnotation", ...args);
}

function InferredPredicate(...args) {
  return (0, _builder.default)("InferredPredicate", ...args);
}

function InterfaceExtends(...args) {
  return (0, _builder.default)("InterfaceExtends", ...args);
}

function InterfaceDeclaration(...args) {
  return (0, _builder.default)("InterfaceDeclaration", ...args);
}

function InterfaceTypeAnnotation(...args) {
  return (0, _builder.default)("InterfaceTypeAnnotation", ...args);
}

function IntersectionTypeAnnotation(...args) {
  return (0, _builder.default)("IntersectionTypeAnnotation", ...args);
}

function MixedTypeAnnotation(...args) {
  return (0, _builder.default)("MixedTypeAnnotation", ...args);
}

function EmptyTypeAnnotation(...args) {
  return (0, _builder.default)("EmptyTypeAnnotation", ...args);
}

function NullableTypeAnnotation(...args) {
  return (0, _builder.default)("NullableTypeAnnotation", ...args);
}

function NumberLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NumberLiteralTypeAnnotation", ...args);
}

function NumberTypeAnnotation(...args) {
  return (0, _builder.default)("NumberTypeAnnotation", ...args);
}

function ObjectTypeAnnotation(...args) {
  return (0, _builder.default)("ObjectTypeAnnotation", ...args);
}

function ObjectTypeInternalSlot(...args) {
  return (0, _builder.default)("ObjectTypeInternalSlot", ...args);
}

function ObjectTypeCallProperty(...args) {
  return (0, _builder.default)("ObjectTypeCallProperty", ...args);
}

function ObjectTypeIndexer(...args) {
  return (0, _builder.default)("ObjectTypeIndexer", ...args);
}

function ObjectTypeProperty(...args) {
  return (0, _builder.default)("ObjectTypeProperty", ...args);
}

function ObjectTypeSpreadProperty(...args) {
  return (0, _builder.default)("ObjectTypeSpreadProperty", ...args);
}

function OpaqueType(...args) {
  return (0, _builder.default)("OpaqueType", ...args);
}

function QualifiedTypeIdentifier(...args) {
  return (0, _builder.default)("QualifiedTypeIdentifier", ...args);
}

function StringLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("StringLiteralTypeAnnotation", ...args);
}

function StringTypeAnnotation(...args) {
  return (0, _builder.default)("StringTypeAnnotation", ...args);
}

function ThisTypeAnnotation(...args) {
  return (0, _builder.default)("ThisTypeAnnotation", ...args);
}

function TupleTypeAnnotation(...args) {
  return (0, _builder.default)("TupleTypeAnnotation", ...args);
}

function TypeofTypeAnnotation(...args) {
  return (0, _builder.default)("TypeofTypeAnnotation", ...args);
}

function TypeAlias(...args) {
  return (0, _builder.default)("TypeAlias", ...args);
}

function TypeAnnotation(...args) {
  return (0, _builder.default)("TypeAnnotation", ...args);
}

function TypeCastExpression(...args) {
  return (0, _builder.default)("TypeCastExpression", ...args);
}

function TypeParameter(...args) {
  return (0, _builder.default)("TypeParameter", ...args);
}

function TypeParameterDeclaration(...args) {
  return (0, _builder.default)("TypeParameterDeclaration", ...args);
}

function TypeParameterInstantiation(...args) {
  return (0, _builder.default)("TypeParameterInstantiation", ...args);
}

function UnionTypeAnnotation(...args) {
  return (0, _builder.default)("UnionTypeAnnotation", ...args);
}

function Variance(...args) {
  return (0, _builder.default)("Variance", ...args);
}

function VoidTypeAnnotation(...args) {
  return (0, _builder.default)("VoidTypeAnnotation", ...args);
}

function JSXAttribute(...args) {
  return (0, _builder.default)("JSXAttribute", ...args);
}

function JSXClosingElement(...args) {
  return (0, _builder.default)("JSXClosingElement", ...args);
}

function JSXElement(...args) {
  return (0, _builder.default)("JSXElement", ...args);
}

function JSXEmptyExpression(...args) {
  return (0, _builder.default)("JSXEmptyExpression", ...args);
}

function JSXExpressionContainer(...args) {
  return (0, _builder.default)("JSXExpressionContainer", ...args);
}

function JSXSpreadChild(...args) {
  return (0, _builder.default)("JSXSpreadChild", ...args);
}

function JSXIdentifier(...args) {
  return (0, _builder.default)("JSXIdentifier", ...args);
}

function JSXMemberExpression(...args) {
  return (0, _builder.default)("JSXMemberExpression", ...args);
}

function JSXNamespacedName(...args) {
  return (0, _builder.default)("JSXNamespacedName", ...args);
}

function JSXOpeningElement(...args) {
  return (0, _builder.default)("JSXOpeningElement", ...args);
}

function JSXSpreadAttribute(...args) {
  return (0, _builder.default)("JSXSpreadAttribute", ...args);
}

function JSXText(...args) {
  return (0, _builder.default)("JSXText", ...args);
}

function JSXFragment(...args) {
  return (0, _builder.default)("JSXFragment", ...args);
}

function JSXOpeningFragment(...args) {
  return (0, _builder.default)("JSXOpeningFragment", ...args);
}

function JSXClosingFragment(...args) {
  return (0, _builder.default)("JSXClosingFragment", ...args);
}

function Noop(...args) {
  return (0, _builder.default)("Noop", ...args);
}

function ParenthesizedExpression(...args) {
  return (0, _builder.default)("ParenthesizedExpression", ...args);
}

function AwaitExpression(...args) {
  return (0, _builder.default)("AwaitExpression", ...args);
}

function BindExpression(...args) {
  return (0, _builder.default)("BindExpression", ...args);
}

function ClassProperty(...args) {
  return (0, _builder.default)("ClassProperty", ...args);
}

function OptionalMemberExpression(...args) {
  return (0, _builder.default)("OptionalMemberExpression", ...args);
}

function PipelineTopicExpression(...args) {
  return (0, _builder.default)("PipelineTopicExpression", ...args);
}

function PipelineBareFunction(...args) {
  return (0, _builder.default)("PipelineBareFunction", ...args);
}

function PipelinePrimaryTopicReference(...args) {
  return (0, _builder.default)("PipelinePrimaryTopicReference", ...args);
}

function OptionalCallExpression(...args) {
  return (0, _builder.default)("OptionalCallExpression", ...args);
}

function ClassPrivateProperty(...args) {
  return (0, _builder.default)("ClassPrivateProperty", ...args);
}

function ClassPrivateMethod(...args) {
  return (0, _builder.default)("ClassPrivateMethod", ...args);
}

function Import(...args) {
  return (0, _builder.default)("Import", ...args);
}

function Decorator(...args) {
  return (0, _builder.default)("Decorator", ...args);
}

function DoExpression(...args) {
  return (0, _builder.default)("DoExpression", ...args);
}

function ExportDefaultSpecifier(...args) {
  return (0, _builder.default)("ExportDefaultSpecifier", ...args);
}

function ExportNamespaceSpecifier(...args) {
  return (0, _builder.default)("ExportNamespaceSpecifier", ...args);
}

function PrivateName(...args) {
  return (0, _builder.default)("PrivateName", ...args);
}

function BigIntLiteral(...args) {
  return (0, _builder.default)("BigIntLiteral", ...args);
}

function TSParameterProperty(...args) {
  return (0, _builder.default)("TSParameterProperty", ...args);
}

function TSDeclareFunction(...args) {
  return (0, _builder.default)("TSDeclareFunction", ...args);
}

function TSDeclareMethod(...args) {
  return (0, _builder.default)("TSDeclareMethod", ...args);
}

function TSQualifiedName(...args) {
  return (0, _builder.default)("TSQualifiedName", ...args);
}

function TSCallSignatureDeclaration(...args) {
  return (0, _builder.default)("TSCallSignatureDeclaration", ...args);
}

function TSConstructSignatureDeclaration(...args) {
  return (0, _builder.default)("TSConstructSignatureDeclaration", ...args);
}

function TSPropertySignature(...args) {
  return (0, _builder.default)("TSPropertySignature", ...args);
}

function TSMethodSignature(...args) {
  return (0, _builder.default)("TSMethodSignature", ...args);
}

function TSIndexSignature(...args) {
  return (0, _builder.default)("TSIndexSignature", ...args);
}

function TSAnyKeyword(...args) {
  return (0, _builder.default)("TSAnyKeyword", ...args);
}

function TSUnknownKeyword(...args) {
  return (0, _builder.default)("TSUnknownKeyword", ...args);
}

function TSNumberKeyword(...args) {
  return (0, _builder.default)("TSNumberKeyword", ...args);
}

function TSObjectKeyword(...args) {
  return (0, _builder.default)("TSObjectKeyword", ...args);
}

function TSBooleanKeyword(...args) {
  return (0, _builder.default)("TSBooleanKeyword", ...args);
}

function TSStringKeyword(...args) {
  return (0, _builder.default)("TSStringKeyword", ...args);
}

function TSSymbolKeyword(...args) {
  return (0, _builder.default)("TSSymbolKeyword", ...args);
}

function TSVoidKeyword(...args) {
  return (0, _builder.default)("TSVoidKeyword", ...args);
}

function TSUndefinedKeyword(...args) {
  return (0, _builder.default)("TSUndefinedKeyword", ...args);
}

function TSNullKeyword(...args) {
  return (0, _builder.default)("TSNullKeyword", ...args);
}

function TSNeverKeyword(...args) {
  return (0, _builder.default)("TSNeverKeyword", ...args);
}

function TSThisType(...args) {
  return (0, _builder.default)("TSThisType", ...args);
}

function TSFunctionType(...args) {
  return (0, _builder.default)("TSFunctionType", ...args);
}

function TSConstructorType(...args) {
  return (0, _builder.default)("TSConstructorType", ...args);
}

function TSTypeReference(...args) {
  return (0, _builder.default)("TSTypeReference", ...args);
}

function TSTypePredicate(...args) {
  return (0, _builder.default)("TSTypePredicate", ...args);
}

function TSTypeQuery(...args) {
  return (0, _builder.default)("TSTypeQuery", ...args);
}

function TSTypeLiteral(...args) {
  return (0, _builder.default)("TSTypeLiteral", ...args);
}

function TSArrayType(...args) {
  return (0, _builder.default)("TSArrayType", ...args);
}

function TSTupleType(...args) {
  return (0, _builder.default)("TSTupleType", ...args);
}

function TSOptionalType(...args) {
  return (0, _builder.default)("TSOptionalType", ...args);
}

function TSRestType(...args) {
  return (0, _builder.default)("TSRestType", ...args);
}

function TSUnionType(...args) {
  return (0, _builder.default)("TSUnionType", ...args);
}

function TSIntersectionType(...args) {
  return (0, _builder.default)("TSIntersectionType", ...args);
}

function TSConditionalType(...args) {
  return (0, _builder.default)("TSConditionalType", ...args);
}

function TSInferType(...args) {
  return (0, _builder.default)("TSInferType", ...args);
}

function TSParenthesizedType(...args) {
  return (0, _builder.default)("TSParenthesizedType", ...args);
}

function TSTypeOperator(...args) {
  return (0, _builder.default)("TSTypeOperator", ...args);
}

function TSIndexedAccessType(...args) {
  return (0, _builder.default)("TSIndexedAccessType", ...args);
}

function TSMappedType(...args) {
  return (0, _builder.default)("TSMappedType", ...args);
}

function TSLiteralType(...args) {
  return (0, _builder.default)("TSLiteralType", ...args);
}

function TSExpressionWithTypeArguments(...args) {
  return (0, _builder.default)("TSExpressionWithTypeArguments", ...args);
}

function TSInterfaceDeclaration(...args) {
  return (0, _builder.default)("TSInterfaceDeclaration", ...args);
}

function TSInterfaceBody(...args) {
  return (0, _builder.default)("TSInterfaceBody", ...args);
}

function TSTypeAliasDeclaration(...args) {
  return (0, _builder.default)("TSTypeAliasDeclaration", ...args);
}

function TSAsExpression(...args) {
  return (0, _builder.default)("TSAsExpression", ...args);
}

function TSTypeAssertion(...args) {
  return (0, _builder.default)("TSTypeAssertion", ...args);
}

function TSEnumDeclaration(...args) {
  return (0, _builder.default)("TSEnumDeclaration", ...args);
}

function TSEnumMember(...args) {
  return (0, _builder.default)("TSEnumMember", ...args);
}

function TSModuleDeclaration(...args) {
  return (0, _builder.default)("TSModuleDeclaration", ...args);
}

function TSModuleBlock(...args) {
  return (0, _builder.default)("TSModuleBlock", ...args);
}

function TSImportType(...args) {
  return (0, _builder.default)("TSImportType", ...args);
}

function TSImportEqualsDeclaration(...args) {
  return (0, _builder.default)("TSImportEqualsDeclaration", ...args);
}

function TSExternalModuleReference(...args) {
  return (0, _builder.default)("TSExternalModuleReference", ...args);
}

function TSNonNullExpression(...args) {
  return (0, _builder.default)("TSNonNullExpression", ...args);
}

function TSExportAssignment(...args) {
  return (0, _builder.default)("TSExportAssignment", ...args);
}

function TSNamespaceExportDeclaration(...args) {
  return (0, _builder.default)("TSNamespaceExportDeclaration", ...args);
}

function TSTypeAnnotation(...args) {
  return (0, _builder.default)("TSTypeAnnotation", ...args);
}

function TSTypeParameterInstantiation(...args) {
  return (0, _builder.default)("TSTypeParameterInstantiation", ...args);
}

function TSTypeParameterDeclaration(...args) {
  return (0, _builder.default)("TSTypeParameterDeclaration", ...args);
}

function TSTypeParameter(...args) {
  return (0, _builder.default)("TSTypeParameter", ...args);
}

function NumberLiteral(...args) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  return NumberLiteral("NumberLiteral", ...args);
}

function RegexLiteral(...args) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  return RegexLiteral("RegexLiteral", ...args);
}

function RestProperty(...args) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  return RestProperty("RestProperty", ...args);
}

function SpreadProperty(...args) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  return SpreadProperty("SpreadProperty", ...args);
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = builder;

function _clone() {
  const data = _interopRequireDefault(__webpack_require__(32));

  _clone = function () {
    return data;
  };

  return data;
}

var _definitions = __webpack_require__(141);

var _validate = _interopRequireDefault(__webpack_require__(159));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function builder(type, ...args) {
  const keys = _definitions.BUILDER_KEYS[type];
  const countArgs = args.length;

  if (countArgs > keys.length) {
    throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
  }

  const node = {
    type
  };
  let i = 0;
  keys.forEach(key => {
    const field = _definitions.NODE_FIELDS[type][key];
    let arg;
    if (i < countArgs) arg = args[i];
    if (arg === undefined) arg = (0, _clone().default)(field.default);
    node[key] = arg;
    i++;
  });

  for (const key in node) {
    (0, _validate.default)(node, key, node[key]);
  }

  return node;
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(33);

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(34),
    arrayEach = __webpack_require__(78),
    assignValue = __webpack_require__(79),
    baseAssign = __webpack_require__(82),
    baseAssignIn = __webpack_require__(105),
    cloneBuffer = __webpack_require__(109),
    copyArray = __webpack_require__(110),
    copySymbols = __webpack_require__(111),
    copySymbolsIn = __webpack_require__(115),
    getAllKeys = __webpack_require__(119),
    getAllKeysIn = __webpack_require__(121),
    getTag = __webpack_require__(122),
    initCloneArray = __webpack_require__(127),
    initCloneByTag = __webpack_require__(128),
    initCloneObject = __webpack_require__(135),
    isArray = __webpack_require__(90),
    isBuffer = __webpack_require__(91),
    isMap = __webpack_require__(137),
    isObject = __webpack_require__(58),
    isSet = __webpack_require__(139),
    keys = __webpack_require__(84);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });

    return result;
  }

  if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });

    return result;
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(35),
    stackClear = __webpack_require__(43),
    stackDelete = __webpack_require__(44),
    stackGet = __webpack_require__(45),
    stackHas = __webpack_require__(46),
    stackSet = __webpack_require__(47);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(36),
    listCacheDelete = __webpack_require__(37),
    listCacheGet = __webpack_require__(40),
    listCacheHas = __webpack_require__(41),
    listCacheSet = __webpack_require__(42);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(38);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(39);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 39 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(38);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(38);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(38);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(35);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 45 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 46 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(35),
    Map = __webpack_require__(48),
    MapCache = __webpack_require__(63);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(49),
    root = __webpack_require__(54);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(50),
    getValue = __webpack_require__(62);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(51),
    isMasked = __webpack_require__(59),
    isObject = __webpack_require__(58),
    toSource = __webpack_require__(61);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(52),
    isObject = __webpack_require__(58);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(53),
    getRawTag = __webpack_require__(56),
    objectToString = __webpack_require__(57);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(54);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(55);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 55 */
/***/ (function(module, exports) {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(53);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 57 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 58 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(60);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(54);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 62 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(64),
    mapCacheDelete = __webpack_require__(72),
    mapCacheGet = __webpack_require__(75),
    mapCacheHas = __webpack_require__(76),
    mapCacheSet = __webpack_require__(77);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(65),
    ListCache = __webpack_require__(35),
    Map = __webpack_require__(48);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(66),
    hashDelete = __webpack_require__(68),
    hashGet = __webpack_require__(69),
    hashHas = __webpack_require__(70),
    hashSet = __webpack_require__(71);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(67);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(49);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 68 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(67);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(67);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(67);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(73);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(74);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(73);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(73);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(73);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 78 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(80),
    eq = __webpack_require__(39);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(81);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(49);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(83),
    keys = __webpack_require__(84);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(79),
    baseAssignValue = __webpack_require__(80);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(85),
    baseKeys = __webpack_require__(100),
    isArrayLike = __webpack_require__(104);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(86),
    isArguments = __webpack_require__(87),
    isArray = __webpack_require__(90),
    isBuffer = __webpack_require__(91),
    isIndex = __webpack_require__(94),
    isTypedArray = __webpack_require__(95);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 86 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(88),
    isObjectLike = __webpack_require__(89);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(52),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 89 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 90 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(54),
    stubFalse = __webpack_require__(93);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 93 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 94 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(96),
    baseUnary = __webpack_require__(98),
    nodeUtil = __webpack_require__(99);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(52),
    isLength = __webpack_require__(97),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(55);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(101),
    nativeKeys = __webpack_require__(102);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(103);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(51),
    isLength = __webpack_require__(97);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(83),
    keysIn = __webpack_require__(106);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(85),
    baseKeysIn = __webpack_require__(107),
    isArrayLike = __webpack_require__(104);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(58),
    isPrototype = __webpack_require__(101),
    nativeKeysIn = __webpack_require__(108);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(54);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 110 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(83),
    getSymbols = __webpack_require__(112);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(113),
    stubArray = __webpack_require__(114);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 113 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(83),
    getSymbolsIn = __webpack_require__(116);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(117),
    getPrototype = __webpack_require__(118),
    getSymbols = __webpack_require__(112),
    stubArray = __webpack_require__(114);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 117 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(103);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(120),
    getSymbols = __webpack_require__(112),
    keys = __webpack_require__(84);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(117),
    isArray = __webpack_require__(90);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(120),
    getSymbolsIn = __webpack_require__(116),
    keysIn = __webpack_require__(106);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(123),
    Map = __webpack_require__(48),
    Promise = __webpack_require__(124),
    Set = __webpack_require__(125),
    WeakMap = __webpack_require__(126),
    baseGetTag = __webpack_require__(52),
    toSource = __webpack_require__(61);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(49),
    root = __webpack_require__(54);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(49),
    root = __webpack_require__(54);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(49),
    root = __webpack_require__(54);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(49),
    root = __webpack_require__(54);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 127 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(129),
    cloneDataView = __webpack_require__(131),
    cloneRegExp = __webpack_require__(132),
    cloneSymbol = __webpack_require__(133),
    cloneTypedArray = __webpack_require__(134);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(130);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(54);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(129);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(53);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(129);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(136),
    getPrototype = __webpack_require__(118),
    isPrototype = __webpack_require__(101);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(58);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(138),
    baseUnary = __webpack_require__(98),
    nodeUtil = __webpack_require__(99);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(122),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(140),
    baseUnary = __webpack_require__(98),
    nodeUtil = __webpack_require__(99);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(122),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VISITOR_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.VISITOR_KEYS;
  }
});
Object.defineProperty(exports, "ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.FLIPPED_ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "NODE_FIELDS", {
  enumerable: true,
  get: function () {
    return _utils.NODE_FIELDS;
  }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.BUILDER_KEYS;
  }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.DEPRECATED_KEYS;
  }
});
exports.TYPES = void 0;

function _toFastProperties() {
  const data = _interopRequireDefault(__webpack_require__(142));

  _toFastProperties = function () {
    return data;
  };

  return data;
}

__webpack_require__(143);

__webpack_require__(153);

__webpack_require__(154);

__webpack_require__(155);

__webpack_require__(156);

__webpack_require__(157);

__webpack_require__(158);

var _utils = __webpack_require__(150);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _toFastProperties().default)(_utils.VISITOR_KEYS);
(0, _toFastProperties().default)(_utils.ALIAS_KEYS);
(0, _toFastProperties().default)(_utils.FLIPPED_ALIAS_KEYS);
(0, _toFastProperties().default)(_utils.NODE_FIELDS);
(0, _toFastProperties().default)(_utils.BUILDER_KEYS);
(0, _toFastProperties().default)(_utils.DEPRECATED_KEYS);
const TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


let fastProto = null;

// Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.
function FastObject(o) {
	// A prototype object will have "fast properties" enabled once it is checked
	// against the inline property cache of a function, e.g. fastProto.property:
	// https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
	if (fastProto !== null && typeof fastProto.property) {
		const result = fastProto;
		fastProto = FastObject.prototype = null;
		return result;
	}
	fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
	return new FastObject;
}

// Initialize the inline property cache of FastObject
FastObject();

module.exports = function toFastproperties(o) {
	return FastObject(o);
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(144));

var _constants = __webpack_require__(149);

var _utils = _interopRequireWildcard(__webpack_require__(150));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _utils.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
(0, _utils.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: (0, _utils.assertValueType)("string")
    },
    left: {
      validate: (0, _utils.assertNodeType)("LVal")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});
(0, _utils.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});
(0, _utils.default)("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    }
  }
});
(0, _utils.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
(0, _utils.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
    },
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
});
(0, _utils.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});
(0, _utils.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("DebuggerStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
(0, _utils.default)("EmptyStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});
(0, _utils.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)("Program")
    }
  }
});
(0, _utils.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
const functionCommon = {
  params: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
  },
  generator: {
    default: false,
    validate: (0, _utils.assertValueType)("boolean")
  },
  async: {
    validate: (0, _utils.assertValueType)("boolean"),
    default: false
  }
};
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = Object.assign({}, functionCommon, {
  declare: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
  }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
(0, _utils.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
});
(0, _utils.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
const patternLikeCommon = {
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
  }
};
exports.patternLikeCommon = patternLikeCommon;
(0, _utils.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, patternLikeCommon, {
    name: {
      validate: (0, _utils.chain)(function (node, key, val) {
        if (!(0, _isValidIdentifier.default)(val)) {}
      }, (0, _utils.assertValueType)("string"))
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
(0, _utils.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Literal"],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)("string")
    },
    flags: {
      validate: (0, _utils.assertValueType)("string"),
      default: ""
    }
  }
});
(0, _utils.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("MemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  }
});
(0, _utils.default)("NewExpression", {
  inherits: "CallExpression"
});
(0, _utils.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceFile: {
      validate: (0, _utils.assertValueType)("string")
    },
    sourceType: {
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block"]
});
(0, _utils.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    kind: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("method", "get", "set")),
      default: "method"
    },
    computed: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
(0, _utils.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", "decorators"],
  fields: {
    computed: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
    },
    shorthand: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"]
});
(0, _utils.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, patternLikeCommon, {
    argument: {
      validate: (0, _utils.assertNodeType)("LVal")
    }
  })
});
(0, _utils.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
(0, _utils.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});
(0, _utils.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  }
});
(0, _utils.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
    }
  }
});
(0, _utils.default)("ThisExpression", {
  aliases: ["Expression"]
});
(0, _utils.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});
(0, _utils.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});
(0, _utils.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    kind: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("var", "let", "const"))
    },
    declarations: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
    }
  }
});
(0, _utils.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("LVal")
    },
    definite: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    init: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
    }
  }
});
(0, _utils.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Statement")
    }
  }
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidIdentifier;

function _esutils() {
  const data = _interopRequireDefault(__webpack_require__(145));

  _esutils = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isValidIdentifier(name) {
  if (typeof name !== "string" || _esutils().default.keyword.isReservedWordES6(name, true)) {
    return false;
  } else if (name === "await") {
    return false;
  } else {
    return _esutils().default.keyword.isIdentifierNameES6(name);
  }
}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = __webpack_require__(146);
    exports.code = __webpack_require__(147);
    exports.keyword = __webpack_require__(148);
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 146 */
/***/ (function(module, exports) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = __webpack_require__(147);

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = ["body", "expressions"];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = ["left", "init"];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = ["||", "&&", "??"];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = ["++", "--"];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = ["typeof"];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;
exports.typeIs = typeIs;
exports.validateType = validateType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.validateArrayOfType = validateArrayOfType;
exports.assertEach = assertEach;
exports.assertOneOf = assertOneOf;
exports.assertNodeType = assertNodeType;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;
exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

var _is = _interopRequireDefault(__webpack_require__(151));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;

function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else if (val === undefined) {
    return "undefined";
  } else {
    return typeof val;
  }
}

function validate(validate) {
  return {
    validate
  };
}

function typeIs(typeName) {
  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}

function validateType(typeName) {
  return validate(typeIs(typeName));
}

function validateOptional(validate) {
  return {
    validate,
    optional: true
  };
}

function validateOptionalType(typeName) {
  return {
    validate: typeIs(typeName),
    optional: true
  };
}

function arrayOf(elementType) {
  return chain(assertValueType("array"), assertEach(elementType));
}

function arrayOfType(typeName) {
  return arrayOf(typeIs(typeName));
}

function validateArrayOfType(typeName) {
  return validate(arrayOfType(typeName));
}

function assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (let i = 0; i < val.length; i++) {
      callback(node, `${key}[${i}]`, val[i]);
    }
  }

  validator.each = callback;
  return validator;
}

function assertOneOf(...values) {
  function validate(node, key, val) {
    if (values.indexOf(val) < 0) {
      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
  }

  validate.oneOf = values;
  return validate;
}

function assertNodeType(...types) {
  function validate(node, key, val) {
    let valid = false;

    for (const type of types) {
      if ((0, _is.default)(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} ` + `but instead got ${JSON.stringify(val && val.type)}`);
    }
  }

  validate.oneOfNodeTypes = types;
  return validate;
}

function assertNodeOrValueType(...types) {
  function validate(node, key, val) {
    let valid = false;

    for (const type of types) {
      if (getType(val) === type || (0, _is.default)(type, val)) {
        valid = true;
        break;
      }
    }

    if (!valid) {
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} ` + `but instead got ${JSON.stringify(val && val.type)}`);
    }
  }

  validate.oneOfNodeOrValueTypes = types;
  return validate;
}

function assertValueType(type) {
  function validate(node, key, val) {
    const valid = getType(val) === type;

    if (!valid) {
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
  }

  validate.type = type;
  return validate;
}

function chain(...fns) {
  function validate(...args) {
    for (const fn of fns) {
      fn(...args);
    }
  }

  validate.chainOf = fns;
  return validate;
}

function defineType(type, opts = {}) {
  const inherits = opts.inherits && store[opts.inherits] || {};
  const fields = opts.fields || inherits.fields || {};
  const visitor = opts.visitor || inherits.visitor || [];
  const aliases = opts.aliases || inherits.aliases || [];
  const builder = opts.builder || inherits.builder || opts.visitor || [];

  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  for (const key of visitor.concat(builder)) {
    fields[key] = fields[key] || {};
  }

  for (const key in fields) {
    const field = fields[key];

    if (builder.indexOf(key) === -1) {
      field.optional = true;
    }

    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate) {
      field.validate = assertValueType(getType(field.default));
    }
  }

  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(alias => {
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
  });
  store[type] = opts;
}

const store = {};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = is;

var _shallowEqual = _interopRequireDefault(__webpack_require__(26));

var _isType = _interopRequireDefault(__webpack_require__(152));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function is(type, node, opts) {
  if (!node) return false;
  const matches = (0, _isType.default)(node.type, type);
  if (!matches) return false;

  if (typeof opts === "undefined") {
    return true;
  } else {
    return (0, _shallowEqual.default)(node, opts);
  }
}

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isType;

var _definitions = __webpack_require__(141);

function isType(nodeType, targetType) {
  if (nodeType === targetType) return true;
  if (_definitions.ALIAS_KEYS[targetType]) return false;
  const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

  if (aliases) {
    if (aliases[0] === nodeType) return true;

    for (const alias of aliases) {
      if (nodeType === alias) return true;
    }
  }

  return false;
}

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;

var _utils = _interopRequireWildcard(__webpack_require__(150));

var _core = __webpack_require__(143);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

(0, _utils.default)("AssignmentPattern", {
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    left: {
      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    }
  })
});
(0, _utils.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("PatternLike")))
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    }
  })
});
(0, _utils.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, _core.functionCommon, _core.functionTypeAnnotationCommon, {
    expression: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
    }
  })
});
(0, _utils.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
    }
  }
});
const classCommon = {
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  },
  body: {
    validate: (0, _utils.assertNodeType)("ClassBody")
  },
  superClass: {
    optional: true,
    validate: (0, _utils.assertNodeType)("Expression")
  },
  superTypeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
    optional: true
  },
  implements: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
    optional: true
  }
};
(0, _utils.default)("ClassDeclaration", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
  fields: Object.assign({}, classCommon, {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ClassExpression", {
  inherits: "ClassDeclaration",
  aliases: ["Scopable", "Class", "Expression", "Pureish"],
  fields: Object.assign({}, classCommon, {
    id: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
    }
  }
});
(0, _utils.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)("Declaration"),
      optional: true
    },
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral"),
      optional: true
    }
  }
});
(0, _utils.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    await: {
      default: false,
      validate: (0, _utils.assertValueType)("boolean")
    }
  }
});
(0, _utils.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  }
});
(0, _utils.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof"),
      optional: true
    }
  }
});
(0, _utils.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
const classMethodOrPropertyCommon = {
  abstract: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  static: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  computed: {
    default: false,
    validate: (0, _utils.assertValueType)("boolean")
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
      const computed = (0, _utils.assertNodeType)("Expression");
      return function (node, key, val) {
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
  }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, classMethodOrPropertyCommon, {
  kind: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("get", "set", "method", "constructor")),
    default: "method"
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    optional: true
  }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
(0, _utils.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, _core.patternLikeCommon, {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
    }
  })
});
(0, _utils.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("Super", {
  aliases: ["Expression"]
});
(0, _utils.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {},
    tail: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    }
  }
});
(0, _utils.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
    }
  }
});
(0, _utils.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(150));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
  (0, _utils.default)(name, {
    builder: ["id", "typeParameters", "extends", "body"],
    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
};

(0, _utils.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    elementType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("BooleanLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("DeclareClass");
(0, _utils.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
  }
});
defineInterfaceishType("DeclareInterface");
(0, _utils.default)("DeclareModule", {
  builder: ["id", "body", "kind"],
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)("BlockStatement"),
    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
  }
});
(0, _utils.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType")
  }
});
(0, _utils.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    declaration: (0, _utils.validateOptionalType)("Flow"),
    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
    source: (0, _utils.validateOptionalType)("StringLiteral"),
    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("DeclareExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    source: (0, _utils.validateType)("StringLiteral"),
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(["type", "value"]))
  }
});
(0, _utils.default)("DeclaredPredicate", {
  visitor: ["value"],
  aliases: ["Flow", "FlowPredicate"],
  fields: {
    value: (0, _utils.validateType)("Flow")
  }
});
(0, _utils.default)("ExistsTypeAnnotation", {
  aliases: ["Flow", "FlowType"]
});
(0, _utils.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
    returnType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {
    name: (0, _utils.validateOptionalType)("Identifier"),
    typeAnnotation: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow", "FlowType"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
(0, _utils.default)("InferredPredicate", {
  aliases: ["Flow", "FlowPredicate"]
});
(0, _utils.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("InterfaceDeclaration");
(0, _utils.default)("InterfaceTypeAnnotation", {
  visitor: ["extends", "body"],
  aliases: ["Flow", "FlowType"],
  fields: {
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
    body: (0, _utils.validateType)("ObjectTypeAnnotation")
  }
});
(0, _utils.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("NumberLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
  }
});
(0, _utils.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
  aliases: ["Flow", "FlowType"],
  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
  fields: {
    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
    exact: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeInternalSlot", {
  visitor: ["id", "value", "optional", "static", "method"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    value: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateOptionalType)("Identifier"),
    key: (0, _utils.validateType)("FlowType"),
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeProperty", {
  visitor: ["key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    value: (0, _utils.validateType)("FlowType"),
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("OpaqueType", {
  visitor: ["id", "typeParameters", "supertype", "impltype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType"),
    impltype: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
  }
});
(0, _utils.default)("StringLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
  }
});
(0, _utils.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow", "FlowType"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAnnotation", {
  aliases: ["Flow"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("TypeParameter", {
  aliases: ["Flow"],
  visitor: ["bound", "default", "variance"],
  fields: {
    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
    default: (0, _utils.validateOptionalType)("FlowType"),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("TypeParameterDeclaration", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
  }
});
(0, _utils.default)("TypeParameterInstantiation", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("Variance", {
  aliases: ["Flow"],
  builder: ["kind"],
  fields: {
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
  }
});
(0, _utils.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(150));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

(0, _utils.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
    }
  }
});
(0, _utils.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    }
  }
});
(0, _utils.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
});
(0, _utils.default)("JSXEmptyExpression", {
  aliases: ["JSX"]
});
(0, _utils.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
    }
  }
});
(0, _utils.default)("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
    },
    selfClosing: {
      default: false,
      validate: (0, _utils.assertValueType)("boolean")
    },
    attributes: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXFragment", {
  builder: ["openingFragment", "closingFragment", "children"],
  visitor: ["openingFragment", "children", "closingFragment"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingFragment: {
      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
    },
    closingFragment: {
      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
});
(0, _utils.default)("JSXOpeningFragment", {
  aliases: ["JSX", "Immutable"]
});
(0, _utils.default)("JSXClosingFragment", {
  aliases: ["JSX", "Immutable"]
});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(150));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

(0, _utils.default)("Noop", {
  visitor: []
});
(0, _utils.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(150));

var _es = __webpack_require__(153);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

(0, _utils.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: {}
});
(0, _utils.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
  aliases: ["Property"],
  fields: Object.assign({}, _es.classMethodOrPropertyCommon, {
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
(0, _utils.default)("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  }
});
(0, _utils.default)("PipelineTopicExpression", {
  builder: ["expression"],
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelineBareFunction", {
  builder: ["callee"],
  visitor: ["callee"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
  aliases: ["Expression"]
});
(0, _utils.default)("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateProperty", {
  visitor: ["key", "value"],
  builder: ["key", "value"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("Import", {
  aliases: ["Expression"]
});
(0, _utils.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _utils = _interopRequireWildcard(__webpack_require__(150));

var _core = __webpack_require__(143);

var _es = __webpack_require__(153);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
(0, _utils.default)("TSParameterProperty", {
  aliases: ["LVal"],
  visitor: ["parameter"],
  fields: {
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    parameter: {
      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
    }
  }
});
(0, _utils.default)("TSDeclareFunction", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSDeclareMethod", {
  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSQualifiedName", {
  aliases: ["TSEntityName"],
  visitor: ["left", "right"],
  fields: {
    left: (0, _utils.validateType)("TSEntityName"),
    right: (0, _utils.validateType)("Identifier")
  }
});
const signatureDeclarationCommon = {
  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
const callConstructSignatureDeclaration = {
  aliases: ["TSTypeElement"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = {
  key: (0, _utils.validateType)("Expression"),
  computed: (0, _utils.validate)(bool),
  optional: (0, _utils.validateOptional)(bool)
};
(0, _utils.default)("TSPropertySignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeAnnotation", "initializer"],
  fields: Object.assign({}, namedTypeElementCommon, {
    readonly: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  })
});
(0, _utils.default)("TSMethodSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
});
(0, _utils.default)("TSIndexSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["parameters", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    parameters: (0, _utils.validateArrayOfType)("Identifier"),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  }
});
const tsKeywordTypes = ["TSAnyKeyword", "TSUnknownKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSBooleanKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSVoidKeyword", "TSUndefinedKeyword", "TSNullKeyword", "TSNeverKeyword"];

for (const type of tsKeywordTypes) {
  (0, _utils.default)(type, {
    aliases: ["TSType"],
    visitor: [],
    fields: {}
  });
}

(0, _utils.default)("TSThisType", {
  aliases: ["TSType"],
  visitor: [],
  fields: {}
});
const fnOrCtr = {
  aliases: ["TSType"],
  visitor: ["typeParameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSFunctionType", fnOrCtr);
(0, _utils.default)("TSConstructorType", fnOrCtr);
(0, _utils.default)("TSTypeReference", {
  aliases: ["TSType"],
  visitor: ["typeName", "typeParameters"],
  fields: {
    typeName: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSTypePredicate", {
  aliases: ["TSType"],
  visitor: ["parameterName", "typeAnnotation"],
  fields: {
    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
    typeAnnotation: (0, _utils.validateType)("TSTypeAnnotation")
  }
});
(0, _utils.default)("TSTypeQuery", {
  aliases: ["TSType"],
  visitor: ["exprName"],
  fields: {
    exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])
  }
});
(0, _utils.default)("TSTypeLiteral", {
  aliases: ["TSType"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSArrayType", {
  aliases: ["TSType"],
  visitor: ["elementType"],
  fields: {
    elementType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTupleType", {
  aliases: ["TSType"],
  visitor: ["elementTypes"],
  fields: {
    elementTypes: (0, _utils.validateArrayOfType)("TSType")
  }
});
(0, _utils.default)("TSOptionalType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSRestType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
const unionOrIntersection = {
  aliases: ["TSType"],
  visitor: ["types"],
  fields: {
    types: (0, _utils.validateArrayOfType)("TSType")
  }
};
(0, _utils.default)("TSUnionType", unionOrIntersection);
(0, _utils.default)("TSIntersectionType", unionOrIntersection);
(0, _utils.default)("TSConditionalType", {
  aliases: ["TSType"],
  visitor: ["checkType", "extendsType", "trueType", "falseType"],
  fields: {
    checkType: (0, _utils.validateType)("TSType"),
    extendsType: (0, _utils.validateType)("TSType"),
    trueType: (0, _utils.validateType)("TSType"),
    falseType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSInferType", {
  aliases: ["TSType"],
  visitor: ["typeParameter"],
  fields: {
    typeParameter: (0, _utils.validateType)("TSTypeParameter")
  }
});
(0, _utils.default)("TSParenthesizedType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeOperator", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSIndexedAccessType", {
  aliases: ["TSType"],
  visitor: ["objectType", "indexType"],
  fields: {
    objectType: (0, _utils.validateType)("TSType"),
    indexType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSMappedType", {
  aliases: ["TSType"],
  visitor: ["typeParameter", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
    optional: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSType")
  }
});
(0, _utils.default)("TSLiteralType", {
  aliases: ["TSType"],
  visitor: ["literal"],
  fields: {
    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral"])
  }
});
(0, _utils.default)("TSExpressionWithTypeArguments", {
  aliases: ["TSType"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSInterfaceDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "extends", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
    body: (0, _utils.validateType)("TSInterfaceBody")
  }
});
(0, _utils.default)("TSInterfaceBody", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSTypeAliasDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "typeAnnotation"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSAsExpression", {
  aliases: ["Expression"],
  visitor: ["expression", "typeAnnotation"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeAssertion", {
  aliases: ["Expression"],
  visitor: ["typeAnnotation", "expression"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType"),
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSEnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "members"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    const: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSEnumMember", {
  visitor: ["id", "initializer"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSModuleDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    global: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
  }
});
(0, _utils.default)("TSModuleBlock", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("Statement")
  }
});
(0, _utils.default)("TSImportType", {
  aliases: ["TSType"],
  visitor: ["argument", "qualifier", "typeParameters"],
  fields: {
    argument: (0, _utils.validateType)("StringLiteral"),
    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSImportEqualsDeclaration", {
  aliases: ["Statement"],
  visitor: ["id", "moduleReference"],
  fields: {
    isExport: (0, _utils.validate)(bool),
    id: (0, _utils.validateType)("Identifier"),
    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
  }
});
(0, _utils.default)("TSExternalModuleReference", {
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("TSNonNullExpression", {
  aliases: ["Expression"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSExportAssignment", {
  aliases: ["Statement"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSNamespaceExportDeclaration", {
  aliases: ["Statement"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("TSTypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TSType")
    }
  }
});
(0, _utils.default)("TSTypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
    }
  }
});
(0, _utils.default)("TSTypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
    }
  }
});
(0, _utils.default)("TSTypeParameter", {
  visitor: ["constraint", "default"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    },
    constraint: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    },
    default: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    }
  }
});

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validate;

var _definitions = __webpack_require__(141);

function validate(node, key, val) {
  if (!node) return;
  const fields = _definitions.NODE_FIELDS[node.type];
  if (!fields) return;
  const field = fields[key];
  if (!field || !field.validate) return;
  if (field.optional && val == null) return;
  field.validate(node, key, val);
}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertNode;

var _isNode = _interopRequireDefault(__webpack_require__(161));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assertNode(node) {
  if (!(0, _isNode.default)(node)) {
    const type = node && node.type || JSON.stringify(node);
    throw new TypeError(`Not a valid node of type "${type}"`);
  }
}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNode;

var _definitions = __webpack_require__(141);

function isNode(node) {
  return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertArrayExpression = assertArrayExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertFile = assertFile;
exports.assertForInStatement = assertForInStatement;
exports.assertForStatement = assertForStatement;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertStringLiteral = assertStringLiteral;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertNullLiteral = assertNullLiteral;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertMemberExpression = assertMemberExpression;
exports.assertNewExpression = assertNewExpression;
exports.assertProgram = assertProgram;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectProperty = assertObjectProperty;
exports.assertRestElement = assertRestElement;
exports.assertReturnStatement = assertReturnStatement;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertThisExpression = assertThisExpression;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTryStatement = assertTryStatement;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertForOfStatement = assertForOfStatement;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertMetaProperty = assertMetaProperty;
exports.assertClassMethod = assertClassMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSuper = assertSuper;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertYieldExpression = assertYieldExpression;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertClassImplements = assertClassImplements;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXText = assertJSXText;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertNoop = assertNoop;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertClassProperty = assertClassProperty;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertImport = assertImport;
exports.assertDecorator = assertDecorator;
exports.assertDoExpression = assertDoExpression;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertPrivateName = assertPrivateName;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSRestType = assertTSRestType;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSImportType = assertTSImportType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertExpression = assertExpression;
exports.assertBinary = assertBinary;
exports.assertScopable = assertScopable;
exports.assertBlockParent = assertBlockParent;
exports.assertBlock = assertBlock;
exports.assertStatement = assertStatement;
exports.assertTerminatorless = assertTerminatorless;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertLoop = assertLoop;
exports.assertWhile = assertWhile;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFor = assertFor;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionParent = assertFunctionParent;
exports.assertPureish = assertPureish;
exports.assertDeclaration = assertDeclaration;
exports.assertPatternLike = assertPatternLike;
exports.assertLVal = assertLVal;
exports.assertTSEntityName = assertTSEntityName;
exports.assertLiteral = assertLiteral;
exports.assertImmutable = assertImmutable;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertMethod = assertMethod;
exports.assertObjectMember = assertObjectMember;
exports.assertProperty = assertProperty;
exports.assertUnaryLike = assertUnaryLike;
exports.assertPattern = assertPattern;
exports.assertClass = assertClass;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertFlow = assertFlow;
exports.assertFlowType = assertFlowType;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertJSX = assertJSX;
exports.assertPrivate = assertPrivate;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSType = assertTSType;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestProperty = assertRestProperty;
exports.assertSpreadProperty = assertSpreadProperty;

var _is = _interopRequireDefault(__webpack_require__(151));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
  }
}

function assertArrayExpression(node, opts = {}) {
  assert("ArrayExpression", node, opts);
}

function assertAssignmentExpression(node, opts = {}) {
  assert("AssignmentExpression", node, opts);
}

function assertBinaryExpression(node, opts = {}) {
  assert("BinaryExpression", node, opts);
}

function assertInterpreterDirective(node, opts = {}) {
  assert("InterpreterDirective", node, opts);
}

function assertDirective(node, opts = {}) {
  assert("Directive", node, opts);
}

function assertDirectiveLiteral(node, opts = {}) {
  assert("DirectiveLiteral", node, opts);
}

function assertBlockStatement(node, opts = {}) {
  assert("BlockStatement", node, opts);
}

function assertBreakStatement(node, opts = {}) {
  assert("BreakStatement", node, opts);
}

function assertCallExpression(node, opts = {}) {
  assert("CallExpression", node, opts);
}

function assertCatchClause(node, opts = {}) {
  assert("CatchClause", node, opts);
}

function assertConditionalExpression(node, opts = {}) {
  assert("ConditionalExpression", node, opts);
}

function assertContinueStatement(node, opts = {}) {
  assert("ContinueStatement", node, opts);
}

function assertDebuggerStatement(node, opts = {}) {
  assert("DebuggerStatement", node, opts);
}

function assertDoWhileStatement(node, opts = {}) {
  assert("DoWhileStatement", node, opts);
}

function assertEmptyStatement(node, opts = {}) {
  assert("EmptyStatement", node, opts);
}

function assertExpressionStatement(node, opts = {}) {
  assert("ExpressionStatement", node, opts);
}

function assertFile(node, opts = {}) {
  assert("File", node, opts);
}

function assertForInStatement(node, opts = {}) {
  assert("ForInStatement", node, opts);
}

function assertForStatement(node, opts = {}) {
  assert("ForStatement", node, opts);
}

function assertFunctionDeclaration(node, opts = {}) {
  assert("FunctionDeclaration", node, opts);
}

function assertFunctionExpression(node, opts = {}) {
  assert("FunctionExpression", node, opts);
}

function assertIdentifier(node, opts = {}) {
  assert("Identifier", node, opts);
}

function assertIfStatement(node, opts = {}) {
  assert("IfStatement", node, opts);
}

function assertLabeledStatement(node, opts = {}) {
  assert("LabeledStatement", node, opts);
}

function assertStringLiteral(node, opts = {}) {
  assert("StringLiteral", node, opts);
}

function assertNumericLiteral(node, opts = {}) {
  assert("NumericLiteral", node, opts);
}

function assertNullLiteral(node, opts = {}) {
  assert("NullLiteral", node, opts);
}

function assertBooleanLiteral(node, opts = {}) {
  assert("BooleanLiteral", node, opts);
}

function assertRegExpLiteral(node, opts = {}) {
  assert("RegExpLiteral", node, opts);
}

function assertLogicalExpression(node, opts = {}) {
  assert("LogicalExpression", node, opts);
}

function assertMemberExpression(node, opts = {}) {
  assert("MemberExpression", node, opts);
}

function assertNewExpression(node, opts = {}) {
  assert("NewExpression", node, opts);
}

function assertProgram(node, opts = {}) {
  assert("Program", node, opts);
}

function assertObjectExpression(node, opts = {}) {
  assert("ObjectExpression", node, opts);
}

function assertObjectMethod(node, opts = {}) {
  assert("ObjectMethod", node, opts);
}

function assertObjectProperty(node, opts = {}) {
  assert("ObjectProperty", node, opts);
}

function assertRestElement(node, opts = {}) {
  assert("RestElement", node, opts);
}

function assertReturnStatement(node, opts = {}) {
  assert("ReturnStatement", node, opts);
}

function assertSequenceExpression(node, opts = {}) {
  assert("SequenceExpression", node, opts);
}

function assertSwitchCase(node, opts = {}) {
  assert("SwitchCase", node, opts);
}

function assertSwitchStatement(node, opts = {}) {
  assert("SwitchStatement", node, opts);
}

function assertThisExpression(node, opts = {}) {
  assert("ThisExpression", node, opts);
}

function assertThrowStatement(node, opts = {}) {
  assert("ThrowStatement", node, opts);
}

function assertTryStatement(node, opts = {}) {
  assert("TryStatement", node, opts);
}

function assertUnaryExpression(node, opts = {}) {
  assert("UnaryExpression", node, opts);
}

function assertUpdateExpression(node, opts = {}) {
  assert("UpdateExpression", node, opts);
}

function assertVariableDeclaration(node, opts = {}) {
  assert("VariableDeclaration", node, opts);
}

function assertVariableDeclarator(node, opts = {}) {
  assert("VariableDeclarator", node, opts);
}

function assertWhileStatement(node, opts = {}) {
  assert("WhileStatement", node, opts);
}

function assertWithStatement(node, opts = {}) {
  assert("WithStatement", node, opts);
}

function assertAssignmentPattern(node, opts = {}) {
  assert("AssignmentPattern", node, opts);
}

function assertArrayPattern(node, opts = {}) {
  assert("ArrayPattern", node, opts);
}

function assertArrowFunctionExpression(node, opts = {}) {
  assert("ArrowFunctionExpression", node, opts);
}

function assertClassBody(node, opts = {}) {
  assert("ClassBody", node, opts);
}

function assertClassDeclaration(node, opts = {}) {
  assert("ClassDeclaration", node, opts);
}

function assertClassExpression(node, opts = {}) {
  assert("ClassExpression", node, opts);
}

function assertExportAllDeclaration(node, opts = {}) {
  assert("ExportAllDeclaration", node, opts);
}

function assertExportDefaultDeclaration(node, opts = {}) {
  assert("ExportDefaultDeclaration", node, opts);
}

function assertExportNamedDeclaration(node, opts = {}) {
  assert("ExportNamedDeclaration", node, opts);
}

function assertExportSpecifier(node, opts = {}) {
  assert("ExportSpecifier", node, opts);
}

function assertForOfStatement(node, opts = {}) {
  assert("ForOfStatement", node, opts);
}

function assertImportDeclaration(node, opts = {}) {
  assert("ImportDeclaration", node, opts);
}

function assertImportDefaultSpecifier(node, opts = {}) {
  assert("ImportDefaultSpecifier", node, opts);
}

function assertImportNamespaceSpecifier(node, opts = {}) {
  assert("ImportNamespaceSpecifier", node, opts);
}

function assertImportSpecifier(node, opts = {}) {
  assert("ImportSpecifier", node, opts);
}

function assertMetaProperty(node, opts = {}) {
  assert("MetaProperty", node, opts);
}

function assertClassMethod(node, opts = {}) {
  assert("ClassMethod", node, opts);
}

function assertObjectPattern(node, opts = {}) {
  assert("ObjectPattern", node, opts);
}

function assertSpreadElement(node, opts = {}) {
  assert("SpreadElement", node, opts);
}

function assertSuper(node, opts = {}) {
  assert("Super", node, opts);
}

function assertTaggedTemplateExpression(node, opts = {}) {
  assert("TaggedTemplateExpression", node, opts);
}

function assertTemplateElement(node, opts = {}) {
  assert("TemplateElement", node, opts);
}

function assertTemplateLiteral(node, opts = {}) {
  assert("TemplateLiteral", node, opts);
}

function assertYieldExpression(node, opts = {}) {
  assert("YieldExpression", node, opts);
}

function assertAnyTypeAnnotation(node, opts = {}) {
  assert("AnyTypeAnnotation", node, opts);
}

function assertArrayTypeAnnotation(node, opts = {}) {
  assert("ArrayTypeAnnotation", node, opts);
}

function assertBooleanTypeAnnotation(node, opts = {}) {
  assert("BooleanTypeAnnotation", node, opts);
}

function assertBooleanLiteralTypeAnnotation(node, opts = {}) {
  assert("BooleanLiteralTypeAnnotation", node, opts);
}

function assertNullLiteralTypeAnnotation(node, opts = {}) {
  assert("NullLiteralTypeAnnotation", node, opts);
}

function assertClassImplements(node, opts = {}) {
  assert("ClassImplements", node, opts);
}

function assertDeclareClass(node, opts = {}) {
  assert("DeclareClass", node, opts);
}

function assertDeclareFunction(node, opts = {}) {
  assert("DeclareFunction", node, opts);
}

function assertDeclareInterface(node, opts = {}) {
  assert("DeclareInterface", node, opts);
}

function assertDeclareModule(node, opts = {}) {
  assert("DeclareModule", node, opts);
}

function assertDeclareModuleExports(node, opts = {}) {
  assert("DeclareModuleExports", node, opts);
}

function assertDeclareTypeAlias(node, opts = {}) {
  assert("DeclareTypeAlias", node, opts);
}

function assertDeclareOpaqueType(node, opts = {}) {
  assert("DeclareOpaqueType", node, opts);
}

function assertDeclareVariable(node, opts = {}) {
  assert("DeclareVariable", node, opts);
}

function assertDeclareExportDeclaration(node, opts = {}) {
  assert("DeclareExportDeclaration", node, opts);
}

function assertDeclareExportAllDeclaration(node, opts = {}) {
  assert("DeclareExportAllDeclaration", node, opts);
}

function assertDeclaredPredicate(node, opts = {}) {
  assert("DeclaredPredicate", node, opts);
}

function assertExistsTypeAnnotation(node, opts = {}) {
  assert("ExistsTypeAnnotation", node, opts);
}

function assertFunctionTypeAnnotation(node, opts = {}) {
  assert("FunctionTypeAnnotation", node, opts);
}

function assertFunctionTypeParam(node, opts = {}) {
  assert("FunctionTypeParam", node, opts);
}

function assertGenericTypeAnnotation(node, opts = {}) {
  assert("GenericTypeAnnotation", node, opts);
}

function assertInferredPredicate(node, opts = {}) {
  assert("InferredPredicate", node, opts);
}

function assertInterfaceExtends(node, opts = {}) {
  assert("InterfaceExtends", node, opts);
}

function assertInterfaceDeclaration(node, opts = {}) {
  assert("InterfaceDeclaration", node, opts);
}

function assertInterfaceTypeAnnotation(node, opts = {}) {
  assert("InterfaceTypeAnnotation", node, opts);
}

function assertIntersectionTypeAnnotation(node, opts = {}) {
  assert("IntersectionTypeAnnotation", node, opts);
}

function assertMixedTypeAnnotation(node, opts = {}) {
  assert("MixedTypeAnnotation", node, opts);
}

function assertEmptyTypeAnnotation(node, opts = {}) {
  assert("EmptyTypeAnnotation", node, opts);
}

function assertNullableTypeAnnotation(node, opts = {}) {
  assert("NullableTypeAnnotation", node, opts);
}

function assertNumberLiteralTypeAnnotation(node, opts = {}) {
  assert("NumberLiteralTypeAnnotation", node, opts);
}

function assertNumberTypeAnnotation(node, opts = {}) {
  assert("NumberTypeAnnotation", node, opts);
}

function assertObjectTypeAnnotation(node, opts = {}) {
  assert("ObjectTypeAnnotation", node, opts);
}

function assertObjectTypeInternalSlot(node, opts = {}) {
  assert("ObjectTypeInternalSlot", node, opts);
}

function assertObjectTypeCallProperty(node, opts = {}) {
  assert("ObjectTypeCallProperty", node, opts);
}

function assertObjectTypeIndexer(node, opts = {}) {
  assert("ObjectTypeIndexer", node, opts);
}

function assertObjectTypeProperty(node, opts = {}) {
  assert("ObjectTypeProperty", node, opts);
}

function assertObjectTypeSpreadProperty(node, opts = {}) {
  assert("ObjectTypeSpreadProperty", node, opts);
}

function assertOpaqueType(node, opts = {}) {
  assert("OpaqueType", node, opts);
}

function assertQualifiedTypeIdentifier(node, opts = {}) {
  assert("QualifiedTypeIdentifier", node, opts);
}

function assertStringLiteralTypeAnnotation(node, opts = {}) {
  assert("StringLiteralTypeAnnotation", node, opts);
}

function assertStringTypeAnnotation(node, opts = {}) {
  assert("StringTypeAnnotation", node, opts);
}

function assertThisTypeAnnotation(node, opts = {}) {
  assert("ThisTypeAnnotation", node, opts);
}

function assertTupleTypeAnnotation(node, opts = {}) {
  assert("TupleTypeAnnotation", node, opts);
}

function assertTypeofTypeAnnotation(node, opts = {}) {
  assert("TypeofTypeAnnotation", node, opts);
}

function assertTypeAlias(node, opts = {}) {
  assert("TypeAlias", node, opts);
}

function assertTypeAnnotation(node, opts = {}) {
  assert("TypeAnnotation", node, opts);
}

function assertTypeCastExpression(node, opts = {}) {
  assert("TypeCastExpression", node, opts);
}

function assertTypeParameter(node, opts = {}) {
  assert("TypeParameter", node, opts);
}

function assertTypeParameterDeclaration(node, opts = {}) {
  assert("TypeParameterDeclaration", node, opts);
}

function assertTypeParameterInstantiation(node, opts = {}) {
  assert("TypeParameterInstantiation", node, opts);
}

function assertUnionTypeAnnotation(node, opts = {}) {
  assert("UnionTypeAnnotation", node, opts);
}

function assertVariance(node, opts = {}) {
  assert("Variance", node, opts);
}

function assertVoidTypeAnnotation(node, opts = {}) {
  assert("VoidTypeAnnotation", node, opts);
}

function assertJSXAttribute(node, opts = {}) {
  assert("JSXAttribute", node, opts);
}

function assertJSXClosingElement(node, opts = {}) {
  assert("JSXClosingElement", node, opts);
}

function assertJSXElement(node, opts = {}) {
  assert("JSXElement", node, opts);
}

function assertJSXEmptyExpression(node, opts = {}) {
  assert("JSXEmptyExpression", node, opts);
}

function assertJSXExpressionContainer(node, opts = {}) {
  assert("JSXExpressionContainer", node, opts);
}

function assertJSXSpreadChild(node, opts = {}) {
  assert("JSXSpreadChild", node, opts);
}

function assertJSXIdentifier(node, opts = {}) {
  assert("JSXIdentifier", node, opts);
}

function assertJSXMemberExpression(node, opts = {}) {
  assert("JSXMemberExpression", node, opts);
}

function assertJSXNamespacedName(node, opts = {}) {
  assert("JSXNamespacedName", node, opts);
}

function assertJSXOpeningElement(node, opts = {}) {
  assert("JSXOpeningElement", node, opts);
}

function assertJSXSpreadAttribute(node, opts = {}) {
  assert("JSXSpreadAttribute", node, opts);
}

function assertJSXText(node, opts = {}) {
  assert("JSXText", node, opts);
}

function assertJSXFragment(node, opts = {}) {
  assert("JSXFragment", node, opts);
}

function assertJSXOpeningFragment(node, opts = {}) {
  assert("JSXOpeningFragment", node, opts);
}

function assertJSXClosingFragment(node, opts = {}) {
  assert("JSXClosingFragment", node, opts);
}

function assertNoop(node, opts = {}) {
  assert("Noop", node, opts);
}

function assertParenthesizedExpression(node, opts = {}) {
  assert("ParenthesizedExpression", node, opts);
}

function assertAwaitExpression(node, opts = {}) {
  assert("AwaitExpression", node, opts);
}

function assertBindExpression(node, opts = {}) {
  assert("BindExpression", node, opts);
}

function assertClassProperty(node, opts = {}) {
  assert("ClassProperty", node, opts);
}

function assertOptionalMemberExpression(node, opts = {}) {
  assert("OptionalMemberExpression", node, opts);
}

function assertPipelineTopicExpression(node, opts = {}) {
  assert("PipelineTopicExpression", node, opts);
}

function assertPipelineBareFunction(node, opts = {}) {
  assert("PipelineBareFunction", node, opts);
}

function assertPipelinePrimaryTopicReference(node, opts = {}) {
  assert("PipelinePrimaryTopicReference", node, opts);
}

function assertOptionalCallExpression(node, opts = {}) {
  assert("OptionalCallExpression", node, opts);
}

function assertClassPrivateProperty(node, opts = {}) {
  assert("ClassPrivateProperty", node, opts);
}

function assertClassPrivateMethod(node, opts = {}) {
  assert("ClassPrivateMethod", node, opts);
}

function assertImport(node, opts = {}) {
  assert("Import", node, opts);
}

function assertDecorator(node, opts = {}) {
  assert("Decorator", node, opts);
}

function assertDoExpression(node, opts = {}) {
  assert("DoExpression", node, opts);
}

function assertExportDefaultSpecifier(node, opts = {}) {
  assert("ExportDefaultSpecifier", node, opts);
}

function assertExportNamespaceSpecifier(node, opts = {}) {
  assert("ExportNamespaceSpecifier", node, opts);
}

function assertPrivateName(node, opts = {}) {
  assert("PrivateName", node, opts);
}

function assertBigIntLiteral(node, opts = {}) {
  assert("BigIntLiteral", node, opts);
}

function assertTSParameterProperty(node, opts = {}) {
  assert("TSParameterProperty", node, opts);
}

function assertTSDeclareFunction(node, opts = {}) {
  assert("TSDeclareFunction", node, opts);
}

function assertTSDeclareMethod(node, opts = {}) {
  assert("TSDeclareMethod", node, opts);
}

function assertTSQualifiedName(node, opts = {}) {
  assert("TSQualifiedName", node, opts);
}

function assertTSCallSignatureDeclaration(node, opts = {}) {
  assert("TSCallSignatureDeclaration", node, opts);
}

function assertTSConstructSignatureDeclaration(node, opts = {}) {
  assert("TSConstructSignatureDeclaration", node, opts);
}

function assertTSPropertySignature(node, opts = {}) {
  assert("TSPropertySignature", node, opts);
}

function assertTSMethodSignature(node, opts = {}) {
  assert("TSMethodSignature", node, opts);
}

function assertTSIndexSignature(node, opts = {}) {
  assert("TSIndexSignature", node, opts);
}

function assertTSAnyKeyword(node, opts = {}) {
  assert("TSAnyKeyword", node, opts);
}

function assertTSUnknownKeyword(node, opts = {}) {
  assert("TSUnknownKeyword", node, opts);
}

function assertTSNumberKeyword(node, opts = {}) {
  assert("TSNumberKeyword", node, opts);
}

function assertTSObjectKeyword(node, opts = {}) {
  assert("TSObjectKeyword", node, opts);
}

function assertTSBooleanKeyword(node, opts = {}) {
  assert("TSBooleanKeyword", node, opts);
}

function assertTSStringKeyword(node, opts = {}) {
  assert("TSStringKeyword", node, opts);
}

function assertTSSymbolKeyword(node, opts = {}) {
  assert("TSSymbolKeyword", node, opts);
}

function assertTSVoidKeyword(node, opts = {}) {
  assert("TSVoidKeyword", node, opts);
}

function assertTSUndefinedKeyword(node, opts = {}) {
  assert("TSUndefinedKeyword", node, opts);
}

function assertTSNullKeyword(node, opts = {}) {
  assert("TSNullKeyword", node, opts);
}

function assertTSNeverKeyword(node, opts = {}) {
  assert("TSNeverKeyword", node, opts);
}

function assertTSThisType(node, opts = {}) {
  assert("TSThisType", node, opts);
}

function assertTSFunctionType(node, opts = {}) {
  assert("TSFunctionType", node, opts);
}

function assertTSConstructorType(node, opts = {}) {
  assert("TSConstructorType", node, opts);
}

function assertTSTypeReference(node, opts = {}) {
  assert("TSTypeReference", node, opts);
}

function assertTSTypePredicate(node, opts = {}) {
  assert("TSTypePredicate", node, opts);
}

function assertTSTypeQuery(node, opts = {}) {
  assert("TSTypeQuery", node, opts);
}

function assertTSTypeLiteral(node, opts = {}) {
  assert("TSTypeLiteral", node, opts);
}

function assertTSArrayType(node, opts = {}) {
  assert("TSArrayType", node, opts);
}

function assertTSTupleType(node, opts = {}) {
  assert("TSTupleType", node, opts);
}

function assertTSOptionalType(node, opts = {}) {
  assert("TSOptionalType", node, opts);
}

function assertTSRestType(node, opts = {}) {
  assert("TSRestType", node, opts);
}

function assertTSUnionType(node, opts = {}) {
  assert("TSUnionType", node, opts);
}

function assertTSIntersectionType(node, opts = {}) {
  assert("TSIntersectionType", node, opts);
}

function assertTSConditionalType(node, opts = {}) {
  assert("TSConditionalType", node, opts);
}

function assertTSInferType(node, opts = {}) {
  assert("TSInferType", node, opts);
}

function assertTSParenthesizedType(node, opts = {}) {
  assert("TSParenthesizedType", node, opts);
}

function assertTSTypeOperator(node, opts = {}) {
  assert("TSTypeOperator", node, opts);
}

function assertTSIndexedAccessType(node, opts = {}) {
  assert("TSIndexedAccessType", node, opts);
}

function assertTSMappedType(node, opts = {}) {
  assert("TSMappedType", node, opts);
}

function assertTSLiteralType(node, opts = {}) {
  assert("TSLiteralType", node, opts);
}

function assertTSExpressionWithTypeArguments(node, opts = {}) {
  assert("TSExpressionWithTypeArguments", node, opts);
}

function assertTSInterfaceDeclaration(node, opts = {}) {
  assert("TSInterfaceDeclaration", node, opts);
}

function assertTSInterfaceBody(node, opts = {}) {
  assert("TSInterfaceBody", node, opts);
}

function assertTSTypeAliasDeclaration(node, opts = {}) {
  assert("TSTypeAliasDeclaration", node, opts);
}

function assertTSAsExpression(node, opts = {}) {
  assert("TSAsExpression", node, opts);
}

function assertTSTypeAssertion(node, opts = {}) {
  assert("TSTypeAssertion", node, opts);
}

function assertTSEnumDeclaration(node, opts = {}) {
  assert("TSEnumDeclaration", node, opts);
}

function assertTSEnumMember(node, opts = {}) {
  assert("TSEnumMember", node, opts);
}

function assertTSModuleDeclaration(node, opts = {}) {
  assert("TSModuleDeclaration", node, opts);
}

function assertTSModuleBlock(node, opts = {}) {
  assert("TSModuleBlock", node, opts);
}

function assertTSImportType(node, opts = {}) {
  assert("TSImportType", node, opts);
}

function assertTSImportEqualsDeclaration(node, opts = {}) {
  assert("TSImportEqualsDeclaration", node, opts);
}

function assertTSExternalModuleReference(node, opts = {}) {
  assert("TSExternalModuleReference", node, opts);
}

function assertTSNonNullExpression(node, opts = {}) {
  assert("TSNonNullExpression", node, opts);
}

function assertTSExportAssignment(node, opts = {}) {
  assert("TSExportAssignment", node, opts);
}

function assertTSNamespaceExportDeclaration(node, opts = {}) {
  assert("TSNamespaceExportDeclaration", node, opts);
}

function assertTSTypeAnnotation(node, opts = {}) {
  assert("TSTypeAnnotation", node, opts);
}

function assertTSTypeParameterInstantiation(node, opts = {}) {
  assert("TSTypeParameterInstantiation", node, opts);
}

function assertTSTypeParameterDeclaration(node, opts = {}) {
  assert("TSTypeParameterDeclaration", node, opts);
}

function assertTSTypeParameter(node, opts = {}) {
  assert("TSTypeParameter", node, opts);
}

function assertExpression(node, opts = {}) {
  assert("Expression", node, opts);
}

function assertBinary(node, opts = {}) {
  assert("Binary", node, opts);
}

function assertScopable(node, opts = {}) {
  assert("Scopable", node, opts);
}

function assertBlockParent(node, opts = {}) {
  assert("BlockParent", node, opts);
}

function assertBlock(node, opts = {}) {
  assert("Block", node, opts);
}

function assertStatement(node, opts = {}) {
  assert("Statement", node, opts);
}

function assertTerminatorless(node, opts = {}) {
  assert("Terminatorless", node, opts);
}

function assertCompletionStatement(node, opts = {}) {
  assert("CompletionStatement", node, opts);
}

function assertConditional(node, opts = {}) {
  assert("Conditional", node, opts);
}

function assertLoop(node, opts = {}) {
  assert("Loop", node, opts);
}

function assertWhile(node, opts = {}) {
  assert("While", node, opts);
}

function assertExpressionWrapper(node, opts = {}) {
  assert("ExpressionWrapper", node, opts);
}

function assertFor(node, opts = {}) {
  assert("For", node, opts);
}

function assertForXStatement(node, opts = {}) {
  assert("ForXStatement", node, opts);
}

function assertFunction(node, opts = {}) {
  assert("Function", node, opts);
}

function assertFunctionParent(node, opts = {}) {
  assert("FunctionParent", node, opts);
}

function assertPureish(node, opts = {}) {
  assert("Pureish", node, opts);
}

function assertDeclaration(node, opts = {}) {
  assert("Declaration", node, opts);
}

function assertPatternLike(node, opts = {}) {
  assert("PatternLike", node, opts);
}

function assertLVal(node, opts = {}) {
  assert("LVal", node, opts);
}

function assertTSEntityName(node, opts = {}) {
  assert("TSEntityName", node, opts);
}

function assertLiteral(node, opts = {}) {
  assert("Literal", node, opts);
}

function assertImmutable(node, opts = {}) {
  assert("Immutable", node, opts);
}

function assertUserWhitespacable(node, opts = {}) {
  assert("UserWhitespacable", node, opts);
}

function assertMethod(node, opts = {}) {
  assert("Method", node, opts);
}

function assertObjectMember(node, opts = {}) {
  assert("ObjectMember", node, opts);
}

function assertProperty(node, opts = {}) {
  assert("Property", node, opts);
}

function assertUnaryLike(node, opts = {}) {
  assert("UnaryLike", node, opts);
}

function assertPattern(node, opts = {}) {
  assert("Pattern", node, opts);
}

function assertClass(node, opts = {}) {
  assert("Class", node, opts);
}

function assertModuleDeclaration(node, opts = {}) {
  assert("ModuleDeclaration", node, opts);
}

function assertExportDeclaration(node, opts = {}) {
  assert("ExportDeclaration", node, opts);
}

function assertModuleSpecifier(node, opts = {}) {
  assert("ModuleSpecifier", node, opts);
}

function assertFlow(node, opts = {}) {
  assert("Flow", node, opts);
}

function assertFlowType(node, opts = {}) {
  assert("FlowType", node, opts);
}

function assertFlowBaseAnnotation(node, opts = {}) {
  assert("FlowBaseAnnotation", node, opts);
}

function assertFlowDeclaration(node, opts = {}) {
  assert("FlowDeclaration", node, opts);
}

function assertFlowPredicate(node, opts = {}) {
  assert("FlowPredicate", node, opts);
}

function assertJSX(node, opts = {}) {
  assert("JSX", node, opts);
}

function assertPrivate(node, opts = {}) {
  assert("Private", node, opts);
}

function assertTSTypeElement(node, opts = {}) {
  assert("TSTypeElement", node, opts);
}

function assertTSType(node, opts = {}) {
  assert("TSType", node, opts);
}

function assertNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  assert("NumberLiteral", node, opts);
}

function assertRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}

function assertRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}

function assertSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  assert("SpreadProperty", node, opts);
}

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTypeAnnotationBasedOnTypeof;

var _generated = __webpack_require__(30);

function createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return (0, _generated.stringTypeAnnotation)();
  } else if (type === "number") {
    return (0, _generated.numberTypeAnnotation)();
  } else if (type === "undefined") {
    return (0, _generated.voidTypeAnnotation)();
  } else if (type === "boolean") {
    return (0, _generated.booleanTypeAnnotation)();
  } else if (type === "function") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
  } else if (type === "object") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
  } else if (type === "symbol") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createUnionTypeAnnotation;

var _generated = __webpack_require__(30);

var _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(165));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createUnionTypeAnnotation(types) {
  const flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.unionTypeAnnotation)(flattened);
  }
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = __webpack_require__(25);

function removeTypeDuplicates(nodes) {
  const generics = {};
  const bases = {};
  const typeGroups = [];
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isAnyTypeAnnotation)(node)) {
      return [node];
    }

    if ((0, _generated.isFlowBaseAnnotation)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isUnionTypeAnnotation)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    if ((0, _generated.isGenericTypeAnnotation)(node)) {
      const name = node.id.name;

      if (generics[name]) {
        let existing = generics[name];

        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (const type in bases) {
    types.push(bases[type]);
  }

  for (const name in generics) {
    types.push(generics[name]);
  }

  return types;
}

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneNode;

var _definitions = __webpack_require__(141);

const has = Function.call.bind(Object.prototype.hasOwnProperty);

function cloneIfNode(obj, deep) {
  if (obj && typeof obj.type === "string" && obj.type !== "CommentLine" && obj.type !== "CommentBlock") {
    return cloneNode(obj, deep);
  }

  return obj;
}

function cloneIfNodeOrArray(obj, deep) {
  if (Array.isArray(obj)) {
    return obj.map(node => cloneIfNode(node, deep));
  }

  return cloneIfNode(obj, deep);
}

function cloneNode(node, deep = true) {
  if (!node) return node;
  const {
    type
  } = node;
  const newNode = {
    type
  };

  if (type === "Identifier") {
    newNode.name = node.name;

    if (has(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    }

    if (has(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true) : node.typeAnnotation;
    }
  } else if (!has(_definitions.NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type}"`);
  } else {
    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
      if (has(node, field)) {
        newNode[field] = deep ? cloneIfNodeOrArray(node[field], true) : node[field];
      }
    }
  }

  if (has(node, "loc")) {
    newNode.loc = node.loc;
  }

  if (has(node, "leadingComments")) {
    newNode.leadingComments = node.leadingComments;
  }

  if (has(node, "innerComments")) {
    newNode.innerComments = node.innerCmments;
  }

  if (has(node, "trailingComments")) {
    newNode.trailingComments = node.trailingComments;
  }

  if (has(node, "extra")) {
    newNode.extra = Object.assign({}, node.extra);
  }

  return newNode;
}

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clone;

var _cloneNode = _interopRequireDefault(__webpack_require__(166));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function clone(node) {
  return (0, _cloneNode.default)(node, false);
}

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeep;

var _cloneNode = _interopRequireDefault(__webpack_require__(166));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeep(node) {
  return (0, _cloneNode.default)(node);
}

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneWithoutLoc;

var _clone = _interopRequireDefault(__webpack_require__(167));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneWithoutLoc(node) {
  const newNode = (0, _clone.default)(node);
  newNode.loc = null;
  return newNode;
}

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComment;

var _addComments = _interopRequireDefault(__webpack_require__(171));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addComment(node, type, content, line) {
  return (0, _addComments.default)(node, type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComments;

function addComments(node, type, comments) {
  if (!comments || !node) return node;
  const key = `${type}Comments`;

  if (node[key]) {
    if (type === "leading") {
      node[key] = comments.concat(node[key]);
    } else {
      node[key] = node[key].concat(comments);
    }
  } else {
    node[key] = comments;
  }

  return node;
}

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritInnerComments;

var _inherit = _interopRequireDefault(__webpack_require__(173));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritInnerComments(child, parent) {
  (0, _inherit.default)("innerComments", child, parent);
}

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherit;

function _uniq() {
  const data = _interopRequireDefault(__webpack_require__(174));

  _uniq = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inherit(key, child, parent) {
  if (child && parent) {
    child[key] = (0, _uniq().default)([].concat(child[key], parent[key]).filter(Boolean));
  }
}

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var baseUniq = __webpack_require__(175);

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? baseUniq(array) : [];
}

module.exports = uniq;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(176),
    arrayIncludes = __webpack_require__(179),
    arrayIncludesWith = __webpack_require__(184),
    cacheHas = __webpack_require__(185),
    createSet = __webpack_require__(186),
    setToArray = __webpack_require__(188);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(63),
    setCacheAdd = __webpack_require__(177),
    setCacheHas = __webpack_require__(178);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 177 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(180);

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(181),
    baseIsNaN = __webpack_require__(182),
    strictIndexOf = __webpack_require__(183);

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),
/* 181 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),
/* 182 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),
/* 183 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),
/* 184 */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),
/* 185 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(125),
    noop = __webpack_require__(187),
    setToArray = __webpack_require__(188);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),
/* 187 */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),
/* 188 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritLeadingComments;

var _inherit = _interopRequireDefault(__webpack_require__(173));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritLeadingComments(child, parent) {
  (0, _inherit.default)("leadingComments", child, parent);
}

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritsComments;

var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(191));

var _inheritLeadingComments = _interopRequireDefault(__webpack_require__(189));

var _inheritInnerComments = _interopRequireDefault(__webpack_require__(172));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritsComments(child, parent) {
  (0, _inheritTrailingComments.default)(child, parent);
  (0, _inheritLeadingComments.default)(child, parent);
  (0, _inheritInnerComments.default)(child, parent);
  return child;
}

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritTrailingComments;

var _inherit = _interopRequireDefault(__webpack_require__(173));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritTrailingComments(child, parent) {
  (0, _inherit.default)("trailingComments", child, parent);
}

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeComments;

var _constants = __webpack_require__(149);

function removeComments(node) {
  _constants.COMMENT_KEYS.forEach(key => {
    node[key] = null;
  });

  return node;
}

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

var _definitions = __webpack_require__(141);

const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ensureBlock;

var _toBlock = _interopRequireDefault(__webpack_require__(195));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ensureBlock(node, key = "body") {
  return node[key] = (0, _toBlock.default)(node[key], node);
}

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBlock;

var _generated = __webpack_require__(25);

var _generated2 = __webpack_require__(30);

function toBlock(node, parent) {
  if ((0, _generated.isBlockStatement)(node)) {
    return node;
  }

  let blockNodes = [];

  if ((0, _generated.isEmptyStatement)(node)) {
    blockNodes = [];
  } else {
    if (!(0, _generated.isStatement)(node)) {
      if ((0, _generated.isFunction)(parent)) {
        node = (0, _generated2.returnStatement)(node);
      } else {
        node = (0, _generated2.expressionStatement)(node);
      }
    }

    blockNodes = [node];
  }

  return (0, _generated2.blockStatement)(blockNodes);
}

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBindingIdentifierName;

var _toIdentifier = _interopRequireDefault(__webpack_require__(197));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBindingIdentifierName(name) {
  name = (0, _toIdentifier.default)(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toIdentifier;

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(144));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toIdentifier(name) {
  name = name + "";
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
  name = name.replace(/^[-0-9]+/, "");
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!(0, _isValidIdentifier.default)(name)) {
    name = `_${name}`;
  }

  return name || "_";
}

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toComputedKey;

var _generated = __webpack_require__(25);

var _generated2 = __webpack_require__(30);

function toComputedKey(node, key = node.key || node.property) {
  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
  return key;
}

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toExpression;

var _generated = __webpack_require__(25);

function toExpression(node) {
  if ((0, _generated.isExpressionStatement)(node)) {
    node = node.expression;
  }

  if ((0, _generated.isExpression)(node)) {
    return node;
  }

  if ((0, _generated.isClass)(node)) {
    node.type = "ClassExpression";
  } else if ((0, _generated.isFunction)(node)) {
    node.type = "FunctionExpression";
  }

  if (!(0, _generated.isExpression)(node)) {
    throw new Error(`cannot turn ${node.type} to an expression`);
  }

  return node;
}

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toKeyAlias;

var _generated = __webpack_require__(25);

var _cloneNode = _interopRequireDefault(__webpack_require__(166));

var _removePropertiesDeep = _interopRequireDefault(__webpack_require__(201));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toKeyAlias(node, key = node.key) {
  let alias;

  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if ((0, _generated.isIdentifier)(key)) {
    alias = key.name;
  } else if ((0, _generated.isStringLiteral)(key)) {
    alias = JSON.stringify(key.value);
  } else {
    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
  }

  if (node.computed) {
    alias = `[${alias}]`;
  }

  if (node.static) {
    alias = `static:${alias}`;
  }

  return alias;
}

toKeyAlias.uid = 0;

toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
    return toKeyAlias.uid = 0;
  } else {
    return toKeyAlias.uid++;
  }
};

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removePropertiesDeep;

var _traverseFast = _interopRequireDefault(__webpack_require__(202));

var _removeProperties = _interopRequireDefault(__webpack_require__(203));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removePropertiesDeep(tree, opts) {
  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
  return tree;
}

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverseFast;

var _definitions = __webpack_require__(141);

function traverseFast(node, enter, opts) {
  if (!node) return;
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  opts = opts || {};
  enter(node, opts);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (const node of subNode) {
        traverseFast(node, enter, opts);
      }
    } else {
      traverseFast(subNode, enter, opts);
    }
  }
}

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeProperties;

var _constants = __webpack_require__(149);

const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

function removeProperties(node, opts = {}) {
  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

  for (const key of map) {
    if (node[key] != null) node[key] = undefined;
  }

  for (const key in node) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }

  const symbols = Object.getOwnPropertySymbols(node);

  for (const sym of symbols) {
    node[sym] = null;
  }
}

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toSequenceExpression;

var _gatherSequenceExpressions = _interopRequireDefault(__webpack_require__(205));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toSequenceExpression(nodes, scope) {
  if (!nodes || !nodes.length) return;
  const declars = [];
  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
  if (!result) return;

  for (const declar of declars) {
    scope.push(declar);
  }

  return result;
}

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gatherSequenceExpressions;

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(206));

var _generated = __webpack_require__(25);

var _generated2 = __webpack_require__(30);

var _cloneNode = _interopRequireDefault(__webpack_require__(166));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gatherSequenceExpressions(nodes, scope, declars) {
  const exprs = [];
  let ensureLastUndefined = true;

  for (const node of nodes) {
    ensureLastUndefined = false;

    if ((0, _generated.isExpression)(node)) {
      exprs.push(node);
    } else if ((0, _generated.isExpressionStatement)(node)) {
      exprs.push(node.expression);
    } else if ((0, _generated.isVariableDeclaration)(node)) {
      if (node.kind !== "var") return;

      for (const declar of node.declarations) {
        const bindings = (0, _getBindingIdentifiers.default)(declar);

        for (const key in bindings) {
          declars.push({
            kind: node.kind,
            id: (0, _cloneNode.default)(bindings[key])
          });
        }

        if (declar.init) {
          exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
        }
      }

      ensureLastUndefined = true;
    } else if ((0, _generated.isIfStatement)(node)) {
      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
      if (!consequent || !alternate) return;
      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
    } else if ((0, _generated.isBlockStatement)(node)) {
      const body = gatherSequenceExpressions(node.body, scope, declars);
      if (!body) return;
      exprs.push(body);
    } else if ((0, _generated.isEmptyStatement)(node)) {
      ensureLastUndefined = true;
    } else {
      return;
    }
  }

  if (ensureLastUndefined) {
    exprs.push(scope.buildUndefinedNode());
  }

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return (0, _generated2.sequenceExpression)(exprs);
  }
}

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBindingIdentifiers;

var _generated = __webpack_require__(25);

function getBindingIdentifiers(node, duplicates, outerOnly) {
  let search = [].concat(node);
  const ids = Object.create(null);

  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    const keys = getBindingIdentifiers.keys[id.type];

    if ((0, _generated.isIdentifier)(id)) {
      if (duplicates) {
        const _ids = ids[id.name] = ids[id.name] || [];

        _ids.push(id);
      } else {
        ids[id.name] = id;
      }

      continue;
    }

    if ((0, _generated.isExportDeclaration)(id)) {
      if ((0, _generated.isDeclaration)(id.declaration)) {
        search.push(id.declaration);
      }

      continue;
    }

    if (outerOnly) {
      if ((0, _generated.isFunctionDeclaration)(id)) {
        search.push(id.id);
        continue;
      }

      if ((0, _generated.isFunctionExpression)(id)) {
        continue;
      }
    }

    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toStatement;

var _generated = __webpack_require__(25);

var _generated2 = __webpack_require__(30);

function toStatement(node, ignore) {
  if ((0, _generated.isStatement)(node)) {
    return node;
  }

  let mustHaveId = false;
  let newType;

  if ((0, _generated.isClass)(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if ((0, _generated.isFunction)(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if ((0, _generated.isAssignmentExpression)(node)) {
    return (0, _generated2.expressionStatement)(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error(`cannot turn ${node.type} to a statement`);
    }
  }

  node.type = newType;
  return node;
}

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = valueToNode;

function _isPlainObject() {
  const data = _interopRequireDefault(__webpack_require__(209));

  _isPlainObject = function () {
    return data;
  };

  return data;
}

function _isRegExp() {
  const data = _interopRequireDefault(__webpack_require__(210));

  _isRegExp = function () {
    return data;
  };

  return data;
}

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(144));

var _generated = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function valueToNode(value) {
  if (value === undefined) {
    return (0, _generated.identifier)("undefined");
  }

  if (value === true || value === false) {
    return (0, _generated.booleanLiteral)(value);
  }

  if (value === null) {
    return (0, _generated.nullLiteral)();
  }

  if (typeof value === "string") {
    return (0, _generated.stringLiteral)(value);
  }

  if (typeof value === "number") {
    let result;

    if (Number.isFinite(value)) {
      result = (0, _generated.numericLiteral)(Math.abs(value));
    } else {
      let numerator;

      if (Number.isNaN(value)) {
        numerator = (0, _generated.numericLiteral)(0);
      } else {
        numerator = (0, _generated.numericLiteral)(1);
      }

      result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
    }

    if (value < 0 || Object.is(value, -0)) {
      result = (0, _generated.unaryExpression)("-", result);
    }

    return result;
  }

  if ((0, _isRegExp().default)(value)) {
    const pattern = value.source;
    const flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return (0, _generated.regExpLiteral)(pattern, flags);
  }

  if (Array.isArray(value)) {
    return (0, _generated.arrayExpression)(value.map(valueToNode));
  }

  if ((0, _isPlainObject().default)(value)) {
    const props = [];

    for (const key in value) {
      let nodeKey;

      if ((0, _isValidIdentifier.default)(key)) {
        nodeKey = (0, _generated.identifier)(key);
      } else {
        nodeKey = (0, _generated.stringLiteral)(key);
      }

      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
    }

    return (0, _generated.objectExpression)(props);
  }

  throw new Error("don't know how to turn this value into a node");
}

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(52),
    getPrototype = __webpack_require__(118),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsRegExp = __webpack_require__(211),
    baseUnary = __webpack_require__(98),
    nodeUtil = __webpack_require__(99);

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(52),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = appendToMemberExpression;

var _generated = __webpack_require__(30);

function appendToMemberExpression(member, append, computed = false) {
  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherits;

var _constants = __webpack_require__(149);

var _inheritsComments = _interopRequireDefault(__webpack_require__(190));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inherits(child, parent) {
  if (!child || !parent) return child;

  for (const key of _constants.INHERIT_KEYS.optional) {
    if (child[key] == null) {
      child[key] = parent[key];
    }
  }

  for (const key in parent) {
    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
  }

  for (const key of _constants.INHERIT_KEYS.force) {
    child[key] = parent[key];
  }

  (0, _inheritsComments.default)(child, parent);
  return child;
}

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prependToMemberExpression;

var _generated = __webpack_require__(30);

function prependToMemberExpression(member, prepend) {
  member.object = (0, _generated.memberExpression)(prepend, member.object);
  return member;
}

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOuterBindingIdentifiers;

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(206));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOuterBindingIdentifiers(node, duplicates) {
  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;

var _definitions = __webpack_require__(141);

function traverse(node, handlers, state) {
  if (typeof handlers === "function") {
    handlers = {
      enter: handlers
    };
  }

  const {
    enter,
    exit
  } = handlers;
  traverseSimpleImpl(node, enter, exit, state, []);
}

function traverseSimpleImpl(node, enter, exit, state, ancestors) {
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  if (enter) enter(node, ancestors, state);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (let i = 0; i < subNode.length; i++) {
        const child = subNode[i];
        if (!child) continue;
        ancestors.push({
          node,
          key,
          index: i
        });
        traverseSimpleImpl(child, enter, exit, state, ancestors);
        ancestors.pop();
      }
    } else if (subNode) {
      ancestors.push({
        node,
        key
      });
      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
      ancestors.pop();
    }
  }

  if (exit) exit(node, ancestors, state);
}

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBinding;

var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(206));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBinding(node, parent) {
  const keys = _getBindingIdentifiers.default.keys[parent.type];

  if (keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const val = parent[key];

      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBlockScoped;

var _generated = __webpack_require__(25);

var _isLet = _interopRequireDefault(__webpack_require__(219));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBlockScoped(node) {
  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isLet;

var _generated = __webpack_require__(25);

var _constants = __webpack_require__(149);

function isLet(node) {
  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isImmutable;

var _isType = _interopRequireDefault(__webpack_require__(152));

var _generated = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isImmutable(node) {
  if ((0, _isType.default)(node.type, "Immutable")) return true;

  if ((0, _generated.isIdentifier)(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNodesEquivalent;

var _definitions = __webpack_require__(141);

function isNodesEquivalent(a, b) {
  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
    return a === b;
  }

  if (a.type !== b.type) {
    return false;
  }

  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
  const visitorKeys = _definitions.VISITOR_KEYS[a.type];

  for (const field of fields) {
    if (typeof a[field] !== typeof b[field]) {
      return false;
    }

    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }

      if (a[field].length !== b[field].length) {
        return false;
      }

      for (let i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }

      continue;
    }

    if (typeof a[field] === "object" && (!visitorKeys || !visitorKeys.includes(field))) {
      for (const key in a[field]) {
        if (a[field][key] !== b[field][key]) {
          return false;
        }
      }

      continue;
    }

    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isReferenced;

function isReferenced(node, parent) {
  switch (parent.type) {
    case "MemberExpression":
    case "JSXMemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }

      return parent.object === node;

    case "VariableDeclarator":
      return parent.init === node;

    case "ArrowFunctionExpression":
      return parent.body === node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      }

      return parent.local === node;

    case "ObjectProperty":
    case "ClassProperty":
    case "ClassPrivateProperty":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.key === node) {
        return !!parent.computed;
      }

      return parent.value === node;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return false;

    case "RestElement":
      return false;

    case "BreakStatement":
    case "ContinueStatement":
      return false;

    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "JSXAttribute":
      return false;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;

    case "MetaProperty":
      return false;

    case "ObjectTypeProperty":
      return parent.key !== node;
  }

  return true;
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isScope;

var _generated = __webpack_require__(25);

function isScope(node, parent) {
  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
    body: node
  })) {
    return false;
  }

  return (0, _generated.isScopable)(node);
}

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isSpecifierDefault;

var _generated = __webpack_require__(25);

function isSpecifierDefault(specifier) {
  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
    name: "default"
  });
}

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidES3Identifier;

var _isValidIdentifier = _interopRequireDefault(__webpack_require__(144));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

function isValidES3Identifier(name) {
  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isVar;

var _generated = __webpack_require__(25);

var _constants = __webpack_require__(149);

function isVar(node) {
  return (0, _generated.isVariableDeclaration)(node, {
    kind: "var"
  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _construct = __webpack_require__(228);

var _traverseFast = _interopRequireDefault(__webpack_require__(279));

var _parser = __webpack_require__(247);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, code, filename, sourceType = "script", startLine = 1) {
  try {
    let plugins = ["objectRestSpread"];

    if (realm.react.enabled) {
      plugins.push("jsx");
    }

    if (realm.stripFlow) {
      plugins.push("flow");
    }

    let ast = (0, _parser.parse)(code, {
      filename,
      sourceType,
      startLine,
      plugins
    });
    (0, _traverseFast.default)(ast, node => {
      (0, _invariant.default)(node.loc);
      node.loc.source = filename;
      return false;
    });
    return ast;
  } catch (e) {
    if (e instanceof SyntaxError) {
      // Babel reports all errors as syntax errors, even if a ReferenceError should be thrown.
      // What we do here is a totally robust way to address that issue.
      let referenceErrors = ["Invalid left-hand side in postfix operation", "Invalid left-hand side in prefix operation", "Invalid left-hand side in assignment expression"];
      let error;

      if (referenceErrors.some(msg => e.message.indexOf(msg) >= 0)) {
        error = (0, _construct.Construct)(realm, realm.intrinsics.ReferenceError, [new _index.StringValue(realm, e.message)]);
      } else {
        error = (0, _construct.Construct)(realm, realm.intrinsics.SyntaxError, [new _index.StringValue(realm, e.message)]);
      }

      error = error.throwIfNotConcreteObject(); // These constructors are currently guaranteed to produce an object with
      // built-in error data. Append location information about the syntax error
      // and the source code to it so that we can use it to print nicer errors.

      (0, _invariant.default)(error.$ErrorData);
      error.$ErrorData.locationData = {
        filename: filename,
        sourceCode: code,
        loc: e.loc,
        stackDecorated: false
      };
      throw new _completions.ThrowCompletion(error, e.loc);
    } else {
      throw e;
    }
  }
}
//# sourceMappingURL=parse.js.map

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MakeConstructor = MakeConstructor;
exports.Construct = Construct;
exports.SpeciesConstructor = SpeciesConstructor;
exports.MakeClassConstructor = MakeClassConstructor;
exports.ConstructorMethod = ConstructorMethod;
exports.NonConstructorMethodDefinitions = NonConstructorMethodDefinitions;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _get = __webpack_require__(230);

var _has = __webpack_require__(269);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 9.2.8
function MakeConstructor(realm, F, _writablePrototype, _prototype) {
  let writablePrototype = _writablePrototype;
  let prototype = _prototype; // 1. Assert: F is an ECMAScript function object.

  (0, _invariant.default)(F instanceof _index.ECMAScriptSourceFunctionValue, "expected function value"); // 2. Assert: F has a [[Construct]] internal method.

  (0, _invariant.default)(F.$Construct !== undefined, "expected construct internal method"); // 3. Assert: F is an extensible object that does not have a prototype own property.

  (0, _invariant.default)(F.getExtensible(), "expected extensible object that doesn't have prototype own property"); // 4. If the writablePrototype argument was not provided, let writablePrototype be true.

  if (writablePrototype === null || writablePrototype === undefined) {
    writablePrototype = true;
  } // 5. If the prototype argument was not provided, then


  if (!prototype) {
    // a. Let prototype be ObjectCreate(%ObjectPrototype%).
    prototype = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);
    prototype.originalConstructor = F; // b. Perform ! DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor{[[Value]]: F, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }).

    _singletons.Properties.DefinePropertyOrThrow(realm, prototype, "constructor", new _descriptors.PropertyDescriptor({
      value: F,
      writable: writablePrototype,
      enumerable: false,
      configurable: true
    }));
  } // 6. Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false}).


  _singletons.Properties.DefinePropertyOrThrow(realm, F, "prototype", new _descriptors.PropertyDescriptor({
    value: prototype,
    writable: writablePrototype,
    enumerable: false,
    configurable: false
  })); // 7. Return NormalCompletion(undefined).


  return realm.intrinsics.undefined;
} // ECMA262 7.3.13


function Construct(realm, F, _argumentsList, _newTarget) {
  let argumentsList = _argumentsList;
  let newTarget = _newTarget; // If newTarget was not passed, let newTarget be F.

  if (!newTarget) newTarget = F; // If argumentsList was not passed, let argumentsList be a new empty List.

  if (!argumentsList) argumentsList = []; // Assert: IsConstructor(F) is true.

  (0, _invariant.default)((0, _is.IsConstructor)(realm, F), "expected constructor"); // Assert: IsConstructor(newTarget) is true.

  (0, _invariant.default)((0, _is.IsConstructor)(realm, newTarget), "expected constructor"); // Return ? F.[[Construct]](argumentsList, newTarget).

  (0, _invariant.default)(F.$Construct !== undefined, "no construct method on realm value");
  return F.$Construct(argumentsList, newTarget);
} // ECMA262 7.3.20


function SpeciesConstructor(realm, O, defaultConstructor) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant.default)(O instanceof _index.ObjectValue, "Type(O) is Object"); // 2. Let C be ? Get(O, "constructor").

  let C = (0, _get.Get)(realm, O, "constructor"); // 3. If C is undefined, return defaultConstructor.

  if (C instanceof _index.UndefinedValue) return defaultConstructor; // 4. If Type(C) is not Object, throw a TypeError exception.

  if (C.mightNotBeObject()) {
    if (C.mightBeObject()) C.throwIfNotConcrete();
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(C) is not an object");
  }

  (0, _invariant.default)(C instanceof _index.ObjectValue || C instanceof _index.AbstractObjectValue); // 5. Let S be ? Get(C, @@species).

  let S = (0, _get.Get)(realm, C, realm.intrinsics.SymbolSpecies); // 6. If S is either undefined or null, return defaultConstructor.

  if ((0, _has.HasSomeCompatibleType)(S, _index.UndefinedValue, _index.NullValue)) return defaultConstructor; // 7. If IsConstructor(S) is true, return S.

  if ((0, _is.IsConstructor)(realm, S)) {
    (0, _invariant.default)(S instanceof _index.ObjectValue);
    return S;
  } // 8. Throw a TypeError exception.


  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Throw a TypeError exception");
} // ECMA 9.2.9


function MakeClassConstructor(realm, F) {
  // 1. Assert: F is an ECMAScript function object.
  (0, _invariant.default)(F instanceof _index.ECMAScriptSourceFunctionValue, "expected function value"); // 2. Assert: Fs [[FunctionKind]] internal slot is "normal".

  (0, _invariant.default)(F.$FunctionKind === "normal"); // 3. Set Fs [[FunctionKind]] internal slot to "classConstructor".

  F.$FunctionKind = "classConstructor"; // 4. Return NormalCompletion(undefined).

  return realm.intrinsics.undefined;
} // ECMA 14.5.3


function ConstructorMethod(realm, ClassElementList) {
  let ClassElement; // ClassElementList : ClassElement

  if (ClassElementList.length === 1) {
    ClassElement = ClassElementList[0]; // 1. If ClassElement is the production ClassElement : ; , return empty.
    // It looks like Babel parses out ClassElements that are only ;
    // 2. If IsStatic of ClassElement is true, return empty.

    if ((0, _is.IsStatic)(ClassElement)) {
      return realm.intrinsics.empty;
    } // 3. If PropName of ClassElement is not "constructor", return empty.


    if (ClassElement.key.name !== "constructor") {
      return realm.intrinsics.empty;
    } // 4. Return ClassElement.


    return ClassElement;
  } else {
    // ClassElementList : ClassElementList ClassElement
    // 1. Let head be ConstructorMethod of ClassElementList.
    let head = ConstructorMethod(realm, ClassElementList.slice(0, -1)); // 2. If head is not empty, return head.

    if (!(head instanceof _index.EmptyValue)) {
      return head;
    }

    ClassElement = ClassElementList[ClassElementList.length - 1]; // 3. If ClassElement is the production ClassElement : ; , return empty.
    // It looks like Babel parses out ClassElements that are only ;
    // 4. If IsStatic of ClassElement is true, return empty.

    if ((0, _is.IsStatic)(ClassElement)) {
      return realm.intrinsics.empty;
    } // If PropName of ClassElement is not "constructor", return empty.


    if (ClassElement.key.name !== "constructor") {
      return realm.intrinsics.empty;
    } // Return ClassElement.


    return ClassElement;
  }
} // ECMA 14.5.10


function NonConstructorMethodDefinitions(realm, ClassElementList) {
  let ClassElement; // ClassElementList : ClassElement

  if (ClassElementList.length === 1) {
    ClassElement = ClassElementList[0]; // If ClassElement is the production ClassElement : ; , return a new empty List.
    // If IsStatic of ClassElement is false and PropName of ClassElement is "constructor", return a new empty List.

    if (!(0, _is.IsStatic)(ClassElement) && ClassElement.key.name === "constructor") {
      return [];
    } // Return a List containing ClassElement.


    return [ClassElement];
  } else {
    // ClassElementList : ClassElementList ClassElement
    ClassElement = ClassElementList[ClassElementList.length - 1]; // Let list be NonConstructorMethodDefinitions of ClassElementList.

    let list = NonConstructorMethodDefinitions(realm, ClassElementList.slice(0, -1)); // If ClassElement is the production ClassElement : ; , return list.
    // If IsStatic of ClassElement is false and PropName of ClassElement is "constructor", return list.

    if (!(0, _is.IsStatic)(ClassElement) && ClassElement.key.name === "constructor") {
      return list;
    } // Append ClassElement to the end of list.


    list.push(ClassElement); // Return list.

    return list;
  }
}
//# sourceMappingURL=construct.js.map

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsConcatSpreadable = IsConcatSpreadable;
exports.IsGenericDescriptor = IsGenericDescriptor;
exports.IsAccessorDescriptor = IsAccessorDescriptor;
exports.IsDataDescriptor = IsDataDescriptor;
exports.OrdinaryIsExtensible = OrdinaryIsExtensible;
exports.IsExtensible = IsExtensible;
exports.IsCallable = IsCallable;
exports.IsConstructor = IsConstructor;
exports.IsInteger = IsInteger;
exports.IsPropertyKey = IsPropertyKey;
exports.IsArray = IsArray;
exports.IsInTailPosition = IsInTailPosition;
exports.IsRegExp = IsRegExp;
exports.IsIdentifierRef = IsIdentifierRef;
exports.IsFunctionDefinition = IsFunctionDefinition;
exports.IsAnonymousFunctionDefinition = IsAnonymousFunctionDefinition;
exports.IsArrayIndex = IsArrayIndex;
exports.IsPromise = IsPromise;
exports.IsDetachedBuffer = IsDetachedBuffer;
exports.IsIntrospectionError = IsIntrospectionError;
exports.IsStatic = IsStatic;

var _errors = __webpack_require__(3);

var _get = __webpack_require__(230);

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _has = __webpack_require__(269);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 22.1.3.1.1
function IsConcatSpreadable(realm, _O) {
  let O = _O; // 1. If Type(O) is not Object, return false.

  if (!O.mightBeObject()) return false;
  O = O.throwIfNotObject(); // 2. Let spreadable be ? Get(O, @@isConcatSpreadable).

  let spreadable = (0, _get.Get)(realm, O, realm.intrinsics.SymbolIsConcatSpreadable); // 3. If spreadable is not undefined, return ToBoolean(spreadable).

  if (!spreadable.mightBeUndefined()) return _singletons.To.ToBooleanPartial(realm, spreadable);
  spreadable.throwIfNotConcrete(); // 4. Return ? IsArray(O).

  return IsArray(realm, O);
} // ECMA262 6.2.4.3


function IsGenericDescriptorInternal(realm, Desc) {
  // 1. If Desc is undefined, return false.
  if (!Desc) return false; // 2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, return true.

  if (!IsAccessorDescriptor(realm, Desc) && !IsDataDescriptor(realm, Desc)) return true; // 3. Return false.

  return false;
} // ECMA262 6.2.4.1


function IsAccessorDescriptorInternal(realm, Desc) {
  // 1. If Desc is undefined, return false.
  if (!Desc) return false; // 2. If both Desc.[[Get]] and Desc.[[Set]] are absent, return false.

  Desc = Desc.throwIfNotConcrete(realm);
  if (Desc.get === undefined && Desc.set === undefined) return false; // 3. Return true.

  return true;
} // ECMA262 6.2.4.2


function IsDataDescriptorInternal(realm, Desc) {
  // If Desc is undefined, return false.
  if (!Desc) return false; // If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.

  Desc = Desc.throwIfNotConcrete(realm);
  if (Desc.value === undefined && Desc.writable === undefined) return false; // Return true.

  return true;
} // Flow wrappers that provide refinements using Predicate Functions.
// These wrappers also assert that the type is PropertyDescriptor so that if this returns
// true, then Flow can refine that the type of Desc as PropertyDescriptor.


function IsGenericDescriptor(realm, Desc) {
  return IsGenericDescriptorInternal(realm, Desc) && Desc instanceof _descriptors.PropertyDescriptor;
}

function IsAccessorDescriptor(realm, Desc) {
  return IsAccessorDescriptorInternal(realm, Desc) && Desc instanceof _descriptors.PropertyDescriptor;
}

function IsDataDescriptor(realm, Desc) {
  return IsDataDescriptorInternal(realm, Desc) && Desc instanceof _descriptors.PropertyDescriptor;
} // ECMA262 9.1.3.1


function OrdinaryIsExtensible(realm, O) {
  // 1. Return the value of the [[Extensible]] internal slot of O.
  return O.getExtensible();
} // ECMA262 7.2.5


function IsExtensible(realm, O) {
  // 1. Assert: Type(O) is Object.
  // 2. Return ? O.[[IsExtensible]]().
  return O.$IsExtensible();
} // ECMA262 7.2.3


function IsCallable(realm, _func) {
  let func = _func; // 1. If Type(argument) is not Object, return false.

  if (!func.mightBeObject()) return false;
  if ((0, _has.HasCompatibleType)(func, _index.FunctionValue)) return true;
  if (func.isSimpleObject()) return false;

  if (func instanceof _index.AbstractObjectValue && !func.values.isTop()) {
    let result;

    for (let element of func.values.getElements()) {
      let isCallable = IsCallable(realm, element);
      if (result === undefined) result = isCallable;else if (result !== isCallable) func.throwIfNotConcreteObject();
    }

    if (result !== undefined) return result;
  } // 2. If argument has a [[Call]] internal method, return true.


  func = func.throwIfNotConcreteObject();
  if (func.$Call) return true; // 3. Return false.

  return false;
} // ECMA262 7.2.4


function IsConstructor(realm, _argument) {
  let argument = _argument; // 1. If Type(argument) is not Object, return false.

  if (!argument.mightBeObject()) return false; // 2. If argument has a [[Construct]] internal method, return true.

  argument = argument.throwIfNotConcreteObject();
  if (argument.$Construct) return true; // 3. Return false.

  return false;
} // ECMA262 7.2.6


function IsInteger(realm, argument) {
  // 1. If Type(argument) is not Number, return false.
  (0, _invariant.default)(typeof argument === "number", "Type(argument) is not number"); // 2. If argument is NaN, +, or -, return false.

  if (isNaN(argument) || argument === +Infinity || argument === -Infinity) return false; // 3. If floor(abs(argument))  abs(argument), return false.

  if (Math.floor(Math.abs(argument)) !== Math.abs(argument)) return false; // 4. Return true.

  return true;
} // ECMA262 7.2.7


function IsPropertyKey(realm, arg) {
  // We allow native strings to be passed around to avoid constructing a StringValue
  if (typeof arg === "string") return true; // 1. If Type(argument) is String, return true.

  if (arg instanceof _index.StringValue) return true; // 2. If Type(argument) is Symbol, return true.

  if (arg instanceof _index.SymbolValue) return true;

  if (arg instanceof _index.AbstractValue) {
    _index.AbstractValue.reportIntrospectionError(arg);

    throw new _errors.FatalError();
  } // 3. Return false.


  return false;
} // ECMA262 7.2.2


function IsArray(realm, argument) {
  // 1. If Type(argument) is not Object, return false.
  if (!argument.mightBeObject()) return false; // 2. If argument is an Array exotic object, return true.

  if (argument instanceof _index.ArrayValue || argument === realm.intrinsics.ArrayPrototype) return true; // 3. If argument is a Proxy exotic object, then

  if (argument instanceof _index.ProxyValue) {
    // a. If the value of the [[ProxyHandler]] internal slot of argument is null, throw a TypeError exception.
    if (!argument.$ProxyHandler || argument.$ProxyHandler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // b. Let target be the value of the [[ProxyTarget]] internal slot of argument.


    let target = argument.$ProxyTarget; // c. Return ? IsArray(target).

    return IsArray(realm, target);
  } // 4. Return false.


  if (argument instanceof _index.AbstractValue && !argument.isSimpleObject()) argument.throwIfNotConcrete();
  return false;
} // ECMA262 14.6.1


function IsInTailPosition(realm, node) {
  // TODO #1008: implement tail calls
  return false;
} // ECMA262 7.2.8


function IsRegExp(realm, _argument) {
  let argument = _argument; // 1. If Type(argument) is not Object, return false.

  if (!argument.mightBeObject()) return false;
  argument = argument.throwIfNotObject(); // 2. Let isRegExp be ? Get(argument, @@match).

  let isRegExp = (0, _get.Get)(realm, argument, realm.intrinsics.SymbolMatch); // 3. If isRegExp is not undefined, return ToBoolean(isRegExp).

  if (isRegExp !== undefined) return _singletons.To.ToBooleanPartial(realm, isRegExp) === true; // 4. If argument has a [[RegExpMatcher]] internal slot, return true.

  if (argument.$RegExpMatcher !== undefined) return true; // 5. Return false.

  return false;
} // ECMA262 12.2.1.4 Static Semantics: IsIdentifierRef
// ECMA262 12.3.1.4 Static Semantics: IsIdentifierRef


function IsIdentifierRef(realm, node) {
  switch (node.type) {
    // ECMA262 12.2.1.4 Static Semantics: IsIdentifierRef
    case "Identifier":
      return true;
    // ECMA262 12.3.1.4 Static Semantics: IsIdentifierRef

    case "MemberExpression":
      return false;

    default:
      throw Error("Unexpected AST form : " + node.type);
  }
} // 12.2.1.3 Static Semantics: IsFunctionDefinition
// 12.2.1.3 Static Semantics: IsFunctionDefinition
// 12.13 Binary Logical Operators
// 12.3.1.2 Static Semantics: IsFunctionDefinition
// 12.15.2 Static Semantics: IsFunctionDefinition


function IsFunctionDefinition(realm, node) {
  switch (node.type) {
    // 12.2.1.3 Static Semantics: IsFunctionDefinition
    case "ThisExpression":
    case "Identifier":
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
    case "NullLiteral":
    case "RegExpLiteral":
    case "ArrayExpression":
    case "ObjectExpression":
    case "TemplateLiteral":
    case "ConditionalExpression":
      return false;
    // 12.2.1.3 Static Semantics: IsFunctionDefinition

    case "UpdateExpression":
      return false;
    // 12.13 Binary Logical Operators

    case "BinaryExpression":
    case "LogicalExpression":
      return false;
    // 12.3.1.2 Static Semantics: IsFunctionDefinition

    case "MemberExpression":
    case "CallExpression":
    case "NewExpression":
    case "MetaProperty":
    case "TaggedTemplateExpression":
      return false;
    //12.5.1 Static Semantics: IsFunctionDefinition

    case "UnaryExpression":
      return false;
    //12.15.2 Static Semantics: IsFunctionDefinition

    case "AssignmentExpression":
      return false;
    //12.16.1 Static Semantics: IsFunctionDefinition

    case "SequenceExpression":
      return false;

    case "ArrowFunctionExpression":
    case "FunctionExpression":
      return true;
    // 14.5.8 Static Semantics: IsFunctionDefinition

    case "ClassExpression":
      return true;
    // JSX Extensions: http://facebook.github.io/jsx/

    case "JSXElement":
      return false;

    default:
      throw Error("Unexpected AST form : " + node.type);
  }
} // ECMA262 14.1.10


function IsAnonymousFunctionDefinition(realm, node) {
  // 1. If IsFunctionDefinition of production is false, return false.
  if (!IsFunctionDefinition(realm, node)) return false; // 2. Let hasName be the result of HasName of production.

  let hasName = (0, _has.HasName)(realm, node); // 3. If hasName is true, return false.

  if (hasName === true) return false; // 4. Return true.

  return true;
} // ECMA262 9.4.2


function IsArrayIndex(realm, P) {
  let key;

  if (typeof P === "string") {
    key = P;
  } else if (P instanceof _index.StringValue) {
    key = P.value;
  } else {
    return false;
  }

  let i = _singletons.To.ToUint32(realm, new _index.StringValue(realm, key));

  return i !== Math.pow(2, 32) - 1 && _singletons.To.ToString(realm, new _index.NumberValue(realm, i)) === key;
} // ECMA262 25.4.1.6


function IsPromise(realm, _x) {
  let x = _x; // 1. If Type(x) is not Object, return false.

  if (!x.mightBeObject()) return false; // 2. If x does not have a [[PromiseState]] internal slot, return false.

  x = x.throwIfNotConcreteObject();
  if (x.$PromiseState === undefined) return false; // 3. Return true.

  return true;
} // ECMA262 24.1.1.2


function IsDetachedBuffer(realm, arrayBuffer) {
  // 1. Assert: Type(arrayBuffer) is Object and it has an [[ArrayBufferData]] internal slot.
  (0, _invariant.default)(arrayBuffer instanceof _index.ObjectValue && "$ArrayBufferData" in arrayBuffer); // 2. If arrayBuffer's [[ArrayBufferData]] internal slot is null, return true.

  if (arrayBuffer.$ArrayBufferData === null) return true; // 3. Return false.

  return false;
}

function IsIntrospectionError(realm, _value) {
  let value = _value;
  if (!value.mightBeObject()) return false;
  value = value.throwIfNotConcreteObject();
  return value.$GetPrototypeOf() === realm.intrinsics.__IntrospectionErrorPrototype;
}

function IsStatic(classElement) {
  // $FlowFixMe need to backport static property to BabelNodeClassMethod
  return classElement.static;
}
//# sourceMappingURL=is.js.map

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetFunctionRealm = GetFunctionRealm;
exports.OrdinaryGet = OrdinaryGet;
exports.OrdinaryGetPartial = OrdinaryGetPartial;
exports.GetGlobalObject = GetGlobalObject;
exports.GetSubstitution = GetSubstitution;
exports.GetMethod = GetMethod;
exports.GetPrototypeFromConstructor = GetPrototypeFromConstructor;
exports.Get = Get;
exports.GetV = GetV;
exports.GetThisValue = GetThisValue;
exports.GetNewTarget = GetNewTarget;
exports.GetTemplateObject = GetTemplateObject;
exports.GetFromArrayWithWidenedNumericProperty = GetFromArrayWithWidenedNumericProperty;

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _environment = __webpack_require__(20);

var _integrity = __webpack_require__(231);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _generator = __webpack_require__(237);

var _descriptors = __webpack_require__(268);

var _is = __webpack_require__(229);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 7.3.22
function GetFunctionRealm(realm, obj) {
  // 1. Assert: obj is a callable object.
  (0, _invariant.default)((0, _index2.IsCallable)(realm, obj), "expected callable object"); // ProxyValue moved to realm before
  // https://github.com/facebook/prepack/pull/1351
  // 4. If obj is a Proxy exotic object, then

  if (obj instanceof _index.ProxyValue) {
    // a. If the value of the [[ProxyHandler]] internal slot of obj is null, throw a TypeError exception.
    if (obj.$ProxyHandler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "proxy handler is null");
    }

    (0, _invariant.default)(obj.$ProxyTarget instanceof _index.ObjectValue); // b. Let proxyTarget be the value of obj's [[ProxyTarget]] internal slot.

    let proxyTarget = obj.$ProxyTarget; // c. Return ? GetFunctionRealm(proxyTarget).

    return GetFunctionRealm(realm, proxyTarget);
  } // 2. If obj has a [[Realm]] internal slot, then


  if (obj.$Realm) {
    // a. Return obj's [[Realm]] internal slot.
    return obj.$Realm;
  } // 3. If obj is a Bound Function exotic object, then


  if (obj instanceof _index.BoundFunctionValue) {
    // a. Let target be obj's [[BoundTargetFunction]] internal slot.
    let target = obj.$BoundTargetFunction; // b. Return ? GetFunctionRealm(target).

    return GetFunctionRealm(realm, target);
  } // 5. Return the current Realm Record.


  return realm;
} // ECMA262 9.1.8.1


function OrdinaryGet(realm, O, P, Receiver, dataOnly) {
  // First deal with potential unknown properties.
  let prop = O.unknownProperty;

  if (prop !== undefined && prop.descriptor !== undefined && O.$GetOwnProperty(P) === undefined) {
    let desc = prop.descriptor;
    (0, _invariant.default)(desc instanceof _descriptors.PropertyDescriptor, "unknown properties are only created with Set and have equal descriptors");
    let val = desc.value;
    (0, _invariant.default)(val instanceof _index.AbstractValue);
    let propValue;

    if (P instanceof _index.StringValue) {
      propValue = P;
    } else if (typeof P === "string") {
      propValue = new _index.StringValue(realm, P);
    }

    if (val.kind === "widened numeric property") {
      (0, _invariant.default)(O instanceof _index.ArrayValue && _index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O));
      let propName;

      if (P instanceof _index.StringValue) {
        propName = P.value;
      } else {
        propName = P;
      }

      (0, _invariant.default)(Receiver instanceof _index.ObjectValue || Receiver instanceof _index.AbstractObjectValue);

      if ((0, _is.IsArrayIndex)(realm, P)) {
        // Deal with aliasing effects
        (0, _invariant.default)(val.args.length === 1);
        let aliasSet = val.args[0];
        (0, _invariant.default)(aliasSet instanceof _index.AbstractValue && aliasSet.kind === "mayAliasSet");

        for (let object of aliasSet.args) {
          // This explicit handling of aliasing should become unnecessary
          // when we unify arrays with widened numeric properties. We have effectively
          // pushed this leaking decision as far out as we possibly can, for now.
          // and objects with widened properties. TODO #2569.
          (0, _invariant.default)(object instanceof _index.ObjectValue); // TODO: Deal with nested Array.map, in which the following
          // pessimistic leaking call may fail because object is not tracked
          // for leaking

          (0, _invariant.default)(realm.createdObjectsTrackedForLeaks !== undefined);
          (0, _invariant.default)(realm.createdObjectsTrackedForLeaks.has(object));

          _singletons.Leak.value(realm, object);
        }
      }

      return GetFromArrayWithWidenedNumericProperty(realm, Receiver, propName);
    } else if (!propValue) {
      _index.AbstractValue.reportIntrospectionError(val, "abstract computed property name");

      throw new _errors.FatalError();
    }

    return specializeJoin(realm, val, propValue);
  } // 1. Assert: IsPropertyKey(P) is true.


  (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected property key"); // 2. Let desc be ? O.[[GetOwnProperty]](P).

  let desc = O.$GetOwnProperty(P);
  if (desc === undefined || !(desc instanceof _descriptors.AbstractJoinedDescriptor)) return OrdinaryGetHelper(); // joined descriptors need special treatment

  let joinCondition = desc.joinCondition;
  let descriptor1 = desc.descriptor1;
  let descriptor2 = desc.descriptor2;
  joinCondition = realm.simplifyAndRefineAbstractCondition(joinCondition);

  if (!joinCondition.mightNotBeTrue()) {
    desc = descriptor1;
    return OrdinaryGetHelper();
  }

  if (!joinCondition.mightNotBeFalse()) {
    desc = desc.descriptor2;
    return OrdinaryGetHelper();
  }

  (0, _invariant.default)(joinCondition instanceof _index.AbstractValue);
  let result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1;

  try {
    desc = descriptor1;
    ({
      result: result1,
      generator: generator1,
      modifiedBindings: modifiedBindings1,
      modifiedProperties: modifiedProperties1,
      createdObjects: createdObjects1
    } = _singletons.Path.withCondition(joinCondition, () => {
      return desc !== undefined ? realm.evaluateForEffects(() => OrdinaryGetHelper(), undefined, "OrdinaryGet/1") : (0, _realm.construct_empty_effects)(realm);
    }));
  } catch (e) {
    if (e instanceof _errors.InfeasiblePathError) {
      // The joinCondition cannot be true in the current path, after all
      desc = descriptor2;
      return OrdinaryGetHelper();
    } else {
      throw e;
    }
  }

  let result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2;

  try {
    desc = descriptor2;
    ({
      result: result2,
      generator: generator2,
      modifiedBindings: modifiedBindings2,
      modifiedProperties: modifiedProperties2,
      createdObjects: createdObjects2
    } = _singletons.Path.withInverseCondition(joinCondition, () => {
      return desc !== undefined ? realm.evaluateForEffects(() => OrdinaryGetHelper(), undefined, "OrdinaryGet/2") : (0, _realm.construct_empty_effects)(realm);
    }));
  } catch (e) {
    if (e instanceof _errors.InfeasiblePathError) {
      // The joinCondition cannot be false in the current path, after all
      desc = descriptor1;
      return OrdinaryGetHelper();
    } else {
      throw e;
    }
  } // Join the effects, creating an abstract view of what happened, regardless
  // of the actual value of ownDesc.joinCondition.


  let joinedEffects = _singletons.Join.joinEffects(joinCondition, new _realm.Effects(result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1), new _realm.Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2));

  realm.applyEffects(joinedEffects);
  return realm.returnOrThrowCompletion(joinedEffects.result);

  function OrdinaryGetHelper() {
    let descValue = !desc ? realm.intrinsics.undefined : desc.value === undefined ? realm.intrinsics.undefined : desc.value;
    (0, _invariant.default)(descValue instanceof _index.Value); // 3. If desc is undefined, then

    if (!desc || descValue.mightHaveBeenDeleted()) {
      // a. Let parent be ? O.[[GetPrototypeOf]]().
      let parent = O.$GetPrototypeOf(); // b. If parent is null, return undefined.

      if (parent instanceof _index.NullValue) {
        // Return the property value since it is now known to be the right value
        // even in the case when it is empty.
        return descValue;
      } // c. Return ? parent.[[Get]](P, Receiver).


      if (descValue.mightHaveBeenDeleted() && descValue instanceof _index.AbstractValue) {
        // We don't know for sure that O.P does not exist.
        let parentVal = OrdinaryGet(realm, parent.throwIfNotConcreteObject(), P, descValue, true);
        if (parentVal instanceof _index.UndefinedValue) // even O.P returns undefined it is still the right value.
          return descValue; // Join with parent value with descValue because the actual value will be
        // descValue unless it is empty.
        // Only get the parent value if it does not involve a getter call.
        // Use a property get for the joined value since it does the check for empty.

        let cond = _index.AbstractValue.createFromBinaryOp(realm, "!==", descValue, realm.intrinsics.empty);

        return _index.AbstractValue.createFromConditionalOp(realm, cond, descValue, parentVal);
      }

      (0, _invariant.default)(!desc || descValue instanceof _index.EmptyValue);
      return parent.$Get(P, Receiver);
    } // 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].


    if ((0, _index2.IsDataDescriptor)(realm, desc)) return descValue;

    if (dataOnly) {
      (0, _invariant.default)(descValue instanceof _index.AbstractValue);

      _index.AbstractValue.reportIntrospectionError(descValue);

      throw new _errors.FatalError();
    } // 5. Assert: IsAccessorDescriptor(desc) is true.


    (0, _invariant.default)((0, _index2.IsAccessorDescriptor)(realm, desc), "expected accessor descriptor"); // 6. Let getter be desc.[[Get]].

    let getter = desc.get; // 7. If getter is undefined, return undefined.

    if (!getter || getter instanceof _index.UndefinedValue) return realm.intrinsics.undefined; // 8. Return ? Call(getter, Receiver).

    return (0, _index2.Call)(realm, getter, Receiver);
  }
}

function isWidenedValue(v) {
  if (!(v instanceof _index.AbstractValue)) return false;
  if (v.kind === "widened" || v.kind === "widened property") return true;

  for (let a of v.args) {
    if (isWidenedValue(a)) return true;
  }

  return false;
}

const lengthTemplateSrc = "(A).length";

function specializeJoin(realm, absVal, propName) {
  if (absVal.kind === "widened property") {
    let ob = absVal.args[0];

    if (propName instanceof _index.StringValue) {
      let pName = propName.value;
      let pNumber = +pName;
      if (pName === pNumber + "") propName = new _index.NumberValue(realm, pNumber);
    }

    return _index.AbstractValue.createTemporalFromBuildFunction(realm, absVal.getType(), [ob, propName], (0, _generator.createOperationDescriptor)("OBJECT_GET_PARTIAL"), {
      skipInvariant: true,
      isPure: true
    });
  }

  (0, _invariant.default)(absVal.args.length === 3 && absVal.kind === "conditional");
  let generic_cond = absVal.args[0];
  (0, _invariant.default)(generic_cond instanceof _index.AbstractValue);
  let cond = specializeCond(realm, generic_cond, propName);
  let arg1 = absVal.args[1];
  if (arg1 instanceof _index.AbstractValue && arg1.args.length === 3) arg1 = specializeJoin(realm, arg1, propName);
  let arg2 = absVal.args[2];

  if (arg2 instanceof _index.AbstractValue) {
    if (arg2.kind === "template for prototype member expression") {
      let ob = arg2.args[0];
      arg2 = _index.AbstractValue.createTemporalFromBuildFunction(realm, absVal.getType(), [ob, propName], (0, _generator.createOperationDescriptor)("OBJECT_GET_PARTIAL"), {
        skipInvariant: true,
        isPure: true
      });
    } else if (arg2.args.length === 3) {
      arg2 = specializeJoin(realm, arg2, propName);
    }
  }

  return _index.AbstractValue.createFromConditionalOp(realm, cond, arg1, arg2, absVal.expressionLocation);
}

function specializeCond(realm, absVal, propName) {
  if (absVal.kind === "template for property name condition") return _index.AbstractValue.createFromBinaryOp(realm, "===", absVal.args[0], propName);
  return absVal;
}

function OrdinaryGetPartial(realm, O, P, Receiver) {
  if (Receiver instanceof _index.AbstractValue && Receiver.getType() === _index.StringValue && P === "length") {
    let absVal = _index.AbstractValue.createFromTemplate(realm, lengthTemplateSrc, _index.NumberValue, [Receiver]); // This operation is a conditional atemporal
    // See #2327


    return _index.AbstractValue.convertToTemporalIfArgsAreTemporal(realm, absVal, [Receiver]);
  }

  if (!(P instanceof _index.AbstractValue)) return O.$Get(P, Receiver); // A string coercion might have side-effects.
  // TODO #1682: We assume that simple objects mean that they don't have a
  // side-effectful valueOf and toString but that's not enforced.

  if (P.mightNotBeString() && P.mightNotBeNumber() && !P.isSimpleObject()) {
    if (realm.isInPureScope()) {
      // If we're in pure scope, we can leak the key and keep going.
      // Coercion can only have effects on anything reachable from the key.
      _singletons.Leak.value(realm, P);
    } else {
      let error = new _errors.CompilerDiagnostic("property key might not have a well behaved toString or be a symbol", realm.currentLocation, "PP0002", "RecoverableError");

      if (realm.handleError(error) !== "Recover") {
        throw new _errors.FatalError();
      }
    }
  } // We assume that simple objects have no getter/setter properties.


  if (!O.isSimpleObject() || O.mightBeLeakedObject()) {
    if (realm.isInPureScope()) {
      // If we're in pure scope, we can leak the object. Coercion
      // can only have effects on anything reachable from this object.
      // We assume that if the receiver is different than this object,
      // then we only got here because there were no other keys with
      // this name on other parts of the prototype chain.
      // TODO #1675: A fix to 1675 needs to take this into account.
      _singletons.Leak.value(realm, Receiver);

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [Receiver, P], (0, _generator.createOperationDescriptor)("OBJECT_GET_PARTIAL"), {
        skipInvariant: true,
        isPure: true
      });
    } else {
      let error = new _errors.CompilerDiagnostic("unknown property access might need to invoke a getter", realm.currentLocation, "PP0030", "RecoverableError");

      if (realm.handleError(error) !== "Recover") {
        throw new _errors.FatalError();
      }
    }
  }

  P = _singletons.To.ToStringAbstract(realm, P); // If all else fails, use this expression
  // TODO #1675: Check the prototype chain for known properties too.

  let result;

  if (O.isPartialObject()) {
    if (isWidenedValue(P)) {
      // TODO #1678: Use a snapshot or leak this object.
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O, P], (0, _generator.createOperationDescriptor)("OBJECT_GET_PARTIAL"), {
        skipInvariant: true,
        isPure: true
      });
    }

    result = _index.AbstractValue.createFromType(realm, _index.Value, "sentinel member expression", [O, P]);
  } else {
    // This is simple and not partial. Any access that isn't covered by checking against
    // all its properties, is covered by reading from the prototype.
    if (O.$Prototype === realm.intrinsics.null) {
      // If the prototype is null, then the fallback value is undefined.
      result = realm.intrinsics.undefined;
    } else {
      // Otherwise, we read the value dynamically from the prototype chain.
      result = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O.$Prototype, P], (0, _generator.createOperationDescriptor)("OBJECT_GET_PARTIAL"), {
        skipInvariant: true,
        isPure: true
      });
    }
  } // Get a specialization of the join of all values written to the object
  // with abstract property names.


  let prop = O.unknownProperty;

  if (prop !== undefined) {
    let desc = prop.descriptor;

    if (desc !== undefined) {
      (0, _invariant.default)(desc instanceof _descriptors.PropertyDescriptor, "unknown properties are only created with Set and have equal descriptors");
      let val = desc.value;
      (0, _invariant.default)(val instanceof _index.AbstractValue);

      if (val.kind === "widened numeric property") {
        (0, _invariant.default)(O instanceof _index.ArrayValue && _index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O));
        (0, _invariant.default)(Receiver instanceof _index.ObjectValue || Receiver instanceof _index.AbstractObjectValue);
        return GetFromArrayWithWidenedNumericProperty(realm, Receiver, P instanceof _index.StringValue ? P.value : P);
      }

      result = specializeJoin(realm, val, P);
    }
  } // Join in all of the other values that were written to the object with
  // concrete property names.


  for (let [key, propertyBinding] of O.properties) {
    let desc = propertyBinding.descriptor;
    if (desc === undefined) continue; // deleted

    desc = desc.throwIfNotConcrete(realm); // TODO: Join descriptor values based on condition

    (0, _invariant.default)(desc.value !== undefined); // otherwise this is not simple

    let val = desc.value;
    (0, _invariant.default)(val instanceof _index.Value);

    let cond = _index.AbstractValue.createFromBinaryOp(realm, "===", P, new _index.StringValue(realm, key), undefined, "check for known property");

    result = _index.AbstractValue.createFromConditionalOp(realm, cond, val, result);
  }

  return result;
} // ECMA262 8.3.6


function GetGlobalObject(realm) {
  // 1. Let ctx be the running execution context.
  let ctx = realm.getRunningContext(); // 2. Let currentRealm be ctx's Realm.

  let currentRealm = ctx.realm; // 3. Return currentRealm.[[GlobalObject]].

  return currentRealm.$GlobalObject;
} // ECMA262 21.1.3.14.1


function GetSubstitution(realm, matched, str, position, captures, replacement) {
  // 1. Assert: Type(matched) is String.
  (0, _invariant.default)(typeof matched === "string", "expected matched to be a stirng"); // 2. Let matchLength be the number of code units in matched.

  let matchLength = matched.length; // 3. Assert: Type(str) is String.

  (0, _invariant.default)(typeof str === "string", "expected matched to be a stirng"); // 4. Let stringLength be the number of code units in str.

  let stringLength = str.length; // 5. Assert: position is a nonnegative integer.

  (0, _invariant.default)(position >= 0, "expected position to be a nonegative integer"); // 6. Assert: position  stringLength.

  (0, _invariant.default)(position <= stringLength, "expected position to be less than string length"); // 7. Assert: captures is a possibly empty List of Strings.

  (0, _invariant.default)(Array.isArray(captures), "expected captures to be an array"); // 8. Assert: Type(replacement) is String.

  (0, _invariant.default)(typeof replacement === "string", "expected replacement to be a stirng"); // 9. Let tailPos be position + matchLength.

  let tailPos = position + matchLength; // 10. Let m be the number of elements in captures.

  let m = captures.length; // 11. Let result be a String value derived from replacement by copying code unit elements
  //     from replacement to result while performing replacements as specified in Table 46.
  //     These $ replacements are done left-to-right, and, once such a replacement is performed,
  //     the new replacement text is not subject to further replacements.

  let result = "";

  for (let i = 0; i < replacement.length; ++i) {
    let ch = replacement.charAt(i);

    if (ch !== "$" || i + 1 >= replacement.length) {
      result += ch;
      continue;
    }

    let peek = replacement.charAt(i + 1);

    if (peek === "&") {
      result += matched;
    } else if (peek === "$") {
      result += "$";
    } else if (peek === "`") {
      result += str.substr(0, position);
    } else if (peek === "'") {
      result += str.substr(tailPos);
    } else if (peek >= "0" && peek <= "9") {
      let idx = peek.charCodeAt(0) - "0".charCodeAt(0);

      if (i + 2 < replacement.length) {
        let peek2 = replacement.charAt(i + 2);

        if (peek2 >= "0" && peek2 <= "9") {
          let newIdx = idx * 10 + (peek2.charCodeAt(0) - "0".charCodeAt(0));

          if (newIdx <= m) {
            idx = newIdx;
            i += 1;
          }
        }
      }

      if (idx > 0 && idx <= m) {
        result += captures[idx - 1] || "";
      } else {
        result += "$" + idx;
      }
    } else {
      result += "$" + peek;
    }

    i += 1;
  } // 12. Return result.


  return result;
} // ECMA262 7.3.9


function GetMethod(realm, V, P) {
  // 1. Assert: IsPropertyKey(P) is true.
  (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected property key"); // 2. Let func be ? GetV(V, P).

  let func = GetV(realm, V, P); // 3. If func is either undefined or null, return undefined.

  if ((0, _index2.HasSomeCompatibleType)(func, _index.NullValue, _index.UndefinedValue)) {
    return realm.intrinsics.undefined;
  } // 4. If IsCallable(func) is false, throw a TypeError exception.


  if (!(0, _index2.IsCallable)(realm, func)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable");
  } // 5. Return func.


  return func;
} // ECMA262 9.1.14


function GetPrototypeFromConstructor(realm, constructor, intrinsicDefaultProto) {
  // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic
  //   object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]
  //   value of an object.
  (0, _invariant.default)(realm.intrinsics[intrinsicDefaultProto], "not a valid proto ref"); // 2. Assert: IsCallable(constructor) is true.

  (0, _invariant.default)((0, _index2.IsCallable)(realm, constructor) === true, "expected constructor to be callable"); // 3. Let proto be ? Get(constructor, "prototype").

  let proto = Get(realm, constructor, new _index.StringValue(realm, "prototype")); // 4. If Type(proto) is not Object, then

  if (!(proto instanceof _index.ObjectValue) && !(proto instanceof _index.AbstractObjectValue)) {
    // a. Let realm be ? GetFunctionRealm(constructor).
    realm = GetFunctionRealm(realm, constructor); // b. Let proto be realm's intrinsic object named intrinsicDefaultProto.

    proto = realm.intrinsics[intrinsicDefaultProto];
  } // 5. Return proto.


  return proto;
} // ECMA262 7.3.1


function Get(realm, O, P) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant.default)(O instanceof _index.ObjectValue || O instanceof _index.AbstractObjectValue, "Not an object value"); // 2. Assert: IsPropertyKey(P) is true.

  (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "Not a valid property key"); // 3. Return ? O.[[Get]](P, O).

  return O.$Get(P, O);
} // ECMA262 7.3.2


function GetV(realm, V, P) {
  // 1. Assert: IsPropertyKey(P) is true.
  (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "Not a valid property key"); // 2. Let O be ? ToObject(V).

  let O = _singletons.To.ToObject(realm, V); // 3. Return ? O.[[Get]](P, V).


  return O.$Get(P, V);
} // ECMA262 6.2.3.3


function GetThisValue(realm, V) {
  // 1. Assert: IsPropertyReference(V) is true.
  (0, _invariant.default)(_singletons.Environment.IsPropertyReference(realm, V), "expected property reference"); // 2. If IsSuperReference(V) is true, then

  if (_singletons.Environment.IsSuperReference(realm, V)) {
    (0, _invariant.default)(V.thisValue !== undefined); // a. Return the value of the thisValue component of the reference V.

    return V.thisValue;
  } // 3. Return GetBase(V).


  let result = _singletons.Environment.GetBase(realm, V);

  (0, _invariant.default)(result instanceof _index.Value);
  return result;
} // ECMA262 8.3.5


function GetNewTarget(realm) {
  // 1. Let envRec be GetThisEnvironment( ).
  let envRec = _singletons.Environment.GetThisEnvironment(realm); // 2. Assert: envRec has a [[NewTarget]] field.


  if (!("$NewTarget" in envRec)) {
    // In the spec we should not get here because earlier static checks are supposed to prevent it.
    // However, we do not have an appropriate place to do this check earlier.
    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "new.target not allowed here");
  } // 3. Return envRec.[[NewTarget]].


  return envRec.$NewTarget || realm.intrinsics.undefined;
}

function GetTemplateObject(realm, templateLiteral) {
  // 1. Let rawStrings be TemplateStrings of templateLiteral with argument true.
  let rawStrings = templateLiteral.quasis.map(quasi => quasi.value.raw); // 2. Let realm be the current Realm Record.

  realm; // 3. Let templateRegistry be realm.[[TemplateMap]].

  let templateRegistry = realm.$TemplateMap; // 4. For each element e of templateRegistry, do

  for (let e of templateRegistry) {
    let same;

    if (e.$Strings.length === rawStrings.length) {
      same = true;

      for (let i = 0; i < rawStrings.length; ++i) {
        if (e.$Strings[i] !== rawStrings[i]) {
          same = false;
          break;
        }
      }
    } else {
      same = false;
    } // a. If e.[[Strings]] and rawStrings contain the same values in the same order, then


    if (same) {
      // i. Return e.[[Array]].
      return e.$Array;
    }
  } // 5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.


  let cookedStrings = templateLiteral.quasis.map(quasi => quasi.value.cooked); // 6. Let count be the number of elements in the List cookedStrings.

  let count = cookedStrings.length; // 7. Let template be ArrayCreate(count).

  let template = _singletons.Create.ArrayCreate(realm, count); // 8. Let rawObj be ArrayCreate(count).


  let rawObj = _singletons.Create.ArrayCreate(realm, count); // 9. Let index be 0.


  let index = 0; // 10. Repeat while index < count

  while (index < count) {
    // a. Let prop be ! ToString(index).
    let prop = _singletons.To.ToString(realm, new _index.NumberValue(realm, index)); // b. Let cookedValue be the String value cookedStrings[index].


    let cookedValue = new _index.StringValue(realm, cookedStrings[index]); // c. Call template.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).

    template.$DefineOwnProperty(prop, new _descriptors.PropertyDescriptor({
      value: cookedValue,
      writable: false,
      enumerable: true,
      configurable: false
    })); // d. Let rawValue be the String value rawStrings[index].

    let rawValue = new _index.StringValue(realm, rawStrings[index]); // e. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).

    rawObj.$DefineOwnProperty(prop, new _descriptors.PropertyDescriptor({
      value: rawValue,
      writable: false,
      enumerable: true,
      configurable: false
    })); // f. Let index be index+1.

    index = index + 1;
  } // 11. Perform SetIntegrityLevel(rawObj, "frozen").


  (0, _integrity.SetIntegrityLevel)(realm, rawObj, "frozen"); // 12. Call template.[[DefineOwnProperty]]("raw", PropertyDescriptor{[[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).

  template.$DefineOwnProperty("raw", new _descriptors.PropertyDescriptor({
    value: rawObj,
    writable: false,
    enumerable: false,
    configurable: false
  })); // 13. Perform SetIntegrityLevel(template, "frozen").

  (0, _integrity.SetIntegrityLevel)(realm, template, "frozen"); // 14. Append the Record{[[Strings]]: rawStrings, [[Array]]: template} to templateRegistry.

  templateRegistry.push({
    $Strings: rawStrings,
    $Array: template
  }); // 15. Return template.

  return template;
}

function GetFromArrayWithWidenedNumericProperty(realm, arr, P) {
  let proto = arr.$GetPrototypeOf();
  (0, _invariant.default)(proto instanceof _index.ObjectValue && proto === realm.intrinsics.ArrayPrototype);

  if (typeof P === "string") {
    if (P === "length") {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.NumberValue, [arr], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_LENGTH"), {
        skipInvariant: true,
        isPure: true
      });
    }

    let prototypeBinding = proto.properties.get(P);

    if (prototypeBinding !== undefined) {
      let descriptor = prototypeBinding.descriptor; // ensure we are accessing a built-in native function

      if (descriptor instanceof _descriptors.PropertyDescriptor && descriptor.value instanceof _index.NativeFunctionValue) {
        return descriptor.value;
      }
    }
  }

  let prop = typeof P === "string" ? new _index.StringValue(realm, P) : P;
  return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [arr, prop], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_GET_PARTIAL"), {
    skipInvariant: true,
    isPure: true
  });
}
//# sourceMappingURL=get.js.map

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrdinaryPreventExtensions = OrdinaryPreventExtensions;
exports.SetIntegrityLevel = SetIntegrityLevel;
exports.TestIntegrityLevel = TestIntegrityLevel;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 9.1.4.1
function OrdinaryPreventExtensions(realm, O) {
  if (O.mightBeLeakedObject() && O.getExtensible()) {
    // todo: emit a diagnostic messsage
    throw new _errors.FatalError();
  } // 1. Set the value of the [[Extensible]] internal slot of O to false.


  O.setExtensible(false); // 2. Return true.

  return true;
} // ECMA262 7.3.14


function SetIntegrityLevel(realm, O, level) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant.default)(O instanceof _index.ObjectValue, "expected an object"); // 2. Assert: level is either "sealed" or "frozen".

  (0, _invariant.default)(level === "sealed" || level === "frozen", "invalid level"); // 3. Let status be ? O.[[PreventExtensions]]().

  let status = O.$PreventExtensions(); // 4. If status is false, return false.

  if (status === false) return false; // 5. Let keys be ? O.[[OwnPropertyKeys]]().

  let keys = O.$OwnPropertyKeys(); // 6. If level is "sealed", then

  if (level === "sealed") {
    // a. Repeat for each element k of keys,
    for (let k of keys) {
      // i. Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false}).
      _singletons.Properties.DefinePropertyOrThrow(realm, O, k, new _descriptors.PropertyDescriptor({
        configurable: false
      }));
    }
  } else if (level === "frozen") {
    // 7. Else level is "frozen",
    // a. Repeat for each element k of keys,
    for (let k of keys) {
      // i. Let currentDesc be ? O.[[GetOwnProperty]](k).
      let currentDesc = O.$GetOwnProperty(k); // ii. If currentDesc is not undefined, then

      if (currentDesc) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(currentDesc);

        let desc; // 1. If IsAccessorDescriptor(currentDesc) is true, then

        if ((0, _index2.IsAccessorDescriptor)(realm, currentDesc)) {
          // a. Let desc be the PropertyDescriptor{[[Configurable]]: false}.
          desc = new _descriptors.PropertyDescriptor({
            configurable: false
          });
        } else {
          // 2. Else,
          // b. Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.
          desc = new _descriptors.PropertyDescriptor({
            configurable: false,
            writable: false
          });
        } // 3. Perform ? DefinePropertyOrThrow(O, k, desc).


        _singletons.Properties.DefinePropertyOrThrow(realm, O, k, desc);
      }
    }
  } // 8. Return true.


  return true;
} // ECMA262 7.3.15


function TestIntegrityLevel(realm, O, level) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant.default)(O instanceof _index.ObjectValue, "expected an object"); // 2. Assert: level is either "sealed" or "frozen".

  (0, _invariant.default)(level === "sealed" || level === "frozen", "invalid level"); // 3. Let status be ? IsExtensible(O).

  let status = (0, _index2.IsExtensible)(realm, O); // 4. If status is true, return false.

  if (status === true) return false; // 5. NOTE If the object is extensible, none of its properties are examined.
  // 6. Let keys be ? O.[[OwnPropertyKeys]]().

  let keys = O.$OwnPropertyKeys(); // 7. Repeat for each element k of keys,

  for (let k of keys) {
    // a. Let currentDesc be ? O.[[GetOwnProperty]](k).
    let currentDesc = O.$GetOwnProperty(k); // b. If currentDesc is not undefined, then

    if (currentDesc) {
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(currentDesc);

      currentDesc = currentDesc.throwIfNotConcrete(realm); // i. If currentDesc.[[Configurable]] is true, return false.

      if (currentDesc.configurable === true) return false; // ii. If level is "frozen" and IsDataDescriptor(currentDesc) is true, then

      if (level === "frozen" && (0, _index2.IsDataDescriptor)(realm, currentDesc) === true) {
        // 1. If currentDesc.[[Writable]] is true, return false.
        if (currentDesc.writable === true) return false;
      }
    }
  } // 8. Return true.


  return true;
}
//# sourceMappingURL=integrity.js.map

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _abstract = __webpack_require__(233);

Object.keys(_abstract).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _abstract[key];
    }
  });
});

var _call = __webpack_require__(234);

Object.keys(_call).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _call[key];
    }
  });
});

var _construct = __webpack_require__(228);

Object.keys(_construct).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _construct[key];
    }
  });
});

var _date = __webpack_require__(270);

Object.keys(_date).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _date[key];
    }
  });
});

var _get = __webpack_require__(230);

Object.keys(_get).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _get[key];
    }
  });
});

var _has = __webpack_require__(269);

Object.keys(_has).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _has[key];
    }
  });
});

var _hash = __webpack_require__(271);

Object.keys(_hash).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _hash[key];
    }
  });
});

var _integrity = __webpack_require__(231);

Object.keys(_integrity).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _integrity[key];
    }
  });
});

var _is = __webpack_require__(229);

Object.keys(_is).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _is[key];
    }
  });
});

var _iterator = __webpack_require__(272);

Object.keys(_iterator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iterator[key];
    }
  });
});

var _own = __webpack_require__(273);

Object.keys(_own).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _own[key];
    }
  });
});

var _destructuring = __webpack_require__(274);

Object.keys(_destructuring).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _destructuring[key];
    }
  });
});

var _regexp = __webpack_require__(276);

Object.keys(_regexp).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _regexp[key];
    }
  });
});

var _promise = __webpack_require__(277);

Object.keys(_promise).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _promise[key];
    }
  });
});

var _arraybuffer = __webpack_require__(278);

Object.keys(_arraybuffer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _arraybuffer[key];
    }
  });
});
//# sourceMappingURL=index.js.map

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SplitMatch = SplitMatch;
exports.RequireObjectCoercible = RequireObjectCoercible;
exports.HasSameType = HasSameType;
exports.AbstractRelationalComparison = AbstractRelationalComparison;
exports.AbstractEqualityComparison = AbstractEqualityComparison;
exports.StrictEqualityComparison = StrictEqualityComparison;
exports.StrictEqualityComparisonPartial = StrictEqualityComparisonPartial;
exports.SameValueZero = SameValueZero;
exports.SameValueZeroPartial = SameValueZeroPartial;
exports.SameValue = SameValue;
exports.SameValuePartial = SameValuePartial;
exports.SameValueNonNumber = SameValueNonNumber;
exports.SamePropertyKey = SamePropertyKey;
exports.Add = Add;
exports.InstanceofOperator = InstanceofOperator;
exports.OrdinaryHasInstance = OrdinaryHasInstance;
exports.Type = Type;
exports.SymbolDescriptiveString = SymbolDescriptiveString;
exports.UpdateEmpty = UpdateEmpty;
exports.URIUnescaped = exports.URIMark = exports.DecimalDigit = exports.URIAlpha = exports.URIReserved = void 0;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _call = __webpack_require__(234);

var _is = __webpack_require__(229);

var _completions = __webpack_require__(18);

var _get = __webpack_require__(230);

var _has = __webpack_require__(269);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const URIReserved = ";/?:@&=+$,";
exports.URIReserved = URIReserved;
const URIAlpha = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
exports.URIAlpha = URIAlpha;
const DecimalDigit = "0123456789";
exports.DecimalDigit = DecimalDigit;
const URIMark = "-_.!~*'()";
exports.URIMark = URIMark;
const URIUnescaped = URIAlpha + DecimalDigit + URIMark; // ECMA262 21.1.3.17.1

exports.URIUnescaped = URIUnescaped;

function SplitMatch(realm, S, q, R) {
  // 1. Assert: Type(R) is String.
  (0, _invariant.default)(typeof R === "string", "expected a string"); // 2. Let r be the number of code units in R.

  let r = R.length; // 3. Let s be the number of code units in S.

  let s = S.length; // 4. If q+r > s, return false.

  if (q + r > s) return false; // 5. If there exists an integer i between 0 (inclusive) and r (exclusive) such that the code unit at index
  //    q+i of S is different from the code unit at index i of R, return false.

  for (let i = 0; i < r; i++) {
    if (S[q + i] !== R[i]) {
      return false;
    }
  } // 6. Return q+r.


  return q + r;
} // ECMA262 7.2.1


function RequireObjectCoercible(realm, arg, argLoc) {
  if (!arg.mightNotBeNull() || !arg.mightNotBeUndefined()) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "null or undefined");
  }

  if (arg instanceof _index.AbstractValue && (arg.mightBeNull() || arg.mightBeUndefined())) {
    if (realm.isInPureScope()) {
      // In a pure function it is ok to throw if this happens to be null or undefined.
      return arg;
    }

    if (argLoc) {
      let error = new _errors.CompilerDiagnostic(`member expression object ${_index.AbstractValue.describe(arg)} is unknown`, argLoc, "PP0012", "FatalError");
      realm.handleError(error);
      throw new _errors.FatalError();
    }

    arg.throwIfNotConcrete();
  }

  return arg;
}

function HasSameType(x, y) {
  const xType = x.getType();
  const yType = y.getType();
  return xType === yType || (xType === _index.IntegralValue || xType === _index.NumberValue) && (yType === _index.IntegralValue || yType === _index.NumberValue);
} // ECMA262 7.2.12 Abstract Relational Comparison


function AbstractRelationalComparison(realm, x, y, LeftFirst, op) {
  let px, py; // 1. If the LeftFirst flag is true, then

  if (LeftFirst) {
    // a. Let px be ? ToPrimitive(x, hint Number).
    px = _singletons.To.ToPrimitiveOrAbstract(realm, x, "number"); // b. Let py be ? ToPrimitive(y, hint Number).

    py = _singletons.To.ToPrimitiveOrAbstract(realm, y, "number");
  } else {
    // 2. Else the order of evaluation needs to be reversed to preserve left to right evaluation
    // a. Let py be ? ToPrimitive(y, hint Number).
    py = _singletons.To.ToPrimitiveOrAbstract(realm, y, "number"); // b. Let px be ? ToPrimitive(x, hint Number).

    px = _singletons.To.ToPrimitiveOrAbstract(realm, x, "number");
  }

  if (px instanceof _index.AbstractValue || py instanceof _index.AbstractValue) {
    let res;

    if (LeftFirst) {
      res = _index.AbstractValue.createFromBinaryOp(realm, op, px, py);
    } else {
      res = _index.AbstractValue.createFromBinaryOp(realm, op, py, px);
    }

    (0, _invariant.default)(res instanceof _index.BooleanValue || res instanceof _index.UndefinedValue || res instanceof _index.AbstractValue);
    return res;
  } // 3. If both px and py are Strings, then


  if (px instanceof _index.StringValue && py instanceof _index.StringValue) {
    // a. If py is a prefix of px, return false. (A String value p is a prefix of String value q if q can be the result of concatenating p and some other String r. Note that any String is a prefix of itself, because r may be the empty String.)
    if (px.value.startsWith(py.value)) return realm.intrinsics.false; // b. If px is a prefix of py, return true.

    if (py.value.startsWith(px.value)) return realm.intrinsics.true; // c. Let k be the smallest nonnegative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)

    let k = 0;

    while (px.value.charCodeAt(k) === py.value.charCodeAt(k)) {
      k += 1;
    } // d. Let m be the integer that is the code unit value at index k within px.


    let m = px.value.charCodeAt(k); // e. Let n be the integer that is the code unit value at index k within py.

    let n = py.value.charCodeAt(k); // f. If m < n, return true. Otherwise, return false.

    return m < n ? realm.intrinsics.true : realm.intrinsics.false;
  } else {
    // 4. Else,
    // a. Let nx be ? ToNumber(px). Because px and py are primitive values evaluation order is not important.
    let nx = _singletons.To.ToNumber(realm, px); // b. Let ny be ? ToNumber(py).


    let ny = _singletons.To.ToNumber(realm, py); // c. If nx is NaN, return undefined.


    if (isNaN(nx)) return realm.intrinsics.undefined; // d. If ny is NaN, return undefined.

    if (isNaN(ny)) return realm.intrinsics.undefined; // e. If nx and ny are the same Number value, return false.

    if (Object.is(nx, ny)) {
      return realm.intrinsics.false;
    } // f. If nx is +0 and ny is -0, return false.


    if (Object.is(nx, +0) && Object.is(ny, -0)) {
      return realm.intrinsics.false;
    } // g. If nx is -0 and ny is +0, return false.


    if (Object.is(nx, -0) && Object.is(ny, +0)) {
      return realm.intrinsics.false;
    } // h. If nx is +, return false.
    // i. If ny is +, return true.
    // j. If ny is -, return false.
    // k. If nx is -, return true.
    // i. If the mathematical value of nx is less than the mathematical value of ny note that these
    //    mathematical values are both finite and not both zeroreturn true. Otherwise, return false.


    if (nx < ny) {
      return realm.intrinsics.true;
    } else {
      return realm.intrinsics.false;
    }
  }
} // ECMA262 7.2.13


function AbstractEqualityComparison(realm, x, y, op) {
  // 1. If Type(x) is the same as Type(y), then
  if (HasSameType(x, y)) {
    // a. Return the result of performing Strict Equality Comparison x === y.
    const strictResult = StrictEqualityComparison(realm, x, y);
    return new _index.BooleanValue(realm, op === "==" ? strictResult : !strictResult);
  } // 2. If x is null and y is undefined, return true.


  if (x instanceof _index.NullValue && y instanceof _index.UndefinedValue) {
    return new _index.BooleanValue(realm, op === "==");
  } // 3. If x is undefined and y is null, return true.


  if (x instanceof _index.UndefinedValue && y instanceof _index.NullValue) {
    return new _index.BooleanValue(realm, op === "==");
  } // 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y).


  if (x instanceof _index.NumberValue && y instanceof _index.StringValue) {
    return AbstractEqualityComparison(realm, x, new _index.NumberValue(realm, _singletons.To.ToNumber(realm, y)), op);
  } // 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y.


  if (x instanceof _index.StringValue && y instanceof _index.NumberValue) {
    return AbstractEqualityComparison(realm, new _index.NumberValue(realm, _singletons.To.ToNumber(realm, x)), y, op);
  } // 6. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.


  if (x instanceof _index.BooleanValue) {
    return AbstractEqualityComparison(realm, new _index.NumberValue(realm, _singletons.To.ToNumber(realm, x)), y, op);
  } // 7. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).


  if (y instanceof _index.BooleanValue) {
    return AbstractEqualityComparison(realm, x, new _index.NumberValue(realm, _singletons.To.ToNumber(realm, y)), op);
  } // 8. If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).


  if ((x instanceof _index.StringValue || x instanceof _index.NumberValue || x instanceof _index.SymbolValue) && y instanceof _index.ObjectValue) {
    const py = _singletons.To.ToPrimitiveOrAbstract(realm, y);

    if (py instanceof _index.AbstractValue) {
      let res = _index.AbstractValue.createFromBinaryOp(realm, "==", x, py);

      (0, _invariant.default)(res instanceof _index.BooleanValue || res instanceof _index.AbstractValue);
      return res;
    }

    return AbstractEqualityComparison(realm, x, py, op);
  } // 9. If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.


  if (x instanceof _index.ObjectValue && (y instanceof _index.StringValue || y instanceof _index.NumberValue || y instanceof _index.SymbolValue)) {
    const px = _singletons.To.ToPrimitiveOrAbstract(realm, x);

    if (px instanceof _index.AbstractValue) {
      let res = _index.AbstractValue.createFromBinaryOp(realm, "==", px, y);

      (0, _invariant.default)(res instanceof _index.BooleanValue || res instanceof _index.AbstractValue);
      return res;
    }

    return AbstractEqualityComparison(realm, px, y, op);
  } // 10. Return false.


  return new _index.BooleanValue(realm, op !== "==");
} // ECMA262 7.2.14 Strict Equality Comparison


function StrictEqualityComparison(realm, x, y) {
  // 1. If Type(x) is different from Type(y), return false.
  if (!HasSameType(x, y)) {
    return false;
  } // 2. If Type(x) is Number, then


  if (x instanceof _index.NumberValue && y instanceof _index.NumberValue) {
    // a. If x is NaN, return false.
    if (isNaN(x.value)) return false; // b. If y is NaN, return false.

    if (isNaN(y.value)) return false; // c. If x is the same Number value as y, return true.
    // d. If x is +0 and y is -0, return true. (handled by c)
    // e. If x is -0 and y is +0, return true. (handled by c)

    if (x.value === y.value) return true; // f. Return false.

    return false;
  } // 3. Return SameValueNonNumber(x, y).


  return SameValueNonNumber(realm, x, y);
}

function StrictEqualityComparisonPartial(realm, x, y) {
  return StrictEqualityComparison(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());
} // ECMA262 7.2.10


function SameValueZero(realm, x, y) {
  // 1. If Type(x) is different from Type(y), return false.
  if (!HasSameType(x, y)) {
    return false;
  } // 2. If Type(x) is Number, then


  if (x instanceof _index.NumberValue) {
    (0, _invariant.default)(y instanceof _index.NumberValue); // a. If x is NaN and y is NaN, return true.

    if (isNaN(x.value) && isNaN(y.value)) return true; // b. If x is +0 and y is -0, return true.

    if (Object.is(x.value, +0) && Object.is(y.value, -0)) return true; // c. If x is -0 and y is +0, return true.

    if (Object.is(x.value, -0) && Object.is(y.value, +0)) return true; // d. If x is the same Number value as y, return true.

    if (x.value === y.value) return true; // e. Return false.

    return false;
  } // 3. Return SameValueNonNumber(x, y).


  return SameValueNonNumber(realm, x, y);
}

function SameValueZeroPartial(realm, x, y) {
  return SameValueZero(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());
} // ECMA262 7.2.9


function SameValue(realm, x, y) {
  // 1. If Type(x) is different from Type(y), return false.
  if (!HasSameType(x, y)) {
    return false;
  } // 2. If Type(x) is Number, then


  if (x instanceof _index.NumberValue && y instanceof _index.NumberValue) {
    // a. If x is NaN and y is NaN, return true.
    if (isNaN(x.value) && isNaN(y.value)) return true; // b. If x is +0 and y is -0, return false.

    if (Object.is(x.value, +0) && Object.is(y.value, -0)) return false; // c. If x is -0 and y is +0, return false.

    if (Object.is(x.value, -0) && Object.is(y.value, +0)) return false; // d. If x is the same Number value as y, return true.

    if (x.value === y.value) return true; // e. Return false.

    return false;
  } // 3. Return SameValueNonNumber(x, y).


  return SameValueNonNumber(realm, x, y);
}

function SameValuePartial(realm, x, y) {
  return SameValue(realm, x.throwIfNotConcrete(), y.throwIfNotConcrete());
} // ECMA262 7.2.11


function SameValueNonNumber(realm, x, y) {
  // 1. Assert: Type(x) is not Number.
  (0, _invariant.default)(!(x instanceof _index.NumberValue), "numbers not allowed"); // 2. Assert: Type(x) is the same as Type(y).

  (0, _invariant.default)(x.getType() === y.getType(), "must be same type"); // 3. If Type(x) is Undefined, return true.

  if (x instanceof _index.UndefinedValue) return true; // 4. If Type(x) is Null, return true.

  if (x instanceof _index.NullValue) return true; // 5. If Type(x) is String, then

  if (x instanceof _index.StringValue && y instanceof _index.StringValue) {
    // a. If x and y are exactly the same sequence of code units (same length and same code units at corresponding indices), return true; otherwise, return false.
    return x.value === y.value;
  } // 6. If Type(x) is Boolean, then


  if (x instanceof _index.BooleanValue && y instanceof _index.BooleanValue) {
    // a. If x and y are both true or both false, return true; otherwise, return false.
    return x.value === y.value;
  } // 7. If Type(x) is Symbol, then


  if (x instanceof _index.SymbolValue) {
    // a. If x and y are both the same Symbol value, return true; otherwise, return false.
    return x === y;
  } // 8. Return true if x and y are the same Object value. Otherwise, return false.


  return x === y;
} // Checks if two property keys are identical.


function SamePropertyKey(realm, x, y) {
  if (typeof x === "string" && typeof y === "string") {
    return x === y;
  }

  if (x instanceof _index.StringValue && y instanceof _index.StringValue) {
    return x.value === y.value;
  }

  if (x instanceof _index.SymbolValue && y instanceof _index.SymbolValue) {
    return x === y;
  }

  return false;
} // ECMA262 12.8.5 Applying the Additive Operators to Numbers


function Add(realm, a, b, subtract = false) {
  // If either operand is NaN, the result is NaN.
  if (isNaN(a) || isNaN(b)) {
    return realm.intrinsics.NaN;
  } // The sum of two infinities of opposite sign is NaN.
  // The sum of two infinities of the same sign is the infinity of that sign.
  // The sum of an infinity and a finite value is equal to the infinite operand.
  // The sum of two negative zeroes is -0. The sum of two positive zeroes, or of two zeroes of opposite sign, is +0.
  // The sum of a zero and a nonzero finite value is equal to the nonzero operand.
  // The sum of two nonzero finite values of the same magnitude and opposite sign is +0.


  let anum = a;
  let bnum = b; // The - operator performs subtraction when applied to two operands of numeric type,
  // producing the difference of its operands; the left operand is the minuend and the right
  // operand is the subtrahend. Given numeric operands a and b, it is always the case that
  // a-b produces the same result as a+(-b).

  if (subtract) {
    bnum = -bnum;
  }

  return _index.IntegralValue.createFromNumberValue(realm, anum + bnum);
} // ECMA262 12.10.4


function InstanceofOperator(realm, O, C) {
  // 1. If Type(C) is not Object, throw a TypeError exception.
  if (!C.mightBeObject()) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Expecting a function in instanceof check");
  } // 2. Let instOfHandler be ? GetMethod(C, @@hasInstance).


  let instOfHandler = (0, _get.GetMethod)(realm, C, realm.intrinsics.SymbolHasInstance); // 3. If instOfHandler is not undefined, then

  if (!(instOfHandler instanceof _index.UndefinedValue)) {
    // a. Return ToBoolean(? Call(instOfHandler, C,  O )).
    return _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, instOfHandler, C, [O]));
  } // 4. If IsCallable(C) is false, throw a TypeError exception.


  if ((0, _is.IsCallable)(realm, C) === false) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Expecting a function in instanceof check");
  } // 5. Return ? OrdinaryHasInstance(C, O).


  return OrdinaryHasInstance(realm, C, O);
} // ECMA262 7.3.19


function OrdinaryHasInstance(realm, C, O) {
  // 1. If IsCallable(C) is false, return false.
  if ((0, _is.IsCallable)(realm, C) === false) return false;
  (0, _invariant.default)(C instanceof _index.ObjectValue); // 2. If C has a [[BoundTargetFunction]] internal slot, then

  if (C instanceof _index.BoundFunctionValue) {
    // a. Let BC be the value of C's [[BoundTargetFunction]] internal slot.
    let BC = C.$BoundTargetFunction; // b. Return ? InstanceofOperator(O, BC).

    return InstanceofOperator(realm, O, BC);
  } // 3. If Type(O) is not Object, return false.


  O = O.throwIfNotConcrete();
  if (!(O instanceof _index.ObjectValue)) return false; // 4. Let P be ? Get(C, "prototype").

  let P = (0, _get.Get)(realm, C, "prototype").throwIfNotConcrete(); // 5. If Type(P) is not Object, throw a TypeError exception.

  if (!(P instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(P) is not Object");
  } // 6. Repeat


  while (true) {
    // a. Let O be ? O.[[GetPrototypeOf]]().
    O = O.$GetPrototypeOf(); // b. If O is null, return false.

    if (O instanceof _index.NullValue) return false; // c. If SameValue(P, O) is true, return true.

    if (SameValuePartial(realm, P, O) === true) return true;
  }

  return false;
} //


function Type(realm, val) {
  if (val instanceof _index.UndefinedValue) {
    return "Undefined";
  } else if (val instanceof _index.NullValue) {
    return "Null";
  } else if ((0, _has.HasCompatibleType)(val, _index.BooleanValue)) {
    return "Boolean";
  } else if ((0, _has.HasCompatibleType)(val, _index.StringValue)) {
    return "String";
  } else if ((0, _has.HasCompatibleType)(val, _index.SymbolValue)) {
    return "Symbol";
  } else if ((0, _has.HasCompatibleType)(val, _index.IntegralValue)) {
    return "Number";
  } else if ((0, _has.HasCompatibleType)(val, _index.NumberValue)) {
    return "Number";
  } else if (!val.mightNotBeObject()) {
    return "Object";
  } else {
    (0, _invariant.default)(val instanceof _index.AbstractValue);

    _index.AbstractValue.reportIntrospectionError(val);

    throw new _errors.FatalError();
  }
} // ECMA262 19.4.3.2.1


function SymbolDescriptiveString(realm, sym) {
  // 1. Assert: Type(sym) is Symbol.
  (0, _invariant.default)(sym instanceof _index.SymbolValue, "expected symbol"); // 2. Let desc be sym's [[Description]] value.

  let desc = sym.$Description; // 3. If desc is undefined, let desc be the empty string.

  if (!desc) desc = "";else desc = desc.throwIfNotConcreteString().value; // 4. Assert: Type(desc) is String.

  (0, _invariant.default)(typeof desc === "string", "expected string"); // 5. Return the result of concatenating the strings "Symbol(", desc, and ")".

  return `Symbol(${desc})`;
} // ECMA262 6.2.2.5


function UpdateEmpty(realm, completionRecord, value) {
  // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
  if (completionRecord instanceof _completions.ReturnCompletion || completionRecord instanceof _completions.ThrowCompletion) {
    (0, _invariant.default)(completionRecord.value, "expected completion record to have a value");
  } // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).


  if (completionRecord instanceof _index.EmptyValue) return value;
  if (completionRecord instanceof _index.Value || completionRecord.value && !(completionRecord.value instanceof _index.EmptyValue)) return completionRecord; // 3. Return Completion{[[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.'

  completionRecord.value = value;
  return completionRecord;
}
//# sourceMappingURL=abstract.js.map

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArgumentListEvaluation = ArgumentListEvaluation;
exports.Invoke = Invoke;
exports.EvaluateCall = EvaluateCall;
exports.PrepareForOrdinaryCall = PrepareForOrdinaryCall;
exports.OrdinaryCallBindThis = OrdinaryCallBindThis;
exports.OrdinaryCallEvaluateBody = OrdinaryCallEvaluateBody;
exports.EvaluateDirectCall = EvaluateDirectCall;
exports.EvaluateDirectCallWithArgList = EvaluateDirectCallWithArgList;
exports.PrepareForTailCall = PrepareForTailCall;
exports.Call = Call;

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _Value = _interopRequireDefault(__webpack_require__(11));

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _generator = __webpack_require__(235);

var _completions = __webpack_require__(18);

var _get = __webpack_require__(230);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _generator2 = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 12.3.6.1
function ArgumentListEvaluation(realm, strictCode, env, argNodes) {
  if (Array.isArray(argNodes)) {
    let args = [];

    for (let node_ of argNodes) {
      if (node_.type === "SpreadElement") {
        let node = node_; // 1. Let list be a new empty List.

        let list = args; // 2. Let spreadRef be the result of evaluating AssignmentExpression.

        let spreadRef = env.evaluate(node.argument, strictCode); // 3. Let spreadObj be ? GetValue(spreadRef).

        let spreadObj = _singletons.Environment.GetValue(realm, spreadRef); // 4. Let iterator be ? GetIterator(spreadObj).


        let iterator = (0, _index2.GetIterator)(realm, spreadObj); // 5. Repeat

        while (true) {
          // a. Let next be ? IteratorStep(iterator).
          let next = (0, _index2.IteratorStep)(realm, iterator); // b. If next is false, return list.

          if (!next) {
            break;
          } // c. Let nextArg be ? IteratorValue(next).


          let nextArg = (0, _index2.IteratorValue)(realm, next); // d. Append nextArg as the last element of list.

          list.push(nextArg);
        }
      } else {
        let ref = env.evaluate(node_, strictCode);

        let expr = _singletons.Environment.GetValue(realm, ref);

        args.push(expr);
      }
    }

    return args;
  } else {
    let node = argNodes;

    if (node.expressions.length === 0) {
      // 1. Let templateLiteral be this TemplateLiteral.
      let templateLiteral = node; // 2. Let siteObj be GetTemplateObject(templateLiteral).

      let siteObj = (0, _get.GetTemplateObject)(realm, templateLiteral); // 3. Return a List containing the one element which is siteObj.

      return [siteObj];
    } else {
      // 1. Let templateLiteral be this TemplateLiteral.
      let templateLiteral = node; // 2. Let siteObj be GetTemplateObject(templateLiteral).

      let siteObj = (0, _get.GetTemplateObject)(realm, templateLiteral); // 3. Let firstSubRef be the result of evaluating Expression.

      let firstSubRef = env.evaluate(node.expressions[0], strictCode); // 4. Let firstSub be ? GetValue(firstSubRef).

      let firstSub = _singletons.Environment.GetValue(realm, firstSubRef); // 5. Let restSub be SubstitutionEvaluation of TemplateSpans.


      let restSub = node.expressions.slice(1, node.expressions.length).map(expr => {
        return _singletons.Environment.GetValue(realm, env.evaluate(expr, strictCode));
      }); // 6. ReturnIfAbrupt(restSub).
      // 7. Assert: restSub is a List.

      (0, _invariant.default)(restSub.constructor === Array, "restSub is a List"); // 8. Return a List whose first element is siteObj, whose second elements is firstSub, and whose subsequent elements are the elements of restSub, in order. restSub may contain no elements.

      return [siteObj, firstSub, ...restSub];
    }
  }
} // ECMA262 7.3.18


function Invoke(realm, V, P, argumentsList) {
  // 1. Assert: IsPropertyKey(P) is true.
  (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected property key"); // 2. If argumentsList was not passed, let argumentsList be a new empty List.

  if (!argumentsList) argumentsList = []; // 3. Let func be ? GetV(V, P).

  let func = (0, _get.GetV)(realm, V, P); // 4. Return ? Call(func, V, argumentsList).

  return Call(realm, func, V, argumentsList);
} // ECMA262 12.3.4.2


function EvaluateCall(realm, strictCode, env, ref, args) {
  let thisValue; // 1. Let func be ? GetValue(ref).

  let func = _singletons.Environment.GetValue(realm, ref); // 2. If Type(ref) is Reference, then


  if (ref instanceof _environment.Reference) {
    // a. If IsPropertyReference(ref) is true, then
    if (_singletons.Environment.IsPropertyReference(realm, ref)) {
      // i. Let thisValue be GetThisValue(ref).
      thisValue = (0, _get.GetThisValue)(realm, ref);
    } else {
      // b. Else, the base of ref is an Environment Record
      // i. Let refEnv be GetBase(ref).
      let refEnv = _singletons.Environment.GetBase(realm, ref);

      (0, _invariant.default)(refEnv instanceof _environment.EnvironmentRecord); // ii. Let thisValue be refEnv.WithBaseObject().

      thisValue = refEnv.WithBaseObject();
    }
  } else {
    // 3. Else Type(ref) is not Reference,
    // a. Let thisValue be undefined.
    thisValue = realm.intrinsics.undefined;
  } // 4. Return ? EvaluateDirectCall(func, thisValue, arguments, tailPosition).


  return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, args);
} // ECMA262 9.2.1.1


function PrepareForOrdinaryCall(realm, F, newTarget) {
  // 1. Assert: Type(newTarget) is Undefined or Object.
  (0, _invariant.default)(newTarget === undefined || newTarget instanceof _index.ObjectValue, "expected undefined or object value for new target"); // 2. Let callerContext be the running execution context.

  let callerContext = realm.getRunningContext(); // 3. Let calleeContext be a new ECMAScript code execution context.

  let calleeContext = realm.createExecutionContext(); // 4. Set the Function of calleeContext to F.

  calleeContext.setFunction(F);
  calleeContext.setCaller(realm.getRunningContext()); // 5. Let calleeRealm be the value of F's [[Realm]] internal slot.

  let calleeRealm = realm; // 6. Set the Realm of calleeContext to calleeRealm.

  calleeContext.realm = calleeRealm; // 7. Set the ScriptOrModule of calleeContext to the value of F's [[ScriptOrModule]] internal slot.

  calleeContext.ScriptOrModule = F.$ScriptOrModule; // 8. Let localEnv be NewFunctionEnvironment(F, newTarget).

  let localEnv = _singletons.Environment.NewFunctionEnvironment(realm, F, newTarget); // 9. Set the LexicalEnvironment of calleeContext to localEnv.


  calleeContext.lexicalEnvironment = localEnv; // 10. Set the VariableEnvironment of calleeContext to localEnv.

  calleeContext.variableEnvironment = localEnv; // 11. If callerContext is not already suspended, suspend callerContext.

  callerContext.suspend(); // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.

  try {
    realm.pushContext(calleeContext);
  } catch (error) {
    // `realm.pushContext` may throw if we have exceeded the maximum stack size.
    realm.onDestroyScope(localEnv);
    throw error;
  } // 13. NOTE Any exception objects produced after this point are associated with calleeRealm.
  // 14. Return calleeContext.


  return calleeContext;
} // ECMA262 9.2.1.2


function OrdinaryCallBindThis(realm, F, calleeContext, thisArgument) {
  // 1. Let thisMode be the value of F's [[ThisMode]] internal slot.
  let thisMode = F.$ThisMode; // 2. If thisMode is lexical, return NormalCompletion(undefined).

  if (thisMode === "lexical") return realm.intrinsics.undefined; // 3. Let calleeRealm be the value of F's [[Realm]] internal slot.

  let calleeRealm = F.$Realm; // 4. Let localEnv be the LexicalEnvironment of calleeContext.

  let localEnv = calleeContext.lexicalEnvironment;
  let thisValue; // 5. If thisMode is strict, let thisValue be thisArgument.

  if (thisMode === "strict") {
    thisValue = thisArgument;
  } else {
    // 6. Else,
    // a. If thisArgument is null or undefined, then
    if ((0, _index2.HasSomeCompatibleType)(thisArgument, _index.NullValue, _index.UndefinedValue)) {
      // i. Let globalEnv be calleeRealm.[[GlobalEnv]].
      let globalEnv = realm.$GlobalEnv; // ii. Let globalEnvRec be globalEnv's EnvironmentRecord.

      let globalEnvRec = globalEnv.environmentRecord;
      (0, _invariant.default)(globalEnvRec instanceof _environment.GlobalEnvironmentRecord); // iii. Let thisValue be globalEnvRec.[[GlobalThisValue]].

      thisValue = globalEnvRec.$GlobalThisValue;
    } else {
      //  b. Else,
      // i. Let thisValue be ! ToObject(thisArgument).
      thisValue = _singletons.To.ToObject(calleeRealm, thisArgument); // ii. NOTE ToObject produces wrapper objects using calleeRealm.
    }
  } // 7. Let envRec be localEnv's EnvironmentRecord.


  (0, _invariant.default)(localEnv !== undefined);
  let envRec = localEnv.environmentRecord; // 8. Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not "initialized".
  // 9. Return envRec.BindThisValue(thisValue).

  return envRec.BindThisValue(thisValue);
}

function callNativeFunctionValue(realm, f, argumentsList) {
  let env = realm.getRunningContext().lexicalEnvironment;
  let context = env.environmentRecord.GetThisBinding(); // we have an inConditional flag, as we do not want to return

  const functionCall = (contextVal, inConditional) => {
    try {
      (0, _invariant.default)(contextVal instanceof _index.AbstractObjectValue || contextVal instanceof _index.ObjectValue || contextVal instanceof _index.NullValue || contextVal instanceof _index.UndefinedValue || (0, _environment.mightBecomeAnObject)(contextVal));
      let completion = f.callCallback( // TODO: this is not right. Either fix the type signature of callCallback or wrap contextVal in a coercion
      contextVal, argumentsList, env.environmentRecord.$NewTarget);
      return inConditional ? completion.value : completion;
    } catch (err) {
      if (err instanceof _completions.AbruptCompletion) {
        return inConditional ? err.value : err;
      } else if (err instanceof Error) {
        throw err;
      } else {
        throw new _errors.FatalError(err);
      }
    }
  };

  const wrapInReturnCompletion = contextVal => new _completions.ReturnCompletion(contextVal, realm.currentLocation);

  if (context instanceof _index.AbstractObjectValue && context.kind === "conditional") {
    let [condValue, consequentVal, alternateVal] = context.args;
    (0, _invariant.default)(condValue instanceof _index.AbstractValue);
    return wrapInReturnCompletion(realm.evaluateWithAbstractConditional(condValue, () => {
      return realm.evaluateForEffects(() => functionCall(consequentVal, true), null, "callNativeFunctionValue consequent");
    }, () => {
      return realm.evaluateForEffects(() => functionCall(alternateVal, true), null, "callNativeFunctionValue alternate");
    }));
  }

  let c = functionCall(context, false);
  if (c instanceof _completions.AbruptCompletion) return c;
  return undefined;
} // ECMA262 9.2.1.3


function OrdinaryCallEvaluateBody(realm, f, argumentsList) {
  if (f instanceof _index.NativeFunctionValue) {
    return callNativeFunctionValue(realm, f, argumentsList);
  } else {
    (0, _invariant.default)(f instanceof _index.ECMAScriptSourceFunctionValue);
    let F = f;

    if (F.$FunctionKind === "generator") {
      // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
      _singletons.Functions.FunctionDeclarationInstantiation(realm, F, argumentsList); // 2. Let G be ? OrdinaryCreateFromConstructor(functionObject, "%GeneratorPrototype%",  [[GeneratorState]], [[GeneratorContext]] ).


      let G = _singletons.Create.OrdinaryCreateFromConstructor(realm, F, "GeneratorPrototype", {
        $GeneratorState: undefined,
        $GeneratorContext: undefined
      }); // 3. Perform GeneratorStart(G, FunctionBody).


      let code = F.$ECMAScriptCode;
      (0, _invariant.default)(code !== undefined);
      (0, _generator.GeneratorStart)(realm, G, code); // 4. Return Completion{[[Type]]: return, [[Value]]: G, [[Target]]: empty}.

      return new _completions.ReturnCompletion(G, realm.currentLocation);
    } else {
      // TODO #1586: abstractRecursionSummarization is disabled for now, as it is likely too limiting
      // (as observed in large internal tests).
      const abstractRecursionSummarization = false;
      if (!realm.useAbstractInterpretation || realm.pathConditions.isEmpty() || !abstractRecursionSummarization) return normalCall();
      let savedIsSelfRecursive = F.isSelfRecursive;

      try {
        F.isSelfRecursive = false;
        let effects = realm.evaluateForEffects(guardedCall, undefined, "OrdinaryCallEvaluateBody");

        if (F.isSelfRecursive) {
          _index.AbstractValue.reportIntrospectionError(F, "call to function that calls itself");

          throw new _errors.FatalError(); //todo: need to emit a specialized function that temporally captures the heap state at this point
        } else {
          realm.applyEffects(effects);
          let c = effects.result;
          return processResult(() => {
            if (c instanceof _completions.AbruptCompletion || c instanceof _completions.JoinedNormalAndAbruptCompletions) return c;
            return undefined;
          });
        }
      } finally {
        F.isSelfRecursive = savedIsSelfRecursive;
      }

      function guardedCall() {
        let currentLocation = realm.currentLocation;

        if (F.activeArguments !== undefined && F.activeArguments.has(currentLocation)) {
          let [previousPathLength, previousArguments] = F.activeArguments.get(currentLocation);

          if (realm.pathConditions.getLength() > previousPathLength) {
            (0, _invariant.default)(previousArguments !== undefined); // F is being called recursively while a call to it is still active

            F.isSelfRecursive = true;

            let widenedArgumentsList = _singletons.Widen.widenValues(realm, previousArguments, argumentsList);

            if (_singletons.Widen.containsArraysOfValue(realm, previousArguments, widenedArgumentsList)) {
              // Reached a fixed point. Executing this call will not add any knowledge
              // about the effects of the original call.
              return realm.intrinsics.undefined;
            } else {
              argumentsList = widenedArgumentsList;
            }
          }
        }

        try {
          if (F.activeArguments === undefined) F.activeArguments = new Map();
          F.activeArguments.set(currentLocation, [realm.pathConditions.getLength(), argumentsList]);
          return normalCall() || realm.intrinsics.undefined;
        } finally {
          F.activeArguments.delete(currentLocation);
        }
      }

      function normalCall() {
        // 1. Perform ? FunctionDeclarationInstantiation(F, argumentsList).
        _singletons.Functions.FunctionDeclarationInstantiation(realm, F, argumentsList); // 2. Return the result of EvaluateBody of the parsed code that is the value of F's
        //    [[ECMAScriptCode]] internal slot passing F as the argument.


        let code = F.$ECMAScriptCode;
        (0, _invariant.default)(code !== undefined);
        let context = realm.getRunningContext();
        return processResult(() => {
          let c = context.lexicalEnvironment.evaluateCompletionDeref(code, F.$Strict);
          if (c instanceof _completions.AbruptCompletion || c instanceof _completions.JoinedNormalAndAbruptCompletions) return c;
          return undefined;
        });
      }

      function processResult(getCompletion) {
        // We don't want the callee to see abrupt completions from the caller.
        let priorSavedCompletion = realm.savedCompletion;
        realm.savedCompletion = undefined;
        let c;

        try {
          c = getCompletion();
        } catch (e) {
          (0, _invariant.default)(!(e instanceof _completions.AbruptCompletion));
          throw e;
        }

        c = _singletons.Functions.incorporateSavedCompletion(realm, c); // in case the callee had conditional abrupt completions

        realm.savedCompletion = priorSavedCompletion;
        if (c === undefined) return undefined; // the callee had no returns or throws

        if (c instanceof _completions.ThrowCompletion || c instanceof _completions.ReturnCompletion) return c; // Non mixed completions will not be joined completions, but single completions with joined values.
        // At this point it must be true that
        // c contains return completions and possibly also normal completions (which are implicitly "return undefined;")
        // and c also contains throw completions. Hence we assert:

        (0, _invariant.default)(c instanceof _completions.JoinedAbruptCompletions || c instanceof _completions.JoinedNormalAndAbruptCompletions); // We want to add only the throw completions to priorSavedCompletion (but must keep their conditions in tact).
        // The (joined) return completions must be returned to our caller

        let rc = c;

        _completions.Completion.makeAllNormalCompletionsResultInUndefined(c);

        c = _completions.Completion.normalizeSelectedCompletions(r => r instanceof _completions.ReturnCompletion, c);
        (0, _invariant.default)(c.containsSelectedCompletion(r => r instanceof _completions.NormalCompletion));

        let rv = _singletons.Join.joinValuesOfSelectedCompletions(r => r instanceof _completions.NormalCompletion, c);

        if (c.containsSelectedCompletion(r => r instanceof _completions.ThrowCompletion)) {
          realm.composeWithSavedCompletion(c);

          if (rv instanceof _index.AbstractValue) {
            rv = realm.simplifyAndRefineAbstractValue(rv);
          }
        }

        rc = new _completions.ReturnCompletion(rv);
        return rc;
      }
    }
  }
} // ECMA262 12.3.4.3


function EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, args, tailPosition) {
  // 1. Let argList be ? ArgumentListEvaluation(arguments).
  let argList = ArgumentListEvaluation(realm, strictCode, env, args);
  return EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailPosition);
}

function EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailPosition) {
  if (func instanceof _index.AbstractObjectValue && _Value.default.isTypeCompatibleWith(func.getType(), _index.FunctionValue)) {
    return _index.AbstractValue.createTemporalFromBuildFunction(realm, func.functionResultType || _Value.default, [func].concat(argList), (0, _generator2.createOperationDescriptor)("DIRECT_CALL_WITH_ARG_LIST"));
  }

  func = func.throwIfNotConcrete(); // 2. If Type(func) is not Object, throw a TypeError exception.

  if (!(func instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an object");
  } // 3. If IsCallable(func) is false, throw a TypeError exception.


  if (!(0, _index2.IsCallable)(realm, func)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable");
  } // 4. If tailPosition is true, perform PrepareForTailCall().


  if (tailPosition === true) PrepareForTailCall(realm); // 5. Let result be Call(func, thisValue, argList).

  let result = Call(realm, func, thisValue, argList); // 6. Assert: If tailPosition is true, the above call will not return here, but instead
  //    evaluation will continue as if the following return has already occurred.
  // 7. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.

  (0, _invariant.default)(result instanceof _Value.default, "expected language value type"); // 8. Return result.

  return result;
} // ECMA262 14.6.3


function PrepareForTailCall(realm) {
  // 1. Let leafContext be the running execution context.
  let leafContext = realm.getRunningContext(); // 2. Suspend leafContext.

  leafContext.suspend(); // 3. Pop leafContext from the execution context stack. The execution context now on the
  //    top of the stack becomes the running execution context.

  realm.onDestroyScope(leafContext.lexicalEnvironment);
  realm.popContext(leafContext); // TODO #1008 4. Assert: leafContext has no further use. It will never be activated as the running execution context.
} // ECMA262 7.3.12


function Call(realm, F, V, argsList) {
  // 1. If argumentsList was not passed, let argumentsList be a new empty List.
  argsList = argsList || []; // 2. If IsCallable(F) is false, throw a TypeError exception.

  if ((0, _index2.IsCallable)(realm, F) === false) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable");
  }

  if (F instanceof _index.AbstractValue && _Value.default.isTypeCompatibleWith(F.getType(), _index.FunctionValue)) {
    _singletons.Leak.value(realm, V);

    for (let arg of argsList) {
      _singletons.Leak.value(realm, arg);
    }

    if (V === realm.intrinsics.undefined) {
      let fullArgs = [F].concat(argsList);
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _Value.default, fullArgs, (0, _generator2.createOperationDescriptor)("CALL_ABSTRACT_FUNC"));
    } else {
      let fullArgs = [F, V].concat(argsList);
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _Value.default, fullArgs, (0, _generator2.createOperationDescriptor)("CALL_ABSTRACT_FUNC_THIS"));
    }
  }

  (0, _invariant.default)(F instanceof _index.ObjectValue); // 3. Return ? F.[[Call]](V, argumentsList).

  (0, _invariant.default)(F.$Call, "no call method on this value");
  return F.$Call(V, argsList);
}
//# sourceMappingURL=call.js.map

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeneratorStart = GeneratorStart;
exports.GeneratorValidate = GeneratorValidate;
exports.GeneratorResume = GeneratorResume;
exports.GeneratorResumeAbrupt = GeneratorResumeAbrupt;
exports.GeneratorYield = GeneratorYield;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA26225.3.3.1
function GeneratorStart(realm, generator, generatorBody) {
  // Note that generator is a new object, and we can thus write to internal slots
  (0, _invariant.default)(realm.isNewObject(generator)); // 1. Assert: The value of generator.[[GeneratorState]] is undefined.

  (0, _invariant.default)(generator instanceof _index.ObjectValue && generator.$GeneratorState === undefined, "The value of generator.[[GeneratorState]] is undefined"); // 2. Let genContext be the running execution context.

  let genContext = realm.getRunningContext(); // 3. Set the Generator component of genContext to generator.
  // 4. Set the code evaluation state of genContext such that when evaluation is resumed for that execution context the following steps will be performed:
  // a. Let result be the result of evaluating generatorBody.
  // b. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
  // c. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
  // d. Set generator.[[GeneratorState]] to "completed".
  // e. Once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.
  // f. If result is a normal completion, let resultValue be undefined.
  // g. Else,
  // i. If result.[[Type]] is return, let resultValue be result.[[Value]].
  // ii. Else, return Completion(result).
  // h. Return CreateIterResultObject(resultValue, true).
  // 5. Set generator.[[GeneratorContext]] to genContext.

  generator.$GeneratorContext = genContext; // 6. Set generator.[[GeneratorState]] to "suspendedStart".

  generator.$GeneratorState = "suspendedStart"; // 7. Return NormalCompletion(undefined).

  return realm.intrinsics.undefined;
} // ECMA26225.3.3.2


function GeneratorValidate(realm, generator) {
  // 1. If Type(generator) is not Object, throw a TypeError exception.
  if (!(generator instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "Type(generator) is not Object");
  } // 2. If generator does not have a [[GeneratorState]] internal slot, throw a TypeError exception.


  if (!("$GeneratorState" in generator)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "Type(generator) is not Object");
  } // 3. Assert: generator also has a [[GeneratorContext]] internal slot.


  (0, _invariant.default)("$GeneratorContext" in generator); // 4. Let state be generator.[[GeneratorState]].

  let state = generator.$GeneratorState; // 5. If state is "executing", throw a TypeError exception.

  if (state === "executing") {
    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "Type(generator) is not Object");
  } // 6. Return state.


  return state;
} // ECMA26225.3.3.3


function GeneratorResume(realm, generator, value) {
  // 1. Let state be ? GeneratorValidate(generator).
  let state = GeneratorValidate(realm, generator);
  (0, _invariant.default)(generator instanceof _index.ObjectValue); // 2. If state is "completed", return CreateIterResultObject(undefined, true).

  if (state === "completed") return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true); // 3. Assert: state is either "suspendedStart" or "suspendedYield".

  (0, _invariant.default)(state === "suspendedStart" || state === "suspendedYield", "state is either 'suspendedStart' or 'suspendedYield'"); // 4. Let genContext be generator.[[GeneratorContext]].

  let genContext = generator.$GeneratorContext;
  (0, _invariant.default)(genContext); // 5. Let methodContext be the running execution context.

  let methodContext = realm.getRunningContext(); // 6. Suspend methodContext.

  methodContext.suspend(); // 7. Set generator.[[GeneratorState]] to "executing".

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, generator, "$GeneratorState").$GeneratorState = "executing"; // 8. Push genContext onto the execution context stack; genContext is now the running execution context.

  realm.pushContext(genContext); // 9. Resume the suspended evaluation of genContext using NormalCompletion(value) as the result of the operation that suspended it. Let result be the value returned by the resumed computation.

  let result = genContext.resume(); // 10. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.

  (0, _invariant.default)(realm.getRunningContext() === methodContext); // 11. Return Completion(result).

  return result;
} // ECMA26225.3.3.4


function GeneratorResumeAbrupt(realm, generator, abruptCompletion) {
  // 1. Let state be ? GeneratorValidate(generator).
  // 2. If state is "suspendedStart", then
  // a. Set generator.[[GeneratorState]] to "completed".
  // b. Once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.
  // c. Let state be "completed".
  // 3. If state is "completed", then
  // a. If abruptCompletion.[[Type]] is return, then
  // i. Return CreateIterResultObject(abruptCompletion.[[Value]], true).
  // b. Return Completion(abruptCompletion).
  // 4. Assert: state is "suspendedYield".
  // 5. Let genContext be generator.[[GeneratorContext]].
  // 6. Let methodContext be the running execution context.
  // 7. Suspend methodContext.
  // 8. Set generator.[[GeneratorState]] to "executing".
  // 9. Push genContext onto the execution context stack; genContext is now the running execution context.
  // 10. Resume the suspended evaluation of genContext using abruptCompletion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.
  // 11. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.
  // 12. Return Completion(result).
  return realm.intrinsics.undefined;
} // ECMA26225.3.3.5


function GeneratorYield(realm, iterNextObj) {
  // 1. Assert: iterNextObj is an Object that implements the IteratorResult interface.
  // 2. Let genContext be the running execution context.
  // 3. Assert: genContext is the execution context of a generator.
  // 4. Let generator be the value of the Generator component of genContext.
  // 5. Set generator.[[GeneratorState]] to "suspendedYield".
  // 6. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
  // 7. Set the code evaluation state of genContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:
  // a.  Return resumptionValue.
  // b. NOTE: This returns to the evaluation of the YieldExpression production that originally called this abstract operation.
  // 8. Return NormalCompletion(iterNextObj).
  return realm.intrinsics.undefined; // 9. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of genContext.
}
//# sourceMappingURL=generator.js.map

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setCreate = setCreate;
exports.setEnvironment = setEnvironment;
exports.setFunctions = setFunctions;
exports.setLeak = setLeak;
exports.setMaterialize = setMaterialize;
exports.setJoin = setJoin;
exports.setPath = setPath;
exports.setPathConditions = setPathConditions;
exports.setProperties = setProperties;
exports.setTo = setTo;
exports.setWiden = setWiden;
exports.setConcretize = setConcretize;
exports.setUtils = setUtils;
exports.setDebugReproManager = setDebugReproManager;
exports.DebugReproManager = exports.Utils = exports.concretize = exports.Widen = exports.To = exports.Properties = exports.createPathConditions = exports.Path = exports.Join = exports.Materialize = exports.Leak = exports.Functions = exports.Environment = exports.Create = void 0;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
let Create = null;
exports.Create = Create;
let Environment = null;
exports.Environment = Environment;
let Functions = null;
exports.Functions = Functions;
let Leak = null;
exports.Leak = Leak;
let Materialize = null;
exports.Materialize = Materialize;
let Join = null;
exports.Join = Join;
let Path = null;
exports.Path = Path;
let createPathConditions = null;
exports.createPathConditions = createPathConditions;
let Properties = null;
exports.Properties = Properties;
let To = null;
exports.To = To;
let Widen = null;
exports.Widen = Widen;
let concretize = null;
exports.concretize = concretize;
let Utils = null;
exports.Utils = Utils;
let DebugReproManager = null;
exports.DebugReproManager = DebugReproManager;

function setCreate(singleton) {
  exports.Create = Create = singleton;
}

function setEnvironment(singleton) {
  exports.Environment = Environment = singleton;
}

function setFunctions(singleton) {
  exports.Functions = Functions = singleton;
}

function setLeak(singleton) {
  exports.Leak = Leak = singleton;
}

function setMaterialize(singleton) {
  exports.Materialize = Materialize = singleton;
}

function setJoin(singleton) {
  exports.Join = Join = singleton;
}

function setPath(singleton) {
  exports.Path = Path = singleton;
}

function setPathConditions(f) {
  exports.createPathConditions = createPathConditions = f;
}

function setProperties(singleton) {
  exports.Properties = Properties = singleton;
}

function setTo(singleton) {
  exports.To = To = singleton;
}

function setWiden(singleton) {
  exports.Widen = Widen = singleton;
}

function setConcretize(singleton) {
  exports.concretize = concretize = singleton;
}

function setUtils(singleton) {
  exports.Utils = Utils = singleton;
}

function setDebugReproManager(singleton) {
  exports.DebugReproManager = DebugReproManager = singleton;
}
//# sourceMappingURL=singletons.js.map

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOperationDescriptor = createOperationDescriptor;
exports.attemptToMergeEquivalentObjectAssigns = attemptToMergeEquivalentObjectAssigns;
exports.Generator = exports.TemporalObjectAssignEntry = exports.TemporalOperationEntry = exports.GeneratorEntry = void 0;

var _index = __webpack_require__(10);

var _errors = __webpack_require__(3);

var _index2 = __webpack_require__(15);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _completions = __webpack_require__(18);

var _singletons = __webpack_require__(236);

var _PreludeGenerator = __webpack_require__(238);

var _descriptors = __webpack_require__(268);

var _environment = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createOperationDescriptor(type, data = {}) {
  return {
    data,
    type
  };
}

class GeneratorEntry {
  constructor(realm) {
    // We increment the index of every TemporalOperationEntry created.
    // This should match up as a form of timeline value due to the tree-like
    // structure we use to create entries during evaluation. For example,
    // if all AST nodes in a BlockStatement resulted in a temporal operation
    // for each AST node, then each would have a sequential index as to its
    // position of how it was evaluated in the BlockSstatement.
    this.index = realm.temporalEntryCounter++;
  }

  print(printer) {
    (0, _invariant.default)(false, "GeneratorEntry is an abstract base class");
  }

  visit(callbacks, containingGenerator) {
    (0, _invariant.default)(false, "GeneratorEntry is an abstract base class");
  }

  serialize(context) {
    (0, _invariant.default)(false, "GeneratorEntry is an abstract base class");
  }

  getDependencies() {
    (0, _invariant.default)(false, "GeneratorEntry is an abstract base class");
  }

  notEqualToAndDoesNotHappenBefore(entry) {
    return this.index > entry.index;
  }

  notEqualToAndDoesNotHappenAfter(entry) {
    return this.index < entry.index;
  }

}

exports.GeneratorEntry = GeneratorEntry;

class TemporalOperationEntry extends GeneratorEntry {
  constructor(realm, args) {
    super(realm);
    Object.assign(this, args);

    if (this.mutatesOnly !== undefined) {
      (0, _invariant.default)(!this.isPure);

      for (let arg of this.mutatesOnly) {
        (0, _invariant.default)(this.args.includes(arg));
      }
    }

    (0, _invariant.default)(this.operationDescriptor !== undefined);
  }

  print(printer) {
    const operationDescriptor = this.operationDescriptor;
    printer.printGeneratorEntry(this.declared, operationDescriptor.type, this.args, this.operationDescriptor.data, {
      isPure: !!this.isPure,
      mutatesOnly: this.mutatesOnly
    });
  }

  toDisplayJson(depth) {
    if (depth <= 0) return `TemporalOperation${this.index}`;

    let obj = _objectSpread({
      type: "TemporalOperation"
    }, this);

    delete obj.operationDescriptor;
    return _singletons.Utils.verboseToDisplayJson(obj, depth);
  }

  visit(callbacks, containingGenerator) {
    let omit = this.isPure && this.declared && callbacks.canOmit(this.declared);

    if (!omit && this.declared && this.mutatesOnly !== undefined) {
      omit = true;

      for (let arg of this.mutatesOnly) {
        if (!callbacks.canOmit(arg)) {
          omit = false;
        }
      }
    }

    if (omit) {
      callbacks.recordDelayedEntry(containingGenerator, this);
      return false;
    } else {
      if (this.declared) callbacks.recordDeclaration(this.declared);

      for (let i = 0, n = this.args.length; i < n; i++) {
        let originalArg = this.args[i];
        let visitedArg = callbacks.visitEquivalentValue(originalArg);
        this.args[i] = visitedArg;

        if (i === 0) {
          switch (this.operationDescriptor.type) {
            case "CALL_BAILOUT":
              if (originalArg === this.operationDescriptor.data.thisArg) this.operationDescriptor.data.thisArg = visitedArg;
              break;

            case "CONDITIONAL_THROW":
              this.operationDescriptor.data.value = visitedArg;
              break;

            default:
              break;
          }
        } else if (i === 1) {
          switch (this.operationDescriptor.type) {
            case "EMIT_PROPERTY_ASSIGNMENT":
            case "LOGICAL_PROPERTY_ASSIGNMENT":
              this.operationDescriptor.data.value = visitedArg;
              break;

            case "CONDITIONAL_PROPERTY_ASSIGNMENT":
              if (originalArg === this.operationDescriptor.data.value) this.operationDescriptor.data.value = visitedArg;
              break;

            case "DEFINE_PROPERTY":
              (0, _invariant.default)(visitedArg instanceof _index.ObjectValue);
              this.operationDescriptor.data.object = visitedArg;
              break;

            default:
              break;
          }
        }
      }

      let dependencies = this.getDependencies();
      if (dependencies !== undefined) for (let dependency of dependencies) callbacks.visitGenerator(dependency, containingGenerator);
      return true;
    }
  }

  serialize(context) {
    let omit = this.isPure && this.declared && context.canOmit(this.declared);

    if (!omit && this.declared && this.mutatesOnly !== undefined) {
      omit = true;

      for (let arg of this.mutatesOnly) {
        if (!context.canOmit(arg)) {
          omit = false;
        }
      }
    }

    if (!omit) {
      let nodes = this.args.map((boundArg, i) => context.serializeValue(boundArg));
      let valuesToProcess = new Set();
      let declaredId = this.declared !== undefined ? this.declared.intrinsicName : undefined;
      let node = context.serializeOperationDescriptor(this.operationDescriptor, nodes, context, valuesToProcess, declaredId);

      if (node.type === "BlockStatement") {
        let block = node;
        let statements = block.body;
        if (statements.length === 0) return;

        if (statements.length === 1) {
          node = statements[0];
        }
      }

      let declared = this.declared;

      if (declared !== undefined && context.options.debugScopes) {
        context.emit(context.serializeDebugScopeComment(declared));
      }

      context.emit(node);
      context.processValues(valuesToProcess);
      if (this.declared !== undefined) context.declare(this.declared);
    }
  }

  getDependencies() {
    const operationDescriptor = this.operationDescriptor;

    switch (operationDescriptor.type) {
      case "DO_WHILE":
        let generator = operationDescriptor.data.generator;
        (0, _invariant.default)(generator !== undefined);
        return [generator];

      case "JOIN_GENERATORS":
        let generators = operationDescriptor.data.generators;
        (0, _invariant.default)(generators !== undefined);
        return generators;

      default:
        return undefined;
    }
  }

}

exports.TemporalOperationEntry = TemporalOperationEntry;

class TemporalObjectAssignEntry extends TemporalOperationEntry {
  visit(callbacks, containingGenerator) {
    let declared = this.declared;

    if (!(declared instanceof _index.AbstractObjectValue || declared instanceof _index.ObjectValue)) {
      return false;
    }

    let realm = declared.$Realm; // The only optimization we attempt to do to Object.assign for now is merging of multiple entries
    // into a new generator entry.

    let result = attemptToMergeEquivalentObjectAssigns(realm, callbacks, this);

    if (result instanceof TemporalObjectAssignEntry) {
      let nextResult = result;

      while (nextResult instanceof TemporalObjectAssignEntry) {
        nextResult = attemptToMergeEquivalentObjectAssigns(realm, callbacks, result); // If we get back a TemporalObjectAssignEntry, then we have successfully merged a single
        // Object.assign, but we may be able to merge more. So repeat the process.

        if (nextResult instanceof TemporalObjectAssignEntry) {
          result = nextResult;
        }
      } // We have an optimized temporal entry, so replace the current temporal
      // entry and visit that entry instead.


      this.args = result.args;
    } else if (result === "POSSIBLE_OPTIMIZATION") {
      callbacks.recordDelayedEntry(containingGenerator, this);
      return false;
    }

    return super.visit(callbacks, containingGenerator);
  }

}

exports.TemporalObjectAssignEntry = TemporalObjectAssignEntry;

class ModifiedPropertyEntry extends GeneratorEntry {
  constructor(realm, args) {
    super(realm);
    Object.assign(this, args);
  }

  print(printer) {
    printer.printGeneratorEntry(undefined, "MODIFIED_PROPERTY", [], {
      descriptor: this.newDescriptor,
      propertyBinding: this.propertyBinding
    }, {
      isPure: false,
      mutatesOnly: undefined
    });
  }

  toDisplayString() {
    let propertyKey = this.propertyBinding.key;
    let propertyKeyString = propertyKey instanceof _index.Value ? propertyKey.toDisplayString() : propertyKey;
    (0, _invariant.default)(propertyKeyString !== undefined);
    return `[ModifiedProperty ${propertyKeyString}]`;
  }

  serialize(context) {
    let desc = this.propertyBinding.descriptor;
    (0, _invariant.default)(desc === this.newDescriptor);
    context.emitPropertyModification(this.propertyBinding);
  }

  visit(context, containingGenerator) {
    (0, _invariant.default)(containingGenerator === this.containingGenerator, "This entry requires effects to be applied and may not be moved");
    let desc = this.propertyBinding.descriptor;
    (0, _invariant.default)(desc === this.newDescriptor);
    context.visitModifiedProperty(this.propertyBinding);
    return true;
  }

  getDependencies() {
    return undefined;
  }

}

class ModifiedBindingEntry extends GeneratorEntry {
  constructor(realm, args) {
    super(realm);
    Object.assign(this, args);
  }

  print(printer) {
    printer.printGeneratorEntry(undefined, "MODIFIED_BINDING", [], {
      binding: this.modifiedBinding,
      value: this.modifiedBinding.value
    }, {
      isPure: false,
      mutatesOnly: undefined
    });
  }

  toDisplayString() {
    return `[ModifiedBinding ${this.modifiedBinding.name}]`;
  }

  serialize(context) {
    context.emitBindingModification(this.modifiedBinding);
  }

  visit(context, containingGenerator) {
    (0, _invariant.default)(containingGenerator === this.containingGenerator, "This entry requires effects to be applied and may not be moved");
    context.visitModifiedBinding(this.modifiedBinding);
    return true;
  }

  getDependencies() {
    return undefined;
  }

}

class ReturnValueEntry extends GeneratorEntry {
  constructor(realm, generator, returnValue) {
    super(realm);
    this.returnValue = returnValue.promoteEmptyToUndefined();
    this.containingGenerator = generator;
  }

  print(printer) {
    printer.printGeneratorEntry(undefined, "RETURN", [this.returnValue], {}, {
      isPure: false,
      mutatesOnly: undefined
    });
  }

  toDisplayString() {
    return `[Return ${this.returnValue.toDisplayString()}]`;
  }

  visit(context, containingGenerator) {
    (0, _invariant.default)(containingGenerator === this.containingGenerator, "This entry requires effects to be applied and may not be moved");
    this.returnValue = context.visitEquivalentValue(this.returnValue);
    return true;
  }

  serialize(context) {
    context.emit(context.serializeReturnValue(this.returnValue));
  }

  getDependencies() {
    return undefined;
  }

}

class BindingAssignmentEntry extends GeneratorEntry {
  constructor(realm, binding, value) {
    super(realm);
    this.binding = binding;
    this.value = value;
  }

  print(printer) {
    printer.printGeneratorEntry(undefined, "BINDING_ASSIGNMENT", [this.value], {
      binding: this.binding
    }, {
      isPure: false,
      mutatesOnly: undefined
    });
  }

  toDisplayString() {
    return `[BindingAssignment ${this.binding.name} = ${this.value.toDisplayString()}]`;
  }

  serialize(context) {
    context.emit(context.serializeBindingAssignment(this.binding, this.value));
  }

  visit(context, containingGenerator) {
    this.value = context.visitBindingAssignment(this.binding, this.value);
    return true;
  }

  getDependencies() {
    return undefined;
  }

}

class Generator {
  constructor(realm, name, pathConditions, effects) {
    (0, _invariant.default)(realm.useAbstractInterpretation);
    let realmPreludeGenerator = realm.preludeGenerator;
    (0, _invariant.default)(realmPreludeGenerator);
    this.preludeGenerator = realmPreludeGenerator;
    this.realm = realm;
    this._entries = [];
    this.id = realm.nextGeneratorId++;
    this._name = name;
    this.effectsToApply = effects;
    this.pathConditions = pathConditions;
  }

  print(printer) {
    for (let entry of this._entries) entry.print(printer);
  }

  toDisplayString() {
    return _singletons.Utils.jsonToDisplayString(this, 2);
  }

  toDisplayJson(depth) {
    if (depth <= 0) return `Generator${this.id}-${this._name}`;
    return _singletons.Utils.verboseToDisplayJson(this, depth);
  }

  static _generatorOfEffects(realm, name, additionalFunctionEffects, optimizedFunction, preEvaluationComponentToWriteEffectFunction, effects) {
    let {
      result,
      generator,
      modifiedBindings,
      modifiedProperties,
      createdObjects
    } = effects;
    let output = new Generator(realm, name, generator.pathConditions, effects);
    output.appendGenerator(generator, generator._name);

    for (let propertyBinding of modifiedProperties.keys()) {
      let object = propertyBinding.object;
      (0, _invariant.default)(object.isValid());
      if (createdObjects.has(object)) continue; // Created Object's binding

      if (_index.ObjectValue.refuseSerializationOnPropertyBinding(propertyBinding)) continue; // modification to internal state
      // modifications to intrinsic objects are tracked in the generator

      if (object.isIntrinsic()) continue;
      output.emitPropertyModification(propertyBinding);
    }

    for (let [modifiedBinding, previousValue] of modifiedBindings.entries()) {
      let cannonicalize = functionValue => preEvaluationComponentToWriteEffectFunction.get(functionValue) || functionValue;

      let optimizedFunctionValue = optimizedFunction;
      (0, _invariant.default)(optimizedFunctionValue);
      (0, _invariant.default)(cannonicalize(optimizedFunctionValue) === optimizedFunctionValue, "These values should be canonical already"); // Walks up the parent chain for the given optimized function checking if the value or any of its parents are
      // equal to the optimized function we're currently building a generator for.

      let valueOrParentEqualsFunction = functionValue => {
        let canonicalOptimizedFunction = cannonicalize(functionValue);
        if (canonicalOptimizedFunction === optimizedFunctionValue) return true;
        let additionalEffects = additionalFunctionEffects.get(canonicalOptimizedFunction);
        (0, _invariant.default)(additionalEffects !== undefined);
        let parent = additionalEffects.parentAdditionalFunction;
        if (parent !== undefined) return valueOrParentEqualsFunction(parent);
        return false;
      };

      let environment = modifiedBinding.environment;
      if (environment instanceof _environment.FunctionEnvironmentRecord && environment.$FunctionObject === optimizedFunctionValue) continue;
      let creatingOptimizedFunction = environment.creatingOptimizedFunction;
      if (creatingOptimizedFunction && valueOrParentEqualsFunction(creatingOptimizedFunction)) continue; // TODO #2586: modifiedBinding.value should always exist

      if (modifiedBinding.value || previousValue.value) {
        output.emitBindingModification(modifiedBinding);
      }
    }

    if (result instanceof _index.UndefinedValue) return output;

    if (result instanceof _completions.SimpleNormalCompletion) {
      output.emitReturnValue(result.value);
    } else if (result instanceof _completions.ThrowCompletion) {
      output.emitThrow(result.value);
    } else if (result instanceof _completions.JoinedNormalAndAbruptCompletions) {
      let selector = c => c instanceof _completions.ThrowCompletion && c.value !== realm.intrinsics.__bottomValue && !(c.value instanceof _index.EmptyValue);

      output.emitConditionalThrow(_singletons.Join.joinValuesOfSelectedCompletions(selector, result, true));
      output.emitReturnValue(result.value);
    } else {
      (0, _invariant.default)(false);
    }

    return output;
  } // Make sure to to fixup
  // how to apply things around sets of things


  static fromEffects(effects, realm, name, additionalFunctionEffects, preEvaluationComponentToWriteEffectFunction, optimizedFunction) {
    return realm.withEffectsAppliedInGlobalEnv(this._generatorOfEffects.bind(this, realm, name, additionalFunctionEffects, optimizedFunction, preEvaluationComponentToWriteEffectFunction), effects);
  }

  emitPropertyModification(propertyBinding) {
    (0, _invariant.default)(this.effectsToApply !== undefined);
    let desc = propertyBinding.descriptor;

    if (desc !== undefined && desc instanceof _descriptors.PropertyDescriptor) {
      let value = desc.value;

      if (value instanceof _index.AbstractValue) {
        if (value.kind === "conditional") {
          let [c, x, y] = value.args;

          if (c instanceof _index.AbstractValue && c.kind === "template for property name condition") {
            let ydesc = new _descriptors.PropertyDescriptor(Object.assign({}, desc, {
              value: y
            }));
            let yprop = Object.assign({}, propertyBinding, {
              descriptor: ydesc
            });
            this.emitPropertyModification(yprop);
            let xdesc = new _descriptors.PropertyDescriptor(Object.assign({}, desc, {
              value: x
            }));
            let key = c.args[0];
            (0, _invariant.default)(key instanceof _index.AbstractValue);
            let xprop = Object.assign({}, propertyBinding, {
              key,
              descriptor: xdesc
            });
            this.emitPropertyModification(xprop);
            return;
          }
        } else if (value.kind === "template for prototype member expression") {
          return;
        }
      }
    }

    this._entries.push(new ModifiedPropertyEntry(this.realm, {
      propertyBinding,
      newDescriptor: desc,
      containingGenerator: this
    }));
  }

  emitBindingModification(modifiedBinding) {
    (0, _invariant.default)(this.effectsToApply !== undefined);

    this._entries.push(new ModifiedBindingEntry(this.realm, {
      modifiedBinding,
      containingGenerator: this
    }));
  }

  emitReturnValue(result) {
    this._entries.push(new ReturnValueEntry(this.realm, this, result));
  }

  getName() {
    return `${this._name}(#${this.id})`;
  }

  empty() {
    return this._entries.length === 0;
  }

  emitGlobalDeclaration(key, value) {
    this.preludeGenerator.declaredGlobals.add(key);
    if (!(value instanceof _index.UndefinedValue)) this.emitGlobalAssignment(key, value);
  }

  emitGlobalAssignment(key, value) {
    this._addEntry({
      args: [value, new _index.StringValue(this.realm, key)],
      operationDescriptor: createOperationDescriptor("GLOBAL_ASSIGNMENT")
    });
  }

  emitConcreteModel(key, value) {
    this._addEntry({
      args: [(0, _singletons.concretize)(this.realm, value), new _index.StringValue(this.realm, key)],
      operationDescriptor: createOperationDescriptor("CONCRETE_MODEL")
    });
  }

  emitGlobalDelete(key) {
    this._addEntry({
      args: [new _index.StringValue(this.realm, key)],
      operationDescriptor: createOperationDescriptor("GLOBAL_DELETE")
    });
  }

  emitBindingAssignment(binding, value) {
    this._entries.push(new BindingAssignmentEntry(this.realm, binding, value));
  }

  emitPropertyAssignment(object, key, value) {
    if (object instanceof _index.ObjectValue && object.refuseSerialization) {
      return;
    }

    if (typeof key === "string") {
      key = new _index.StringValue(this.realm, key);
    }

    this._addEntry({
      args: [object, value, key],
      operationDescriptor: createOperationDescriptor("EMIT_PROPERTY_ASSIGNMENT", {
        value
      })
    });
  }

  emitDefineProperty(object, key, desc, isDescChanged = true) {
    if (object.refuseSerialization) return;

    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {
      let descValue = desc.value;
      (0, _invariant.default)(descValue instanceof _index.Value);
      this.emitPropertyAssignment(object, key, descValue);
    } else {
      desc = new _descriptors.PropertyDescriptor(desc);
      let descValue = desc.value || object.$Realm.intrinsics.undefined;
      (0, _invariant.default)(descValue instanceof _index.Value);

      this._addEntry({
        args: [new _index.StringValue(this.realm, key), object, descValue, desc.get || object.$Realm.intrinsics.undefined, desc.set || object.$Realm.intrinsics.undefined],
        operationDescriptor: createOperationDescriptor("DEFINE_PROPERTY", {
          object,
          descriptor: desc
        })
      });
    }
  }

  emitPropertyDelete(object, key) {
    if (object.refuseSerialization) return;

    this._addEntry({
      args: [object, new _index.StringValue(this.realm, key)],
      operationDescriptor: createOperationDescriptor("PROPERTY_DELETE")
    });
  }

  emitCall(callFunctionRef, args) {
    this._addEntry({
      args,
      operationDescriptor: createOperationDescriptor("EMIT_CALL", {
        callFunctionRef
      })
    });
  }

  emitConsoleLog(method, args) {
    this._addEntry({
      args: [new _index.StringValue(this.realm, method), ...args.map(v => typeof v === "string" ? new _index.StringValue(this.realm, v) : v)],
      operationDescriptor: createOperationDescriptor("CONSOLE_LOG")
    });
  } // test must be a temporal value, which means that it must have a defined intrinsicName


  emitDoWhileStatement(test, body) {
    this._addEntry({
      args: [],
      operationDescriptor: createOperationDescriptor("DO_WHILE", {
        generator: body,
        value: test
      })
    });
  }

  emitConditionalThrow(value) {
    if (value instanceof _index.EmptyValue) return;

    this._issueThrowCompilerDiagnostic(value);

    this._addEntry({
      args: [value],
      operationDescriptor: createOperationDescriptor("CONDITIONAL_THROW", {
        value
      })
    });
  }

  _issueThrowCompilerDiagnostic(value) {
    let message = "Program may terminate with exception";

    if (value instanceof _index.ObjectValue) {
      let object = value;
      let objectMessage = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue("message"));
      if (objectMessage instanceof _index.StringValue) message += `: ${objectMessage.value}`;
      const objectStack = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue("stack"));
      if (objectStack instanceof _index.StringValue) message += `
  ${objectStack.value}`;
    }

    const diagnostic = new _errors.CompilerDiagnostic(message, value.expressionLocation, "PP0023", "Warning");
    this.realm.handleError(diagnostic);
  }

  emitThrow(value) {
    this._issueThrowCompilerDiagnostic(value);

    this.emitStatement([value], createOperationDescriptor("THROW"));
  } // Checks the full set of possible concrete values as well as typeof
  // for any AbstractValues
  // e.g: (obj.property !== undefined && typeof obj.property !== "object")
  // NB: if the type of the AbstractValue is top, skips the invariant


  emitFullInvariant(object, key, value) {
    if (object.refuseSerialization) return;

    if (value instanceof _index.AbstractValue) {
      let isTop = false;
      let concreteComparisons = [];
      let typeComparisons = new Set();

      function populateComparisonsLists(absValue) {
        if (absValue.kind === "abstractConcreteUnion") {
          // recurse
          for (let nestedValue of absValue.args) if (nestedValue instanceof _index.ConcreteValue) {
            concreteComparisons.push(nestedValue);
          } else {
            (0, _invariant.default)(nestedValue instanceof _index.AbstractValue);
            populateComparisonsLists(nestedValue);
          }
        } else if (absValue.getType() === _index.Value) {
          isTop = true;
        } else {
          typeComparisons.add(absValue.getType());
        }
      }

      populateComparisonsLists(value); // No point in doing the invariant if we don't know the type
      // of one of the nested abstract values

      if (isTop) {
        return;
      } else {
        this._emitInvariant([new _index.StringValue(this.realm, key), value, value], createOperationDescriptor("FULL_INVARIANT_ABSTRACT", {
          concreteComparisons,
          typeComparisons
        }), createOperationDescriptor("INVARIANT_APPEND"));
      }
    } else if (value instanceof _index.FunctionValue) {
      // We do a special case for functions,
      // as we like to use concrete functions in the model to model abstract behaviors.
      // These concrete functions do not have the right identity.
      this._emitInvariant([new _index.StringValue(this.realm, key), object, value, object], createOperationDescriptor("FULL_INVARIANT_FUNCTION"), createOperationDescriptor("INVARIANT_APPEND"));
    } else {
      this._emitInvariant([new _index.StringValue(this.realm, key), object, value, object], createOperationDescriptor("FULL_INVARIANT"), createOperationDescriptor("INVARIANT_APPEND"));
    }
  }

  emitPropertyInvariant(object, key, state) {
    if (object.refuseSerialization) return;

    this._emitInvariant([new _index.StringValue(this.realm, key), object, object], createOperationDescriptor("PROPERTY_INVARIANT", {
      state
    }), createOperationDescriptor("INVARIANT_APPEND"));
  }

  _emitInvariant(args, violationConditionOperationDescriptor, appendLastToInvariantOperationDescriptor) {
    (0, _invariant.default)(this.realm.invariantLevel > 0);
    let invariantOperationDescriptor = createOperationDescriptor("INVARIANT", {
      appendLastToInvariantOperationDescriptor,
      violationConditionOperationDescriptor
    });

    this._addEntry({
      args,
      operationDescriptor: invariantOperationDescriptor
    });
  }

  emitCallAndCaptureResult(types, values, callFunctionRef, args, kind) {
    return this.deriveAbstract(types, values, args, createOperationDescriptor("EMIT_CALL_AND_CAPTURE_RESULT", {
      callFunctionRef
    }), {
      kind
    });
  }

  emitStatement(args, operationDescriptor) {
    (0, _invariant.default)(typeof operationDescriptor !== "function");

    this._addEntry({
      args,
      operationDescriptor
    });
  }

  emitVoidExpression(types, values, args, operationDescriptor) {
    this._addEntry({
      args,
      operationDescriptor
    });

    return this.realm.intrinsics.undefined;
  }

  emitForInStatement(o, lh, sourceObject, targetObject, boundName) {
    this._addEntry({
      // duplicate args to ensure refcount > 1
      args: [o, targetObject, sourceObject, targetObject, sourceObject],
      operationDescriptor: createOperationDescriptor("FOR_IN", {
        boundName,
        lh
      })
    });
  }

  deriveConcreteObject(buildValue, args, operationDescriptor, optionalArgs) {
    let id = this.preludeGenerator.nameGenerator.generate("derived");
    let value = buildValue(id);
    value.intrinsicNameGenerated = true;
    value.isScopedTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope

    (0, _invariant.default)(value.intrinsicName === id);

    this._addDerivedEntry({
      isPure: optionalArgs ? optionalArgs.isPure : undefined,
      declared: value,
      args,
      operationDescriptor
    });

    return value;
  }

  deriveAbstract(types, values, args, operationDescriptor, optionalArgs) {
    let id = this.preludeGenerator.nameGenerator.generate("derived");
    let options = {};
    if (optionalArgs && optionalArgs.kind !== undefined) options.kind = optionalArgs.kind;
    if (optionalArgs && optionalArgs.shape !== undefined) options.shape = optionalArgs.shape;
    let Constructor = _index.Value.isTypeCompatibleWith(types.getType(), _index.ObjectValue) ? _index.AbstractObjectValue : _index.AbstractValue;
    let res = new Constructor(this.realm, types, values, 1735003607742176 + this.realm.derivedIds.size, [], createOperationDescriptor("IDENTIFIER", {
      id
    }), options);
    res.intrinsicName = id;

    this._addDerivedEntry({
      isPure: optionalArgs ? optionalArgs.isPure : undefined,
      declared: res,
      args,
      operationDescriptor,
      mutatesOnly: optionalArgs ? optionalArgs.mutatesOnly : undefined
    });

    let type = types.getType();
    if (optionalArgs && optionalArgs.skipInvariant) return res;
    let typeofString;
    if (type instanceof _index.FunctionValue) typeofString = "function";else if (type === _index.UndefinedValue) (0, _invariant.default)(false);else if (type === _index.NullValue) (0, _invariant.default)(false);else if (type === _index.StringValue) typeofString = "string";else if (type === _index.BooleanValue) typeofString = "boolean";else if (type === _index.NumberValue) typeofString = "number";else if (type === _index.IntegralValue) typeofString = "number";else if (type === _index.SymbolValue) typeofString = "symbol";else if (type === _index.ObjectValue) typeofString = "object";

    if (typeofString !== undefined && this.realm.invariantLevel >= 1) {
      // Verify that the types are as expected, a failure of this invariant
      // should mean the model is wrong.
      this._emitInvariant([new _index.StringValue(this.realm, typeofString), res, res], createOperationDescriptor("DERIVED_ABSTRACT_INVARIANT"), createOperationDescriptor("SINGLE_ARG"));
    }

    return res;
  }

  visit(callbacks) {
    let visitFn = () => {
      for (let entry of this._entries) entry.visit(callbacks, this);

      return null;
    };

    if (this.effectsToApply) {
      this.realm.withEffectsAppliedInGlobalEnv(visitFn, this.effectsToApply);
    } else {
      visitFn();
    }
  }

  serialize(context) {
    let serializeFn = () => {
      context.initGenerator(this);

      for (let entry of this._entries) entry.serialize(context);

      context.finalizeGenerator(this);
      return null;
    };

    if (this.effectsToApply) {
      this.realm.withEffectsAppliedInGlobalEnv(serializeFn, this.effectsToApply);
    } else {
      serializeFn();
    }
  }

  getDependencies() {
    let res = [];

    for (let entry of this._entries) {
      let dependencies = entry.getDependencies();
      if (dependencies !== undefined) res.push(...dependencies);
    }

    return res;
  }

  _addEntry(entryArgs) {
    let entry;
    let operationDescriptor = entryArgs.operationDescriptor;

    if (operationDescriptor && operationDescriptor.type === "OBJECT_ASSIGN") {
      entry = new TemporalObjectAssignEntry(this.realm, entryArgs);
    } else {
      entry = new TemporalOperationEntry(this.realm, entryArgs);
    }

    this.realm.saveTemporalGeneratorEntryArgs(entry);

    this._entries.push(entry);

    return entry;
  }

  _addDerivedEntry(entryArgs) {
    let declared = entryArgs.declared;
    (0, _invariant.default)(declared !== undefined);
    let id = declared.intrinsicName;
    (0, _invariant.default)(id !== undefined);

    let entry = this._addEntry(entryArgs);

    this.realm.derivedIds.set(id, entry);
  }

  appendGenerator(other, leadingComment) {
    (0, _invariant.default)(other !== this);
    (0, _invariant.default)(other.realm === this.realm);
    (0, _invariant.default)(other.preludeGenerator === this.preludeGenerator);
    (0, _invariant.default)(other.effectsToApply === undefined);
    if (other.empty()) return;

    this._entries.push(...other._entries);
  }

  joinGenerators(joinCondition, generator1, generator2) {
    (0, _invariant.default)(generator1 !== this && generator2 !== this && generator1 !== generator2);
    if (generator1.empty() && generator2.empty()) return;
    let generators = [generator1, generator2];

    this._addEntry({
      args: [joinCondition],
      operationDescriptor: createOperationDescriptor("JOIN_GENERATORS", {
        generators
      })
    });
  }

}

exports.Generator = Generator;

// This function attempts to optimize Object.assign calls, by merging mulitple
// calls into one another where possible. For example:
//
// var a = Object.assign({}, someAbstact);
// var b = Object.assign({}, a);
//
// Becomes:
// var b = Object.assign({}, someAbstract, a);
//
function attemptToMergeEquivalentObjectAssigns(realm, callbacks, temporalOperationEntry) {
  let args = temporalOperationEntry.args; // If we are Object.assigning 2 or more args

  if (args.length < 2) {
    return "NO_OPTIMIZATION";
  }

  let to = args[0]; // Then scan through the args after the "to" of this Object.assign, to see if any
  // other sources are the "to" of a previous Object.assign call

  loopThroughArgs: for (let i = 1; i < args.length; i++) {
    let possibleOtherObjectAssignTo = args[i]; // Ensure that the "to" value can be omitted
    // Note: this check is still somewhat fragile and depends on the visiting order
    // but it's not a functional problem right now and can be better addressed at a
    // later point.

    if (!callbacks.canOmit(possibleOtherObjectAssignTo)) {
      continue;
    } // Check if the "to" was definitely an Object.assign, it should
    // be a snapshot AbstractObjectValue


    if (possibleOtherObjectAssignTo instanceof _index.AbstractObjectValue) {
      let otherTemporalOperationEntry = realm.getTemporalOperationEntryFromDerivedValue(possibleOtherObjectAssignTo);

      if (!(otherTemporalOperationEntry instanceof TemporalObjectAssignEntry)) {
        continue;
      }

      let otherArgs = otherTemporalOperationEntry.args; // Object.assign has at least 1 arg

      if (otherArgs.length < 1) {
        continue;
      }

      let otherArgsToUse = [];

      for (let x = 1; x < otherArgs.length; x++) {
        let arg = otherArgs[x]; // The arg might have been leaked, so ensure we do not continue in this case

        if (arg instanceof _index.ObjectValue && arg.mightBeLeakedObject()) {
          continue loopThroughArgs;
        }

        if (arg instanceof _index.ObjectValue || arg instanceof _index.AbstractValue) {
          let temporalGeneratorEntries = realm.getTemporalGeneratorEntriesReferencingArg(arg); // We need to now check if there are any other temporal entries that exist
          // between the Object.assign TemporalObjectAssignEntry that we're trying to
          // merge and the current TemporalObjectAssignEntry we're going to merge into.

          if (temporalGeneratorEntries !== undefined) {
            for (let temporalGeneratorEntry of temporalGeneratorEntries) {
              // If the entry is that of another Object.assign, then
              // we know that this entry isn't going to cause issues
              // with merging the TemporalObjectAssignEntry.
              if (temporalGeneratorEntry instanceof TemporalObjectAssignEntry) {
                continue;
              } // TODO: what if the temporalGeneratorEntry can be omitted and not needed?
              // If the index of this entry exists between start and end indexes,
              // then we cannot optimize and merge the TemporalObjectAssignEntry
              // because another generator entry may have a dependency on the Object.assign
              // TemporalObjectAssignEntry we're trying to merge.


              if (temporalGeneratorEntry.notEqualToAndDoesNotHappenBefore(otherTemporalOperationEntry) && temporalGeneratorEntry.notEqualToAndDoesNotHappenAfter(temporalOperationEntry)) {
                continue loopThroughArgs;
              }
            }
          }
        }

        otherArgsToUse.push(arg);
      } // If we cannot omit the "to" value that means it's being used, so we shall not try to
      // optimize this Object.assign.


      if (!callbacks.canOmit(to)) {
        // our merged Object.assign, shoud look like:
        // Object.assign(to, ...prefixArgs, ...otherArgsToUse, ...suffixArgs)
        let prefixArgs = args.slice(1, i - 1); // We start at 1, as 0 is the index of "to" a

        let suffixArgs = args.slice(i + 1);
        let newArgs = [to, ...prefixArgs, ...otherArgsToUse, ...suffixArgs]; // We now create a new TemporalObjectAssignEntry, without mutating the existing
        // entry at this point. This new entry is essentially a TemporalObjectAssignEntry
        // that contains two Object.assign call TemporalObjectAssignEntry entries that have
        // been merged into a single entry. The previous Object.assign TemporalObjectAssignEntry
        // should dead-code eliminate away once we replace the original TemporalObjectAssignEntry
        // we started with with the new merged on as they will no longer be referenced.

        let newTemporalObjectAssignEntryArgs = Object.assign({}, temporalOperationEntry, {
          args: newArgs
        });
        return new TemporalObjectAssignEntry(realm, newTemporalObjectAssignEntryArgs);
      } // We might be able to optimize, but we are not sure because "to" can still omit.
      // So we return possible optimization status and wait until "to" does get visited.
      // It may never get visited, but that's okay as we'll skip the optimization all
      // together.


      return "POSSIBLE_OPTIMIZATION";
    }
  }

  return "NO_OPTIMIZATION";
}
//# sourceMappingURL=generator.js.map

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PreludeGenerator = exports.DisablePlaceholderSuffix = exports.Placeholders = void 0;

var t = _interopRequireWildcard(__webpack_require__(21));

var _babelhelpers = __webpack_require__(239);

var _NameGenerator = __webpack_require__(240);

var _template = _interopRequireDefault(__webpack_require__(241));

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const Placeholders = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
exports.Placeholders = Placeholders;
const placeholderDefaultWhiteList = new Set(["global"]);
const placeholderWhitelist = new Set([...placeholderDefaultWhiteList, ...Placeholders]);
const DisablePlaceholderSuffix = "// disable placeholders";
exports.DisablePlaceholderSuffix = DisablePlaceholderSuffix;

class PreludeGenerator {
  constructor(debugNames, uniqueSuffix) {
    this.prelude = [];
    this.memoizedRefs = new Map();
    this.nameGenerator = new _NameGenerator.NameGenerator(new Set(), !!debugNames, uniqueSuffix || "", "_$");
    this.usesThis = false;
    this.declaredGlobals = new Set();
    this.nextInvariantId = 0;
    this._expressionTemplates = new Map();
  }

  createNameGenerator(prefix) {
    return new _NameGenerator.NameGenerator(this.nameGenerator.forbiddenNames, this.nameGenerator.debugNames, this.nameGenerator.uniqueSuffix, prefix);
  }

  convertStringToMember(str) {
    return str.split(".").map(name => {
      if (name === "global") {
        return this.memoizeReference(name);
      } else if (name === "this") {
        return t.thisExpression();
      } else {
        return t.identifier(name);
      }
    }).reduce((obj, prop) => t.memberExpression(obj, prop));
  }

  globalReference(key, globalScope = false) {
    if (globalScope && t.isValidIdentifier(key)) return t.identifier(key);
    return (0, _babelhelpers.memberExpressionHelper)(this.memoizeReference("global"), key);
  }

  memoizeReference(key) {
    let ref = this.memoizedRefs.get(key);
    if (ref) return ref;
    let init;

    if (key.includes("(") || key.includes("[")) {
      // Horrible but effective hack:
      // Some internal object have intrinsic names such as
      //    ([][Symbol.iterator]().__proto__.__proto__)
      // and
      //    RegExp.prototype[Symbol.match]
      // which get turned into a babel node here.
      // TODO: We should properly parse such a string, and memoize all references in it separately.
      // Instead, we just turn it into a funky identifier, which Babel seems to accept.
      init = t.identifier(key);
    } else if (key === "global") {
      this.usesThis = true;
      init = t.thisExpression();
    } else {
      let i = key.lastIndexOf(".");

      if (i === -1) {
        init = t.memberExpression(this.memoizeReference("global"), t.identifier(key));
      } else {
        init = t.memberExpression(this.memoizeReference(key.substr(0, i)), t.identifier(key.substr(i + 1)));
      }
    }

    ref = t.identifier(this.nameGenerator.generate(key));
    this.prelude.push(t.variableDeclaration("var", [t.variableDeclarator(ref, init)]));
    this.memoizedRefs.set(key, ref);
    return ref;
  }

  buildExpression(code, templateArguments) {
    let disablePlaceholders = false;
    const key = code;

    let template = this._expressionTemplates.get(key);

    if (template === undefined) {
      if (code.endsWith(DisablePlaceholderSuffix)) {
        code = code.substring(0, code.length - DisablePlaceholderSuffix.length);
        disablePlaceholders = true;
      }

      template = (0, _template.default)(code, {
        placeholderPattern: false,
        placeholderWhitelist: disablePlaceholders ? placeholderDefaultWhiteList : placeholderWhitelist
      });

      this._expressionTemplates.set(key, template);
    }

    if (code.includes("global")) templateArguments = Object.assign({
      global: this.memoizeReference("global")
    }, templateArguments);
    let result = template(templateArguments).expression;
    (0, _invariant.default)(result !== undefined, "Code does not represent an expression: " + code);
    return result;
  }

}

exports.PreludeGenerator = PreludeGenerator;
//# sourceMappingURL=PreludeGenerator.js.map

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAsPropertyNameExpression = getAsPropertyNameExpression;
exports.memberExpressionHelper = memberExpressionHelper;
exports.optionalStringOfLocation = optionalStringOfLocation;
exports.stringOfLocation = stringOfLocation;
exports.protoExpression = exports.constructorExpression = exports.emptyExpression = exports.nullExpression = exports.voidExpression = void 0;

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const voidExpression = t.unaryExpression("void", t.numericLiteral(0), true);
exports.voidExpression = voidExpression;
const nullExpression = t.nullLiteral();
exports.nullExpression = nullExpression;
const emptyExpression = t.identifier("__empty");
exports.emptyExpression = emptyExpression;
const constructorExpression = t.identifier("__constructor");
exports.constructorExpression = constructorExpression;
const protoExpression = t.identifier("__proto__");
exports.protoExpression = protoExpression;

function getAsPropertyNameExpression(key, canBeIdentifier = true) {
  // If key is a non-negative numeric string literal, parse it and set it as a numeric index instead.
  let index = Number.parseInt(key, 10);

  if (index >= 0 && index.toString() === key) {
    return t.numericLiteral(index);
  }

  if (canBeIdentifier) {
    // TODO #1020: revert this when Unicode identifiers are supported by all targetted JavaScript engines
    let keyIsAscii = /^[\u0000-\u007f]*$/.test(key);
    if (t.isValidIdentifier(key) && keyIsAscii) return t.identifier(key);
  }

  return t.stringLiteral(key);
}

function memberExpressionHelper(object, property) {
  let propertyExpression;
  let computed;

  if (typeof property === "string") {
    propertyExpression = getAsPropertyNameExpression(property);
    computed = !t.isIdentifier(propertyExpression);
  } else if (t.isStringLiteral(property)) {
    propertyExpression = getAsPropertyNameExpression(property.value);
    computed = !t.isIdentifier(propertyExpression);
  } else {
    propertyExpression = property;
    computed = true;
  }

  return t.memberExpression(object, propertyExpression, computed);
}

function optionalStringOfLocation(location) {
  // if we can't get a value, then it's likely that the source file was not given
  return location ? ` at location ${stringOfLocation(location)}` : "";
}

function stringOfLocation(location) {
  return `${location.source || "(unknown source file)"}[${location.start.line}:${location.start.column}]`;
}
//# sourceMappingURL=babelhelpers.js.map

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NameGenerator = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function escapeInvalidIdentifierCharacters(s) {
  let res = "";

  for (let c of s) if (c >= "0" && c <= "9" || c >= "a" && c <= "z" || c >= "A" && c <= "Z") res += c;else res += "_" + c.charCodeAt(0);

  return res;
}

const base62characters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

function base62encode(n) {
  (0, _invariant.default)((n | 0) === n && n >= 0);
  if (n === 0) return "0";
  let s = "";

  while (n > 0) {
    let f = n % base62characters.length;
    s = base62characters[f] + s;
    n = (n - f) / base62characters.length;
  }

  return s;
}

class NameGenerator {
  constructor(forbiddenNames, debugNames, uniqueSuffix, prefix) {
    this.prefix = prefix;
    this.uidCounter = 0;
    this.debugNames = debugNames;
    this.forbiddenNames = forbiddenNames;
    this.uniqueSuffix = uniqueSuffix;
  }

  generate(debugSuffix) {
    let id;

    do {
      id = this.prefix + base62encode(this.uidCounter++);
      if (this.uniqueSuffix.length > 0) id += this.uniqueSuffix;

      if (this.debugNames) {
        if (debugSuffix) id += "_" + escapeInvalidIdentifierCharacters(debugSuffix);else id += "_";
      }
    } while (this.forbiddenNames.has(id));

    return id;
  }

}

exports.NameGenerator = NameGenerator;
//# sourceMappingURL=NameGenerator.js.map

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.program = exports.expression = exports.statements = exports.statement = exports.smart = void 0;

var formatters = _interopRequireWildcard(__webpack_require__(242));

var _builder = _interopRequireDefault(__webpack_require__(243));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const smart = (0, _builder.default)(formatters.smart);
exports.smart = smart;
const statement = (0, _builder.default)(formatters.statement);
exports.statement = statement;
const statements = (0, _builder.default)(formatters.statements);
exports.statements = statements;
const expression = (0, _builder.default)(formatters.expression);
exports.expression = expression;
const program = (0, _builder.default)(formatters.program);
exports.program = program;

var _default = Object.assign(smart.bind(undefined), {
  smart,
  statement,
  statements,
  expression,
  program,
  ast: smart.ast
});

exports.default = _default;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.program = exports.expression = exports.statement = exports.statements = exports.smart = void 0;

function makeStatementFormatter(fn) {
  return {
    code: str => `/* @babel/template */;\n${str}`,
    validate: () => {},
    unwrap: ast => {
      return fn(ast.program.body.slice(1));
    }
  };
}

const smart = makeStatementFormatter(body => {
  if (body.length > 1) {
    return body;
  } else {
    return body[0];
  }
});
exports.smart = smart;
const statements = makeStatementFormatter(body => body);
exports.statements = statements;
const statement = makeStatementFormatter(body => {
  if (body.length === 0) {
    throw new Error("Found nothing to return.");
  }

  if (body.length > 1) {
    throw new Error("Found multiple statements but wanted one");
  }

  return body[0];
});
exports.statement = statement;
const expression = {
  code: str => `(\n${str}\n)`,
  validate: ({
    program
  }) => {
    if (program.body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }

    const expression = program.body[0].expression;

    if (expression.start === 0) {
      throw new Error("Parse result included parens.");
    }
  },
  unwrap: ast => ast.program.body[0].expression
};
exports.expression = expression;
const program = {
  code: str => str,
  validate: () => {},
  unwrap: ast => ast.program
};
exports.program = program;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTemplateBuilder;

var _options = __webpack_require__(244);

var _string = _interopRequireDefault(__webpack_require__(245));

var _literal = _interopRequireDefault(__webpack_require__(267));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NO_PLACEHOLDER = (0, _options.validate)({
  placeholderPattern: false
});

function createTemplateBuilder(formatter, defaultOpts) {
  const templateFnCache = new WeakMap();
  const templateAstCache = new WeakMap();
  const cachedOpts = defaultOpts || (0, _options.validate)(null);
  return Object.assign((tpl, ...args) => {
    if (typeof tpl === "string") {
      if (args.length > 1) throw new Error("Unexpected extra params.");
      return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
    } else if (Array.isArray(tpl)) {
      let builder = templateFnCache.get(tpl);

      if (!builder) {
        builder = (0, _literal.default)(formatter, tpl, cachedOpts);
        templateFnCache.set(tpl, builder);
      }

      return extendedTrace(builder(args));
    } else if (typeof tpl === "object" && tpl) {
      if (args.length > 0) throw new Error("Unexpected extra params.");
      return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
    }

    throw new Error(`Unexpected template param ${typeof tpl}`);
  }, {
    ast: (tpl, ...args) => {
      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
      } else if (Array.isArray(tpl)) {
        let builder = templateAstCache.get(tpl);

        if (!builder) {
          builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
          templateAstCache.set(tpl, builder);
        }

        return builder(args)();
      }

      throw new Error(`Unexpected template param ${typeof tpl}`);
    }
  });
}

function extendedTrace(fn) {
  let rootStack = "";

  try {
    throw new Error();
  } catch (error) {
    if (error.stack) {
      rootStack = error.stack.split("\n").slice(3).join("\n");
    }
  }

  return arg => {
    try {
      return fn(arg);
    } catch (err) {
      err.stack += `\n    =============\n${rootStack}`;
      throw err;
    }
  };
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.merge = merge;
exports.validate = validate;
exports.normalizeReplacements = normalizeReplacements;

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function merge(a, b) {
  const {
    placeholderWhitelist = a.placeholderWhitelist,
    placeholderPattern = a.placeholderPattern,
    preserveComments = a.preserveComments
  } = b;
  return {
    parser: Object.assign({}, a.parser, b.parser),
    placeholderWhitelist,
    placeholderPattern,
    preserveComments
  };
}

function validate(opts) {
  if (opts != null && typeof opts !== "object") {
    throw new Error("Unknown template options.");
  }

  const _ref = opts || {},
        {
    placeholderWhitelist,
    placeholderPattern,
    preserveComments
  } = _ref,
        parser = _objectWithoutPropertiesLoose(_ref, ["placeholderWhitelist", "placeholderPattern", "preserveComments"]);

  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
  }

  if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
  }

  if (preserveComments != null && typeof preserveComments !== "boolean") {
    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
  }

  return {
    parser,
    placeholderWhitelist: placeholderWhitelist || undefined,
    placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
    preserveComments: preserveComments == null ? false : preserveComments
  };
}

function normalizeReplacements(replacements) {
  if (Array.isArray(replacements)) {
    return replacements.reduce((acc, replacement, i) => {
      acc["$" + i] = replacement;
      return acc;
    }, {});
  } else if (typeof replacements === "object" || replacements == null) {
    return replacements || undefined;
  }

  throw new Error("Template replacements must be an array, object, null, or undefined");
}

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = stringTemplate;

var _options = __webpack_require__(244);

var _parse = _interopRequireDefault(__webpack_require__(246));

var _populate = _interopRequireDefault(__webpack_require__(266));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringTemplate(formatter, code, opts) {
  code = formatter.code(code);
  let metadata;
  return arg => {
    const replacements = (0, _options.normalizeReplacements)(arg);
    if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
    return formatter.unwrap((0, _populate.default)(metadata, replacements));
  };
}

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseAndBuildMetadata;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _parser() {
  const data = __webpack_require__(247);

  _parser = function () {
    return data;
  };

  return data;
}

function _codeFrame() {
  const data = __webpack_require__(248);

  _codeFrame = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const PATTERN = /^[_$A-Z0-9]+$/;

function parseAndBuildMetadata(formatter, code, opts) {
  const ast = parseWithCodeFrame(code, opts.parser);
  const {
    placeholderWhitelist,
    placeholderPattern = PATTERN,
    preserveComments
  } = opts;
  t().removePropertiesDeep(ast, {
    preserveComments
  });
  formatter.validate(ast);
  const placeholders = [];
  const placeholderNames = new Set();
  t().traverse(ast, placeholderVisitorHandler, {
    placeholders,
    placeholderNames,
    placeholderWhitelist,
    placeholderPattern
  });
  return {
    ast,
    placeholders,
    placeholderNames
  };
}

function placeholderVisitorHandler(node, ancestors, state) {
  let name;

  if (t().isIdentifier(node) || t().isJSXIdentifier(node)) {
    name = node.name;
  } else if (t().isStringLiteral(node)) {
    name = node.value;
  } else {
    return;
  }

  if ((!state.placeholderPattern || !state.placeholderPattern.test(name)) && (!state.placeholderWhitelist || !state.placeholderWhitelist.has(name))) {
    return;
  }

  ancestors = ancestors.slice();
  const {
    node: parent,
    key
  } = ancestors[ancestors.length - 1];
  let type;

  if (t().isStringLiteral(node)) {
    type = "string";
  } else if (t().isNewExpression(parent) && key === "arguments" || t().isCallExpression(parent) && key === "arguments" || t().isFunction(parent) && key === "params") {
    type = "param";
  } else if (t().isExpressionStatement(parent)) {
    type = "statement";
    ancestors = ancestors.slice(0, -1);
  } else {
    type = "other";
  }

  state.placeholders.push({
    name,
    type,
    resolve: ast => resolveAncestors(ast, ancestors),
    isDuplicate: state.placeholderNames.has(name)
  });
  state.placeholderNames.add(name);
}

function resolveAncestors(ast, ancestors) {
  let parent = ast;

  for (let i = 0; i < ancestors.length - 1; i++) {
    const {
      key,
      index
    } = ancestors[i];

    if (index === undefined) {
      parent = parent[key];
    } else {
      parent = parent[key][index];
    }
  }

  const {
    key,
    index
  } = ancestors[ancestors.length - 1];
  return {
    parent,
    key,
    index
  };
}

function parseWithCodeFrame(code, parserOpts) {
  parserOpts = Object.assign({
    allowReturnOutsideFunction: true,
    allowSuperOutsideMethod: true,
    sourceType: "module"
  }, parserOpts);

  try {
    return (0, _parser().parse)(code, parserOpts);
  } catch (err) {
    const loc = err.loc;

    if (loc) {
      err.message += "\n" + (0, _codeFrame().codeFrameColumns)(code, {
        start: loc
      });
      err.code = "BABEL_TEMPLATE_PARSE_ERROR";
    }

    throw err;
  }
}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

const beforeExpr = true;
const startsExpr = true;
const isLoop = true;
const isAssign = true;
const prefix = true;
const postfix = true;
class TokenType {
  constructor(label, conf = {}) {
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop === 0 ? 0 : conf.binop || null;
    this.updateContext = null;
  }

}

function KeywordTokenType(keyword, options = {}) {
  return new TokenType(keyword, Object.assign({}, options, {
    keyword
  }));
}

function BinopTokenType(name, binop) {
  return new TokenType(name, {
    beforeExpr,
    binop
  });
}

const types = {
  num: new TokenType("num", {
    startsExpr
  }),
  bigint: new TokenType("bigint", {
    startsExpr
  }),
  regexp: new TokenType("regexp", {
    startsExpr
  }),
  string: new TokenType("string", {
    startsExpr
  }),
  name: new TokenType("name", {
    startsExpr
  }),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", {
    beforeExpr,
    startsExpr
  }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {
    beforeExpr,
    startsExpr
  }),
  braceBarL: new TokenType("{|", {
    beforeExpr,
    startsExpr
  }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", {
    beforeExpr,
    startsExpr
  }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", {
    beforeExpr
  }),
  semi: new TokenType(";", {
    beforeExpr
  }),
  colon: new TokenType(":", {
    beforeExpr
  }),
  doubleColon: new TokenType("::", {
    beforeExpr
  }),
  dot: new TokenType("."),
  question: new TokenType("?", {
    beforeExpr
  }),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", {
    beforeExpr
  }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", {
    beforeExpr
  }),
  backQuote: new TokenType("`", {
    startsExpr
  }),
  dollarBraceL: new TokenType("${", {
    beforeExpr,
    startsExpr
  }),
  at: new TokenType("@"),
  hash: new TokenType("#", {
    startsExpr
  }),
  interpreterDirective: new TokenType("#!..."),
  eq: new TokenType("=", {
    beforeExpr,
    isAssign
  }),
  assign: new TokenType("_=", {
    beforeExpr,
    isAssign
  }),
  incDec: new TokenType("++/--", {
    prefix,
    postfix,
    startsExpr
  }),
  bang: new TokenType("!", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  tilde: new TokenType("~", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  pipeline: BinopTokenType("|>", 0),
  nullishCoalescing: BinopTokenType("??", 1),
  logicalOR: BinopTokenType("||", 1),
  logicalAND: BinopTokenType("&&", 2),
  bitwiseOR: BinopTokenType("|", 3),
  bitwiseXOR: BinopTokenType("^", 4),
  bitwiseAND: BinopTokenType("&", 5),
  equality: BinopTokenType("==/!=", 6),
  relational: BinopTokenType("</>", 7),
  bitShift: BinopTokenType("<</>>", 8),
  plusMin: new TokenType("+/-", {
    beforeExpr,
    binop: 9,
    prefix,
    startsExpr
  }),
  modulo: BinopTokenType("%", 10),
  star: BinopTokenType("*", 10),
  slash: BinopTokenType("/", 10),
  exponent: new TokenType("**", {
    beforeExpr,
    binop: 11,
    rightAssociative: true
  })
};

function makeKeywordProps(name, conf) {
  return {
    value: KeywordTokenType(name, conf),
    enumerable: true
  };
}

const keywords = Object.create(null, {
  break: makeKeywordProps("break"),
  case: makeKeywordProps("case", {
    beforeExpr
  }),
  catch: makeKeywordProps("catch"),
  continue: makeKeywordProps("continue"),
  debugger: makeKeywordProps("debugger"),
  default: makeKeywordProps("default", {
    beforeExpr
  }),
  do: makeKeywordProps("do", {
    isLoop,
    beforeExpr
  }),
  else: makeKeywordProps("else", {
    beforeExpr
  }),
  finally: makeKeywordProps("finally"),
  for: makeKeywordProps("for", {
    isLoop
  }),
  function: makeKeywordProps("function", {
    startsExpr
  }),
  if: makeKeywordProps("if"),
  return: makeKeywordProps("return", {
    beforeExpr
  }),
  switch: makeKeywordProps("switch"),
  throw: makeKeywordProps("throw", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  try: makeKeywordProps("try"),
  var: makeKeywordProps("var"),
  const: makeKeywordProps("const"),
  while: makeKeywordProps("while", {
    isLoop
  }),
  with: makeKeywordProps("with"),
  new: makeKeywordProps("new", {
    beforeExpr,
    startsExpr
  }),
  this: makeKeywordProps("this", {
    startsExpr
  }),
  super: makeKeywordProps("super", {
    startsExpr
  }),
  class: makeKeywordProps("class", {
    startsExpr
  }),
  extends: makeKeywordProps("extends", {
    beforeExpr
  }),
  export: makeKeywordProps("export"),
  import: makeKeywordProps("import", {
    startsExpr
  }),
  null: makeKeywordProps("null", {
    startsExpr
  }),
  true: makeKeywordProps("true", {
    startsExpr
  }),
  false: makeKeywordProps("false", {
    startsExpr
  }),
  in: makeKeywordProps("in", {
    beforeExpr,
    binop: 7
  }),
  instanceof: makeKeywordProps("instanceof", {
    beforeExpr,
    binop: 7
  }),
  typeof: makeKeywordProps("typeof", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  void: makeKeywordProps("void", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  delete: makeKeywordProps("delete", {
    beforeExpr,
    prefix,
    startsExpr
  })
});
Object.keys(keywords).forEach(name => {
  types["_" + name] = keywords[name];
});

function isSimpleProperty(node) {
  return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
}

var estree = (superClass => class extends superClass {
  estreeParseRegExpLiteral({
    pattern,
    flags
  }) {
    let regex = null;

    try {
      regex = new RegExp(pattern, flags);
    } catch (e) {}

    const node = this.estreeParseLiteral(regex);
    node.regex = {
      pattern,
      flags
    };
    return node;
  }

  estreeParseLiteral(value) {
    return this.parseLiteral(value, "Literal");
  }

  directiveToStmt(directive) {
    const directiveLiteral = directive.value;
    const stmt = this.startNodeAt(directive.start, directive.loc.start);
    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
    expression.value = directiveLiteral.value;
    expression.raw = directiveLiteral.extra.raw;
    stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
    return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
  }

  initFunction(node, isAsync) {
    super.initFunction(node, isAsync);
    node.expression = false;
  }

  checkDeclaration(node) {
    if (isSimpleProperty(node)) {
      this.checkDeclaration(node.value);
    } else {
      super.checkDeclaration(node);
    }
  }

  checkGetterSetterParams(method) {
    const prop = method;
    const paramCount = prop.kind === "get" ? 0 : 1;
    const start = prop.start;

    if (prop.value.params.length !== paramCount) {
      if (prop.kind === "get") {
        this.raise(start, "getter must not have any formal parameters");
      } else {
        this.raise(start, "setter must have exactly one formal parameter");
      }
    }

    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raise(start, "setter function argument must not be a rest parameter");
    }
  }

  checkLVal(expr, isBinding, checkClashes, contextDescription) {
    switch (expr.type) {
      case "ObjectPattern":
        expr.properties.forEach(prop => {
          this.checkLVal(prop.type === "Property" ? prop.value : prop, isBinding, checkClashes, "object destructuring pattern");
        });
        break;

      default:
        super.checkLVal(expr, isBinding, checkClashes, contextDescription);
    }
  }

  checkPropClash(prop, propHash) {
    if (prop.computed || !isSimpleProperty(prop)) return;
    const key = prop.key;
    const name = key.type === "Identifier" ? key.name : String(key.value);

    if (name === "__proto__") {
      if (propHash.proto) {
        this.raise(key.start, "Redefinition of __proto__ property");
      }

      propHash.proto = true;
    }
  }

  isStrictBody(node) {
    const isBlockStatement = node.body.type === "BlockStatement";

    if (isBlockStatement && node.body.body.length > 0) {
      for (let _i = 0, _node$body$body = node.body.body; _i < _node$body$body.length; _i++) {
        const directive = _node$body$body[_i];

        if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
          if (directive.expression.value === "use strict") return true;
        } else {
          break;
        }
      }
    }

    return false;
  }

  isValidDirective(stmt) {
    return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
  }

  stmtToDirective(stmt) {
    const directive = super.stmtToDirective(stmt);
    const value = stmt.expression.value;
    directive.value.value = value;
    return directive;
  }

  parseBlockBody(node, allowDirectives, topLevel, end) {
    super.parseBlockBody(node, allowDirectives, topLevel, end);
    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));
    node.body = directiveStatements.concat(node.body);
    delete node.directives;
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
    this.parseMethod(method, isGenerator, isAsync, isConstructor, "MethodDefinition");

    if (method.typeParameters) {
      method.value.typeParameters = method.typeParameters;
      delete method.typeParameters;
    }

    classBody.body.push(method);
  }

  parseExprAtom(refShorthandDefaultPos) {
    switch (this.state.type) {
      case types.regexp:
        return this.estreeParseRegExpLiteral(this.state.value);

      case types.num:
      case types.string:
        return this.estreeParseLiteral(this.state.value);

      case types._null:
        return this.estreeParseLiteral(null);

      case types._true:
        return this.estreeParseLiteral(true);

      case types._false:
        return this.estreeParseLiteral(false);

      default:
        return super.parseExprAtom(refShorthandDefaultPos);
    }
  }

  parseLiteral(value, type, startPos, startLoc) {
    const node = super.parseLiteral(value, type, startPos, startLoc);
    node.raw = node.extra.raw;
    delete node.extra;
    return node;
  }

  parseFunctionBody(node, allowExpression) {
    super.parseFunctionBody(node, allowExpression);
    node.expression = node.body.type !== "BlockStatement";
  }

  parseMethod(node, isGenerator, isAsync, isConstructor, type) {
    let funcNode = this.startNode();
    funcNode.kind = node.kind;
    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, "FunctionExpression");
    delete funcNode.kind;
    node.value = funcNode;
    return this.finishNode(node, type);
  }

  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc);

    if (node) {
      node.type = "Property";
      if (node.kind === "method") node.kind = "init";
      node.shorthand = false;
    }

    return node;
  }

  parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);

    if (node) {
      node.kind = "init";
      node.type = "Property";
    }

    return node;
  }

  toAssignable(node, isBinding, contextDescription) {
    if (isSimpleProperty(node)) {
      this.toAssignable(node.value, isBinding, contextDescription);
      return node;
    }

    return super.toAssignable(node, isBinding, contextDescription);
  }

  toAssignableObjectExpressionProp(prop, isBinding, isLast) {
    if (prop.kind === "get" || prop.kind === "set") {
      this.raise(prop.key.start, "Object pattern can't contain getter or setter");
    } else if (prop.method) {
      this.raise(prop.key.start, "Object pattern can't contain methods");
    } else {
      super.toAssignableObjectExpressionProp(prop, isBinding, isLast);
    }
  }

});

const lineBreak = /\r\n?|[\n\u2028\u2029]/;
const lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  switch (code) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;

    default:
      return false;
  }
}
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function isWhitespace(code) {
  switch (code) {
    case 0x0009:
    case 0x000b:
    case 0x000c:
    case 32:
    case 160:
    case 5760:
    case 0x2000:
    case 0x2001:
    case 0x2002:
    case 0x2003:
    case 0x2004:
    case 0x2005:
    case 0x2006:
    case 0x2007:
    case 0x2008:
    case 0x2009:
    case 0x200a:
    case 0x202f:
    case 0x205f:
    case 0x3000:
    case 0xfeff:
      return true;

    default:
      return false;
  }
}

class TokContext {
  constructor(token, isExpr, preserveSpace, override) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
  }

}
const types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", false),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, p => p.readTmplToken()),
  functionExpression: new TokContext("function", true),
  functionStatement: new TokContext("function", false)
};

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  let out = this.state.context.pop();

  if (out === types$1.braceStatement && this.curContext().token === "function") {
    out = this.state.context.pop();
  }

  this.state.exprAllowed = !out.isExpr;
};

types.name.updateContext = function (prevType) {
  let allowed = false;

  if (prevType !== types.dot) {
    if (this.state.value === "of" && !this.state.exprAllowed || this.state.value === "yield" && this.state.inGenerator) {
      allowed = true;
    }
  }

  this.state.exprAllowed = allowed;

  if (this.state.isIterator) {
    this.state.isIterator = false;
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.state.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
    this.state.context.push(types$1.functionExpression);
  } else {
    this.state.context.push(types$1.functionStatement);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }

  this.state.exprAllowed = false;
};

const reservedWords = {
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strict.concat(reservedWords.strictBind));
const isReservedWord = (word, inModule) => {
  return inModule && word === "await" || word === "enum";
};
function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictBindSet.has(word);
}
const keywords$1 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "while", "with", "null", "true", "false", "instanceof", "typeof", "void", "delete", "new", "in", "this", "const", "class", "extends", "export", "import", "super"]);
function isKeyword(word) {
  return keywords$1.has(word);
}
const keywordRelationalOperator = /^in(stanceof)?$/;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];
const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

function isInAstralSet(code, set) {
  let pos = 0x10000;

  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIteratorStart(current, next) {
  return current === 64 && next === 64;
}
function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

const reservedTypes = ["any", "bool", "boolean", "empty", "false", "mixed", "null", "number", "static", "string", "true", "typeof", "void", "interface", "extends", "_"];

function isEsModuleType(bodyElement) {
  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
}

function hasTypeImportKind(node) {
  return node.importKind === "type" || node.importKind === "typeof";
}

function isMaybeDefaultImport(state) {
  return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
}

const exportSuggestions = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};

function partition(list, test) {
  const list1 = [];
  const list2 = [];

  for (let i = 0; i < list.length; i++) {
    (test(list[i], i, list) ? list1 : list2).push(list[i]);
  }

  return [list1, list2];
}

const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
var flow = (superClass => class extends superClass {
  constructor(options, input) {
    super(options, input);
    this.flowPragma = undefined;
  }

  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }

  addComment(comment) {
    if (this.flowPragma === undefined) {
      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);

      if (!matches) {
        this.flowPragma = null;
      } else if (matches[1] === "flow") {
        this.flowPragma = "flow";
      } else if (matches[1] === "noflow") {
        this.flowPragma = "noflow";
      } else {
        throw new Error("Unexpected flow pragma");
      }
    }

    return super.addComment(comment);
  }

  flowParseTypeInitialiser(tok) {
    const oldInType = this.state.inType;
    this.state.inType = true;
    this.expect(tok || types.colon);
    const type = this.flowParseType();
    this.state.inType = oldInType;
    return type;
  }

  flowParsePredicate() {
    const node = this.startNode();
    const moduloLoc = this.state.startLoc;
    const moduloPos = this.state.start;
    this.expect(types.modulo);
    const checksLoc = this.state.startLoc;
    this.expectContextual("checks");

    if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
      this.raise(moduloPos, "Spaces between % and checks are not allowed here.");
    }

    if (this.eat(types.parenL)) {
      node.value = this.parseExpression();
      this.expect(types.parenR);
      return this.finishNode(node, "DeclaredPredicate");
    } else {
      return this.finishNode(node, "InferredPredicate");
    }
  }

  flowParseTypeAndPredicateInitialiser() {
    const oldInType = this.state.inType;
    this.state.inType = true;
    this.expect(types.colon);
    let type = null;
    let predicate = null;

    if (this.match(types.modulo)) {
      this.state.inType = oldInType;
      predicate = this.flowParsePredicate();
    } else {
      type = this.flowParseType();
      this.state.inType = oldInType;

      if (this.match(types.modulo)) {
        predicate = this.flowParsePredicate();
      }
    }

    return [type, predicate];
  }

  flowParseDeclareClass(node) {
    this.next();
    this.flowParseInterfaceish(node, true);
    return this.finishNode(node, "DeclareClass");
  }

  flowParseDeclareFunction(node) {
    this.next();
    const id = node.id = this.parseIdentifier();
    const typeNode = this.startNode();
    const typeContainer = this.startNode();

    if (this.isRelational("<")) {
      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      typeNode.typeParameters = null;
    }

    this.expect(types.parenL);
    const tmp = this.flowParseFunctionTypeParams();
    typeNode.params = tmp.params;
    typeNode.rest = tmp.rest;
    this.expect(types.parenR);
    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
    this.finishNode(id, id.type);
    this.semicolon();
    return this.finishNode(node, "DeclareFunction");
  }

  flowParseDeclare(node, insideModule) {
    if (this.match(types._class)) {
      return this.flowParseDeclareClass(node);
    } else if (this.match(types._function)) {
      return this.flowParseDeclareFunction(node);
    } else if (this.match(types._var)) {
      return this.flowParseDeclareVariable(node);
    } else if (this.isContextual("module")) {
      if (this.lookahead().type === types.dot) {
        return this.flowParseDeclareModuleExports(node);
      } else {
        if (insideModule) {
          this.unexpected(null, "`declare module` cannot be used inside another `declare module`");
        }

        return this.flowParseDeclareModule(node);
      }
    } else if (this.isContextual("type")) {
      return this.flowParseDeclareTypeAlias(node);
    } else if (this.isContextual("opaque")) {
      return this.flowParseDeclareOpaqueType(node);
    } else if (this.isContextual("interface")) {
      return this.flowParseDeclareInterface(node);
    } else if (this.match(types._export)) {
      return this.flowParseDeclareExportDeclaration(node, insideModule);
    } else {
      throw this.unexpected();
    }
  }

  flowParseDeclareVariable(node) {
    this.next();
    node.id = this.flowParseTypeAnnotatableIdentifier(true);
    this.semicolon();
    return this.finishNode(node, "DeclareVariable");
  }

  flowParseDeclareModule(node) {
    this.next();

    if (this.match(types.string)) {
      node.id = this.parseExprAtom();
    } else {
      node.id = this.parseIdentifier();
    }

    const bodyNode = node.body = this.startNode();
    const body = bodyNode.body = [];
    this.expect(types.braceL);

    while (!this.match(types.braceR)) {
      let bodyNode = this.startNode();

      if (this.match(types._import)) {
        const lookahead = this.lookahead();

        if (lookahead.value !== "type" && lookahead.value !== "typeof") {
          this.unexpected(null, "Imports within a `declare module` body must always be `import type` or `import typeof`");
        }

        this.next();
        this.parseImport(bodyNode);
      } else {
        this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");
        bodyNode = this.flowParseDeclare(bodyNode, true);
      }

      body.push(bodyNode);
    }

    this.expect(types.braceR);
    this.finishNode(bodyNode, "BlockStatement");
    let kind = null;
    let hasModuleExport = false;
    const errorMessage = "Found both `declare module.exports` and `declare export` in the same module. " + "Modules can only have 1 since they are either an ES module or they are a CommonJS module";
    body.forEach(bodyElement => {
      if (isEsModuleType(bodyElement)) {
        if (kind === "CommonJS") {
          this.unexpected(bodyElement.start, errorMessage);
        }

        kind = "ES";
      } else if (bodyElement.type === "DeclareModuleExports") {
        if (hasModuleExport) {
          this.unexpected(bodyElement.start, "Duplicate `declare module.exports` statement");
        }

        if (kind === "ES") this.unexpected(bodyElement.start, errorMessage);
        kind = "CommonJS";
        hasModuleExport = true;
      }
    });
    node.kind = kind || "CommonJS";
    return this.finishNode(node, "DeclareModule");
  }

  flowParseDeclareExportDeclaration(node, insideModule) {
    this.expect(types._export);

    if (this.eat(types._default)) {
      if (this.match(types._function) || this.match(types._class)) {
        node.declaration = this.flowParseDeclare(this.startNode());
      } else {
        node.declaration = this.flowParseType();
        this.semicolon();
      }

      node.default = true;
      return this.finishNode(node, "DeclareExportDeclaration");
    } else {
      if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
        const label = this.state.value;
        const suggestion = exportSuggestions[label];
        this.unexpected(this.state.start, `\`declare export ${label}\` is not supported. Use \`${suggestion}\` instead`);
      }

      if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
          node.declaration = this.flowParseDeclare(this.startNode());
          node.default = false;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
          node = this.parseExport(node);

          if (node.type === "ExportNamedDeclaration") {
            node.type = "ExportDeclaration";
            node.default = false;
            delete node.exportKind;
          }

          node.type = "Declare" + node.type;
          return node;
        }
    }

    throw this.unexpected();
  }

  flowParseDeclareModuleExports(node) {
    this.expectContextual("module");
    this.expect(types.dot);
    this.expectContextual("exports");
    node.typeAnnotation = this.flowParseTypeAnnotation();
    this.semicolon();
    return this.finishNode(node, "DeclareModuleExports");
  }

  flowParseDeclareTypeAlias(node) {
    this.next();
    this.flowParseTypeAlias(node);
    return this.finishNode(node, "DeclareTypeAlias");
  }

  flowParseDeclareOpaqueType(node) {
    this.next();
    this.flowParseOpaqueType(node, true);
    return this.finishNode(node, "DeclareOpaqueType");
  }

  flowParseDeclareInterface(node) {
    this.next();
    this.flowParseInterfaceish(node);
    return this.finishNode(node, "DeclareInterface");
  }

  flowParseInterfaceish(node, isClass = false) {
    node.id = this.flowParseRestrictedIdentifier(!isClass);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.extends = [];
    node.implements = [];
    node.mixins = [];

    if (this.eat(types._extends)) {
      do {
        node.extends.push(this.flowParseInterfaceExtends());
      } while (!isClass && this.eat(types.comma));
    }

    if (this.isContextual("mixins")) {
      this.next();

      do {
        node.mixins.push(this.flowParseInterfaceExtends());
      } while (this.eat(types.comma));
    }

    if (this.isContextual("implements")) {
      this.next();

      do {
        node.implements.push(this.flowParseInterfaceExtends());
      } while (this.eat(types.comma));
    }

    node.body = this.flowParseObjectType({
      allowStatic: isClass,
      allowExact: false,
      allowSpread: false,
      allowProto: isClass,
      allowInexact: false
    });
  }

  flowParseInterfaceExtends() {
    const node = this.startNode();
    node.id = this.flowParseQualifiedTypeIdentifier();

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    } else {
      node.typeParameters = null;
    }

    return this.finishNode(node, "InterfaceExtends");
  }

  flowParseInterface(node) {
    this.flowParseInterfaceish(node);
    return this.finishNode(node, "InterfaceDeclaration");
  }

  checkNotUnderscore(word) {
    if (word === "_") {
      throw this.unexpected(null, "`_` is only allowed as a type argument to call or new");
    }
  }

  checkReservedType(word, startLoc) {
    if (reservedTypes.indexOf(word) > -1) {
      this.raise(startLoc, `Cannot overwrite reserved type ${word}`);
    }
  }

  flowParseRestrictedIdentifier(liberal) {
    this.checkReservedType(this.state.value, this.state.start);
    return this.parseIdentifier(liberal);
  }

  flowParseTypeAlias(node) {
    node.id = this.flowParseRestrictedIdentifier();

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.right = this.flowParseTypeInitialiser(types.eq);
    this.semicolon();
    return this.finishNode(node, "TypeAlias");
  }

  flowParseOpaqueType(node, declare) {
    this.expectContextual("type");
    node.id = this.flowParseRestrictedIdentifier(true);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    } else {
      node.typeParameters = null;
    }

    node.supertype = null;

    if (this.match(types.colon)) {
      node.supertype = this.flowParseTypeInitialiser(types.colon);
    }

    node.impltype = null;

    if (!declare) {
      node.impltype = this.flowParseTypeInitialiser(types.eq);
    }

    this.semicolon();
    return this.finishNode(node, "OpaqueType");
  }

  flowParseTypeParameter(allowDefault = true, requireDefault = false) {
    if (!allowDefault && requireDefault) {
      throw new Error("Cannot disallow a default value (`allowDefault`) while also requiring it (`requireDefault`).");
    }

    const nodeStart = this.state.start;
    const node = this.startNode();
    const variance = this.flowParseVariance();
    const ident = this.flowParseTypeAnnotatableIdentifier();
    node.name = ident.name;
    node.variance = variance;
    node.bound = ident.typeAnnotation;

    if (this.match(types.eq)) {
      if (allowDefault) {
        this.eat(types.eq);
        node.default = this.flowParseType();
      } else {
        this.unexpected();
      }
    } else {
      if (requireDefault) {
        this.unexpected(nodeStart, "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.");
      }
    }

    return this.finishNode(node, "TypeParameter");
  }

  flowParseTypeParameterDeclaration(allowDefault = true) {
    const oldInType = this.state.inType;
    const node = this.startNode();
    node.params = [];
    this.state.inType = true;

    if (this.isRelational("<") || this.match(types.jsxTagStart)) {
      this.next();
    } else {
      this.unexpected();
    }

    let defaultRequired = false;

    do {
      const typeParameter = this.flowParseTypeParameter(allowDefault, defaultRequired);
      node.params.push(typeParameter);

      if (typeParameter.default) {
        defaultRequired = true;
      }

      if (!this.isRelational(">")) {
        this.expect(types.comma);
      }
    } while (!this.isRelational(">"));

    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterDeclaration");
  }

  flowParseTypeParameterInstantiation() {
    const node = this.startNode();
    const oldInType = this.state.inType;
    node.params = [];
    this.state.inType = true;
    this.expectRelational("<");
    const oldNoAnonFunctionType = this.state.noAnonFunctionType;
    this.state.noAnonFunctionType = false;

    while (!this.isRelational(">")) {
      node.params.push(this.flowParseType());

      if (!this.isRelational(">")) {
        this.expect(types.comma);
      }
    }

    this.state.noAnonFunctionType = oldNoAnonFunctionType;
    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterInstantiation");
  }

  flowParseTypeParameterInstantiationCallOrNew() {
    const node = this.startNode();
    const oldInType = this.state.inType;
    node.params = [];
    this.state.inType = true;
    this.expectRelational("<");

    while (!this.isRelational(">")) {
      node.params.push(this.flowParseTypeOrImplicitInstantiation());

      if (!this.isRelational(">")) {
        this.expect(types.comma);
      }
    }

    this.expectRelational(">");
    this.state.inType = oldInType;
    return this.finishNode(node, "TypeParameterInstantiation");
  }

  flowParseInterfaceType() {
    const node = this.startNode();
    this.expectContextual("interface");
    node.extends = [];

    if (this.eat(types._extends)) {
      do {
        node.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(types.comma));
    }

    node.body = this.flowParseObjectType({
      allowStatic: false,
      allowExact: false,
      allowSpread: false,
      allowProto: false,
      allowInexact: false
    });
    return this.finishNode(node, "InterfaceTypeAnnotation");
  }

  flowParseObjectPropertyKey() {
    return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
  }

  flowParseObjectTypeIndexer(node, isStatic, variance) {
    node.static = isStatic;

    if (this.lookahead().type === types.colon) {
      node.id = this.flowParseObjectPropertyKey();
      node.key = this.flowParseTypeInitialiser();
    } else {
      node.id = null;
      node.key = this.flowParseType();
    }

    this.expect(types.bracketR);
    node.value = this.flowParseTypeInitialiser();
    node.variance = variance;
    return this.finishNode(node, "ObjectTypeIndexer");
  }

  flowParseObjectTypeInternalSlot(node, isStatic) {
    node.static = isStatic;
    node.id = this.flowParseObjectPropertyKey();
    this.expect(types.bracketR);
    this.expect(types.bracketR);

    if (this.isRelational("<") || this.match(types.parenL)) {
      node.method = true;
      node.optional = false;
      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
    } else {
      node.method = false;

      if (this.eat(types.question)) {
        node.optional = true;
      }

      node.value = this.flowParseTypeInitialiser();
    }

    return this.finishNode(node, "ObjectTypeInternalSlot");
  }

  flowParseObjectTypeMethodish(node) {
    node.params = [];
    node.rest = null;
    node.typeParameters = null;

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration(false);
    }

    this.expect(types.parenL);

    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
      node.params.push(this.flowParseFunctionTypeParam());

      if (!this.match(types.parenR)) {
        this.expect(types.comma);
      }
    }

    if (this.eat(types.ellipsis)) {
      node.rest = this.flowParseFunctionTypeParam();
    }

    this.expect(types.parenR);
    node.returnType = this.flowParseTypeInitialiser();
    return this.finishNode(node, "FunctionTypeAnnotation");
  }

  flowParseObjectTypeCallProperty(node, isStatic) {
    const valueNode = this.startNode();
    node.static = isStatic;
    node.value = this.flowParseObjectTypeMethodish(valueNode);
    return this.finishNode(node, "ObjectTypeCallProperty");
  }

  flowParseObjectType({
    allowStatic,
    allowExact,
    allowSpread,
    allowProto,
    allowInexact
  }) {
    const oldInType = this.state.inType;
    this.state.inType = true;
    const nodeStart = this.startNode();
    nodeStart.callProperties = [];
    nodeStart.properties = [];
    nodeStart.indexers = [];
    nodeStart.internalSlots = [];
    let endDelim;
    let exact;
    let inexact = false;

    if (allowExact && this.match(types.braceBarL)) {
      this.expect(types.braceBarL);
      endDelim = types.braceBarR;
      exact = true;
    } else {
      this.expect(types.braceL);
      endDelim = types.braceR;
      exact = false;
    }

    nodeStart.exact = exact;

    while (!this.match(endDelim)) {
      let isStatic = false;
      let protoStart = null;
      const node = this.startNode();

      if (allowProto && this.isContextual("proto")) {
        const lookahead = this.lookahead();

        if (lookahead.type !== types.colon && lookahead.type !== types.question) {
          this.next();
          protoStart = this.state.start;
          allowStatic = false;
        }
      }

      if (allowStatic && this.isContextual("static")) {
        const lookahead = this.lookahead();

        if (lookahead.type !== types.colon && lookahead.type !== types.question) {
          this.next();
          isStatic = true;
        }
      }

      const variance = this.flowParseVariance();

      if (this.eat(types.bracketL)) {
        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (this.eat(types.bracketL)) {
          if (variance) {
            this.unexpected(variance.start);
          }

          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
        } else {
          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
        }
      } else if (this.match(types.parenL) || this.isRelational("<")) {
        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (variance) {
          this.unexpected(variance.start);
        }

        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
      } else {
        let kind = "init";

        if (this.isContextual("get") || this.isContextual("set")) {
          const lookahead = this.lookahead();

          if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {
            kind = this.state.value;
            this.next();
          }
        }

        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact);

        if (propOrInexact === null) {
          inexact = true;
        } else {
          nodeStart.properties.push(propOrInexact);
        }
      }

      this.flowObjectTypeSemicolon();
    }

    this.expect(endDelim);

    if (allowSpread) {
      nodeStart.inexact = inexact;
    }

    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
    this.state.inType = oldInType;
    return out;
  }

  flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
    if (this.match(types.ellipsis)) {
      if (!allowSpread) {
        this.unexpected(null, "Spread operator cannot appear in class or interface definitions");
      }

      if (protoStart != null) {
        this.unexpected(protoStart);
      }

      if (variance) {
        this.unexpected(variance.start, "Spread properties cannot have variance");
      }

      this.expect(types.ellipsis);
      const isInexactToken = this.eat(types.comma) || this.eat(types.semi);

      if (this.match(types.braceR)) {
        if (allowInexact) return null;
        this.unexpected(null, "Explicit inexact syntax is only allowed inside inexact objects");
      }

      if (this.match(types.braceBarR)) {
        this.unexpected(null, "Explicit inexact syntax cannot appear inside an explicit exact object type");
      }

      if (isInexactToken) {
        this.unexpected(null, "Explicit inexact syntax must appear at the end of an inexact object");
      }

      node.argument = this.flowParseType();
      return this.finishNode(node, "ObjectTypeSpreadProperty");
    } else {
      node.key = this.flowParseObjectPropertyKey();
      node.static = isStatic;
      node.proto = protoStart != null;
      node.kind = kind;
      let optional = false;

      if (this.isRelational("<") || this.match(types.parenL)) {
        node.method = true;

        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (variance) {
          this.unexpected(variance.start);
        }

        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

        if (kind === "get" || kind === "set") {
          this.flowCheckGetterSetterParams(node);
        }
      } else {
        if (kind !== "init") this.unexpected();
        node.method = false;

        if (this.eat(types.question)) {
          optional = true;
        }

        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
      }

      node.optional = optional;
      return this.finishNode(node, "ObjectTypeProperty");
    }
  }

  flowCheckGetterSetterParams(property) {
    const paramCount = property.kind === "get" ? 0 : 1;
    const start = property.start;
    const length = property.value.params.length + (property.value.rest ? 1 : 0);

    if (length !== paramCount) {
      if (property.kind === "get") {
        this.raise(start, "getter must not have any formal parameters");
      } else {
        this.raise(start, "setter must have exactly one formal parameter");
      }
    }

    if (property.kind === "set" && property.value.rest) {
      this.raise(start, "setter function argument must not be a rest parameter");
    }
  }

  flowObjectTypeSemicolon() {
    if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
      this.unexpected();
    }
  }

  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
    startPos = startPos || this.state.start;
    startLoc = startLoc || this.state.startLoc;
    let node = id || this.parseIdentifier();

    while (this.eat(types.dot)) {
      const node2 = this.startNodeAt(startPos, startLoc);
      node2.qualification = node;
      node2.id = this.parseIdentifier();
      node = this.finishNode(node2, "QualifiedTypeIdentifier");
    }

    return node;
  }

  flowParseGenericType(startPos, startLoc, id) {
    const node = this.startNodeAt(startPos, startLoc);
    node.typeParameters = null;
    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterInstantiation();
    }

    return this.finishNode(node, "GenericTypeAnnotation");
  }

  flowParseTypeofType() {
    const node = this.startNode();
    this.expect(types._typeof);
    node.argument = this.flowParsePrimaryType();
    return this.finishNode(node, "TypeofTypeAnnotation");
  }

  flowParseTupleType() {
    const node = this.startNode();
    node.types = [];
    this.expect(types.bracketL);

    while (this.state.pos < this.state.length && !this.match(types.bracketR)) {
      node.types.push(this.flowParseType());
      if (this.match(types.bracketR)) break;
      this.expect(types.comma);
    }

    this.expect(types.bracketR);
    return this.finishNode(node, "TupleTypeAnnotation");
  }

  flowParseFunctionTypeParam() {
    let name = null;
    let optional = false;
    let typeAnnotation = null;
    const node = this.startNode();
    const lh = this.lookahead();

    if (lh.type === types.colon || lh.type === types.question) {
      name = this.parseIdentifier();

      if (this.eat(types.question)) {
        optional = true;
      }

      typeAnnotation = this.flowParseTypeInitialiser();
    } else {
      typeAnnotation = this.flowParseType();
    }

    node.name = name;
    node.optional = optional;
    node.typeAnnotation = typeAnnotation;
    return this.finishNode(node, "FunctionTypeParam");
  }

  reinterpretTypeAsFunctionTypeParam(type) {
    const node = this.startNodeAt(type.start, type.loc.start);
    node.name = null;
    node.optional = false;
    node.typeAnnotation = type;
    return this.finishNode(node, "FunctionTypeParam");
  }

  flowParseFunctionTypeParams(params = []) {
    let rest = null;

    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
      params.push(this.flowParseFunctionTypeParam());

      if (!this.match(types.parenR)) {
        this.expect(types.comma);
      }
    }

    if (this.eat(types.ellipsis)) {
      rest = this.flowParseFunctionTypeParam();
    }

    return {
      params,
      rest
    };
  }

  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
    switch (id.name) {
      case "any":
        return this.finishNode(node, "AnyTypeAnnotation");

      case "bool":
      case "boolean":
        return this.finishNode(node, "BooleanTypeAnnotation");

      case "mixed":
        return this.finishNode(node, "MixedTypeAnnotation");

      case "empty":
        return this.finishNode(node, "EmptyTypeAnnotation");

      case "number":
        return this.finishNode(node, "NumberTypeAnnotation");

      case "string":
        return this.finishNode(node, "StringTypeAnnotation");

      default:
        this.checkNotUnderscore(id.name);
        return this.flowParseGenericType(startPos, startLoc, id);
    }
  }

  flowParsePrimaryType() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const node = this.startNode();
    let tmp;
    let type;
    let isGroupedType = false;
    const oldNoAnonFunctionType = this.state.noAnonFunctionType;

    switch (this.state.type) {
      case types.name:
        if (this.isContextual("interface")) {
          return this.flowParseInterfaceType();
        }

        return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

      case types.braceL:
        return this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: true,
          allowProto: false,
          allowInexact: true
        });

      case types.braceBarL:
        return this.flowParseObjectType({
          allowStatic: false,
          allowExact: true,
          allowSpread: true,
          allowProto: false,
          allowInexact: false
        });

      case types.bracketL:
        return this.flowParseTupleType();

      case types.relational:
        if (this.state.value === "<") {
          node.typeParameters = this.flowParseTypeParameterDeclaration(false);
          this.expect(types.parenL);
          tmp = this.flowParseFunctionTypeParams();
          node.params = tmp.params;
          node.rest = tmp.rest;
          this.expect(types.parenR);
          this.expect(types.arrow);
          node.returnType = this.flowParseType();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }

        break;

      case types.parenL:
        this.next();

        if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          if (this.match(types.name)) {
            const token = this.lookahead().type;
            isGroupedType = token !== types.question && token !== types.colon;
          } else {
            isGroupedType = true;
          }
        }

        if (isGroupedType) {
          this.state.noAnonFunctionType = false;
          type = this.flowParseType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;

          if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
            this.expect(types.parenR);
            return type;
          } else {
            this.eat(types.comma);
          }
        }

        if (type) {
          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
        } else {
          tmp = this.flowParseFunctionTypeParams();
        }

        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(types.parenR);
        this.expect(types.arrow);
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");

      case types.string:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

      case types._true:
      case types._false:
        node.value = this.match(types._true);
        this.next();
        return this.finishNode(node, "BooleanLiteralTypeAnnotation");

      case types.plusMin:
        if (this.state.value === "-") {
          this.next();

          if (!this.match(types.num)) {
            this.unexpected(null, `Unexpected token, expected "number"`);
          }

          return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
        }

        this.unexpected();

      case types.num:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

      case types._void:
        this.next();
        return this.finishNode(node, "VoidTypeAnnotation");

      case types._null:
        this.next();
        return this.finishNode(node, "NullLiteralTypeAnnotation");

      case types._this:
        this.next();
        return this.finishNode(node, "ThisTypeAnnotation");

      case types.star:
        this.next();
        return this.finishNode(node, "ExistsTypeAnnotation");

      default:
        if (this.state.type.keyword === "typeof") {
          return this.flowParseTypeofType();
        } else if (this.state.type.keyword) {
          const label = this.state.type.label;
          this.next();
          return super.createIdentifier(node, label);
        }

    }

    throw this.unexpected();
  }

  flowParsePostfixType() {
    const startPos = this.state.start,
          startLoc = this.state.startLoc;
    let type = this.flowParsePrimaryType();

    while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
      const node = this.startNodeAt(startPos, startLoc);
      node.elementType = type;
      this.expect(types.bracketL);
      this.expect(types.bracketR);
      type = this.finishNode(node, "ArrayTypeAnnotation");
    }

    return type;
  }

  flowParsePrefixType() {
    const node = this.startNode();

    if (this.eat(types.question)) {
      node.typeAnnotation = this.flowParsePrefixType();
      return this.finishNode(node, "NullableTypeAnnotation");
    } else {
      return this.flowParsePostfixType();
    }
  }

  flowParseAnonFunctionWithoutParens() {
    const param = this.flowParsePrefixType();

    if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
      const node = this.startNodeAt(param.start, param.loc.start);
      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
      node.rest = null;
      node.returnType = this.flowParseType();
      node.typeParameters = null;
      return this.finishNode(node, "FunctionTypeAnnotation");
    }

    return param;
  }

  flowParseIntersectionType() {
    const node = this.startNode();
    this.eat(types.bitwiseAND);
    const type = this.flowParseAnonFunctionWithoutParens();
    node.types = [type];

    while (this.eat(types.bitwiseAND)) {
      node.types.push(this.flowParseAnonFunctionWithoutParens());
    }

    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
  }

  flowParseUnionType() {
    const node = this.startNode();
    this.eat(types.bitwiseOR);
    const type = this.flowParseIntersectionType();
    node.types = [type];

    while (this.eat(types.bitwiseOR)) {
      node.types.push(this.flowParseIntersectionType());
    }

    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
  }

  flowParseType() {
    const oldInType = this.state.inType;
    this.state.inType = true;
    const type = this.flowParseUnionType();
    this.state.inType = oldInType;
    this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
    return type;
  }

  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === types.name && this.state.value === "_") {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const node = this.parseIdentifier();
      return this.flowParseGenericType(startPos, startLoc, node);
    } else {
      return this.flowParseType();
    }
  }

  flowParseTypeAnnotation() {
    const node = this.startNode();
    node.typeAnnotation = this.flowParseTypeInitialiser();
    return this.finishNode(node, "TypeAnnotation");
  }

  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

    if (this.match(types.colon)) {
      ident.typeAnnotation = this.flowParseTypeAnnotation();
      this.finishNode(ident, ident.type);
    }

    return ident;
  }

  typeCastToParameter(node) {
    node.expression.typeAnnotation = node.typeAnnotation;
    return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
  }

  flowParseVariance() {
    let variance = null;

    if (this.match(types.plusMin)) {
      variance = this.startNode();

      if (this.state.value === "+") {
        variance.kind = "plus";
      } else {
        variance.kind = "minus";
      }

      this.next();
      this.finishNode(variance, "Variance");
    }

    return variance;
  }

  parseFunctionBody(node, allowExpressionBody) {
    if (allowExpressionBody) {
      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true));
    }

    return super.parseFunctionBody(node, false);
  }

  parseFunctionBodyAndFinish(node, type, allowExpressionBody) {
    if (!allowExpressionBody && this.match(types.colon)) {
      const typeNode = this.startNode();
      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
    }

    super.parseFunctionBodyAndFinish(node, type, allowExpressionBody);
  }

  parseStatement(context, topLevel) {
    if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
      const node = this.startNode();
      this.next();
      return this.flowParseInterface(node);
    } else {
      const stmt = super.parseStatement(context, topLevel);

      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
        this.flowPragma = null;
      }

      return stmt;
    }
  }

  parseExpressionStatement(node, expr) {
    if (expr.type === "Identifier") {
      if (expr.name === "declare") {
        if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
          return this.flowParseDeclare(node);
        }
      } else if (this.match(types.name)) {
        if (expr.name === "interface") {
          return this.flowParseInterface(node);
        } else if (expr.name === "type") {
          return this.flowParseTypeAlias(node);
        } else if (expr.name === "opaque") {
          return this.flowParseOpaqueType(node, false);
        }
      }
    }

    return super.parseExpressionStatement(node, expr);
  }

  shouldParseExportDeclaration() {
    return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || super.shouldParseExportDeclaration();
  }

  isExportDefaultSpecifier() {
    if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque")) {
      return false;
    }

    return super.isExportDefaultSpecifier();
  }

  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
    if (!this.match(types.question)) return expr;

    if (refNeedsArrowPos) {
      const state = this.state.clone();

      try {
        return super.parseConditional(expr, noIn, startPos, startLoc);
      } catch (err) {
        if (err instanceof SyntaxError) {
          this.state = state;
          refNeedsArrowPos.start = err.pos || this.state.start;
          return expr;
        } else {
          throw err;
        }
      }
    }

    this.expect(types.question);
    const state = this.state.clone();
    const originalNoArrowAt = this.state.noArrowAt;
    const node = this.startNodeAt(startPos, startLoc);
    let {
      consequent,
      failed
    } = this.tryParseConditionalConsequent();
    let [valid, invalid] = this.getArrowLikeExpressions(consequent);

    if (failed || invalid.length > 0) {
      const noArrowAt = [...originalNoArrowAt];

      if (invalid.length > 0) {
        this.state = state;
        this.state.noArrowAt = noArrowAt;

        for (let i = 0; i < invalid.length; i++) {
          noArrowAt.push(invalid[i].start);
        }

        ({
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
        [valid, invalid] = this.getArrowLikeExpressions(consequent);
      }

      if (failed && valid.length > 1) {
        this.raise(state.start, "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.");
      }

      if (failed && valid.length === 1) {
        this.state = state;
        this.state.noArrowAt = noArrowAt.concat(valid[0].start);
        ({
          consequent,
          failed
        } = this.tryParseConditionalConsequent());
      }

      this.getArrowLikeExpressions(consequent, true);
    }

    this.state.noArrowAt = originalNoArrowAt;
    this.expect(types.colon);
    node.test = expr;
    node.consequent = consequent;
    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(noIn, undefined, undefined, undefined));
    return this.finishNode(node, "ConditionalExpression");
  }

  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const consequent = this.parseMaybeAssign();
    const failed = !this.match(types.colon);
    this.state.noArrowParamsConversionAt.pop();
    return {
      consequent,
      failed
    };
  }

  getArrowLikeExpressions(node, disallowInvalid) {
    const stack = [node];
    const arrows = [];

    while (stack.length !== 0) {
      const node = stack.pop();

      if (node.type === "ArrowFunctionExpression") {
        if (node.typeParameters || !node.returnType) {
          this.toAssignableList(node.params, true, "arrow function parameters");
          super.checkFunctionNameAndParams(node, true);
        } else {
          arrows.push(node);
        }

        stack.push(node.body);
      } else if (node.type === "ConditionalExpression") {
        stack.push(node.consequent);
        stack.push(node.alternate);
      }
    }

    if (disallowInvalid) {
      for (let i = 0; i < arrows.length; i++) {
        this.toAssignableList(node.params, true, "arrow function parameters");
      }

      return [arrows, []];
    }

    return partition(arrows, node => {
      try {
        this.toAssignableList(node.params, true, "arrow function parameters");
        return true;
      } catch (err) {
        return false;
      }
    });
  }

  forwardNoArrowParamsConversionAt(node, parse) {
    let result;

    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      result = parse();
      this.state.noArrowParamsConversionAt.pop();
    } else {
      result = parse();
    }

    return result;
  }

  parseParenItem(node, startPos, startLoc) {
    node = super.parseParenItem(node, startPos, startLoc);

    if (this.eat(types.question)) {
      node.optional = true;
    }

    if (this.match(types.colon)) {
      const typeCastNode = this.startNodeAt(startPos, startLoc);
      typeCastNode.expression = node;
      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
      return this.finishNode(typeCastNode, "TypeCastExpression");
    }

    return node;
  }

  assertModuleNodeAllowed(node) {
    if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
      return;
    }

    super.assertModuleNodeAllowed(node);
  }

  parseExport(node) {
    const decl = super.parseExport(node);

    if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
      decl.exportKind = decl.exportKind || "value";
    }

    return decl;
  }

  parseExportDeclaration(node) {
    if (this.isContextual("type")) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();

      if (this.match(types.braceL)) {
        node.specifiers = this.parseExportSpecifiers();
        this.parseExportFrom(node);
        return null;
      } else {
        return this.flowParseTypeAlias(declarationNode);
      }
    } else if (this.isContextual("opaque")) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseOpaqueType(declarationNode, false);
    } else if (this.isContextual("interface")) {
      node.exportKind = "type";
      const declarationNode = this.startNode();
      this.next();
      return this.flowParseInterface(declarationNode);
    } else {
      return super.parseExportDeclaration(node);
    }
  }

  eatExportStar(node) {
    if (super.eatExportStar(...arguments)) return true;

    if (this.isContextual("type") && this.lookahead().type === types.star) {
      node.exportKind = "type";
      this.next();
      this.next();
      return true;
    }

    return false;
  }

  maybeParseExportNamespaceSpecifier(node) {
    const pos = this.state.start;
    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);

    if (hasNamespace && node.exportKind === "type") {
      this.unexpected(pos);
    }

    return hasNamespace;
  }

  parseClassId(node, isStatement, optionalId) {
    super.parseClassId(node, isStatement, optionalId);

    if (this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration();
    }
  }

  getTokenFromCode(code) {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (code === 123 && next === 124) {
      return this.finishOp(types.braceBarL, 2);
    } else if (this.state.inType && (code === 62 || code === 60)) {
      return this.finishOp(types.relational, 1);
    } else if (isIteratorStart(code, next)) {
      this.state.isIterator = true;
      return super.readWord();
    } else {
      return super.getTokenFromCode(code);
    }
  }

  toAssignable(node, isBinding, contextDescription) {
    if (node.type === "TypeCastExpression") {
      return super.toAssignable(this.typeCastToParameter(node), isBinding, contextDescription);
    } else {
      return super.toAssignable(node, isBinding, contextDescription);
    }
  }

  toAssignableList(exprList, isBinding, contextDescription) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];

      if (expr && expr.type === "TypeCastExpression") {
        exprList[i] = this.typeCastToParameter(expr);
      }
    }

    return super.toAssignableList(exprList, isBinding, contextDescription);
  }

  toReferencedList(exprList, isParenthesizedExpr) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];

      if (expr && expr.type === "TypeCastExpression" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
        this.raise(expr.typeAnnotation.start, "The type cast expression is expected to be wrapped with parenthesis");
      }
    }

    return exprList;
  }

  checkLVal(expr, isBinding, checkClashes, contextDescription) {
    if (expr.type !== "TypeCastExpression") {
      return super.checkLVal(expr, isBinding, checkClashes, contextDescription);
    }
  }

  parseClassProperty(node) {
    if (this.match(types.colon)) {
      node.typeAnnotation = this.flowParseTypeAnnotation();
    }

    return super.parseClassProperty(node);
  }

  parseClassPrivateProperty(node) {
    if (this.match(types.colon)) {
      node.typeAnnotation = this.flowParseTypeAnnotation();
    }

    return super.parseClassPrivateProperty(node);
  }

  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }

  isClassProperty() {
    return this.match(types.colon) || super.isClassProperty();
  }

  isNonstaticConstructor(method) {
    return !this.match(types.colon) && super.isNonstaticConstructor(method);
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
    if (method.variance) {
      this.unexpected(method.variance.start);
    }

    delete method.variance;

    if (this.isRelational("<")) {
      method.typeParameters = this.flowParseTypeParameterDeclaration(false);
    }

    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor);
  }

  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    if (method.variance) {
      this.unexpected(method.variance.start);
    }

    delete method.variance;

    if (this.isRelational("<")) {
      method.typeParameters = this.flowParseTypeParameterDeclaration();
    }

    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
  }

  parseClassSuper(node) {
    super.parseClassSuper(node);

    if (node.superClass && this.isRelational("<")) {
      node.superTypeParameters = this.flowParseTypeParameterInstantiation();
    }

    if (this.isContextual("implements")) {
      this.next();
      const implemented = node.implements = [];

      do {
        const node = this.startNode();
        node.id = this.flowParseRestrictedIdentifier(true);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }

        implemented.push(this.finishNode(node, "ClassImplements"));
      } while (this.eat(types.comma));
    }
  }

  parsePropertyName(node) {
    const variance = this.flowParseVariance();
    const key = super.parsePropertyName(node);
    node.variance = variance;
    return key;
  }

  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
    if (prop.variance) {
      this.unexpected(prop.variance.start);
    }

    delete prop.variance;
    let typeParameters;

    if (this.isRelational("<")) {
      typeParameters = this.flowParseTypeParameterDeclaration(false);
      if (!this.match(types.parenL)) this.unexpected();
    }

    super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);

    if (typeParameters) {
      (prop.value || prop).typeParameters = typeParameters;
    }
  }

  parseAssignableListItemTypes(param) {
    if (this.eat(types.question)) {
      if (param.type !== "Identifier") {
        throw this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
      }

      param.optional = true;
    }

    if (this.match(types.colon)) {
      param.typeAnnotation = this.flowParseTypeAnnotation();
    }

    this.finishNode(param, param.type);
    return param;
  }

  parseMaybeDefault(startPos, startLoc, left) {
    const node = super.parseMaybeDefault(startPos, startLoc, left);

    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
    }

    return node;
  }

  shouldParseDefaultImport(node) {
    if (!hasTypeImportKind(node)) {
      return super.shouldParseDefaultImport(node);
    }

    return isMaybeDefaultImport(this.state);
  }

  parseImportSpecifierLocal(node, specifier, type, contextDescription) {
    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true) : this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, contextDescription);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  maybeParseDefaultImportSpecifier(node) {
    node.importKind = "value";
    let kind = null;

    if (this.match(types._typeof)) {
      kind = "typeof";
    } else if (this.isContextual("type")) {
      kind = "type";
    }

    if (kind) {
      const lh = this.lookahead();

      if (kind === "type" && lh.type === types.star) {
        this.unexpected(lh.start);
      }

      if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
        this.next();
        node.importKind = kind;
      }
    }

    return super.maybeParseDefaultImportSpecifier(node);
  }

  parseImportSpecifier(node) {
    const specifier = this.startNode();
    const firstIdentLoc = this.state.start;
    const firstIdent = this.parseIdentifier(true);
    let specifierTypeKind = null;

    if (firstIdent.name === "type") {
      specifierTypeKind = "type";
    } else if (firstIdent.name === "typeof") {
      specifierTypeKind = "typeof";
    }

    let isBinding = false;

    if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
      const as_ident = this.parseIdentifier(true);

      if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
        specifier.imported = as_ident;
        specifier.importKind = specifierTypeKind;
        specifier.local = as_ident.__clone();
      } else {
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = this.parseIdentifier();
      }
    } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
      specifier.imported = this.parseIdentifier(true);
      specifier.importKind = specifierTypeKind;

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        isBinding = true;
        specifier.local = specifier.imported.__clone();
      }
    } else {
      isBinding = true;
      specifier.imported = firstIdent;
      specifier.importKind = null;
      specifier.local = specifier.imported.__clone();
    }

    const nodeIsTypeImport = hasTypeImportKind(node);
    const specifierIsTypeImport = hasTypeImportKind(specifier);

    if (nodeIsTypeImport && specifierIsTypeImport) {
      this.raise(firstIdentLoc, "The `type` and `typeof` keywords on named imports can only be used on regular " + "`import` statements. It cannot be used with `import type` or `import typeof` statements");
    }

    if (nodeIsTypeImport || specifierIsTypeImport) {
      this.checkReservedType(specifier.local.name, specifier.local.start);
    }

    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
      this.checkReservedWord(specifier.local.name, specifier.start, true, true);
    }

    this.checkLVal(specifier.local, true, undefined, "import specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
  }

  parseFunctionParams(node) {
    const kind = node.kind;

    if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
      node.typeParameters = this.flowParseTypeParameterDeclaration(false);
    }

    super.parseFunctionParams(node);
  }

  parseVarId(decl, kind) {
    super.parseVarId(decl, kind);

    if (this.match(types.colon)) {
      decl.id.typeAnnotation = this.flowParseTypeAnnotation();
      this.finishNode(decl.id, decl.id.type);
    }
  }

  parseAsyncArrowFromCallExpression(node, call) {
    if (this.match(types.colon)) {
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = true;
      node.returnType = this.flowParseTypeAnnotation();
      this.state.noAnonFunctionType = oldNoAnonFunctionType;
    }

    return super.parseAsyncArrowFromCallExpression(node, call);
  }

  shouldParseAsyncArrow() {
    return this.match(types.colon) || super.shouldParseAsyncArrow();
  }

  parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
    let jsxError = null;

    if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
      const state = this.state.clone();

      try {
        return super.parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
      } catch (err) {
        if (err instanceof SyntaxError) {
          this.state = state;
          const cLength = this.state.context.length;

          if (this.state.context[cLength - 1] === types$1.j_oTag) {
            this.state.context.length -= 2;
          }

          jsxError = err;
        } else {
          throw err;
        }
      }
    }

    if (jsxError != null || this.isRelational("<")) {
      let arrowExpression;
      let typeParameters;

      try {
        typeParameters = this.flowParseTypeParameterDeclaration();
        arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => super.parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos));
        arrowExpression.typeParameters = typeParameters;
        this.resetStartLocationFromNode(arrowExpression, typeParameters);
      } catch (err) {
        throw jsxError || err;
      }

      if (arrowExpression.type === "ArrowFunctionExpression") {
        return arrowExpression;
      } else if (jsxError != null) {
        throw jsxError;
      } else {
        this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
      }
    }

    return super.parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);
  }

  parseArrow(node) {
    if (this.match(types.colon)) {
      const state = this.state.clone();

      try {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        if (this.canInsertSemicolon()) this.unexpected();
        if (!this.match(types.arrow)) this.unexpected();
        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      } catch (err) {
        if (err instanceof SyntaxError) {
          this.state = state;
        } else {
          throw err;
        }
      }
    }

    return super.parseArrow(node);
  }

  shouldParseArrow() {
    return this.match(types.colon) || super.shouldParseArrow();
  }

  setArrowFunctionParameters(node, params) {
    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      node.params = params;
    } else {
      super.setArrowFunctionParameters(node, params);
    }
  }

  checkFunctionNameAndParams(node, isArrowFunction) {
    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
      return;
    }

    return super.checkFunctionNameAndParams(node, isArrowFunction);
  }

  parseParenAndDistinguishExpression(canBeArrow) {
    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }

  parseSubscripts(base, startPos, startLoc, noCalls) {
    if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
      this.next();
      const node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
      const state = this.state.clone();
      let error;

      try {
        const node = this.parseAsyncArrowWithTypeParameters(startPos, startLoc);
        if (node) return node;
      } catch (e) {
        error = e;
      }

      this.state = state;

      try {
        return super.parseSubscripts(base, startPos, startLoc, noCalls);
      } catch (e) {
        throw error || e;
      }
    }

    return super.parseSubscripts(base, startPos, startLoc, noCalls);
  }

  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
    if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
      this.expectPlugin("optionalChaining");
      subscriptState.optionalChainMember = true;

      if (noCalls) {
        subscriptState.stop = true;
        return base;
      }

      this.next();
      const node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.typeArguments = this.flowParseTypeParameterInstantiation();
      this.expect(types.parenL);
      node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      node.optional = true;
      return this.finishNode(node, "OptionalCallExpression");
    } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
      const node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      const state = this.state.clone();

      try {
        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
        this.expect(types.parenL);
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);

        if (subscriptState.optionalChainMember) {
          node.optional = false;
          return this.finishNode(node, "OptionalCallExpression");
        }

        return this.finishNode(node, "CallExpression");
      } catch (e) {
        if (e instanceof SyntaxError) {
          this.state = state;
        } else {
          throw e;
        }
      }
    }

    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
  }

  parseNewArguments(node) {
    let targs = null;

    if (this.shouldParseTypes() && this.isRelational("<")) {
      const state = this.state.clone();

      try {
        targs = this.flowParseTypeParameterInstantiationCallOrNew();
      } catch (e) {
        if (e instanceof SyntaxError) {
          this.state = state;
        } else {
          throw e;
        }
      }
    }

    node.typeArguments = targs;
    super.parseNewArguments(node);
  }

  parseAsyncArrowWithTypeParameters(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);
    this.parseFunctionParams(node);
    if (!this.parseArrow(node)) return;
    return this.parseArrowExpression(node, undefined, true);
  }

  readToken_mult_modulo(code) {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (code === 42 && next === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = false;
      this.state.pos += 2;
      this.nextToken();
      return;
    }

    super.readToken_mult_modulo(code);
  }

  readToken_pipe_amp(code) {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (code === 124 && next === 125) {
      this.finishOp(types.braceBarR, 2);
      return;
    }

    super.readToken_pipe_amp(code);
  }

  parseTopLevel(file, program) {
    const fileNode = super.parseTopLevel(file, program);

    if (this.state.hasFlowComment) {
      this.unexpected(null, "Unterminated flow-comment");
    }

    return fileNode;
  }

  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment) {
        this.unexpected(null, "Cannot have a flow comment inside another flow comment");
      }

      this.hasFlowCommentCompletion();
      this.state.pos += this.skipFlowComment();
      this.state.hasFlowComment = true;
      return;
    }

    if (this.state.hasFlowComment) {
      const end = this.state.input.indexOf("*-/", this.state.pos += 2);
      if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");
      this.state.pos = end + 3;
      return;
    }

    super.skipBlockComment();
  }

  skipFlowComment() {
    const {
      pos
    } = this.state;
    let shiftToFirstNonWhiteSpace = 2;

    while ([32, 9].includes(this.state.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
      shiftToFirstNonWhiteSpace++;
    }

    const ch2 = this.state.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
    const ch3 = this.state.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

    if (ch2 === 58 && ch3 === 58) {
      return shiftToFirstNonWhiteSpace + 2;
    }

    if (this.state.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
      return shiftToFirstNonWhiteSpace + 12;
    }

    if (ch2 === 58 && ch3 !== 58) {
      return shiftToFirstNonWhiteSpace;
    }

    return false;
  }

  hasFlowCommentCompletion() {
    const end = this.state.input.indexOf("*/", this.state.pos);

    if (end === -1) {
      this.raise(this.state.pos, "Unterminated comment");
    }
  }

});

const entities = {
  quot: "\u0022",
  amp: "&",
  apos: "\u0027",
  lt: "<",
  gt: ">",
  nbsp: "\u00A0",
  iexcl: "\u00A1",
  cent: "\u00A2",
  pound: "\u00A3",
  curren: "\u00A4",
  yen: "\u00A5",
  brvbar: "\u00A6",
  sect: "\u00A7",
  uml: "\u00A8",
  copy: "\u00A9",
  ordf: "\u00AA",
  laquo: "\u00AB",
  not: "\u00AC",
  shy: "\u00AD",
  reg: "\u00AE",
  macr: "\u00AF",
  deg: "\u00B0",
  plusmn: "\u00B1",
  sup2: "\u00B2",
  sup3: "\u00B3",
  acute: "\u00B4",
  micro: "\u00B5",
  para: "\u00B6",
  middot: "\u00B7",
  cedil: "\u00B8",
  sup1: "\u00B9",
  ordm: "\u00BA",
  raquo: "\u00BB",
  frac14: "\u00BC",
  frac12: "\u00BD",
  frac34: "\u00BE",
  iquest: "\u00BF",
  Agrave: "\u00C0",
  Aacute: "\u00C1",
  Acirc: "\u00C2",
  Atilde: "\u00C3",
  Auml: "\u00C4",
  Aring: "\u00C5",
  AElig: "\u00C6",
  Ccedil: "\u00C7",
  Egrave: "\u00C8",
  Eacute: "\u00C9",
  Ecirc: "\u00CA",
  Euml: "\u00CB",
  Igrave: "\u00CC",
  Iacute: "\u00CD",
  Icirc: "\u00CE",
  Iuml: "\u00CF",
  ETH: "\u00D0",
  Ntilde: "\u00D1",
  Ograve: "\u00D2",
  Oacute: "\u00D3",
  Ocirc: "\u00D4",
  Otilde: "\u00D5",
  Ouml: "\u00D6",
  times: "\u00D7",
  Oslash: "\u00D8",
  Ugrave: "\u00D9",
  Uacute: "\u00DA",
  Ucirc: "\u00DB",
  Uuml: "\u00DC",
  Yacute: "\u00DD",
  THORN: "\u00DE",
  szlig: "\u00DF",
  agrave: "\u00E0",
  aacute: "\u00E1",
  acirc: "\u00E2",
  atilde: "\u00E3",
  auml: "\u00E4",
  aring: "\u00E5",
  aelig: "\u00E6",
  ccedil: "\u00E7",
  egrave: "\u00E8",
  eacute: "\u00E9",
  ecirc: "\u00EA",
  euml: "\u00EB",
  igrave: "\u00EC",
  iacute: "\u00ED",
  icirc: "\u00EE",
  iuml: "\u00EF",
  eth: "\u00F0",
  ntilde: "\u00F1",
  ograve: "\u00F2",
  oacute: "\u00F3",
  ocirc: "\u00F4",
  otilde: "\u00F5",
  ouml: "\u00F6",
  divide: "\u00F7",
  oslash: "\u00F8",
  ugrave: "\u00F9",
  uacute: "\u00FA",
  ucirc: "\u00FB",
  uuml: "\u00FC",
  yacute: "\u00FD",
  thorn: "\u00FE",
  yuml: "\u00FF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};

const HEX_NUMBER = /^[\da-fA-F]+$/;
const DECIMAL_NUMBER = /^\d+$/;
types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", {
  beforeExpr: true
});
types.jsxTagStart = new TokenType("jsxTagStart", {
  startsExpr: true
});
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr);
  this.state.context.push(types$1.j_oTag);
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  const out = this.state.context.pop();

  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

function isFragment(object) {
  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
}

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }

  throw new Error("Node had unexpected type: " + object.type);
}

var jsx = (superClass => class extends superClass {
  jsxReadToken() {
    let out = "";
    let chunkStart = this.state.pos;

    for (;;) {
      if (this.state.pos >= this.state.length) {
        this.raise(this.state.start, "Unterminated JSX contents");
      }

      const ch = this.state.input.charCodeAt(this.state.pos);

      switch (ch) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            if (ch === 60 && this.state.exprAllowed) {
              ++this.state.pos;
              return this.finishToken(types.jsxTagStart);
            }

            return super.getTokenFromCode(ch);
          }

          out += this.state.input.slice(chunkStart, this.state.pos);
          return this.finishToken(types.jsxText, out);

        case 38:
          out += this.state.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
          break;

        default:
          if (isNewLine(ch)) {
            out += this.state.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(true);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }

      }
    }
  }

  jsxReadNewLine(normalizeCRLF) {
    const ch = this.state.input.charCodeAt(this.state.pos);
    let out;
    ++this.state.pos;

    if (ch === 13 && this.state.input.charCodeAt(this.state.pos) === 10) {
      ++this.state.pos;
      out = normalizeCRLF ? "\n" : "\r\n";
    } else {
      out = String.fromCharCode(ch);
    }

    ++this.state.curLine;
    this.state.lineStart = this.state.pos;
    return out;
  }

  jsxReadString(quote) {
    let out = "";
    let chunkStart = ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.state.length) {
        this.raise(this.state.start, "Unterminated string constant");
      }

      const ch = this.state.input.charCodeAt(this.state.pos);
      if (ch === quote) break;

      if (ch === 38) {
        out += this.state.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.state.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadNewLine(false);
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }

    out += this.state.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(types.string, out);
  }

  jsxReadEntity() {
    let str = "";
    let count = 0;
    let entity;
    let ch = this.state.input[this.state.pos];
    const startPos = ++this.state.pos;

    while (this.state.pos < this.state.length && count++ < 10) {
      ch = this.state.input[this.state.pos++];

      if (ch === ";") {
        if (str[0] === "#") {
          if (str[1] === "x") {
            str = str.substr(2);

            if (HEX_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 16));
            }
          } else {
            str = str.substr(1);

            if (DECIMAL_NUMBER.test(str)) {
              entity = String.fromCodePoint(parseInt(str, 10));
            }
          }
        } else {
          entity = entities[str];
        }

        break;
      }

      str += ch;
    }

    if (!entity) {
      this.state.pos = startPos;
      return "&";
    }

    return entity;
  }

  jsxReadWord() {
    let ch;
    const start = this.state.pos;

    do {
      ch = this.state.input.charCodeAt(++this.state.pos);
    } while (isIdentifierChar(ch) || ch === 45);

    return this.finishToken(types.jsxName, this.state.input.slice(start, this.state.pos));
  }

  jsxParseIdentifier() {
    const node = this.startNode();

    if (this.match(types.jsxName)) {
      node.name = this.state.value;
    } else if (this.state.type.keyword) {
      node.name = this.state.type.keyword;
    } else {
      this.unexpected();
    }

    this.next();
    return this.finishNode(node, "JSXIdentifier");
  }

  jsxParseNamespacedName() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const name = this.jsxParseIdentifier();
    if (!this.eat(types.colon)) return name;
    const node = this.startNodeAt(startPos, startLoc);
    node.namespace = name;
    node.name = this.jsxParseIdentifier();
    return this.finishNode(node, "JSXNamespacedName");
  }

  jsxParseElementName() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let node = this.jsxParseNamespacedName();

    while (this.eat(types.dot)) {
      const newNode = this.startNodeAt(startPos, startLoc);
      newNode.object = node;
      newNode.property = this.jsxParseIdentifier();
      node = this.finishNode(newNode, "JSXMemberExpression");
    }

    return node;
  }

  jsxParseAttributeValue() {
    let node;

    switch (this.state.type) {
      case types.braceL:
        node = this.jsxParseExpressionContainer();

        if (node.expression.type === "JSXEmptyExpression") {
          throw this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
        } else {
          return node;
        }

      case types.jsxTagStart:
      case types.string:
        return this.parseExprAtom();

      default:
        throw this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
    }
  }

  jsxParseEmptyExpression() {
    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
    return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
  }

  jsxParseSpreadChild() {
    const node = this.startNode();
    this.expect(types.braceL);
    this.expect(types.ellipsis);
    node.expression = this.parseExpression();
    this.expect(types.braceR);
    return this.finishNode(node, "JSXSpreadChild");
  }

  jsxParseExpressionContainer() {
    const node = this.startNode();
    this.next();

    if (this.match(types.braceR)) {
      node.expression = this.jsxParseEmptyExpression();
    } else {
      node.expression = this.parseExpression();
    }

    this.expect(types.braceR);
    return this.finishNode(node, "JSXExpressionContainer");
  }

  jsxParseAttribute() {
    const node = this.startNode();

    if (this.eat(types.braceL)) {
      this.expect(types.ellipsis);
      node.argument = this.parseMaybeAssign();
      this.expect(types.braceR);
      return this.finishNode(node, "JSXSpreadAttribute");
    }

    node.name = this.jsxParseNamespacedName();
    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
    return this.finishNode(node, "JSXAttribute");
  }

  jsxParseOpeningElementAt(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);

    if (this.match(types.jsxTagEnd)) {
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXOpeningFragment");
    }

    node.name = this.jsxParseElementName();
    return this.jsxParseOpeningElementAfterName(node);
  }

  jsxParseOpeningElementAfterName(node) {
    const attributes = [];

    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
      attributes.push(this.jsxParseAttribute());
    }

    node.attributes = attributes;
    node.selfClosing = this.eat(types.slash);
    this.expect(types.jsxTagEnd);
    return this.finishNode(node, "JSXOpeningElement");
  }

  jsxParseClosingElementAt(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);

    if (this.match(types.jsxTagEnd)) {
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXClosingFragment");
    }

    node.name = this.jsxParseElementName();
    this.expect(types.jsxTagEnd);
    return this.finishNode(node, "JSXClosingElement");
  }

  jsxParseElementAt(startPos, startLoc) {
    const node = this.startNodeAt(startPos, startLoc);
    const children = [];
    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
    let closingElement = null;

    if (!openingElement.selfClosing) {
      contents: for (;;) {
        switch (this.state.type) {
          case types.jsxTagStart:
            startPos = this.state.start;
            startLoc = this.state.startLoc;
            this.next();

            if (this.eat(types.slash)) {
              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
              break contents;
            }

            children.push(this.jsxParseElementAt(startPos, startLoc));
            break;

          case types.jsxText:
            children.push(this.parseExprAtom());
            break;

          case types.braceL:
            if (this.lookahead().type === types.ellipsis) {
              children.push(this.jsxParseSpreadChild());
            } else {
              children.push(this.jsxParseExpressionContainer());
            }

            break;

          default:
            throw this.unexpected();
        }
      }

      if (isFragment(openingElement) && !isFragment(closingElement)) {
        this.raise(closingElement.start, "Expected corresponding JSX closing tag for <>");
      } else if (!isFragment(openingElement) && isFragment(closingElement)) {
        this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
        }
      }
    }

    if (isFragment(openingElement)) {
      node.openingFragment = openingElement;
      node.closingFragment = closingElement;
    } else {
      node.openingElement = openingElement;
      node.closingElement = closingElement;
    }

    node.children = children;

    if (this.match(types.relational) && this.state.value === "<") {
      this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag. " + "Did you want a JSX fragment <>...</>?");
    }

    return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
  }

  jsxParseElement() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    this.next();
    return this.jsxParseElementAt(startPos, startLoc);
  }

  parseExprAtom(refShortHandDefaultPos) {
    if (this.match(types.jsxText)) {
      return this.parseLiteral(this.state.value, "JSXText");
    } else if (this.match(types.jsxTagStart)) {
      return this.jsxParseElement();
    } else if (this.isRelational("<") && this.state.input.charCodeAt(this.state.pos) !== 33) {
      this.finishToken(types.jsxTagStart);
      return this.jsxParseElement();
    } else {
      return super.parseExprAtom(refShortHandDefaultPos);
    }
  }

  getTokenFromCode(code) {
    if (this.state.inPropertyName) return super.getTokenFromCode(code);
    const context = this.curContext();

    if (context === types$1.j_expr) {
      return this.jsxReadToken();
    }

    if (context === types$1.j_oTag || context === types$1.j_cTag) {
      if (isIdentifierStart(code)) {
        return this.jsxReadWord();
      }

      if (code === 62) {
        ++this.state.pos;
        return this.finishToken(types.jsxTagEnd);
      }

      if ((code === 34 || code === 39) && context === types$1.j_oTag) {
        return this.jsxReadString(code);
      }
    }

    if (code === 60 && this.state.exprAllowed && this.state.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos;
      return this.finishToken(types.jsxTagStart);
    }

    return super.getTokenFromCode(code);
  }

  updateContext(prevType) {
    if (this.match(types.braceL)) {
      const curContext = this.curContext();

      if (curContext === types$1.j_oTag) {
        this.state.context.push(types$1.braceExpression);
      } else if (curContext === types$1.j_expr) {
        this.state.context.push(types$1.templateQuasi);
      } else {
        super.updateContext(prevType);
      }

      this.state.exprAllowed = true;
    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
      this.state.context.length -= 2;
      this.state.context.push(types$1.j_cTag);
      this.state.exprAllowed = false;
    } else {
      return super.updateContext(prevType);
    }
  }

});

const defaultOptions = {
  sourceType: "script",
  sourceFilename: undefined,
  startLine: 1,
  allowAwaitOutsideFunction: false,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowSuperOutsideMethod: false,
  plugins: [],
  strictMode: null,
  ranges: false,
  tokens: false
};
function getOptions(opts) {
  const options = {};

  for (const key in defaultOptions) {
    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
  }

  return options;
}

class Position {
  constructor(line, col) {
    this.line = line;
    this.column = col;
  }

}
class SourceLocation {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }

}
function getLineInfo(input, offset) {
  let line = 1;
  let lineStart = 0;
  let match;
  lineBreakG.lastIndex = 0;

  while ((match = lineBreakG.exec(input)) && match.index < offset) {
    line++;
    lineStart = lineBreakG.lastIndex;
  }

  return new Position(line, offset - lineStart);
}

class BaseParser {
  constructor() {
    this.sawUnambiguousESM = false;
  }

  hasPlugin(name) {
    return this.plugins.has(name);
  }

  getPluginOption(plugin, name) {
    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
  }

}

function last(stack) {
  return stack[stack.length - 1];
}

class CommentsParser extends BaseParser {
  addComment(comment) {
    if (this.filename) comment.loc.filename = this.filename;
    this.state.trailingComments.push(comment);
    this.state.leadingComments.push(comment);
  }

  processComment(node) {
    if (node.type === "Program" && node.body.length > 0) return;
    const stack = this.state.commentStack;
    let firstChild, lastChild, trailingComments, i, j;

    if (this.state.trailingComments.length > 0) {
      if (this.state.trailingComments[0].start >= node.end) {
        trailingComments = this.state.trailingComments;
        this.state.trailingComments = [];
      } else {
        this.state.trailingComments.length = 0;
      }
    } else if (stack.length > 0) {
      const lastInStack = last(stack);

      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
        trailingComments = lastInStack.trailingComments;
        delete lastInStack.trailingComments;
      }
    }

    if (stack.length > 0 && last(stack).start >= node.start) {
      firstChild = stack.pop();
    }

    while (stack.length > 0 && last(stack).start >= node.start) {
      lastChild = stack.pop();
    }

    if (!lastChild && firstChild) lastChild = firstChild;

    if (firstChild && this.state.leadingComments.length > 0) {
      const lastComment = last(this.state.leadingComments);

      if (firstChild.type === "ObjectProperty") {
        if (lastComment.start >= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }

            if (this.state.leadingComments.length > 0) {
              firstChild.trailingComments = this.state.leadingComments;
              this.state.leadingComments = [];
            }
          }
        }
      } else if (node.type === "CallExpression" && node.arguments && node.arguments.length) {
        const lastArg = last(node.arguments);

        if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }

            if (this.state.leadingComments.length > 0) {
              lastArg.trailingComments = this.state.leadingComments;
              this.state.leadingComments = [];
            }
          }
        }
      }
    }

    if (lastChild) {
      if (lastChild.leadingComments) {
        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
          node.leadingComments = lastChild.leadingComments;
          delete lastChild.leadingComments;
        } else {
          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
            if (lastChild.leadingComments[i].end <= node.start) {
              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
              break;
            }
          }
        }
      }
    } else if (this.state.leadingComments.length > 0) {
      if (last(this.state.leadingComments).end <= node.start) {
        if (this.state.commentPreviousNode) {
          for (j = 0; j < this.state.leadingComments.length; j++) {
            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
              this.state.leadingComments.splice(j, 1);
              j--;
            }
          }
        }

        if (this.state.leadingComments.length > 0) {
          node.leadingComments = this.state.leadingComments;
          this.state.leadingComments = [];
        }
      } else {
        for (i = 0; i < this.state.leadingComments.length; i++) {
          if (this.state.leadingComments[i].end > node.start) {
            break;
          }
        }

        const leadingComments = this.state.leadingComments.slice(0, i);

        if (leadingComments.length) {
          node.leadingComments = leadingComments;
        }

        trailingComments = this.state.leadingComments.slice(i);

        if (trailingComments.length === 0) {
          trailingComments = null;
        }
      }
    }

    this.state.commentPreviousNode = node;

    if (trailingComments) {
      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
        node.innerComments = trailingComments;
      } else {
        node.trailingComments = trailingComments;
      }
    }

    stack.push(node);
  }

}

class LocationParser extends CommentsParser {
  raise(pos, message, {
    missingPluginNames,
    code
  } = {}) {
    const loc = getLineInfo(this.state.input, pos);
    message += ` (${loc.line}:${loc.column})`;
    const err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;

    if (missingPluginNames) {
      err.missingPlugin = missingPluginNames;
    }

    if (code !== undefined) {
      err.code = code;
    }

    throw err;
  }

}

class State {
  constructor() {
    this.potentialArrowAt = -1;
    this.noArrowAt = [];
    this.noArrowParamsConversionAt = [];
    this.commaAfterSpreadAt = -1;
    this.inFunction = false;
    this.inParameters = false;
    this.maybeInArrowParameters = false;
    this.inGenerator = false;
    this.inMethod = false;
    this.inAsync = false;
    this.inPipeline = false;
    this.inType = false;
    this.noAnonFunctionType = false;
    this.inPropertyName = false;
    this.inClassProperty = false;
    this.hasFlowComment = false;
    this.isIterator = false;
    this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };
    this.classLevel = 0;
    this.labels = [];
    this.decoratorStack = [[]];
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.tokens = [];
    this.comments = [];
    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];
    this.commentPreviousNode = null;
    this.pos = 0;
    this.lineStart = 0;
    this.type = types.eof;
    this.value = null;
    this.start = 0;
    this.end = 0;
    this.lastTokEndLoc = null;
    this.lastTokStartLoc = null;
    this.lastTokStart = 0;
    this.lastTokEnd = 0;
    this.context = [types$1.braceStatement];
    this.exprAllowed = true;
    this.containsEsc = false;
    this.containsOctal = false;
    this.octalPosition = null;
    this.exportedIdentifiers = [];
    this.invalidTemplateEscapePosition = null;
  }

  init(options, input) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";
    this.input = input;
    this.length = input.length;
    this.curLine = options.startLine;
    this.startLoc = this.endLoc = this.curPosition();
  }

  curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart);
  }

  clone(skipArrays) {
    const state = new State();
    const keys = Object.keys(this);

    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i];
      let val = this[key];

      if ((!skipArrays || key === "context") && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }

    return state;
  }

}

var _isDigit = function isDigit(code) {
  return code >= 48 && code <= 57;
};

const VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
const forbiddenNumericSeparatorSiblings = {
  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
  hex: [46, 88, 95, 120]
};
const allowedNumericSeparatorSiblings = {};
allowedNumericSeparatorSiblings.bin = [48, 49];
allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
class Token {
  constructor(state) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  }

}
class Tokenizer extends LocationParser {
  constructor(options, input) {
    super();
    this.state = new State();
    this.state.init(options, input);
    this.isLookahead = false;
  }

  next() {
    if (this.options.tokens && !this.isLookahead) {
      this.state.tokens.push(new Token(this.state));
    }

    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  }

  eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  }

  match(type) {
    return this.state.type === type;
  }

  lookahead() {
    const old = this.state;
    this.state = old.clone(true);
    this.isLookahead = true;
    this.next();
    this.isLookahead = false;
    const curr = this.state;
    this.state = old;
    return curr;
  }

  setStrict(strict) {
    this.state.strict = strict;
    if (!this.match(types.num) && !this.match(types.string)) return;
    this.state.pos = this.state.start;

    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart = this.state.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }

    this.nextToken();
  }

  curContext() {
    return this.state.context[this.state.context.length - 1];
  }

  nextToken() {
    const curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();
    this.state.containsOctal = false;
    this.state.octalPosition = null;
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();

    if (this.state.pos >= this.state.length) {
      this.finishToken(types.eof);
      return;
    }

    if (curContext.override) {
      curContext.override(this);
    } else {
      this.getTokenFromCode(this.state.input.codePointAt(this.state.pos));
    }
  }

  pushComment(block, text, start, end, startLoc, endLoc) {
    const comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new SourceLocation(startLoc, endLoc)
    };

    if (!this.isLookahead) {
      if (this.options.tokens) this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  }

  skipBlockComment() {
    const startLoc = this.state.curPosition();
    const start = this.state.pos;
    const end = this.state.input.indexOf("*/", this.state.pos += 2);
    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");
    this.state.pos = end + 2;
    lineBreakG.lastIndex = start;
    let match;

    while ((match = lineBreakG.exec(this.state.input)) && match.index < this.state.pos) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }

    this.pushComment(true, this.state.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
  }

  skipLineComment(startSkip) {
    const start = this.state.pos;
    const startLoc = this.state.curPosition();
    let ch = this.state.input.charCodeAt(this.state.pos += startSkip);

    if (this.state.pos < this.state.length) {
      while (ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233 && ++this.state.pos < this.state.length) {
        ch = this.state.input.charCodeAt(this.state.pos);
      }
    }

    this.pushComment(false, this.state.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
  }

  skipSpace() {
    loop: while (this.state.pos < this.state.length) {
      const ch = this.state.input.charCodeAt(this.state.pos);

      switch (ch) {
        case 32:
        case 160:
        case 9:
          ++this.state.pos;
          break;

        case 13:
          if (this.state.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos;
          }

        case 10:
        case 8232:
        case 8233:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;

        case 47:
          switch (this.state.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;

            case 47:
              this.skipLineComment(2);
              break;

            default:
              break loop;
          }

          break;

        default:
          if (isWhitespace(ch)) {
            ++this.state.pos;
          } else {
            break loop;
          }

      }
    }
  }

  finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    const prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;
    this.updateContext(prevType);
  }

  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter()) {
      return;
    }

    const nextPos = this.state.pos + 1;
    const next = this.state.input.charCodeAt(nextPos);

    if (next >= 48 && next <= 57) {
      this.raise(this.state.pos, "Unexpected digit after hash token");
    }

    if ((this.hasPlugin("classPrivateProperties") || this.hasPlugin("classPrivateMethods")) && this.state.classLevel > 0) {
      ++this.state.pos;
      this.finishToken(types.hash);
      return;
    } else if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
      this.finishOp(types.hash, 1);
    } else {
      this.raise(this.state.pos, "Unexpected character '#'");
    }
  }

  readToken_dot() {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (next >= 48 && next <= 57) {
      this.readNumber(true);
      return;
    }

    const next2 = this.state.input.charCodeAt(this.state.pos + 2);

    if (next === 46 && next2 === 46) {
      this.state.pos += 3;
      this.finishToken(types.ellipsis);
    } else {
      ++this.state.pos;
      this.finishToken(types.dot);
    }
  }

  readToken_slash() {
    if (this.state.exprAllowed && !this.state.inType) {
      ++this.state.pos;
      this.readRegexp();
      return;
    }

    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (next === 61) {
      this.finishOp(types.assign, 2);
    } else {
      this.finishOp(types.slash, 1);
    }
  }

  readToken_interpreter() {
    if (this.state.pos !== 0 || this.state.length < 2) return false;
    const start = this.state.pos;
    this.state.pos += 1;
    let ch = this.state.input.charCodeAt(this.state.pos);
    if (ch !== 33) return false;

    while (ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233 && ++this.state.pos < this.state.length) {
      ch = this.state.input.charCodeAt(this.state.pos);
    }

    const value = this.state.input.slice(start + 2, this.state.pos);
    this.finishToken(types.interpreterDirective, value);
    return true;
  }

  readToken_mult_modulo(code) {
    let type = code === 42 ? types.star : types.modulo;
    let width = 1;
    let next = this.state.input.charCodeAt(this.state.pos + 1);
    const exprAllowed = this.state.exprAllowed;

    if (code === 42 && next === 42) {
      width++;
      next = this.state.input.charCodeAt(this.state.pos + 2);
      type = types.exponent;
    }

    if (next === 61 && !exprAllowed) {
      width++;
      type = types.assign;
    }

    this.finishOp(type, width);
  }

  readToken_pipe_amp(code) {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (this.state.input.charCodeAt(this.state.pos + 2) === 61) {
        this.finishOp(types.assign, 3);
      } else {
        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
      }

      return;
    }

    if (code === 124) {
      if (next === 62) {
        this.finishOp(types.pipeline, 2);
        return;
      }
    }

    if (next === 61) {
      this.finishOp(types.assign, 2);
      return;
    }

    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
  }

  readToken_caret() {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (next === 61) {
      this.finishOp(types.assign, 2);
    } else {
      this.finishOp(types.bitwiseXOR, 1);
    }
  }

  readToken_plus_min(code) {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (next === 45 && !this.inModule && this.state.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.state.input.slice(this.state.lastTokEnd, this.state.pos))) {
        this.skipLineComment(3);
        this.skipSpace();
        this.nextToken();
        return;
      }

      this.finishOp(types.incDec, 2);
      return;
    }

    if (next === 61) {
      this.finishOp(types.assign, 2);
    } else {
      this.finishOp(types.plusMin, 1);
    }
  }

  readToken_lt_gt(code) {
    const next = this.state.input.charCodeAt(this.state.pos + 1);
    let size = 1;

    if (next === code) {
      size = code === 62 && this.state.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

      if (this.state.input.charCodeAt(this.state.pos + size) === 61) {
        this.finishOp(types.assign, size + 1);
        return;
      }

      this.finishOp(types.bitShift, size);
      return;
    }

    if (next === 33 && code === 60 && !this.inModule && this.state.input.charCodeAt(this.state.pos + 2) === 45 && this.state.input.charCodeAt(this.state.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      this.nextToken();
      return;
    }

    if (next === 61) {
      size = 2;
    }

    this.finishOp(types.relational, size);
  }

  readToken_eq_excl(code) {
    const next = this.state.input.charCodeAt(this.state.pos + 1);

    if (next === 61) {
      this.finishOp(types.equality, this.state.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }

    if (code === 61 && next === 62) {
      this.state.pos += 2;
      this.finishToken(types.arrow);
      return;
    }

    this.finishOp(code === 61 ? types.eq : types.bang, 1);
  }

  readToken_question() {
    const next = this.state.input.charCodeAt(this.state.pos + 1);
    const next2 = this.state.input.charCodeAt(this.state.pos + 2);

    if (next === 63 && !this.state.inType) {
      if (next2 === 61) {
        this.finishOp(types.assign, 3);
      } else {
        this.finishOp(types.nullishCoalescing, 2);
      }
    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
      this.state.pos += 2;
      this.finishToken(types.questionDot);
    } else {
      ++this.state.pos;
      this.finishToken(types.question);
    }
  }

  getTokenFromCode(code) {
    switch (code) {
      case 46:
        this.readToken_dot();
        return;

      case 40:
        ++this.state.pos;
        this.finishToken(types.parenL);
        return;

      case 41:
        ++this.state.pos;
        this.finishToken(types.parenR);
        return;

      case 59:
        ++this.state.pos;
        this.finishToken(types.semi);
        return;

      case 44:
        ++this.state.pos;
        this.finishToken(types.comma);
        return;

      case 91:
        ++this.state.pos;
        this.finishToken(types.bracketL);
        return;

      case 93:
        ++this.state.pos;
        this.finishToken(types.bracketR);
        return;

      case 123:
        ++this.state.pos;
        this.finishToken(types.braceL);
        return;

      case 125:
        ++this.state.pos;
        this.finishToken(types.braceR);
        return;

      case 58:
        if (this.hasPlugin("functionBind") && this.state.input.charCodeAt(this.state.pos + 1) === 58) {
          this.finishOp(types.doubleColon, 2);
        } else {
          ++this.state.pos;
          this.finishToken(types.colon);
        }

        return;

      case 63:
        this.readToken_question();
        return;

      case 96:
        ++this.state.pos;
        this.finishToken(types.backQuote);
        return;

      case 48:
        {
          const next = this.state.input.charCodeAt(this.state.pos + 1);

          if (next === 120 || next === 88) {
            this.readRadixNumber(16);
            return;
          }

          if (next === 111 || next === 79) {
            this.readRadixNumber(8);
            return;
          }

          if (next === 98 || next === 66) {
            this.readRadixNumber(2);
            return;
          }
        }

      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(false);
        return;

      case 34:
      case 39:
        this.readString(code);
        return;

      case 47:
        this.readToken_slash();
        return;

      case 37:
      case 42:
        this.readToken_mult_modulo(code);
        return;

      case 124:
      case 38:
        this.readToken_pipe_amp(code);
        return;

      case 94:
        this.readToken_caret();
        return;

      case 43:
      case 45:
        this.readToken_plus_min(code);
        return;

      case 60:
      case 62:
        this.readToken_lt_gt(code);
        return;

      case 61:
      case 33:
        this.readToken_eq_excl(code);
        return;

      case 126:
        this.finishOp(types.tilde, 1);
        return;

      case 64:
        ++this.state.pos;
        this.finishToken(types.at);
        return;

      case 35:
        this.readToken_numberSign();
        return;

      case 92:
        this.readWord();
        return;

      default:
        if (isIdentifierStart(code)) {
          this.readWord();
          return;
        }

    }

    this.raise(this.state.pos, `Unexpected character '${String.fromCodePoint(code)}'`);
  }

  finishOp(type, size) {
    const str = this.state.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    this.finishToken(type, str);
  }

  readRegexp() {
    const start = this.state.pos;
    let escaped, inClass;

    for (;;) {
      if (this.state.pos >= this.state.length) {
        this.raise(start, "Unterminated regular expression");
      }

      const ch = this.state.input.charAt(this.state.pos);

      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }

      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }

        escaped = ch === "\\";
      }

      ++this.state.pos;
    }

    const content = this.state.input.slice(start, this.state.pos);
    ++this.state.pos;
    let mods = "";

    while (this.state.pos < this.state.length) {
      const char = this.state.input[this.state.pos];
      const charCode = this.state.input.codePointAt(this.state.pos);

      if (VALID_REGEX_FLAGS.has(char)) {
        if (mods.indexOf(char) > -1) {
          this.raise(this.state.pos + 1, "Duplicate regular expression flag");
        }

        ++this.state.pos;
        mods += char;
      } else if (isIdentifierChar(charCode) || charCode === 92) {
        this.raise(this.state.pos + 1, "Invalid regular expression flag");
      } else {
        break;
      }
    }

    this.finishToken(types.regexp, {
      pattern: content,
      flags: mods
    });
  }

  readInt(radix, len) {
    const start = this.state.pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
    let total = 0;

    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      const code = this.state.input.charCodeAt(this.state.pos);
      let val;

      if (this.hasPlugin("numericSeparator")) {
        const prev = this.state.input.charCodeAt(this.state.pos - 1);
        const next = this.state.input.charCodeAt(this.state.pos + 1);

        if (code === 95) {
          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, "Invalid or unexpected token");
          }

          if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, "Invalid or unexpected token");
          }

          ++this.state.pos;
          continue;
        }
      }

      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }

      if (val >= radix) break;
      ++this.state.pos;
      total = total * radix + val;
    }

    if (this.state.pos === start || len != null && this.state.pos - start !== len) {
      return null;
    }

    return total;
  }

  readRadixNumber(radix) {
    const start = this.state.pos;
    let isBigInt = false;
    this.state.pos += 2;
    const val = this.readInt(radix);

    if (val == null) {
      this.raise(this.state.start + 2, "Expected number in radix " + radix);
    }

    if (this.hasPlugin("bigInt")) {
      if (this.state.input.charCodeAt(this.state.pos) === 110) {
        ++this.state.pos;
        isBigInt = true;
      }
    }

    if (isIdentifierStart(this.state.input.codePointAt(this.state.pos))) {
      this.raise(this.state.pos, "Identifier directly after number");
    }

    if (isBigInt) {
      const str = this.state.input.slice(start, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(types.bigint, str);
      return;
    }

    this.finishToken(types.num, val);
  }

  readNumber(startsWithDot) {
    const start = this.state.pos;
    let isFloat = false;
    let isBigInt = false;

    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }

    let octal = this.state.pos - start >= 2 && this.state.input.charCodeAt(start) === 48;

    if (octal) {
      if (this.state.strict) {
        this.raise(start, "Legacy octal literals are not allowed in strict mode");
      }

      if (/[89]/.test(this.state.input.slice(start, this.state.pos))) {
        octal = false;
      }
    }

    let next = this.state.input.charCodeAt(this.state.pos);

    if (next === 46 && !octal) {
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.state.input.charCodeAt(this.state.pos);
    }

    if ((next === 69 || next === 101) && !octal) {
      next = this.state.input.charCodeAt(++this.state.pos);

      if (next === 43 || next === 45) {
        ++this.state.pos;
      }

      if (this.readInt(10) === null) this.raise(start, "Invalid number");
      isFloat = true;
      next = this.state.input.charCodeAt(this.state.pos);
    }

    if (this.hasPlugin("bigInt")) {
      if (next === 110) {
        if (isFloat || octal) this.raise(start, "Invalid BigIntLiteral");
        ++this.state.pos;
        isBigInt = true;
      }
    }

    if (isIdentifierStart(this.state.input.codePointAt(this.state.pos))) {
      this.raise(this.state.pos, "Identifier directly after number");
    }

    const str = this.state.input.slice(start, this.state.pos).replace(/[_n]/g, "");

    if (isBigInt) {
      this.finishToken(types.bigint, str);
      return;
    }

    const val = octal ? parseInt(str, 8) : parseFloat(str);
    this.finishToken(types.num, val);
  }

  readCodePoint(throwOnInvalid) {
    const ch = this.state.input.charCodeAt(this.state.pos);
    let code;

    if (ch === 123) {
      const codePos = ++this.state.pos;
      code = this.readHexChar(this.state.input.indexOf("}", this.state.pos) - this.state.pos, throwOnInvalid);
      ++this.state.pos;

      if (code === null) {
        --this.state.invalidTemplateEscapePosition;
      } else if (code > 0x10ffff) {
        if (throwOnInvalid) {
          this.raise(codePos, "Code point out of bounds");
        } else {
          this.state.invalidTemplateEscapePosition = codePos - 2;
          return null;
        }
      }
    } else {
      code = this.readHexChar(4, throwOnInvalid);
    }

    return code;
  }

  readString(quote) {
    let out = "",
        chunkStart = ++this.state.pos;

    for (;;) {
      if (this.state.pos >= this.state.length) {
        this.raise(this.state.start, "Unterminated string constant");
      }

      const ch = this.state.input.charCodeAt(this.state.pos);
      if (ch === quote) break;

      if (ch === 92) {
        out += this.state.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else if (ch === 8232 || ch === 8233) {
        ++this.state.pos;
        ++this.state.curLine;
      } else if (isNewLine(ch)) {
        this.raise(this.state.start, "Unterminated string constant");
      } else {
        ++this.state.pos;
      }
    }

    out += this.state.input.slice(chunkStart, this.state.pos++);
    this.finishToken(types.string, out);
  }

  readTmplToken() {
    let out = "",
        chunkStart = this.state.pos,
        containsInvalid = false;

    for (;;) {
      if (this.state.pos >= this.state.length) {
        this.raise(this.state.start, "Unterminated template");
      }

      const ch = this.state.input.charCodeAt(this.state.pos);

      if (ch === 96 || ch === 36 && this.state.input.charCodeAt(this.state.pos + 1) === 123) {
        if (this.state.pos === this.state.start && this.match(types.template)) {
          if (ch === 36) {
            this.state.pos += 2;
            this.finishToken(types.dollarBraceL);
            return;
          } else {
            ++this.state.pos;
            this.finishToken(types.backQuote);
            return;
          }
        }

        out += this.state.input.slice(chunkStart, this.state.pos);
        this.finishToken(types.template, containsInvalid ? null : out);
        return;
      }

      if (ch === 92) {
        out += this.state.input.slice(chunkStart, this.state.pos);
        const escaped = this.readEscapedChar(true);

        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }

        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.state.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;

        switch (ch) {
          case 13:
            if (this.state.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
            }

          case 10:
            out += "\n";
            break;

          default:
            out += String.fromCharCode(ch);
            break;
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  }

  readEscapedChar(inTemplate) {
    const throwOnInvalid = !inTemplate;
    const ch = this.state.input.charCodeAt(++this.state.pos);
    ++this.state.pos;

    switch (ch) {
      case 110:
        return "\n";

      case 114:
        return "\r";

      case 120:
        {
          const code = this.readHexChar(2, throwOnInvalid);
          return code === null ? null : String.fromCharCode(code);
        }

      case 117:
        {
          const code = this.readCodePoint(throwOnInvalid);
          return code === null ? null : String.fromCodePoint(code);
        }

      case 116:
        return "\t";

      case 98:
        return "\b";

      case 118:
        return "\u000b";

      case 102:
        return "\f";

      case 13:
        if (this.state.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
        }

      case 10:
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;

      case 8232:
      case 8233:
        return "";

      default:
        if (ch >= 48 && ch <= 55) {
          const codePos = this.state.pos - 1;
          let octalStr = this.state.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
          let octal = parseInt(octalStr, 8);

          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }

          if (octal > 0) {
            if (inTemplate) {
              this.state.invalidTemplateEscapePosition = codePos;
              return null;
            } else if (this.state.strict) {
              this.raise(codePos, "Octal literal in strict mode");
            } else if (!this.state.containsOctal) {
              this.state.containsOctal = true;
              this.state.octalPosition = codePos;
            }
          }

          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }

        return String.fromCharCode(ch);
    }
  }

  readHexChar(len, throwOnInvalid) {
    const codePos = this.state.pos;
    const n = this.readInt(16, len);

    if (n === null) {
      if (throwOnInvalid) {
        this.raise(codePos, "Bad character escape sequence");
      } else {
        this.state.pos = codePos - 1;
        this.state.invalidTemplateEscapePosition = codePos - 1;
      }
    }

    return n;
  }

  readWord1() {
    let word = "";
    this.state.containsEsc = false;
    const start = this.state.pos;
    let chunkStart = this.state.pos;

    while (this.state.pos < this.state.length) {
      const ch = this.state.input.codePointAt(this.state.pos);

      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (this.state.isIterator && ch === 64) {
        ++this.state.pos;
      } else if (ch === 92) {
        this.state.containsEsc = true;
        word += this.state.input.slice(chunkStart, this.state.pos);
        const escStart = this.state.pos;
        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

        if (this.state.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

        ++this.state.pos;
        const esc = this.readCodePoint(true);

        if (!identifierCheck(esc, true)) {
          this.raise(escStart, "Invalid Unicode escape");
        }

        word += String.fromCodePoint(esc);
        chunkStart = this.state.pos;
      } else {
        break;
      }
    }

    return word + this.state.input.slice(chunkStart, this.state.pos);
  }

  isIterator(word) {
    return word === "@@iterator" || word === "@@asyncIterator";
  }

  readWord() {
    const word = this.readWord1();
    const type = keywords[word] || types.name;

    if (type.keyword && this.state.containsEsc) {
      this.raise(this.state.pos, `Escape sequence in keyword ${word}`);
    }

    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
      this.raise(this.state.pos, `Invalid identifier ${word}`);
    }

    this.finishToken(type, word);
  }

  braceIsBlock(prevType) {
    const parent = this.curContext();

    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
      return true;
    }

    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
      return !parent.isExpr;
    }

    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
      return lineBreak.test(this.state.input.slice(this.state.lastTokEnd, this.state.start));
    }

    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
      return true;
    }

    if (prevType === types.braceL) {
      return parent === types$1.braceStatement;
    }

    if (prevType === types._var || prevType === types._const || prevType === types.name) {
      return false;
    }

    if (prevType === types.relational) {
      return true;
    }

    return !this.state.exprAllowed;
  }

  updateContext(prevType) {
    const type = this.state.type;
    let update;

    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
      this.state.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  }

}

class UtilParser extends Tokenizer {
  addExtra(node, key, val) {
    if (!node) return;
    const extra = node.extra = node.extra || {};
    extra[key] = val;
  }

  isRelational(op) {
    return this.match(types.relational) && this.state.value === op;
  }

  isLookaheadRelational(op) {
    const l = this.lookahead();
    return l.type === types.relational && l.value === op;
  }

  expectRelational(op) {
    if (this.isRelational(op)) {
      this.next();
    } else {
      this.unexpected(null, types.relational);
    }
  }

  eatRelational(op) {
    if (this.isRelational(op)) {
      this.next();
      return true;
    }

    return false;
  }

  isContextual(name) {
    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
  }

  isLookaheadContextual(name) {
    const l = this.lookahead();
    return l.type === types.name && l.value === name;
  }

  eatContextual(name) {
    return this.isContextual(name) && this.eat(types.name);
  }

  expectContextual(name, message) {
    if (!this.eatContextual(name)) this.unexpected(null, message);
  }

  canInsertSemicolon() {
    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
  }

  hasPrecedingLineBreak() {
    return lineBreak.test(this.state.input.slice(this.state.lastTokEnd, this.state.start));
  }

  isLineTerminator() {
    return this.eat(types.semi) || this.canInsertSemicolon();
  }

  semicolon() {
    if (!this.isLineTerminator()) this.unexpected(null, types.semi);
  }

  expect(type, pos) {
    this.eat(type) || this.unexpected(pos, type);
  }

  unexpected(pos, messageOrType = "Unexpected token") {
    if (typeof messageOrType !== "string") {
      messageOrType = `Unexpected token, expected "${messageOrType.label}"`;
    }

    throw this.raise(pos != null ? pos : this.state.start, messageOrType);
  }

  expectPlugin(name, pos) {
    if (!this.hasPlugin(name)) {
      throw this.raise(pos != null ? pos : this.state.start, `This experimental syntax requires enabling the parser plugin: '${name}'`, {
        missingPluginNames: [name]
      });
    }

    return true;
  }

  expectOnePlugin(names, pos) {
    if (!names.some(n => this.hasPlugin(n))) {
      throw this.raise(pos != null ? pos : this.state.start, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`, {
        missingPluginNames: names
      });
    }
  }

  checkYieldAwaitInDefaultParams() {
    if (this.state.yieldPos && (!this.state.awaitPos || this.state.yieldPos < this.state.awaitPos)) {
      this.raise(this.state.yieldPos, "Yield cannot be used as name inside a generator function");
    }

    if (this.state.awaitPos) {
      this.raise(this.state.awaitPos, "Await cannot be used as name inside an async function");
    }
  }

}

class Node {
  constructor(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser && parser.options.ranges) this.range = [pos, 0];
    if (parser && parser.filename) this.loc.filename = parser.filename;
  }

  __clone() {
    const newNode = new Node();
    const keys = Object.keys(this);

    for (let i = 0, length = keys.length; i < length; i++) {
      const key = keys[i];

      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
        newNode[key] = this[key];
      }
    }

    return newNode;
  }

}

class NodeUtils extends UtilParser {
  startNode() {
    return new Node(this, this.state.start, this.state.startLoc);
  }

  startNodeAt(pos, loc) {
    return new Node(this, pos, loc);
  }

  startNodeAtNode(type) {
    return this.startNodeAt(type.start, type.loc.start);
  }

  finishNode(node, type) {
    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
  }

  finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    node.loc.end = loc;
    if (this.options.ranges) node.range[1] = pos;
    this.processComment(node);
    return node;
  }

  resetStartLocation(node, start, startLoc) {
    node.start = start;
    node.loc.start = startLoc;
    if (this.options.ranges) node.range[0] = start;
  }

  resetStartLocationFromNode(node, locationNode) {
    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
  }

}

class LValParser extends NodeUtils {
  toAssignable(node, isBinding, contextDescription) {
    if (node) {
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            const prop = node.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isBinding, isLast);
          }

          break;

        case "ObjectProperty":
          this.toAssignable(node.value, isBinding, contextDescription);
          break;

        case "SpreadElement":
          {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            const arg = node.argument;
            this.toAssignable(arg, isBinding, contextDescription);
            break;
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, isBinding, contextDescription);
          break;

        case "AssignmentExpression":
          if (node.operator === "=") {
            node.type = "AssignmentPattern";
            delete node.operator;
          } else {
            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          }

          break;

        case "MemberExpression":
          if (!isBinding) break;

        default:
          {
            const message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
            this.raise(node.start, message);
          }
      }
    }

    return node;
  }

  toAssignableObjectExpressionProp(prop, isBinding, isLast) {
    if (prop.type === "ObjectMethod") {
      const error = prop.kind === "get" || prop.kind === "set" ? "Object pattern can't contain getter or setter" : "Object pattern can't contain methods";
      this.raise(prop.key.start, error);
    } else if (prop.type === "SpreadElement" && !isLast) {
      this.raiseRestNotLast(prop.start, "property");
    } else {
      this.toAssignable(prop, isBinding, "object destructuring pattern");
    }
  }

  toAssignableList(exprList, isBinding, contextDescription) {
    let end = exprList.length;

    if (end) {
      const last = exprList[end - 1];

      if (last && last.type === "RestElement") {
        --end;
      } else if (last && last.type === "SpreadElement") {
        last.type = "RestElement";
        const arg = last.argument;
        this.toAssignable(arg, isBinding, contextDescription);

        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
          this.unexpected(arg.start);
        }

        --end;
      }
    }

    for (let i = 0; i < end; i++) {
      const elt = exprList[i];

      if (elt) {
        this.toAssignable(elt, isBinding, contextDescription);

        if (elt.type === "RestElement") {
          this.raiseRestNotLast(elt.start, "element");
        }
      }
    }

    return exprList;
  }

  toReferencedList(exprList, isParenthesizedExpr) {
    return exprList;
  }

  toReferencedListDeep(exprList, isParenthesizedExpr) {
    this.toReferencedList(exprList, isParenthesizedExpr);

    for (let _i = 0; _i < exprList.length; _i++) {
      const expr = exprList[_i];

      if (expr && expr.type === "ArrayExpression") {
        this.toReferencedListDeep(expr.elements);
      }
    }

    return exprList;
  }

  parseSpread(refShorthandDefaultPos, refNeedsArrowPos) {
    const node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos, undefined, refNeedsArrowPos);

    if (this.state.commaAfterSpreadAt === -1 && this.match(types.comma)) {
      this.state.commaAfterSpreadAt = this.state.start;
    }

    return this.finishNode(node, "SpreadElement");
  }

  parseRest() {
    const node = this.startNode();
    this.next();
    node.argument = this.parseBindingAtom();
    return this.finishNode(node, "RestElement");
  }

  parseBindingAtom() {
    switch (this.state.type) {
      case types.name:
        return this.parseIdentifier();

      case types.bracketL:
        {
          const node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types.bracketR, true);
          return this.finishNode(node, "ArrayPattern");
        }

      case types.braceL:
        return this.parseObj(true);

      default:
        throw this.unexpected();
    }
  }

  parseBindingList(close, allowEmpty, allowModifiers) {
    const elts = [];
    let first = true;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);
      }

      if (allowEmpty && this.match(types.comma)) {
        elts.push(null);
      } else if (this.eat(close)) {
        break;
      } else if (this.match(types.ellipsis)) {
        elts.push(this.parseAssignableListItemTypes(this.parseRest()));
        this.checkCommaAfterRest(close, this.state.inFunction && this.state.inParameters ? "parameter" : "element");
        this.expect(close);
        break;
      } else {
        const decorators = [];

        if (this.match(types.at) && this.hasPlugin("decorators")) {
          this.raise(this.state.start, "Stage 2 decorators cannot be used to decorate parameters");
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }

        elts.push(this.parseAssignableListItem(allowModifiers, decorators));
      }
    }

    return elts;
  }

  parseAssignableListItem(allowModifiers, decorators) {
    const left = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left);
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

    if (decorators.length) {
      left.decorators = decorators;
    }

    return elt;
  }

  parseAssignableListItemTypes(param) {
    return param;
  }

  parseMaybeDefault(startPos, startLoc, left) {
    startLoc = startLoc || this.state.startLoc;
    startPos = startPos || this.state.start;
    left = left || this.parseBindingAtom();
    if (!this.eat(types.eq)) return left;
    const node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern");
  }

  checkLVal(expr, isBinding, checkClashes, contextDescription) {
    switch (expr.type) {
      case "Identifier":
        if (this.state.strict && isStrictBindReservedWord(expr.name, this.inModule)) {
          this.raise(expr.start, `${isBinding ? "Binding" : "Assigning to"} '${expr.name}' in strict mode`);
        }

        if (checkClashes) {
          const key = `_${expr.name}`;

          if (checkClashes[key]) {
            this.raise(expr.start, "Argument name clash in strict mode");
          } else {
            checkClashes[key] = true;
          }
        }

        break;

      case "MemberExpression":
        if (isBinding) this.raise(expr.start, "Binding member expression");
        break;

      case "ObjectPattern":
        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {
          let prop = _expr$properties[_i2];
          if (prop.type === "ObjectProperty") prop = prop.value;
          this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
        }

        break;

      case "ArrayPattern":
        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {
          const elem = _expr$elements[_i3];

          if (elem) {
            this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
          }
        }

        break;

      case "AssignmentPattern":
        this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
        break;

      case "RestElement":
        this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
        break;

      default:
        {
          const message = (isBinding ? "Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
          this.raise(expr.start, message);
        }
    }
  }

  checkToRestConversion(node) {
    if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
      this.raise(node.argument.start, "Invalid rest operator's argument");
    }
  }

  checkCommaAfterRest(close, kind) {
    if (this.match(types.comma)) {
      if (this.lookahead().type === close) {
        this.raiseCommaAfterRest(this.state.start, kind);
      } else {
        this.raiseRestNotLast(this.state.start, kind);
      }
    }
  }

  checkCommaAfterRestFromSpread(kind) {
    if (this.state.commaAfterSpreadAt > -1) {
      this.raiseCommaAfterRest(this.state.commaAfterSpreadAt, kind);
    }
  }

  raiseCommaAfterRest(pos, kind) {
    this.raise(pos, `A trailing comma is not permitted after the rest ${kind}`);
  }

  raiseRestNotLast(pos, kind) {
    this.raise(pos, `The rest ${kind} must be the last ${kind}`);
  }

}

class ExpressionParser extends LValParser {
  checkPropClash(prop, propHash) {
    if (prop.computed || prop.kind) return;
    const key = prop.key;
    const name = key.type === "Identifier" ? key.name : String(key.value);

    if (name === "__proto__") {
      if (propHash.proto) {
        this.raise(key.start, "Redefinition of __proto__ property");
      }

      propHash.proto = true;
    }
  }

  getExpression() {
    this.nextToken();
    const expr = this.parseExpression();

    if (!this.match(types.eof)) {
      this.unexpected();
    }

    expr.comments = this.state.comments;
    return expr;
  }

  parseExpression(noIn, refShorthandDefaultPos) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);

    if (this.match(types.comma)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];

      while (this.eat(types.comma)) {
        node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
      }

      this.toReferencedList(node.expressions);
      return this.finishNode(node, "SequenceExpression");
    }

    return expr;
  }

  parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;

    if (this.isContextual("yield")) {
      if (this.state.inGenerator) {
        let left = this.parseYield(noIn);

        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }

        return left;
      } else {
        this.state.exprAllowed = false;
      }
    }

    const oldCommaAfterSpreadAt = this.state.commaAfterSpreadAt;
    this.state.commaAfterSpreadAt = -1;
    let failOnShorthandAssign;

    if (refShorthandDefaultPos) {
      failOnShorthandAssign = false;
    } else {
      refShorthandDefaultPos = {
        start: 0
      };
      failOnShorthandAssign = true;
    }

    if (this.match(types.parenL) || this.match(types.name)) {
      this.state.potentialArrowAt = this.state.start;
    }

    let left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);

    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }

    if (this.state.type.isAssign) {
      const node = this.startNodeAt(startPos, startLoc);
      const operator = this.state.value;
      node.operator = operator;

      if (operator === "??=") {
        this.expectPlugin("nullishCoalescingOperator");
        this.expectPlugin("logicalAssignment");
      }

      if (operator === "||=" || operator === "&&=") {
        this.expectPlugin("logicalAssignment");
      }

      node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
      refShorthandDefaultPos.start = 0;
      this.checkLVal(left, undefined, undefined, "assignment expression");
      let patternErrorMsg;
      let elementName;

      if (left.type === "ObjectPattern") {
        patternErrorMsg = "`({a}) = 0` use `({a} = 0)`";
        elementName = "property";
      } else if (left.type === "ArrayPattern") {
        patternErrorMsg = "`([a]) = 0` use `([a] = 0)`";
        elementName = "element";
      }

      if (patternErrorMsg && left.extra && left.extra.parenthesized) {
        this.raise(left.start, `You're trying to assign to a parenthesized expression, eg. instead of ${patternErrorMsg}`);
      }

      if (elementName) this.checkCommaAfterRestFromSpread(elementName);
      this.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression");
    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    this.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;
    return left;
  }

  parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprOps(noIn, refShorthandDefaultPos);

    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
  }

  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
    if (this.eat(types.question)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression");
    }

    return expr;
  }

  parseExprOps(noIn, refShorthandDefaultPos) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseMaybeUnary(refShorthandDefaultPos);

    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      return expr;
    }

    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    const prec = this.state.type.binop;

    if (prec != null && (!noIn || !this.match(types._in))) {
      if (prec > minPrec) {
        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        const operator = this.state.value;
        node.left = left;
        node.operator = operator;

        if (operator === "**" && left.type === "UnaryExpression" && !(left.extra && left.extra.parenthesized)) {
          this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
        }

        const op = this.state.type;

        if (op === types.pipeline) {
          this.expectPlugin("pipelineOperator");
          this.state.inPipeline = true;
          this.checkPipelineAtInfixOperator(left, leftStartPos);
        } else if (op === types.nullishCoalescing) {
          this.expectPlugin("nullishCoalescingOperator");
        }

        this.next();

        if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
          if (this.match(types.name) && this.state.value === "await" && this.state.inAsync) {
            throw this.raise(this.state.start, `Unexpected "await" after pipeline body; await must have parentheses in minimal proposal`);
          }
        }

        node.right = this.parseExprOpRightExpr(op, prec, noIn);
        this.finishNode(node, op === types.logicalOR || op === types.logicalAND || op === types.nullishCoalescing ? "LogicalExpression" : "BinaryExpression");
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
      }
    }

    return left;
  }

  parseExprOpRightExpr(op, prec, noIn) {
    switch (op) {
      case types.pipeline:
        if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.withTopicPermittingContext(() => {
            return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);
          });
        }

      default:
        return this.parseExprOpBaseRightExpr(op, prec, noIn);
    }
  }

  parseExprOpBaseRightExpr(op, prec, noIn) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
  }

  parseMaybeUnary(refShorthandDefaultPos) {
    if (this.isContextual("await") && (this.state.inAsync || !this.state.inFunction && this.options.allowAwaitOutsideFunction)) {
      return this.parseAwait();
    } else if (this.state.type.prefix) {
      const node = this.startNode();
      const update = this.match(types.incDec);
      node.operator = this.state.value;
      node.prefix = true;

      if (node.operator === "throw") {
        this.expectPlugin("throwExpressions");
      }

      this.next();
      node.argument = this.parseMaybeUnary();

      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }

      if (update) {
        this.checkLVal(node.argument, undefined, undefined, "prefix operation");
      } else if (this.state.strict && node.operator === "delete") {
        const arg = node.argument;

        if (arg.type === "Identifier") {
          this.raise(node.start, "Deleting local variable in strict mode");
        } else if (arg.type === "MemberExpression" && arg.property.type === "PrivateName") {
          this.raise(node.start, "Deleting a private field is not allowed");
        }
      }

      return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }

    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let expr = this.parseExprSubscripts(refShorthandDefaultPos);
    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

    while (this.state.type.postfix && !this.canInsertSemicolon()) {
      const node = this.startNodeAt(startPos, startLoc);
      node.operator = this.state.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr, undefined, undefined, "postfix operation");
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }

    return expr;
  }

  parseExprSubscripts(refShorthandDefaultPos) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const potentialArrowAt = this.state.potentialArrowAt;
    const expr = this.parseExprAtom(refShorthandDefaultPos);

    if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
      return expr;
    }

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      return expr;
    }

    return this.parseSubscripts(expr, startPos, startLoc);
  }

  parseSubscripts(base, startPos, startLoc, noCalls) {
    const state = {
      optionalChainMember: false,
      stop: false
    };

    do {
      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
    } while (!state.stop);

    return base;
  }

  parseSubscript(base, startPos, startLoc, noCalls, state) {
    if (!noCalls && this.eat(types.doubleColon)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    } else if (this.match(types.questionDot)) {
      this.expectPlugin("optionalChaining");
      state.optionalChainMember = true;

      if (noCalls && this.lookahead().type === types.parenL) {
        state.stop = true;
        return base;
      }

      this.next();
      const node = this.startNodeAt(startPos, startLoc);

      if (this.eat(types.bracketL)) {
        node.object = base;
        node.property = this.parseExpression();
        node.computed = true;
        node.optional = true;
        this.expect(types.bracketR);
        return this.finishNode(node, "OptionalMemberExpression");
      } else if (this.eat(types.parenL)) {
        const possibleAsync = this.atPossibleAsync(base);
        node.callee = base;
        node.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);
        node.optional = true;
        return this.finishNode(node, "OptionalCallExpression");
      } else {
        node.object = base;
        node.property = this.parseIdentifier(true);
        node.computed = false;
        node.optional = true;
        return this.finishNode(node, "OptionalMemberExpression");
      }
    } else if (this.eat(types.dot)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseMaybePrivateName();
      node.computed = false;

      if (state.optionalChainMember) {
        node.optional = false;
        return this.finishNode(node, "OptionalMemberExpression");
      }

      return this.finishNode(node, "MemberExpression");
    } else if (this.eat(types.bracketL)) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(types.bracketR);

      if (state.optionalChainMember) {
        node.optional = false;
        return this.finishNode(node, "OptionalMemberExpression");
      }

      return this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.match(types.parenL)) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = 0;
      this.state.awaitPos = 0;
      const possibleAsync = this.atPossibleAsync(base);
      this.next();
      let node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      const oldCommaAfterSpreadAt = this.state.commaAfterSpreadAt;
      this.state.commaAfterSpreadAt = -1;
      node.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync, base.type === "Import");

      if (!state.optionalChainMember) {
        this.finishCallExpression(node);
      } else {
        this.finishOptionalCallExpression(node);
      }

      if (possibleAsync && this.shouldParseAsyncArrow()) {
        state.stop = true;
        this.checkCommaAfterRestFromSpread("parameter");
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
        this.checkYieldAwaitInDefaultParams();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;
      } else {
        this.toReferencedListDeep(node.arguments);
        this.state.yieldPos = oldYieldPos || this.state.yieldPos;
        this.state.awaitPos = oldAwaitPos || this.state.awaitPos;
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;
      return node;
    } else if (this.match(types.backQuote)) {
      return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);
    } else {
      state.stop = true;
      return base;
    }
  }

  parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
    const node = this.startNodeAt(startPos, startLoc);
    node.tag = base;
    node.quasi = this.parseTemplate(true);
    if (typeArguments) node.typeParameters = typeArguments;

    if (state.optionalChainMember) {
      this.raise(startPos, "Tagged Template Literals are not allowed in optionalChain");
    }

    return this.finishNode(node, "TaggedTemplateExpression");
  }

  atPossibleAsync(base) {
    return !this.state.containsEsc && this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
  }

  finishCallExpression(node) {
    if (node.callee.type === "Import") {
      if (node.arguments.length !== 1) {
        this.raise(node.start, "import() requires exactly one argument");
      }

      const importArg = node.arguments[0];

      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }

    return this.finishNode(node, "CallExpression");
  }

  finishOptionalCallExpression(node) {
    if (node.callee.type === "Import") {
      if (node.arguments.length !== 1) {
        this.raise(node.start, "import() requires exactly one argument");
      }

      const importArg = node.arguments[0];

      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }

    return this.finishNode(node, "OptionalCallExpression");
  }

  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport) {
    const elts = [];
    let innerParenStart;
    let first = true;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);

        if (this.eat(close)) {
          if (dynamicImport) {
            this.raise(this.state.lastTokStart, "Trailing comma is disallowed inside import(...) arguments");
          }

          break;
        }
      }

      if (this.match(types.parenL) && !innerParenStart) {
        innerParenStart = this.state.start;
      }

      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? {
        start: 0
      } : undefined, possibleAsyncArrow ? {
        start: 0
      } : undefined));
    }

    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
      this.unexpected();
    }

    return elts;
  }

  shouldParseAsyncArrow() {
    return this.match(types.arrow);
  }

  parseAsyncArrowFromCallExpression(node, call) {
    this.expect(types.arrow);
    this.parseArrowExpression(node, call.arguments, true);
    return node;
  }

  parseNoCallExpr() {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  }

  parseExprAtom(refShorthandDefaultPos) {
    if (this.state.type === types.slash) this.readRegexp();
    const canBeArrow = this.state.potentialArrowAt === this.state.start;
    let node;

    switch (this.state.type) {
      case types._super:
        if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {
          this.raise(this.state.start, "super is only allowed in object methods and classes");
        }

        node = this.startNode();
        this.next();

        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
          this.unexpected();
        }

        if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
          this.raise(node.start, "super() is only valid inside a class constructor. " + "Make sure the method name is spelled exactly as 'constructor'.");
        }

        return this.finishNode(node, "Super");

      case types._import:
        if (this.lookahead().type === types.dot) {
          return this.parseImportMetaProperty();
        }

        this.expectPlugin("dynamicImport");
        node = this.startNode();
        this.next();

        if (!this.match(types.parenL)) {
          this.unexpected(null, types.parenL);
        }

        return this.finishNode(node, "Import");

      case types._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression");

      case types.name:
        {
          node = this.startNode();
          const containsEsc = this.state.containsEsc;
          const id = this.parseIdentifier();

          if (!containsEsc && id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseFunction(node, false, false, true);
          } else if (canBeArrow && id.name === "async" && this.match(types.name) && !this.canInsertSemicolon()) {
            const oldInAsync = this.state.inAsync;
            this.state.inAsync = true;
            const params = [this.parseIdentifier()];
            this.expect(types.arrow);
            this.parseArrowExpression(node, params, true);
            this.state.inAsync = oldInAsync;
            return node;
          }

          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
            this.next();
            this.parseArrowExpression(node, [id], false);
            return node;
          }

          return id;
        }

      case types._do:
        {
          this.expectPlugin("doExpressions");
          const node = this.startNode();
          this.next();
          const oldInFunction = this.state.inFunction;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.state.inFunction = false;
          node.body = this.parseBlock(false);
          this.state.inFunction = oldInFunction;
          this.state.labels = oldLabels;
          return this.finishNode(node, "DoExpression");
        }

      case types.regexp:
        {
          const value = this.state.value;
          node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }

      case types.num:
        return this.parseLiteral(this.state.value, "NumericLiteral");

      case types.bigint:
        return this.parseLiteral(this.state.value, "BigIntLiteral");

      case types.string:
        return this.parseLiteral(this.state.value, "StringLiteral");

      case types._null:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");

      case types._true:
      case types._false:
        return this.parseBooleanLiteral();

      case types.parenL:
        return this.parseParenAndDistinguishExpression(canBeArrow);

      case types.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);

        if (!this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }

        return this.finishNode(node, "ArrayExpression");

      case types.braceL:
        return this.parseObj(false, refShorthandDefaultPos);

      case types._function:
        return this.parseFunctionExpression();

      case types.at:
        this.parseDecorators();

      case types._class:
        node = this.startNode();
        this.takeDecorators(node);
        return this.parseClass(node, false);

      case types._new:
        return this.parseNew();

      case types.backQuote:
        return this.parseTemplate(false);

      case types.doubleColon:
        {
          node = this.startNode();
          this.next();
          node.object = null;
          const callee = node.callee = this.parseNoCallExpr();

          if (callee.type === "MemberExpression") {
            return this.finishNode(node, "BindExpression");
          } else {
            throw this.raise(callee.start, "Binding should be performed on object property.");
          }
        }

      case types.hash:
        {
          if (this.state.inPipeline) {
            node = this.startNode();

            if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
              this.raise(node.start, "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.");
            }

            this.next();

            if (this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            } else {
              throw this.raise(node.start, `Topic reference was used in a lexical context without topic binding`);
            }
          }
        }

      default:
        throw this.unexpected();
    }
  }

  parseBooleanLiteral() {
    const node = this.startNode();
    node.value = this.match(types._true);
    this.next();
    return this.finishNode(node, "BooleanLiteral");
  }

  parseMaybePrivateName() {
    const isPrivate = this.match(types.hash);

    if (isPrivate) {
      this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);
      const node = this.startNode();
      const columnHashEnd = this.state.end;
      this.next();
      const columnIdentifierStart = this.state.start;
      const spacesBetweenHashAndIdentifier = columnIdentifierStart - columnHashEnd;

      if (spacesBetweenHashAndIdentifier != 0) {
        this.raise(columnIdentifierStart, "Unexpected space between # and identifier");
      }

      node.id = this.parseIdentifier(true);
      return this.finishNode(node, "PrivateName");
    } else {
      return this.parseIdentifier(true);
    }
  }

  parseFunctionExpression() {
    const node = this.startNode();
    let meta = this.startNode();
    this.next();
    meta = this.createIdentifier(meta, "function");

    if (this.state.inGenerator && this.eat(types.dot)) {
      return this.parseMetaProperty(node, meta, "sent");
    }

    return this.parseFunction(node, false);
  }

  parseMetaProperty(node, meta, propertyName) {
    node.meta = meta;

    if (meta.name === "function" && propertyName === "sent") {
      if (this.isContextual(propertyName)) {
        this.expectPlugin("functionSent");
      } else if (!this.hasPlugin("functionSent")) {
        this.unexpected();
      }
    }

    const containsEsc = this.state.containsEsc;
    node.property = this.parseIdentifier(true);

    if (node.property.name !== propertyName || containsEsc) {
      this.raise(node.property.start, `The only valid meta property for ${meta.name} is ${meta.name}.${propertyName}`);
    }

    return this.finishNode(node, "MetaProperty");
  }

  parseImportMetaProperty() {
    const node = this.startNode();
    const id = this.parseIdentifier(true);
    this.expect(types.dot);

    if (id.name === "import") {
      if (this.isContextual("meta")) {
        this.expectPlugin("importMeta");
      } else if (!this.hasPlugin("importMeta")) {
        this.raise(id.start, `Dynamic imports require a parameter: import('a.js')`);
      }
    }

    if (!this.inModule) {
      this.raise(id.start, `import.meta may appear only with 'sourceType: "module"'`, {
        code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      });
    }

    this.sawUnambiguousESM = true;
    return this.parseMetaProperty(node, id, "meta");
  }

  parseLiteral(value, type, startPos, startLoc) {
    startPos = startPos || this.state.start;
    startLoc = startLoc || this.state.startLoc;
    const node = this.startNodeAt(startPos, startLoc);
    this.addExtra(node, "rawValue", value);
    this.addExtra(node, "raw", this.state.input.slice(startPos, this.state.end));
    node.value = value;
    this.next();
    return this.finishNode(node, type);
  }

  parseParenExpression() {
    this.expect(types.parenL);
    const val = this.parseExpression();
    this.expect(types.parenR);
    return val;
  }

  parseParenAndDistinguishExpression(canBeArrow) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let val;
    this.expect(types.parenL);
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    this.state.maybeInArrowParameters = true;
    this.state.yieldPos = 0;
    this.state.awaitPos = 0;
    const innerStartPos = this.state.start;
    const innerStartLoc = this.state.startLoc;
    const exprList = [];
    const refShorthandDefaultPos = {
      start: 0
    };
    const refNeedsArrowPos = {
      start: 0
    };
    let first = true;
    let spreadStart;
    let optionalCommaStart;

    while (!this.match(types.parenR)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma, refNeedsArrowPos.start || null);

        if (this.match(types.parenR)) {
          optionalCommaStart = this.state.start;
          break;
        }
      }

      if (this.match(types.ellipsis)) {
        const spreadNodeStartPos = this.state.start;
        const spreadNodeStartLoc = this.state.startLoc;
        spreadStart = this.state.start;
        exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));
        this.checkCommaAfterRest(types.parenR, "parameter");
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
      }
    }

    const innerEndPos = this.state.start;
    const innerEndLoc = this.state.startLoc;
    this.expect(types.parenR);
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    let arrowNode = this.startNodeAt(startPos, startLoc);

    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
      this.checkYieldAwaitInDefaultParams();
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;

      for (let _i = 0; _i < exprList.length; _i++) {
        const param = exprList[_i];

        if (param.extra && param.extra.parenthesized) {
          this.unexpected(param.extra.parenStart);
        }
      }

      this.parseArrowExpression(arrowNode, exprList, false);
      return arrowNode;
    }

    this.state.yieldPos = oldYieldPos || this.state.yieldPos;
    this.state.awaitPos = oldAwaitPos || this.state.awaitPos;

    if (!exprList.length) {
      this.unexpected(this.state.lastTokStart);
    }

    if (optionalCommaStart) this.unexpected(optionalCommaStart);
    if (spreadStart) this.unexpected(spreadStart);

    if (refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
    this.toReferencedListDeep(exprList, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }

    this.addExtra(val, "parenthesized", true);
    this.addExtra(val, "parenStart", startPos);
    return val;
  }

  shouldParseArrow() {
    return !this.canInsertSemicolon();
  }

  parseArrow(node) {
    if (this.eat(types.arrow)) {
      return node;
    }
  }

  parseParenItem(node, startPos, startLoc) {
    return node;
  }

  parseNew() {
    const node = this.startNode();
    const meta = this.parseIdentifier(true);

    if (this.eat(types.dot)) {
      const metaProp = this.parseMetaProperty(node, meta, "target");

      if (!this.state.inFunction && !this.state.inClassProperty) {
        let error = "new.target can only be used in functions";

        if (this.hasPlugin("classProperties")) {
          error += " or class properties";
        }

        this.raise(metaProp.start, error);
      }

      return metaProp;
    }

    node.callee = this.parseNoCallExpr();

    if (node.callee.type === "Import") {
      this.raise(node.callee.start, "Cannot use new with import(...)");
    } else if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
      this.raise(this.state.lastTokEnd, "constructors in/after an Optional Chain are not allowed");
    } else if (this.eat(types.questionDot)) {
      this.raise(this.state.start, "constructors in/after an Optional Chain are not allowed");
    }

    this.parseNewArguments(node);
    return this.finishNode(node, "NewExpression");
  }

  parseNewArguments(node) {
    if (this.eat(types.parenL)) {
      const args = this.parseExprList(types.parenR);
      this.toReferencedList(args);
      node.arguments = args;
    } else {
      node.arguments = [];
    }
  }

  parseTemplateElement(isTagged) {
    const elem = this.startNode();

    if (this.state.value === null) {
      if (!isTagged) {
        this.raise(this.state.invalidTemplateEscapePosition || 0, "Invalid escape sequence in template");
      } else {
        this.state.invalidTemplateEscapePosition = null;
      }
    }

    elem.value = {
      raw: this.state.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
      cooked: this.state.value
    };
    this.next();
    elem.tail = this.match(types.backQuote);
    return this.finishNode(elem, "TemplateElement");
  }

  parseTemplate(isTagged) {
    const node = this.startNode();
    this.next();
    node.expressions = [];
    let curElt = this.parseTemplateElement(isTagged);
    node.quasis = [curElt];

    while (!curElt.tail) {
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement(isTagged));
    }

    this.next();
    return this.finishNode(node, "TemplateLiteral");
  }

  parseObj(isPattern, refShorthandDefaultPos) {
    let decorators = [];
    const propHash = Object.create(null);
    let first = true;
    const node = this.startNode();
    node.properties = [];
    this.next();

    while (!this.eat(types.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);
        if (this.eat(types.braceR)) break;
      }

      if (this.match(types.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, "Stage 2 decorators disallow object literal property decorators");
        } else {
          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }
        }
      }

      let prop = this.startNode(),
          isGenerator = false,
          isAsync = false,
          startPos,
          startLoc;

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      if (this.match(types.ellipsis)) {
        prop = this.parseSpread(isPattern ? {
          start: 0
        } : undefined);
        node.properties.push(prop);

        if (isPattern) {
          this.toAssignable(prop, true, "object pattern");
          this.checkCommaAfterRest(types.braceR, "property");
          this.expect(types.braceR);
          break;
        }

        continue;
      }

      prop.method = false;

      if (isPattern || refShorthandDefaultPos) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }

      const containsEsc = this.state.containsEsc;

      if (!isPattern && this.isContextual("async")) {
        if (isGenerator) this.unexpected();
        const asyncId = this.parseIdentifier();

        if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {
          prop.key = asyncId;
          prop.computed = false;
        } else {
          isAsync = true;
          isGenerator = this.eat(types.star);
          this.parsePropertyName(prop);
        }
      } else {
        this.parsePropertyName(prop);
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);
      this.checkPropClash(prop, propHash);

      if (prop.shorthand) {
        this.addExtra(prop, "shorthand", true);
      }

      node.properties.push(prop);
    }

    if (decorators.length) {
      this.raise(this.state.start, "You have trailing decorators with no property");
    }

    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
  }

  isGetterOrSetterMethod(prop, isPattern) {
    return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);
  }

  checkGetterSetterParams(method) {
    const paramCount = method.kind === "get" ? 0 : 1;
    const start = method.start;

    if (method.params.length !== paramCount) {
      if (method.kind === "get") {
        this.raise(start, "getter must not have any formal parameters");
      } else {
        this.raise(start, "setter must have exactly one formal parameter");
      }
    }

    if (method.kind === "set" && method.params[0].type === "RestElement") {
      this.raise(start, "setter function argument must not be a rest parameter");
    }
  }

  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
    if (isAsync || isGenerator || this.match(types.parenL)) {
      if (isPattern) this.unexpected();
      prop.kind = "method";
      prop.method = true;
      return this.parseMethod(prop, isGenerator, isAsync, false, "ObjectMethod");
    }

    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {
      if (isGenerator || isAsync) this.unexpected();
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      this.parseMethod(prop, false, false, false, "ObjectMethod");
      this.checkGetterSetterParams(prop);
      return prop;
    }
  }

  parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
    prop.shorthand = false;

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
      return this.finishNode(prop, "ObjectProperty");
    }

    if (!prop.computed && prop.key.type === "Identifier") {
      this.checkReservedWord(prop.key.name, prop.key.start, true, true);

      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
      } else if (this.match(types.eq) && refShorthandDefaultPos) {
        if (!refShorthandDefaultPos.start) {
          refShorthandDefaultPos.start = this.state.start;
        }

        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
      } else {
        prop.value = prop.key.__clone();
      }

      prop.shorthand = true;
      return this.finishNode(prop, "ObjectProperty");
    }
  }

  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {
    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);
    if (!node) this.unexpected();
    return node;
  }

  parsePropertyName(prop) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
    } else {
      const oldInPropertyName = this.state.inPropertyName;
      this.state.inPropertyName = true;
      prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseMaybePrivateName();

      if (prop.key.type !== "PrivateName") {
        prop.computed = false;
      }

      this.state.inPropertyName = oldInPropertyName;
    }

    return prop.key;
  }

  initFunction(node, isAsync) {
    node.id = null;
    node.generator = false;
    node.async = !!isAsync;
  }

  parseMethod(node, isGenerator, isAsync, isConstructor, type) {
    const oldInFunc = this.state.inFunction;
    const oldInMethod = this.state.inMethod;
    const oldInAsync = this.state.inAsync;
    const oldInGenerator = this.state.inGenerator;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    this.state.inFunction = true;
    this.state.inMethod = node.kind || true;
    this.state.inAsync = isAsync;
    this.state.inGenerator = isGenerator;
    this.state.yieldPos = 0;
    this.state.awaitPos = 0;
    this.initFunction(node, isAsync);
    node.generator = !!isGenerator;
    const allowModifiers = isConstructor;
    this.parseFunctionParams(node, allowModifiers);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBodyAndFinish(node, type);
    this.state.inFunction = oldInFunc;
    this.state.inMethod = oldInMethod;
    this.state.inAsync = oldInAsync;
    this.state.inGenerator = oldInGenerator;
    this.state.yieldPos = oldYieldPos;
    this.state.awaitPos = oldAwaitPos;
    return node;
  }

  parseArrowExpression(node, params, isAsync) {
    this.initFunction(node, isAsync);
    const oldInFunc = this.state.inFunction;
    const oldInAsync = this.state.inAsync;
    const oldInGenerator = this.state.inGenerator;
    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    this.state.inFunction = true;
    this.state.inAsync = isAsync;
    this.state.inGenerator = false;
    this.state.maybeInArrowParameters = false;
    this.state.yieldPos = 0;
    this.state.awaitPos = 0;
    if (params) this.setArrowFunctionParameters(node, params);
    this.parseFunctionBody(node, true);
    this.state.inAsync = oldInAsync;
    this.state.inGenerator = oldInGenerator;
    this.state.inFunction = oldInFunc;
    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
    this.state.yieldPos = oldYieldPos;
    this.state.awaitPos = oldAwaitPos;
    return this.finishNode(node, "ArrowFunctionExpression");
  }

  setArrowFunctionParameters(node, params) {
    node.params = this.toAssignableList(params, true, "arrow function parameters");
  }

  isStrictBody(node) {
    const isBlockStatement = node.body.type === "BlockStatement";

    if (isBlockStatement && node.body.directives.length) {
      for (let _i2 = 0, _node$body$directives = node.body.directives; _i2 < _node$body$directives.length; _i2++) {
        const directive = _node$body$directives[_i2];

        if (directive.value.value === "use strict") {
          return true;
        }
      }
    }

    return false;
  }

  parseFunctionBodyAndFinish(node, type, allowExpressionBody) {
    this.parseFunctionBody(node, allowExpressionBody);
    this.finishNode(node, type);
  }

  parseFunctionBody(node, allowExpression) {
    const isExpression = allowExpression && !this.match(types.braceL);
    const oldInParameters = this.state.inParameters;
    this.state.inParameters = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
    } else {
      const oldInFunc = this.state.inFunction;
      const oldLabels = this.state.labels;
      this.state.inFunction = true;
      this.state.labels = [];
      node.body = this.parseBlock(true);
      this.state.inFunction = oldInFunc;
      this.state.labels = oldLabels;
    }

    this.checkFunctionNameAndParams(node, allowExpression);
    this.state.inParameters = oldInParameters;
  }

  checkFunctionNameAndParams(node, isArrowFunction) {
    const isStrict = this.isStrictBody(node);
    const checkLVal = this.state.strict || isStrict || isArrowFunction;
    const oldStrict = this.state.strict;
    if (isStrict) this.state.strict = isStrict;

    if (checkLVal) {
      const nameHash = Object.create(null);

      if (node.id) {
        this.checkLVal(node.id, true, undefined, "function name");
      }

      for (let _i3 = 0, _node$params = node.params; _i3 < _node$params.length; _i3++) {
        const param = _node$params[_i3];

        if (isStrict && param.type !== "Identifier") {
          this.raise(param.start, "Non-simple parameter in strict mode");
        }

        this.checkLVal(param, true, nameHash, "function parameter list");
      }
    }

    this.state.strict = oldStrict;
  }

  parseExprList(close, allowEmpty, refShorthandDefaultPos) {
    const elts = [];
    let first = true;

    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);
        if (this.eat(close)) break;
      }

      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
    }

    return elts;
  }

  parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {
    let elt;

    if (allowEmpty && this.match(types.comma)) {
      elt = null;
    } else if (this.match(types.ellipsis)) {
      const spreadNodeStartPos = this.state.start;
      const spreadNodeStartLoc = this.state.startLoc;
      elt = this.parseParenItem(this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
    } else {
      elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
    }

    return elt;
  }

  parseIdentifier(liberal) {
    const node = this.startNode();
    const name = this.parseIdentifierName(node.start, liberal);
    return this.createIdentifier(node, name);
  }

  createIdentifier(node, name) {
    node.name = name;
    node.loc.identifierName = name;
    return this.finishNode(node, "Identifier");
  }

  parseIdentifierName(pos, liberal) {
    let name;

    if (this.match(types.name)) {
      name = this.state.value;
    } else if (this.state.type.keyword) {
      name = this.state.type.keyword;

      if ((name === "class" || name === "function") && (this.state.lastTokEnd !== this.state.lastTokStart + 1 || this.state.input.charCodeAt(this.state.lastTokStart) !== 46)) {
        this.state.context.pop();
      }
    } else {
      throw this.unexpected();
    }

    if (!liberal) {
      this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);
    }

    this.next();
    return name;
  }

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {
    const state = this.state;

    if (state.inGenerator && word === "yield") {
      this.raise(startLoc, "Can not use 'yield' as identifier inside a generator");
    }

    if (state.inAsync && word === "await") {
      this.raise(startLoc, "Can not use 'await' as identifier inside an async function");
    }

    if (state.inClassProperty && word === "arguments") {
      this.raise(startLoc, "'arguments' is not allowed in class field initializer");
    }

    if (checkKeywords && isKeyword(word)) {
      this.raise(startLoc, `Unexpected keyword '${word}'`);
    }

    const reservedTest = !state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

    if (reservedTest(word, this.inModule)) {
      if (!state.inAsync && word === "await") {
        this.raise(startLoc, "Can not use keyword 'await' outside an async function");
      }

      this.raise(startLoc, `Unexpected reserved word '${word}'`);
    }
  }

  parseAwait() {
    if (!this.state.awaitPos) {
      this.state.awaitPos = this.state.start;
    }

    const node = this.startNode();
    this.next();

    if (this.state.inParameters) {
      this.raise(node.start, "await is not allowed in async function parameters");
    }

    if (this.match(types.star)) {
      this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
    }

    node.argument = this.parseMaybeUnary();
    return this.finishNode(node, "AwaitExpression");
  }

  parseYield(noIn) {
    if (!this.state.yieldPos) {
      this.state.yieldPos = this.state.start;
    }

    const node = this.startNode();

    if (this.state.inParameters) {
      this.raise(node.start, "yield is not allowed in generator parameters");
    }

    this.next();

    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.canInsertSemicolon()) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }

    return this.finishNode(node, "YieldExpression");
  }

  checkPipelineAtInfixOperator(left, leftStartPos) {
    if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
      if (left.type === "SequenceExpression") {
        throw this.raise(leftStartPos, `Pipeline head should not be a comma-separated sequence expression`);
      }
    }
  }

  parseSmartPipelineBody(childExpression, startPos, startLoc) {
    const pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);
    this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);
    return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);
  }

  checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {
    if (this.match(types.arrow)) {
      throw this.raise(this.state.start, `Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized`);
    } else if (pipelineStyle === "PipelineTopicExpression" && childExpression.type === "SequenceExpression") {
      throw this.raise(startPos, `Pipeline body may not be a comma-separated sequence expression`);
    }
  }

  parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {
    const bodyNode = this.startNodeAt(startPos, startLoc);

    switch (pipelineStyle) {
      case "PipelineBareFunction":
        bodyNode.callee = childExpression;
        break;

      case "PipelineBareConstructor":
        bodyNode.callee = childExpression.callee;
        break;

      case "PipelineBareAwaitedFunction":
        bodyNode.callee = childExpression.argument;
        break;

      case "PipelineTopicExpression":
        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
          throw this.raise(startPos, `Pipeline is in topic style but does not use topic reference`);
        }

        bodyNode.expression = childExpression;
        break;

      default:
        throw this.raise(startPos, `Unknown pipeline style ${pipelineStyle}`);
    }

    return this.finishNode(bodyNode, pipelineStyle);
  }

  checkSmartPipelineBodyStyle(expression) {
    switch (expression.type) {
      default:
        return this.isSimpleReference(expression) ? "PipelineBareFunction" : "PipelineTopicExpression";
    }
  }

  isSimpleReference(expression) {
    switch (expression.type) {
      case "MemberExpression":
        return !expression.computed && this.isSimpleReference(expression.object);

      case "Identifier":
        return true;

      default:
        return false;
    }
  }

  withTopicPermittingContext(callback) {
    const outerContextTopicState = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };

    try {
      return callback();
    } finally {
      this.state.topicContext = outerContextTopicState;
    }
  }

  withTopicForbiddingContext(callback) {
    const outerContextTopicState = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    };

    try {
      return callback();
    } finally {
      this.state.topicContext = outerContextTopicState;
    }
  }

  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }

  primaryTopicReferenceIsAllowedInCurrentTopicContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }

  topicReferenceWasUsedInCurrentTopicContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }

}

const empty = [];
const loopLabel = {
  kind: "loop"
};
const switchLabel = {
  kind: "switch"
};
class StatementParser extends ExpressionParser {
  parseTopLevel(file, program) {
    program.sourceType = this.options.sourceType;
    program.interpreter = this.parseInterpreterDirective();
    this.parseBlockBody(program, true, true, types.eof);
    file.program = this.finishNode(program, "Program");
    file.comments = this.state.comments;
    if (this.options.tokens) file.tokens = this.state.tokens;
    return this.finishNode(file, "File");
  }

  stmtToDirective(stmt) {
    const expr = stmt.expression;
    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
    const directive = this.startNodeAt(stmt.start, stmt.loc.start);
    const raw = this.state.input.slice(expr.start, expr.end);
    const val = directiveLiteral.value = raw.slice(1, -1);
    this.addExtra(directiveLiteral, "raw", raw);
    this.addExtra(directiveLiteral, "rawValue", val);
    directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
    return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
  }

  parseInterpreterDirective() {
    if (!this.match(types.interpreterDirective)) {
      return null;
    }

    const node = this.startNode();
    node.value = this.state.value;
    this.next();
    return this.finishNode(node, "InterpreterDirective");
  }

  isLet(context) {
    if (!this.isContextual("let")) {
      return false;
    }

    skipWhiteSpace.lastIndex = this.state.pos;
    const skip = skipWhiteSpace.exec(this.state.input);
    const next = this.state.pos + skip[0].length;
    const nextCh = this.state.input.charCodeAt(next);
    if (nextCh === 91) return true;
    if (context) return false;
    if (nextCh === 123) return true;

    if (isIdentifierStart(nextCh)) {
      let pos = next + 1;

      while (isIdentifierChar(this.state.input.charCodeAt(pos))) {
        ++pos;
      }

      const ident = this.state.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) return true;
    }

    return false;
  }

  parseStatement(context, topLevel) {
    if (this.match(types.at)) {
      this.parseDecorators(true);
    }

    return this.parseStatementContent(context, topLevel);
  }

  parseStatementContent(context, topLevel) {
    let starttype = this.state.type;
    const node = this.startNode();
    let kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }

    switch (starttype) {
      case types._break:
      case types._continue:
        return this.parseBreakContinueStatement(node, starttype.keyword);

      case types._debugger:
        return this.parseDebuggerStatement(node);

      case types._do:
        return this.parseDoStatement(node);

      case types._for:
        return this.parseForStatement(node);

      case types._function:
        {
          if (this.lookahead().type === types.dot) break;

          if (context && (this.state.strict || context !== "if" && context !== "label")) {
            this.raise(this.state.start, "Function declaration not allowed in this context");
          }

          const result = this.parseFunctionStatement(node);

          if (context && result.generator) {
            this.unexpected(node.start);
          }

          return result;
        }

      case types._class:
        if (context) this.unexpected();
        return this.parseClass(node, true);

      case types._if:
        return this.parseIfStatement(node);

      case types._return:
        return this.parseReturnStatement(node);

      case types._switch:
        return this.parseSwitchStatement(node);

      case types._throw:
        return this.parseThrowStatement(node);

      case types._try:
        return this.parseTryStatement(node);

      case types._const:
      case types._var:
        kind = kind || this.state.value;
        if (context && kind !== "var") this.unexpected();
        return this.parseVarStatement(node, kind);

      case types._while:
        return this.parseWhileStatement(node);

      case types._with:
        return this.parseWithStatement(node);

      case types.braceL:
        return this.parseBlock();

      case types.semi:
        return this.parseEmptyStatement(node);

      case types._export:
      case types._import:
        {
          const nextToken = this.lookahead();

          if (nextToken.type === types.parenL || nextToken.type === types.dot) {
            break;
          }

          if (!this.options.allowImportExportEverywhere && !topLevel) {
            this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
          }

          this.next();
          let result;

          if (starttype === types._import) {
            result = this.parseImport(node);

            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
              this.sawUnambiguousESM = true;
            }
          } else {
            result = this.parseExport(node);

            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
              this.sawUnambiguousESM = true;
            }
          }

          this.assertModuleNodeAllowed(node);
          return result;
        }

      case types.name:
        if (this.isContextual("async")) {
          const state = this.state.clone();
          this.next();

          if (this.match(types._function) && !this.canInsertSemicolon()) {
            if (context) {
              this.raise(this.state.lastTokStart, "Function declaration not allowed in this context");
            }

            this.next();
            return this.parseFunction(node, true, false, true);
          } else {
            this.state = state;
          }
        }

    }

    const maybeName = this.state.value;
    const expr = this.parseExpression();

    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
      return this.parseLabeledStatement(node, maybeName, expr, context);
    } else {
      return this.parseExpressionStatement(node, expr);
    }
  }

  assertModuleNodeAllowed(node) {
    if (!this.options.allowImportExportEverywhere && !this.inModule) {
      this.raise(node.start, `'import' and 'export' may appear only with 'sourceType: "module"'`, {
        code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      });
    }
  }

  takeDecorators(node) {
    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    if (decorators.length) {
      node.decorators = decorators;
      this.resetStartLocationFromNode(node, decorators[0]);
      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
    }
  }

  canHaveLeadingDecorator() {
    return this.match(types._class);
  }

  parseDecorators(allowExport) {
    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    while (this.match(types.at)) {
      const decorator = this.parseDecorator();
      currentContextDecorators.push(decorator);
    }

    if (this.match(types._export)) {
      if (!allowExport) {
        this.unexpected();
      }

      if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
        this.raise(this.state.start, "Using the export keyword between a decorator and a class is not allowed. " + "Please use `export @dec class` instead.");
      }
    } else if (!this.canHaveLeadingDecorator()) {
      this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
    }
  }

  parseDecorator() {
    this.expectOnePlugin(["decorators-legacy", "decorators"]);
    const node = this.startNode();
    this.next();

    if (this.hasPlugin("decorators")) {
      this.state.decoratorStack.push([]);
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let expr;

      if (this.eat(types.parenL)) {
        expr = this.parseExpression();
        this.expect(types.parenR);
      } else {
        expr = this.parseIdentifier(false);

        while (this.eat(types.dot)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = expr;
          node.property = this.parseIdentifier(true);
          node.computed = false;
          expr = this.finishNode(node, "MemberExpression");
        }
      }

      node.expression = this.parseMaybeDecoratorArguments(expr);
      this.state.decoratorStack.pop();
    } else {
      node.expression = this.parseMaybeAssign();
    }

    return this.finishNode(node, "Decorator");
  }

  parseMaybeDecoratorArguments(expr) {
    if (this.eat(types.parenL)) {
      const node = this.startNodeAtNode(expr);
      node.callee = expr;
      node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      this.toReferencedList(node.arguments);
      return this.finishNode(node, "CallExpression");
    }

    return expr;
  }

  parseBreakContinueStatement(node, keyword) {
    const isBreak = keyword === "break";
    this.next();

    if (this.isLineTerminator()) {
      node.label = null;
    } else if (!this.match(types.name)) {
      this.unexpected();
    } else {
      node.label = this.parseIdentifier();
      this.semicolon();
    }

    let i;

    for (i = 0; i < this.state.labels.length; ++i) {
      const lab = this.state.labels[i];

      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
        if (node.label && isBreak) break;
      }
    }

    if (i === this.state.labels.length) {
      this.raise(node.start, "Unsyntactic " + keyword);
    }

    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }

  parseDebuggerStatement(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
  }

  parseDoStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("do"));
    this.state.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    this.eat(types.semi);
    return this.finishNode(node, "DoWhileStatement");
  }

  parseForStatement(node) {
    this.next();
    this.state.labels.push(loopLabel);
    let awaitAt = -1;

    if ((this.state.inAsync || !this.state.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await")) {
      awaitAt = this.state.lastTokStart;
    }

    this.expect(types.parenL);

    if (this.match(types.semi)) {
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, null);
    }

    const isLet = this.isLet();

    if (this.match(types._var) || this.match(types._const) || isLet) {
      const init = this.startNode();
      const kind = isLet ? "let" : this.state.value;
      this.next();
      this.parseVar(init, true, kind);
      this.finishNode(init, "VariableDeclaration");

      if (this.match(types._in) || this.isContextual("of")) {
        if (init.declarations.length === 1) {
          const declaration = init.declarations[0];
          const isForInInitializer = kind === "var" && declaration.init && declaration.id.type != "ObjectPattern" && declaration.id.type != "ArrayPattern" && !this.isContextual("of");

          if (this.state.strict && isForInInitializer) {
            this.raise(this.state.start, "for-in initializer in strict mode");
          } else if (isForInInitializer || !declaration.init) {
            return this.parseForIn(node, init, awaitAt);
          }
        }
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }

    const refShorthandDefaultPos = {
      start: 0
    };
    const init = this.parseExpression(true, refShorthandDefaultPos);

    if (this.match(types._in) || this.isContextual("of")) {
      const description = this.isContextual("of") ? "for-of statement" : "for-in statement";
      this.toAssignable(init, undefined, description);
      this.checkLVal(init, undefined, undefined, description);
      return this.parseForIn(node, init, awaitAt);
    } else if (refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }

    return this.parseFor(node, init);
  }

  parseFunctionStatement(node) {
    this.next();
    return this.parseFunction(node, true);
  }

  parseIfStatement(node) {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement");
  }

  parseReturnStatement(node) {
    if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
      this.raise(this.state.start, "'return' outside of function");
    }

    this.next();

    if (this.isLineTerminator()) {
      node.argument = null;
    } else {
      node.argument = this.parseExpression();
      this.semicolon();
    }

    return this.finishNode(node, "ReturnStatement");
  }

  parseSwitchStatement(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    const cases = node.cases = [];
    this.expect(types.braceL);
    this.state.labels.push(switchLabel);
    let cur;

    for (let sawDefault; !this.match(types.braceR);) {
      if (this.match(types._case) || this.match(types._default)) {
        const isCase = this.match(types._case);
        if (cur) this.finishNode(cur, "SwitchCase");
        cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();

        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raise(this.state.lastTokStart, "Multiple default clauses");
          }

          sawDefault = true;
          cur.test = null;
        }

        this.expect(types.colon);
      } else {
        if (cur) {
          cur.consequent.push(this.parseStatement(null));
        } else {
          this.unexpected();
        }
      }
    }

    if (cur) this.finishNode(cur, "SwitchCase");
    this.next();
    this.state.labels.pop();
    return this.finishNode(node, "SwitchStatement");
  }

  parseThrowStatement(node) {
    this.next();

    if (lineBreak.test(this.state.input.slice(this.state.lastTokEnd, this.state.start))) {
      this.raise(this.state.lastTokEnd, "Illegal newline after throw");
    }

    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
  }

  parseTryStatement(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;

    if (this.match(types._catch)) {
      const clause = this.startNode();
      this.next();

      if (this.match(types.parenL)) {
        this.expect(types.parenL);
        clause.param = this.parseBindingAtom();
        const clashes = Object.create(null);
        this.checkLVal(clause.param, true, clashes, "catch clause");
        this.expect(types.parenR);
      } else {
        clause.param = null;
      }

      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false));
      node.handler = this.finishNode(clause, "CatchClause");
    }

    node.guardedHandlers = empty;
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

    if (!node.handler && !node.finalizer) {
      this.raise(node.start, "Missing catch or finally clause");
    }

    return this.finishNode(node, "TryStatement");
  }

  parseVarStatement(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  }

  parseWhileStatement(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.state.labels.push(loopLabel);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("while"));
    this.state.labels.pop();
    return this.finishNode(node, "WhileStatement");
  }

  parseWithStatement(node) {
    if (this.state.strict) {
      this.raise(this.state.start, "'with' in strict mode");
    }

    this.next();
    node.object = this.parseParenExpression();
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("with"));
    return this.finishNode(node, "WithStatement");
  }

  parseEmptyStatement(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
  }

  parseLabeledStatement(node, maybeName, expr, context) {
    for (let _i = 0, _this$state$labels = this.state.labels; _i < _this$state$labels.length; _i++) {
      const label = _this$state$labels[_i];

      if (label.name === maybeName) {
        this.raise(expr.start, `Label '${maybeName}' is already declared`);
      }
    }

    const kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

    for (let i = this.state.labels.length - 1; i >= 0; i--) {
      const label = this.state.labels[i];

      if (label.statementStart === node.start) {
        label.statementStart = this.state.start;
        label.kind = kind;
      } else {
        break;
      }
    }

    this.state.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: this.state.start
    });
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.state.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
  }

  parseExpressionStatement(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
  }

  parseBlock(allowDirectives) {
    const node = this.startNode();
    this.expect(types.braceL);
    this.parseBlockBody(node, allowDirectives, false, types.braceR);
    return this.finishNode(node, "BlockStatement");
  }

  isValidDirective(stmt) {
    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
  }

  parseBlockBody(node, allowDirectives, topLevel, end) {
    const body = node.body = [];
    const directives = node.directives = [];
    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end);
  }

  parseBlockOrModuleBlockBody(body, directives, topLevel, end) {
    let parsedNonDirective = false;
    let oldStrict;
    let octalPosition;

    while (!this.eat(end)) {
      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
        octalPosition = this.state.octalPosition;
      }

      const stmt = this.parseStatement(null, topLevel);

      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
        const directive = this.stmtToDirective(stmt);
        directives.push(directive);

        if (oldStrict === undefined && directive.value.value === "use strict") {
          oldStrict = this.state.strict;
          this.setStrict(true);

          if (octalPosition) {
            this.raise(octalPosition, "Octal literal in strict mode");
          }
        }

        continue;
      }

      parsedNonDirective = true;
      body.push(stmt);
    }

    if (oldStrict === false) {
      this.setStrict(false);
    }
  }

  parseFor(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.match(types.semi) ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.match(types.parenR) ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
    this.state.labels.pop();
    return this.finishNode(node, "ForStatement");
  }

  parseForIn(node, init, awaitAt) {
    const type = this.match(types._in) ? "ForInStatement" : "ForOfStatement";

    if (awaitAt > -1) {
      this.eatContextual("of");
    } else {
      this.next();
    }

    if (type === "ForOfStatement") {
      node.await = awaitAt > -1;
    }

    node.left = init;
    node.right = this.parseExpression();
    this.expect(types.parenR);
    node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
    this.state.labels.pop();
    return this.finishNode(node, type);
  }

  parseVar(node, isFor, kind) {
    const declarations = node.declarations = [];
    const isTypescript = this.hasPlugin("typescript");
    node.kind = kind;

    for (;;) {
      const decl = this.startNode();
      this.parseVarId(decl, kind);

      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else {
        if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
          if (!isTypescript) {
            this.unexpected();
          }
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
          this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
        }

        decl.init = null;
      }

      declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) break;
    }

    return node;
  }

  parseVarId(decl, kind) {
    if ((kind === "const" || kind === "let") && this.isContextual("let")) {
      this.unexpected(null, "let is disallowed as a lexically bound name");
    }

    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, true, undefined, "variable declaration");
  }

  parseFunction(node, isStatement, allowExpressionBody = false, isAsync = false, optionalId = false) {
    const oldInFunc = this.state.inFunction;
    const oldInMethod = this.state.inMethod;
    const oldInAsync = this.state.inAsync;
    const oldInGenerator = this.state.inGenerator;
    const oldInClassProperty = this.state.inClassProperty;
    const oldYieldPos = this.state.yieldPos;
    const oldAwaitPos = this.state.awaitPos;
    this.state.inFunction = true;
    this.state.inMethod = false;
    this.state.inClassProperty = false;
    this.state.yieldPos = 0;
    this.state.awaitPos = 0;
    this.initFunction(node, isAsync);
    node.generator = this.eat(types.star);

    if (isStatement && !optionalId && !this.match(types.name)) {
      this.unexpected();
    }

    if (!isStatement) {
      this.state.inAsync = isAsync;
      this.state.inGenerator = node.generator;
    }

    if (this.match(types.name)) {
      node.id = this.parseIdentifier();
    }

    if (isStatement) {
      this.state.inAsync = isAsync;
      this.state.inGenerator = node.generator;
    }

    this.parseFunctionParams(node);
    this.withTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression", allowExpressionBody);
    });
    this.state.inFunction = oldInFunc;
    this.state.inMethod = oldInMethod;
    this.state.inAsync = oldInAsync;
    this.state.inGenerator = oldInGenerator;
    this.state.inClassProperty = oldInClassProperty;
    this.state.yieldPos = oldYieldPos;
    this.state.awaitPos = oldAwaitPos;
    return node;
  }

  parseFunctionParams(node, allowModifiers) {
    const oldInParameters = this.state.inParameters;
    this.state.inParameters = true;
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, allowModifiers);
    this.state.inParameters = oldInParameters;
    this.checkYieldAwaitInDefaultParams();
  }

  parseClass(node, isStatement, optionalId) {
    this.next();
    this.takeDecorators(node);
    const oldStrict = this.state.strict;
    this.state.strict = true;
    this.parseClassId(node, isStatement, optionalId);
    this.parseClassSuper(node);
    this.parseClassBody(node);
    this.state.strict = oldStrict;
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  }

  isClassProperty() {
    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
  }

  isClassMethod() {
    return this.match(types.parenL);
  }

  isNonstaticConstructor(method) {
    return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
  }

  parseClassBody(node) {
    this.state.classLevel++;
    const state = {
      hadConstructor: false
    };
    let decorators = [];
    const classBody = this.startNode();
    classBody.body = [];
    this.expect(types.braceL);
    this.withTopicForbiddingContext(() => {
      while (!this.eat(types.braceR)) {
        if (this.eat(types.semi)) {
          if (decorators.length > 0) {
            this.raise(this.state.lastTokEnd, "Decorators must not be followed by a semicolon");
          }

          continue;
        }

        if (this.match(types.at)) {
          decorators.push(this.parseDecorator());
          continue;
        }

        const member = this.startNode();

        if (decorators.length) {
          member.decorators = decorators;
          this.resetStartLocationFromNode(member, decorators[0]);
          decorators = [];
        }

        this.parseClassMember(classBody, member, state);

        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
          this.raise(member.start, "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?");
        }
      }
    });

    if (decorators.length) {
      this.raise(this.state.start, "You have trailing decorators with no method");
    }

    node.body = this.finishNode(classBody, "ClassBody");
    this.state.classLevel--;
  }

  parseClassMember(classBody, member, state) {
    let isStatic = false;
    const containsEsc = this.state.containsEsc;

    if (this.match(types.name) && this.state.value === "static") {
      const key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        const method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false);
        return;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return;
      } else if (containsEsc) {
        throw this.unexpected();
      }

      isStatic = true;
    }

    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const publicMethod = member;
    const privateMethod = member;
    const publicProp = member;
    const privateProp = member;
    const method = publicMethod;
    const publicMember = publicMethod;
    member.static = isStatic;

    if (this.eat(types.star)) {
      method.kind = "method";
      this.parseClassPropertyName(method);

      if (method.key.type === "PrivateName") {
        this.pushClassPrivateMethod(classBody, privateMethod, true, false);
        return;
      }

      if (this.isNonstaticConstructor(publicMethod)) {
        this.raise(publicMethod.key.start, "Constructor can't be a generator");
      }

      this.pushClassMethod(classBody, publicMethod, true, false, false);
      return;
    }

    const key = this.parseClassPropertyName(member);
    const isPrivate = key.type === "PrivateName";
    const isSimple = key.type === "Identifier";
    this.parsePostMemberNameModifiers(publicMember);

    if (this.isClassMethod()) {
      method.kind = "method";

      if (isPrivate) {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        return;
      }

      const isConstructor = this.isNonstaticConstructor(publicMethod);

      if (isConstructor) {
        publicMethod.kind = "constructor";

        if (publicMethod.decorators) {
          this.raise(publicMethod.start, "You can't attach decorators to a class constructor");
        }

        if (state.hadConstructor && !this.hasPlugin("typescript")) {
          this.raise(key.start, "Duplicate constructor in the same class");
        }

        state.hadConstructor = true;
      }

      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor);
    } else if (this.isClassProperty()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else if (isSimple && key.name === "async" && !this.isLineTerminator()) {
      const isGenerator = this.eat(types.star);
      method.kind = "method";
      this.parseClassPropertyName(method);

      if (method.key.type === "PrivateName") {
        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, "Constructor can't be an async function");
        }

        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false);
      }
    } else if (isSimple && (key.name === "get" || key.name === "set") && !(this.match(types.star) && this.isLineTerminator())) {
      method.kind = key.name;
      this.parseClassPropertyName(publicMethod);

      if (method.key.type === "PrivateName") {
        this.pushClassPrivateMethod(classBody, privateMethod, false, false);
      } else {
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, "Constructor can't have get/set modifier");
        }

        this.pushClassMethod(classBody, publicMethod, false, false, false);
      }

      this.checkGetterSetterParams(publicMethod);
    } else if (this.isLineTerminator()) {
      if (isPrivate) {
        this.pushClassPrivateProperty(classBody, privateProp);
      } else {
        this.pushClassProperty(classBody, publicProp);
      }
    } else {
      this.unexpected();
    }
  }

  parseClassPropertyName(member) {
    const key = this.parsePropertyName(member);

    if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
      this.raise(key.start, "Classes may not have static property named prototype");
    }

    if (key.type === "PrivateName" && key.id.name === "constructor") {
      this.raise(key.start, "Classes may not have a private field named '#constructor'");
    }

    return key;
  }

  pushClassProperty(classBody, prop) {
    if (this.isNonstaticConstructor(prop)) {
      this.raise(prop.key.start, "Classes may not have a non-static field named 'constructor'");
    }

    classBody.body.push(this.parseClassProperty(prop));
  }

  pushClassPrivateProperty(classBody, prop) {
    this.expectPlugin("classPrivateProperties", prop.key.start);
    classBody.body.push(this.parseClassPrivateProperty(prop));
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, "ClassMethod"));
  }

  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    this.expectPlugin("classPrivateMethods", method.key.start);
    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, false, "ClassPrivateMethod"));
  }

  parsePostMemberNameModifiers(methodOrProp) {}

  parseAccessModifier() {
    return undefined;
  }

  parseClassPrivateProperty(node) {
    const oldInMethod = this.state.inMethod;
    this.state.inMethod = false;
    this.state.inClassProperty = true;
    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;
    this.semicolon();
    this.state.inClassProperty = false;
    this.state.inMethod = oldInMethod;
    return this.finishNode(node, "ClassPrivateProperty");
  }

  parseClassProperty(node) {
    if (!node.typeAnnotation) {
      this.expectPlugin("classProperties");
    }

    const oldInMethod = this.state.inMethod;
    this.state.inMethod = false;
    this.state.inClassProperty = true;

    if (this.match(types.eq)) {
      this.expectPlugin("classProperties");
      this.next();
      node.value = this.parseMaybeAssign();
    } else {
      node.value = null;
    }

    this.semicolon();
    this.state.inClassProperty = false;
    this.state.inMethod = oldInMethod;
    return this.finishNode(node, "ClassProperty");
  }

  parseClassId(node, isStatement, optionalId) {
    if (this.match(types.name)) {
      node.id = this.parseIdentifier();
    } else {
      if (optionalId || !isStatement) {
        node.id = null;
      } else {
        this.unexpected(null, "A class name is required");
      }
    }
  }

  parseClassSuper(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  }

  parseExport(node) {
    const hasDefault = this.maybeParseExportDefaultSpecifier(node);
    const parseAfterDefault = !hasDefault || this.eat(types.comma);
    const hasStar = parseAfterDefault && this.eatExportStar(node);
    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
    const isFromRequired = hasDefault || hasStar;

    if (hasStar && !hasNamespace) {
      if (hasDefault) this.unexpected();
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }

    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
      throw this.unexpected(null, types.braceL);
    }

    let hasDeclaration;

    if (isFromRequired || hasSpecifiers) {
      hasDeclaration = false;
      this.parseExportFrom(node, isFromRequired);
    } else {
      hasDeclaration = this.maybeParseExportDeclaration(node);
    }

    if (isFromRequired || hasSpecifiers || hasDeclaration) {
      this.checkExport(node, true);
      return this.finishNode(node, "ExportNamedDeclaration");
    }

    if (this.eat(types._default)) {
      node.declaration = this.parseExportDefaultExpression();
      this.checkExport(node, true, true);
      return this.finishNode(node, "ExportDefaultDeclaration");
    }

    throw this.unexpected(null, types.braceL);
  }

  eatExportStar(node) {
    return this.eat(types.star);
  }

  maybeParseExportDefaultSpecifier(node) {
    if (this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = this.parseIdentifier(true);
      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return true;
    }

    return false;
  }

  maybeParseExportNamespaceSpecifier(node) {
    if (this.isContextual("as")) {
      if (!node.specifiers) node.specifiers = [];
      this.expectPlugin("exportNamespaceFrom");
      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
      this.next();
      specifier.exported = this.parseIdentifier(true);
      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
      return true;
    }

    return false;
  }

  maybeParseExportNamedSpecifiers(node) {
    if (this.match(types.braceL)) {
      if (!node.specifiers) node.specifiers = [];
      node.specifiers.push(...this.parseExportSpecifiers());
      node.source = null;
      node.declaration = null;
      return true;
    }

    return false;
  }

  maybeParseExportDeclaration(node) {
    if (this.shouldParseExportDeclaration()) {
      if (this.isContextual("async")) {
        const next = this.lookahead();

        if (next.type !== types._function) {
          this.unexpected(next.start, `Unexpected token, expected "function"`);
        }
      }

      node.specifiers = [];
      node.source = null;
      node.declaration = this.parseExportDeclaration(node);
      return true;
    }

    return false;
  }

  isAsyncFunction() {
    if (!this.isContextual("async")) return false;
    const {
      input,
      pos,
      length
    } = this.state;
    skipWhiteSpace.lastIndex = pos;
    const skip = skipWhiteSpace.exec(input);
    if (!skip || !skip.length) return false;
    const next = pos + skip[0].length;
    return !lineBreak.test(input.slice(pos, next)) && input.slice(next, next + 8) === "function" && (next + 8 === length || !isIdentifierChar(input.charCodeAt(next + 8)));
  }

  parseExportDefaultExpression() {
    const expr = this.startNode();
    const isAsync = this.isAsyncFunction();

    if (this.eat(types._function) || isAsync) {
      if (isAsync) {
        this.eatContextual("async");
        this.expect(types._function);
      }

      return this.parseFunction(expr, true, false, isAsync, true);
    } else if (this.match(types._class)) {
      return this.parseClass(expr, true, true);
    } else if (this.match(types.at)) {
      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
        this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
      }

      this.parseDecorators(false);
      return this.parseClass(expr, true, true);
    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
      return this.raise(this.state.start, "Only expressions, functions or classes are allowed as the `default` export.");
    } else {
      const res = this.parseMaybeAssign();
      this.semicolon();
      return res;
    }
  }

  parseExportDeclaration(node) {
    return this.parseStatement(null);
  }

  isExportDefaultSpecifier() {
    if (this.match(types.name)) {
      return this.state.value !== "async" && this.state.value !== "let";
    }

    if (!this.match(types._default)) {
      return false;
    }

    const lookahead = this.lookahead();
    return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from";
  }

  parseExportFrom(node, expect) {
    if (this.eatContextual("from")) {
      node.source = this.parseImportSource();
      this.checkExport(node);
    } else {
      if (expect) {
        this.unexpected();
      } else {
        node.source = null;
      }
    }

    this.semicolon();
  }

  shouldParseExportDeclaration() {
    if (this.match(types.at)) {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);

      if (this.hasPlugin("decorators")) {
        if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.unexpected(this.state.start, "Decorators must be placed *before* the 'export' keyword." + " You can set the 'decoratorsBeforeExport' option to false to use" + " the 'export @decorator class {}' syntax");
        } else {
          return true;
        }
      }
    }

    return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
  }

  checkExport(node, checkNames, isDefault) {
    if (checkNames) {
      if (isDefault) {
        this.checkDuplicateExports(node, "default");
      } else if (node.specifiers && node.specifiers.length) {
        for (let _i2 = 0, _node$specifiers = node.specifiers; _i2 < _node$specifiers.length; _i2++) {
          const specifier = _node$specifiers[_i2];
          this.checkDuplicateExports(specifier, specifier.exported.name);
        }
      } else if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          const id = node.declaration.id;
          if (!id) throw new Error("Assertion failure");
          this.checkDuplicateExports(node, id.name);
        } else if (node.declaration.type === "VariableDeclaration") {
          for (let _i3 = 0, _node$declaration$dec = node.declaration.declarations; _i3 < _node$declaration$dec.length; _i3++) {
            const declaration = _node$declaration$dec[_i3];
            this.checkDeclaration(declaration.id);
          }
        }
      }
    }

    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

    if (currentContextDecorators.length) {
      const isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");

      if (!node.declaration || !isClass) {
        throw this.raise(node.start, "You can only use decorators on an export when exporting a class");
      }

      this.takeDecorators(node.declaration);
    }
  }

  checkDeclaration(node) {
    if (node.type === "ObjectPattern") {
      for (let _i4 = 0, _node$properties = node.properties; _i4 < _node$properties.length; _i4++) {
        const prop = _node$properties[_i4];
        this.checkDeclaration(prop);
      }
    } else if (node.type === "ArrayPattern") {
      for (let _i5 = 0, _node$elements = node.elements; _i5 < _node$elements.length; _i5++) {
        const elem = _node$elements[_i5];

        if (elem) {
          this.checkDeclaration(elem);
        }
      }
    } else if (node.type === "ObjectProperty") {
      this.checkDeclaration(node.value);
    } else if (node.type === "RestElement") {
      this.checkDeclaration(node.argument);
    } else if (node.type === "Identifier") {
      this.checkDuplicateExports(node, node.name);
    }
  }

  checkDuplicateExports(node, name) {
    if (this.state.exportedIdentifiers.indexOf(name) > -1) {
      throw this.raise(node.start, name === "default" ? "Only one default export allowed per module." : `\`${name}\` has already been exported. Exported identifiers must be unique.`);
    }

    this.state.exportedIdentifiers.push(name);
  }

  parseExportSpecifiers() {
    const nodes = [];
    let first = true;
    let needsFrom;
    this.expect(types.braceL);

    while (!this.eat(types.braceR)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);
        if (this.eat(types.braceR)) break;
      }

      const isDefault = this.match(types._default);
      if (isDefault && !needsFrom) needsFrom = true;
      const node = this.startNode();
      node.local = this.parseIdentifier(isDefault);
      node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }

    if (needsFrom && !this.isContextual("from")) {
      this.unexpected();
    }

    return nodes;
  }

  parseImport(node) {
    node.specifiers = [];

    if (!this.match(types.string)) {
      const hasDefault = this.maybeParseDefaultImportSpecifier(node);
      const parseNext = !hasDefault || this.eat(types.comma);
      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
      this.expectContextual("from");
    }

    node.source = this.parseImportSource();
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  }

  parseImportSource() {
    if (!this.match(types.string)) this.unexpected();
    return this.parseExprAtom();
  }

  shouldParseDefaultImport(node) {
    return this.match(types.name);
  }

  parseImportSpecifierLocal(node, specifier, type, contextDescription) {
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, contextDescription);
    node.specifiers.push(this.finishNode(specifier, type));
  }

  maybeParseDefaultImportSpecifier(node) {
    if (this.shouldParseDefaultImport(node)) {
      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
      return true;
    }

    return false;
  }

  maybeParseStarImportSpecifier(node) {
    if (this.match(types.star)) {
      const specifier = this.startNode();
      this.next();
      this.expectContextual("as");
      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
      return true;
    }

    return false;
  }

  parseNamedImportSpecifiers(node) {
    let first = true;
    this.expect(types.braceL);

    while (!this.eat(types.braceR)) {
      if (first) {
        first = false;
      } else {
        if (this.eat(types.colon)) {
          this.unexpected(null, "ES2015 named imports do not destructure. " + "Use another statement for destructuring after the import.");
        }

        this.expect(types.comma);
        if (this.eat(types.braceR)) break;
      }

      this.parseImportSpecifier(node);
    }
  }

  parseImportSpecifier(node) {
    const specifier = this.startNode();
    specifier.imported = this.parseIdentifier(true);

    if (this.eatContextual("as")) {
      specifier.local = this.parseIdentifier();
    } else {
      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
      specifier.local = specifier.imported.__clone();
    }

    this.checkLVal(specifier.local, true, undefined, "import specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
  }

}

class Parser extends StatementParser {
  constructor(options, input) {
    options = getOptions(options);
    super(options, input);
    this.options = options;
    this.inModule = this.options.sourceType === "module";
    this.plugins = pluginsMap(this.options.plugins);
    this.filename = options.sourceFilename;
  }

  parse() {
    const file = this.startNode();
    const program = this.startNode();
    this.nextToken();
    return this.parseTopLevel(file, program);
  }

}

function pluginsMap(plugins) {
  const pluginMap = new Map();

  for (let _i = 0; _i < plugins.length; _i++) {
    const plugin = plugins[_i];
    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
    if (!pluginMap.has(name)) pluginMap.set(name, options || {});
  }

  return pluginMap;
}

function nonNull(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`);
  }

  return x;
}

function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}

function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";

    case "boolean":
      return "TSBooleanKeyword";

    case "bigint":
      return "TSBigIntKeyword";

    case "never":
      return "TSNeverKeyword";

    case "number":
      return "TSNumberKeyword";

    case "object":
      return "TSObjectKeyword";

    case "string":
      return "TSStringKeyword";

    case "symbol":
      return "TSSymbolKeyword";

    case "undefined":
      return "TSUndefinedKeyword";

    case "unknown":
      return "TSUnknownKeyword";

    default:
      return undefined;
  }
}

var typescript = (superClass => class extends superClass {
  tsIsIdentifier() {
    return this.match(types.name);
  }

  tsNextTokenCanFollowModifier() {
    this.next();
    return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question);
  }

  tsParseModifier(allowedModifiers) {
    if (!this.match(types.name)) {
      return undefined;
    }

    const modifier = this.state.value;

    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
      return modifier;
    }

    return undefined;
  }

  tsIsListTerminator(kind) {
    switch (kind) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(types.braceR);

      case "HeritageClauseElement":
        return this.match(types.braceL);

      case "TupleElementTypes":
        return this.match(types.bracketR);

      case "TypeParametersOrArguments":
        return this.isRelational(">");
    }

    throw new Error("Unreachable");
  }

  tsParseList(kind, parseElement) {
    const result = [];

    while (!this.tsIsListTerminator(kind)) {
      result.push(parseElement());
    }

    return result;
  }

  tsParseDelimitedList(kind, parseElement) {
    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
  }

  tsTryParseDelimitedList(kind, parseElement) {
    return this.tsParseDelimitedListWorker(kind, parseElement, false);
  }

  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
    const result = [];

    while (true) {
      if (this.tsIsListTerminator(kind)) {
        break;
      }

      const element = parseElement();

      if (element == null) {
        return undefined;
      }

      result.push(element);

      if (this.eat(types.comma)) {
        continue;
      }

      if (this.tsIsListTerminator(kind)) {
        break;
      }

      if (expectSuccess) {
        this.expect(types.comma);
      }

      return undefined;
    }

    return result;
  }

  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
    if (!skipFirstToken) {
      if (bracket) {
        this.expect(types.bracketL);
      } else {
        this.expectRelational("<");
      }
    }

    const result = this.tsParseDelimitedList(kind, parseElement);

    if (bracket) {
      this.expect(types.bracketR);
    } else {
      this.expectRelational(">");
    }

    return result;
  }

  tsParseImportType() {
    const node = this.startNode();
    this.expect(types._import);
    this.expect(types.parenL);

    if (!this.match(types.string)) {
      throw this.unexpected(null, "Argument in a type import must be a string literal");
    }

    node.argument = this.parseLiteral(this.state.value, "StringLiteral");
    this.expect(types.parenR);

    if (this.eat(types.dot)) {
      node.qualifier = this.tsParseEntityName(true);
    }

    if (this.isRelational("<")) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSImportType");
  }

  tsParseEntityName(allowReservedWords) {
    let entity = this.parseIdentifier();

    while (this.eat(types.dot)) {
      const node = this.startNodeAtNode(entity);
      node.left = entity;
      node.right = this.parseIdentifier(allowReservedWords);
      entity = this.finishNode(node, "TSQualifiedName");
    }

    return entity;
  }

  tsParseTypeReference() {
    const node = this.startNode();
    node.typeName = this.tsParseEntityName(false);

    if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSTypeReference");
  }

  tsParseThisTypePredicate(lhs) {
    this.next();
    const node = this.startNodeAtNode(lhs);
    node.parameterName = lhs;
    node.typeAnnotation = this.tsParseTypeAnnotation(false);
    return this.finishNode(node, "TSTypePredicate");
  }

  tsParseThisTypeNode() {
    const node = this.startNode();
    this.next();
    return this.finishNode(node, "TSThisType");
  }

  tsParseTypeQuery() {
    const node = this.startNode();
    this.expect(types._typeof);

    if (this.match(types._import)) {
      node.exprName = this.tsParseImportType();
    } else {
      node.exprName = this.tsParseEntityName(true);
    }

    return this.finishNode(node, "TSTypeQuery");
  }

  tsParseTypeParameter() {
    const node = this.startNode();
    node.name = this.parseIdentifierName(node.start);
    node.constraint = this.tsEatThenParseType(types._extends);
    node.default = this.tsEatThenParseType(types.eq);
    return this.finishNode(node, "TSTypeParameter");
  }

  tsTryParseTypeParameters() {
    if (this.isRelational("<")) {
      return this.tsParseTypeParameters();
    }
  }

  tsParseTypeParameters() {
    const node = this.startNode();

    if (this.isRelational("<") || this.match(types.jsxTagStart)) {
      this.next();
    } else {
      this.unexpected();
    }

    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
    return this.finishNode(node, "TSTypeParameterDeclaration");
  }

  tsFillSignature(returnToken, signature) {
    const returnTokenRequired = returnToken === types.arrow;
    signature.typeParameters = this.tsTryParseTypeParameters();
    this.expect(types.parenL);
    signature.parameters = this.tsParseBindingListForSignature();

    if (returnTokenRequired) {
      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    } else if (this.match(returnToken)) {
      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
    }
  }

  tsParseBindingListForSignature() {
    return this.parseBindingList(types.parenR).map(pattern => {
      if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
        throw this.unexpected(pattern.start, `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${pattern.type}`);
      }

      return pattern;
    });
  }

  tsParseTypeMemberSemicolon() {
    if (!this.eat(types.comma)) {
      this.semicolon();
    }
  }

  tsParseSignatureMember(kind) {
    const node = this.startNode();

    if (kind === "TSConstructSignatureDeclaration") {
      this.expect(types._new);
    }

    this.tsFillSignature(types.colon, node);
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, kind);
  }

  tsIsUnambiguouslyIndexSignature() {
    this.next();
    return this.eat(types.name) && this.match(types.colon);
  }

  tsTryParseIndexSignature(node) {
    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
      return undefined;
    }

    this.expect(types.bracketL);
    const id = this.parseIdentifier();
    id.typeAnnotation = this.tsParseTypeAnnotation();
    this.finishNode(id, "Identifier");
    this.expect(types.bracketR);
    node.parameters = [id];
    const type = this.tsTryParseTypeAnnotation();
    if (type) node.typeAnnotation = type;
    this.tsParseTypeMemberSemicolon();
    return this.finishNode(node, "TSIndexSignature");
  }

  tsParsePropertyOrMethodSignature(node, readonly) {
    this.parsePropertyName(node);
    if (this.eat(types.question)) node.optional = true;
    const nodeAny = node;

    if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
      const method = nodeAny;
      this.tsFillSignature(types.colon, method);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(method, "TSMethodSignature");
    } else {
      const property = nodeAny;
      if (readonly) property.readonly = true;
      const type = this.tsTryParseTypeAnnotation();
      if (type) property.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(property, "TSPropertySignature");
    }
  }

  tsParseTypeMember() {
    if (this.match(types.parenL) || this.isRelational("<")) {
      return this.tsParseSignatureMember("TSCallSignatureDeclaration");
    }

    if (this.match(types._new) && this.tsLookAhead(this.tsIsStartOfConstructSignature.bind(this))) {
      return this.tsParseSignatureMember("TSConstructSignatureDeclaration");
    }

    const node = this.startNode();
    const readonly = !!this.tsParseModifier(["readonly"]);
    const idx = this.tsTryParseIndexSignature(node);

    if (idx) {
      if (readonly) node.readonly = true;
      return idx;
    }

    return this.tsParsePropertyOrMethodSignature(node, readonly);
  }

  tsIsStartOfConstructSignature() {
    this.next();
    return this.match(types.parenL) || this.isRelational("<");
  }

  tsParseTypeLiteral() {
    const node = this.startNode();
    node.members = this.tsParseObjectTypeMembers();
    return this.finishNode(node, "TSTypeLiteral");
  }

  tsParseObjectTypeMembers() {
    this.expect(types.braceL);
    const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    this.expect(types.braceR);
    return members;
  }

  tsIsStartOfMappedType() {
    this.next();

    if (this.eat(types.plusMin)) {
      return this.isContextual("readonly");
    }

    if (this.isContextual("readonly")) {
      this.next();
    }

    if (!this.match(types.bracketL)) {
      return false;
    }

    this.next();

    if (!this.tsIsIdentifier()) {
      return false;
    }

    this.next();
    return this.match(types._in);
  }

  tsParseMappedTypeParameter() {
    const node = this.startNode();
    node.name = this.parseIdentifierName(node.start);
    node.constraint = this.tsExpectThenParseType(types._in);
    return this.finishNode(node, "TSTypeParameter");
  }

  tsParseMappedType() {
    const node = this.startNode();
    this.expect(types.braceL);

    if (this.match(types.plusMin)) {
      node.readonly = this.state.value;
      this.next();
      this.expectContextual("readonly");
    } else if (this.eatContextual("readonly")) {
      node.readonly = true;
    }

    this.expect(types.bracketL);
    node.typeParameter = this.tsParseMappedTypeParameter();
    this.expect(types.bracketR);

    if (this.match(types.plusMin)) {
      node.optional = this.state.value;
      this.next();
      this.expect(types.question);
    } else if (this.eat(types.question)) {
      node.optional = true;
    }

    node.typeAnnotation = this.tsTryParseType();
    this.semicolon();
    this.expect(types.braceR);
    return this.finishNode(node, "TSMappedType");
  }

  tsParseTupleType() {
    const node = this.startNode();
    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let seenOptionalElement = false;
    node.elementTypes.forEach(elementNode => {
      if (elementNode.type === "TSOptionalType") {
        seenOptionalElement = true;
      } else if (seenOptionalElement && elementNode.type !== "TSRestType") {
        this.raise(elementNode.start, "A required element cannot follow an optional element.");
      }
    });
    return this.finishNode(node, "TSTupleType");
  }

  tsParseTupleElementType() {
    if (this.match(types.ellipsis)) {
      const restNode = this.startNode();
      this.next();
      restNode.typeAnnotation = this.tsParseType();
      this.checkCommaAfterRest(types.bracketR, "type");
      return this.finishNode(restNode, "TSRestType");
    }

    const type = this.tsParseType();

    if (this.eat(types.question)) {
      const optionalTypeNode = this.startNodeAtNode(type);
      optionalTypeNode.typeAnnotation = type;
      return this.finishNode(optionalTypeNode, "TSOptionalType");
    }

    return type;
  }

  tsParseParenthesizedType() {
    const node = this.startNode();
    this.expect(types.parenL);
    node.typeAnnotation = this.tsParseType();
    this.expect(types.parenR);
    return this.finishNode(node, "TSParenthesizedType");
  }

  tsParseFunctionOrConstructorType(type) {
    const node = this.startNode();

    if (type === "TSConstructorType") {
      this.expect(types._new);
    }

    this.tsFillSignature(types.arrow, node);
    return this.finishNode(node, type);
  }

  tsParseLiteralTypeNode() {
    const node = this.startNode();

    node.literal = (() => {
      switch (this.state.type) {
        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteral");

        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteral");

        case types._true:
        case types._false:
          return this.parseBooleanLiteral();

        default:
          throw this.unexpected();
      }
    })();

    return this.finishNode(node, "TSLiteralType");
  }

  tsParseNonArrayType() {
    switch (this.state.type) {
      case types.name:
      case types._void:
      case types._null:
        {
          const type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

          if (type !== undefined && this.lookahead().type !== types.dot) {
            const node = this.startNode();
            this.next();
            return this.finishNode(node, type);
          }

          return this.tsParseTypeReference();
        }

      case types.string:
      case types.num:
      case types._true:
      case types._false:
        return this.tsParseLiteralTypeNode();

      case types.plusMin:
        if (this.state.value === "-") {
          const node = this.startNode();
          this.next();

          if (!this.match(types.num)) {
            throw this.unexpected();
          }

          node.literal = this.parseLiteral(-this.state.value, "NumericLiteral", node.start, node.loc.start);
          return this.finishNode(node, "TSLiteralType");
        }

        break;

      case types._this:
        {
          const thisKeyword = this.tsParseThisTypeNode();

          if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }

      case types._typeof:
        return this.tsParseTypeQuery();

      case types._import:
        return this.tsParseImportType();

      case types.braceL:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

      case types.bracketL:
        return this.tsParseTupleType();

      case types.parenL:
        return this.tsParseParenthesizedType();
    }

    throw this.unexpected();
  }

  tsParseArrayTypeOrHigher() {
    let type = this.tsParseNonArrayType();

    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
      if (this.match(types.bracketR)) {
        const node = this.startNodeAtNode(type);
        node.elementType = type;
        this.expect(types.bracketR);
        type = this.finishNode(node, "TSArrayType");
      } else {
        const node = this.startNodeAtNode(type);
        node.objectType = type;
        node.indexType = this.tsParseType();
        this.expect(types.bracketR);
        type = this.finishNode(node, "TSIndexedAccessType");
      }
    }

    return type;
  }

  tsParseTypeOperator(operator) {
    const node = this.startNode();
    this.expectContextual(operator);
    node.operator = operator;
    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
    return this.finishNode(node, "TSTypeOperator");
  }

  tsParseInferType() {
    const node = this.startNode();
    this.expectContextual("infer");
    const typeParameter = this.startNode();
    typeParameter.name = this.parseIdentifierName(typeParameter.start);
    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
    return this.finishNode(node, "TSInferType");
  }

  tsParseTypeOperatorOrHigher() {
    const operator = ["keyof", "unique"].find(kw => this.isContextual(kw));
    return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
  }

  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
    this.eat(operator);
    let type = parseConstituentType();

    if (this.match(operator)) {
      const types$$1 = [type];

      while (this.eat(operator)) {
        types$$1.push(parseConstituentType());
      }

      const node = this.startNodeAtNode(type);
      node.types = types$$1;
      type = this.finishNode(node, kind);
    }

    return type;
  }

  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
  }

  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
  }

  tsIsStartOfFunctionType() {
    if (this.isRelational("<")) {
      return true;
    }

    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }

  tsSkipParameterStart() {
    if (this.match(types.name) || this.match(types._this)) {
      this.next();
      return true;
    }

    if (this.match(types.braceL)) {
      let braceStackCounter = 1;
      this.next();

      while (braceStackCounter > 0) {
        if (this.match(types.braceL)) {
          ++braceStackCounter;
        } else if (this.match(types.braceR)) {
          --braceStackCounter;
        }

        this.next();
      }

      return true;
    }

    if (this.match(types.bracketL)) {
      let braceStackCounter = 1;
      this.next();

      while (braceStackCounter > 0) {
        if (this.match(types.bracketL)) {
          ++braceStackCounter;
        } else if (this.match(types.bracketR)) {
          --braceStackCounter;
        }

        this.next();
      }

      return true;
    }

    return false;
  }

  tsIsUnambiguouslyStartOfFunctionType() {
    this.next();

    if (this.match(types.parenR) || this.match(types.ellipsis)) {
      return true;
    }

    if (this.tsSkipParameterStart()) {
      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
        return true;
      }

      if (this.match(types.parenR)) {
        this.next();

        if (this.match(types.arrow)) {
          return true;
        }
      }
    }

    return false;
  }

  tsParseTypeOrTypePredicateAnnotation(returnToken) {
    return this.tsInType(() => {
      const t = this.startNode();
      this.expect(returnToken);
      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));

      if (!typePredicateVariable) {
        return this.tsParseTypeAnnotation(false, t);
      }

      const type = this.tsParseTypeAnnotation(false);
      const node = this.startNodeAtNode(typePredicateVariable);
      node.parameterName = typePredicateVariable;
      node.typeAnnotation = type;
      t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
      return this.finishNode(t, "TSTypeAnnotation");
    });
  }

  tsTryParseTypeOrTypePredicateAnnotation() {
    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
  }

  tsTryParseTypeAnnotation() {
    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
  }

  tsTryParseType() {
    return this.tsEatThenParseType(types.colon);
  }

  tsParseTypePredicatePrefix() {
    const id = this.parseIdentifier();

    if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
      this.next();
      return id;
    }
  }

  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
    this.tsInType(() => {
      if (eatColon) this.expect(types.colon);
      t.typeAnnotation = this.tsParseType();
    });
    return this.finishNode(t, "TSTypeAnnotation");
  }

  tsParseType() {
    assert(this.state.inType);
    const type = this.tsParseNonConditionalType();

    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
      return type;
    }

    const node = this.startNodeAtNode(type);
    node.checkType = type;
    node.extendsType = this.tsParseNonConditionalType();
    this.expect(types.question);
    node.trueType = this.tsParseType();
    this.expect(types.colon);
    node.falseType = this.tsParseType();
    return this.finishNode(node, "TSConditionalType");
  }

  tsParseNonConditionalType() {
    if (this.tsIsStartOfFunctionType()) {
      return this.tsParseFunctionOrConstructorType("TSFunctionType");
    }

    if (this.match(types._new)) {
      return this.tsParseFunctionOrConstructorType("TSConstructorType");
    }

    return this.tsParseUnionTypeOrHigher();
  }

  tsParseTypeAssertion() {
    const node = this.startNode();
    this.next();
    node.typeAnnotation = this.tsInType(() => this.tsParseType());
    this.expectRelational(">");
    node.expression = this.parseMaybeUnary();
    return this.finishNode(node, "TSTypeAssertion");
  }

  tsParseHeritageClause(descriptor) {
    const originalStart = this.state.start;
    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

    if (!delimitedList.length) {
      this.raise(originalStart, `'${descriptor}' list cannot be empty.`);
    }

    return delimitedList;
  }

  tsParseExpressionWithTypeArguments() {
    const node = this.startNode();
    node.expression = this.tsParseEntityName(false);

    if (this.isRelational("<")) {
      node.typeParameters = this.tsParseTypeArguments();
    }

    return this.finishNode(node, "TSExpressionWithTypeArguments");
  }

  tsParseInterfaceDeclaration(node) {
    node.id = this.parseIdentifier();
    node.typeParameters = this.tsTryParseTypeParameters();

    if (this.eat(types._extends)) {
      node.extends = this.tsParseHeritageClause("extends");
    }

    const body = this.startNode();
    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
    node.body = this.finishNode(body, "TSInterfaceBody");
    return this.finishNode(node, "TSInterfaceDeclaration");
  }

  tsParseTypeAliasDeclaration(node) {
    node.id = this.parseIdentifier();
    node.typeParameters = this.tsTryParseTypeParameters();
    node.typeAnnotation = this.tsExpectThenParseType(types.eq);
    this.semicolon();
    return this.finishNode(node, "TSTypeAliasDeclaration");
  }

  tsInNoContext(cb) {
    const oldContext = this.state.context;
    this.state.context = [oldContext[0]];

    try {
      return cb();
    } finally {
      this.state.context = oldContext;
    }
  }

  tsInType(cb) {
    const oldInType = this.state.inType;
    this.state.inType = true;

    try {
      return cb();
    } finally {
      this.state.inType = oldInType;
    }
  }

  tsEatThenParseType(token) {
    return !this.match(token) ? undefined : this.tsNextThenParseType();
  }

  tsExpectThenParseType(token) {
    return this.tsDoThenParseType(() => this.expect(token));
  }

  tsNextThenParseType() {
    return this.tsDoThenParseType(() => this.next());
  }

  tsDoThenParseType(cb) {
    return this.tsInType(() => {
      cb();
      return this.tsParseType();
    });
  }

  tsParseEnumMember() {
    const node = this.startNode();
    node.id = this.match(types.string) ? this.parseLiteral(this.state.value, "StringLiteral") : this.parseIdentifier(true);

    if (this.eat(types.eq)) {
      node.initializer = this.parseMaybeAssign();
    }

    return this.finishNode(node, "TSEnumMember");
  }

  tsParseEnumDeclaration(node, isConst) {
    if (isConst) node.const = true;
    node.id = this.parseIdentifier();
    this.expect(types.braceL);
    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
    this.expect(types.braceR);
    return this.finishNode(node, "TSEnumDeclaration");
  }

  tsParseModuleBlock() {
    const node = this.startNode();
    this.expect(types.braceL);
    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
    return this.finishNode(node, "TSModuleBlock");
  }

  tsParseModuleOrNamespaceDeclaration(node) {
    node.id = this.parseIdentifier();

    if (this.eat(types.dot)) {
      const inner = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(inner);
      node.body = inner;
    } else {
      node.body = this.tsParseModuleBlock();
    }

    return this.finishNode(node, "TSModuleDeclaration");
  }

  tsParseAmbientExternalModuleDeclaration(node) {
    if (this.isContextual("global")) {
      node.global = true;
      node.id = this.parseIdentifier();
    } else if (this.match(types.string)) {
      node.id = this.parseExprAtom();
    } else {
      this.unexpected();
    }

    if (this.match(types.braceL)) {
      node.body = this.tsParseModuleBlock();
    } else {
      this.semicolon();
    }

    return this.finishNode(node, "TSModuleDeclaration");
  }

  tsParseImportEqualsDeclaration(node, isExport) {
    node.isExport = isExport || false;
    node.id = this.parseIdentifier();
    this.expect(types.eq);
    node.moduleReference = this.tsParseModuleReference();
    this.semicolon();
    return this.finishNode(node, "TSImportEqualsDeclaration");
  }

  tsIsExternalModuleReference() {
    return this.isContextual("require") && this.lookahead().type === types.parenL;
  }

  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
  }

  tsParseExternalModuleReference() {
    const node = this.startNode();
    this.expectContextual("require");
    this.expect(types.parenL);

    if (!this.match(types.string)) {
      throw this.unexpected();
    }

    node.expression = this.parseLiteral(this.state.value, "StringLiteral");
    this.expect(types.parenR);
    return this.finishNode(node, "TSExternalModuleReference");
  }

  tsLookAhead(f) {
    const state = this.state.clone();
    const res = f();
    this.state = state;
    return res;
  }

  tsTryParseAndCatch(f) {
    const state = this.state.clone();

    try {
      return f();
    } catch (e) {
      if (e instanceof SyntaxError) {
        this.state = state;
        return undefined;
      }

      throw e;
    }
  }

  tsTryParse(f) {
    const state = this.state.clone();
    const result = f();

    if (result !== undefined && result !== false) {
      return result;
    } else {
      this.state = state;
      return undefined;
    }
  }

  nodeWithSamePosition(original, type) {
    const node = this.startNodeAtNode(original);
    node.type = type;
    node.end = original.end;
    node.loc.end = original.loc.end;

    if (original.leadingComments) {
      node.leadingComments = original.leadingComments;
    }

    if (original.trailingComments) {
      node.trailingComments = original.trailingComments;
    }

    if (original.innerComments) node.innerComments = original.innerComments;
    return node;
  }

  tsTryParseDeclare(nany) {
    if (this.isLineTerminator()) {
      return;
    }

    let starttype = this.state.type;
    let kind;

    if (this.isContextual("let")) {
      starttype = types._var;
      kind = "let";
    }

    switch (starttype) {
      case types._function:
        this.next();
        return this.parseFunction(nany, true);

      case types._class:
        return this.parseClass(nany, true, false);

      case types._const:
        if (this.match(types._const) && this.isLookaheadContextual("enum")) {
          this.expect(types._const);
          this.expectContextual("enum");
          return this.tsParseEnumDeclaration(nany, true);
        }

      case types._var:
        kind = kind || this.state.value;
        return this.parseVarStatement(nany, kind);

      case types.name:
        {
          const value = this.state.value;

          if (value === "global") {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          } else {
            return this.tsParseDeclaration(nany, value, true);
          }
        }
    }
  }

  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, true);
  }

  tsParseExpressionStatement(node, expr) {
    switch (expr.name) {
      case "declare":
        {
          const declaration = this.tsTryParseDeclare(node);

          if (declaration) {
            declaration.declare = true;
            return declaration;
          }

          break;
        }

      case "global":
        if (this.match(types.braceL)) {
          const mod = node;
          mod.global = true;
          mod.id = expr;
          mod.body = this.tsParseModuleBlock();
          return this.finishNode(mod, "TSModuleDeclaration");
        }

        break;

      default:
        return this.tsParseDeclaration(node, expr.name, false);
    }
  }

  tsParseDeclaration(node, value, next) {
    switch (value) {
      case "abstract":
        if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
          const cls = node;
          cls.abstract = true;

          if (next) {
            this.next();

            if (!this.match(types._class)) {
              this.unexpected(null, types._class);
            }
          }

          return this.parseClass(cls, true, false);
        }

        break;

      case "enum":
        if (next || this.match(types.name)) {
          if (next) this.next();
          return this.tsParseEnumDeclaration(node, false);
        }

        break;

      case "interface":
        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          if (next) this.next();
          return this.tsParseInterfaceDeclaration(node);
        }

        break;

      case "module":
        if (next) this.next();

        if (this.match(types.string)) {
          return this.tsParseAmbientExternalModuleDeclaration(node);
        } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          return this.tsParseModuleOrNamespaceDeclaration(node);
        }

        break;

      case "namespace":
        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          if (next) this.next();
          return this.tsParseModuleOrNamespaceDeclaration(node);
        }

        break;

      case "type":
        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
          if (next) this.next();
          return this.tsParseTypeAliasDeclaration(node);
        }

        break;
    }
  }

  tsCheckLineTerminatorAndMatch(tokenType, next) {
    return (next || this.match(tokenType)) && !this.isLineTerminator();
  }

  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
    const res = this.tsTryParseAndCatch(() => {
      const node = this.startNodeAt(startPos, startLoc);
      node.typeParameters = this.tsParseTypeParameters();
      super.parseFunctionParams(node);
      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
      this.expect(types.arrow);
      return node;
    });

    if (!res) {
      return undefined;
    }

    const oldInAsync = this.state.inAsync;
    const oldInGenerator = this.state.inGenerator;
    this.state.inAsync = true;
    this.state.inGenerator = false;
    res.id = null;
    res.generator = false;
    res.expression = true;
    res.async = true;
    this.parseFunctionBody(res, true);
    this.state.inAsync = oldInAsync;
    this.state.inGenerator = oldInGenerator;
    return this.finishNode(res, "ArrowFunctionExpression");
  }

  tsParseTypeArguments() {
    const node = this.startNode();
    node.params = this.tsInType(() => this.tsInNoContext(() => {
      this.expectRelational("<");
      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
    }));
    this.state.exprAllowed = false;
    this.expectRelational(">");
    return this.finishNode(node, "TSTypeParameterInstantiation");
  }

  tsIsDeclarationStart() {
    if (this.match(types.name)) {
      switch (this.state.value) {
        case "abstract":
        case "declare":
        case "enum":
        case "interface":
        case "module":
        case "namespace":
        case "type":
          return true;
      }
    }

    return false;
  }

  isExportDefaultSpecifier() {
    if (this.tsIsDeclarationStart()) return false;
    return super.isExportDefaultSpecifier();
  }

  parseAssignableListItem(allowModifiers, decorators) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    let accessibility;
    let readonly = false;

    if (allowModifiers) {
      accessibility = this.parseAccessModifier();
      readonly = !!this.tsParseModifier(["readonly"]);
    }

    const left = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(left);
    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

    if (accessibility || readonly) {
      const pp = this.startNodeAt(startPos, startLoc);

      if (decorators.length) {
        pp.decorators = decorators;
      }

      if (accessibility) pp.accessibility = accessibility;
      if (readonly) pp.readonly = readonly;

      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
        throw this.raise(pp.start, "A parameter property may not be declared using a binding pattern.");
      }

      pp.parameter = elt;
      return this.finishNode(pp, "TSParameterProperty");
    }

    if (decorators.length) {
      left.decorators = decorators;
    }

    return elt;
  }

  parseFunctionBodyAndFinish(node, type, allowExpressionBody) {
    if (!allowExpressionBody && this.match(types.colon)) {
      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
    }

    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
      this.finishNode(node, bodilessType);
      return;
    }

    super.parseFunctionBodyAndFinish(node, type, allowExpressionBody);
  }

  parseSubscript(base, startPos, startLoc, noCalls, state) {
    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
      this.state.exprAllowed = false;
      this.next();
      const nonNullExpression = this.startNodeAt(startPos, startLoc);
      nonNullExpression.expression = base;
      return this.finishNode(nonNullExpression, "TSNonNullExpression");
    }

    if (this.isRelational("<")) {
      const result = this.tsTryParseAndCatch(() => {
        if (!noCalls && this.atPossibleAsync(base)) {
          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

          if (asyncArrowFn) {
            return asyncArrowFn;
          }
        }

        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        const typeArguments = this.tsParseTypeArguments();

        if (typeArguments) {
          if (!noCalls && this.eat(types.parenL)) {
            node.arguments = this.parseCallExpressionArguments(types.parenR, false);
            node.typeParameters = typeArguments;
            return this.finishCallExpression(node);
          } else if (this.match(types.backQuote)) {
            return this.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
          }
        }

        this.unexpected();
      });
      if (result) return result;
    }

    return super.parseSubscript(base, startPos, startLoc, noCalls, state);
  }

  parseNewArguments(node) {
    if (this.isRelational("<")) {
      const typeParameters = this.tsTryParseAndCatch(() => {
        const args = this.tsParseTypeArguments();
        if (!this.match(types.parenL)) this.unexpected();
        return args;
      });

      if (typeParameters) {
        node.typeParameters = typeParameters;
      }
    }

    super.parseNewArguments(node);
  }

  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
      const node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.expression = left;
      node.typeAnnotation = this.tsNextThenParseType();
      this.finishNode(node, "TSAsExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }

    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);
  }

  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}

  checkDuplicateExports() {}

  parseImport(node) {
    if (this.match(types.name) && this.lookahead().type === types.eq) {
      return this.tsParseImportEqualsDeclaration(node);
    }

    return super.parseImport(node);
  }

  parseExport(node) {
    if (this.match(types._import)) {
      this.expect(types._import);
      return this.tsParseImportEqualsDeclaration(node, true);
    } else if (this.eat(types.eq)) {
      const assign = node;
      assign.expression = this.parseExpression();
      this.semicolon();
      return this.finishNode(assign, "TSExportAssignment");
    } else if (this.eatContextual("as")) {
      const decl = node;
      this.expectContextual("namespace");
      decl.id = this.parseIdentifier();
      this.semicolon();
      return this.finishNode(decl, "TSNamespaceExportDeclaration");
    } else {
      return super.parseExport(node);
    }
  }

  isAbstractClass() {
    return this.isContextual("abstract") && this.lookahead().type === types._class;
  }

  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const cls = this.startNode();
      this.next();
      this.parseClass(cls, true, true);
      cls.abstract = true;
      return cls;
    }

    if (this.state.value === "interface") {
      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
      if (result) return result;
    }

    return super.parseExportDefaultExpression();
  }

  parseStatementContent(context, topLevel) {
    if (this.state.type === types._const) {
      const ahead = this.lookahead();

      if (ahead.type === types.name && ahead.value === "enum") {
        const node = this.startNode();
        this.expect(types._const);
        this.expectContextual("enum");
        return this.tsParseEnumDeclaration(node, true);
      }
    }

    return super.parseStatementContent(context, topLevel);
  }

  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }

  parseClassMember(classBody, member, state) {
    const accessibility = this.parseAccessModifier();
    if (accessibility) member.accessibility = accessibility;
    super.parseClassMember(classBody, member, state);
  }

  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
    const methodOrProp = member;
    const prop = member;
    const propOrIdx = member;
    let abstract = false,
        readonly = false;
    const mod = this.tsParseModifier(["abstract", "readonly"]);

    switch (mod) {
      case "readonly":
        readonly = true;
        abstract = !!this.tsParseModifier(["abstract"]);
        break;

      case "abstract":
        abstract = true;
        readonly = !!this.tsParseModifier(["readonly"]);
        break;
    }

    if (abstract) methodOrProp.abstract = true;
    if (readonly) propOrIdx.readonly = true;

    if (!abstract && !isStatic && !methodOrProp.accessibility) {
      const idx = this.tsTryParseIndexSignature(member);

      if (idx) {
        classBody.body.push(idx);
        return;
      }
    }

    if (readonly) {
      methodOrProp.static = isStatic;
      this.parseClassPropertyName(prop);
      this.parsePostMemberNameModifiers(methodOrProp);
      this.pushClassProperty(classBody, prop);
      return;
    }

    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
  }

  parsePostMemberNameModifiers(methodOrProp) {
    const optional = this.eat(types.question);
    if (optional) methodOrProp.optional = true;
  }

  parseExpressionStatement(node, expr) {
    const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
    return decl || super.parseExpressionStatement(node, expr);
  }

  shouldParseExportDeclaration() {
    if (this.tsIsDeclarationStart()) return true;
    return super.shouldParseExportDeclaration();
  }

  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
    if (!refNeedsArrowPos || !this.match(types.question)) {
      return super.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
    }

    const state = this.state.clone();

    try {
      return super.parseConditional(expr, noIn, startPos, startLoc);
    } catch (err) {
      if (!(err instanceof SyntaxError)) {
        throw err;
      }

      this.state = state;
      refNeedsArrowPos.start = err.pos || this.state.start;
      return expr;
    }
  }

  parseParenItem(node, startPos, startLoc) {
    node = super.parseParenItem(node, startPos, startLoc);

    if (this.eat(types.question)) {
      node.optional = true;
    }

    if (this.match(types.colon)) {
      const typeCastNode = this.startNodeAt(startPos, startLoc);
      typeCastNode.expression = node;
      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
      return this.finishNode(typeCastNode, "TSTypeCastExpression");
    }

    return this.finishNode(node, node.type);
  }

  parseExportDeclaration(node) {
    const startPos = this.state.start;
    const startLoc = this.state.startLoc;
    const isDeclare = this.eatContextual("declare");
    let declaration;

    if (this.match(types.name)) {
      declaration = this.tsTryParseExportDeclaration();
    }

    if (!declaration) {
      declaration = super.parseExportDeclaration(node);
    }

    if (declaration && isDeclare) {
      this.resetStartLocation(declaration, startPos, startLoc);
      declaration.declare = true;
    }

    return declaration;
  }

  parseClassId(node, isStatement, optionalId) {
    if ((!isStatement || optionalId) && this.isContextual("implements")) {
      return;
    }

    super.parseClassId(...arguments);
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) node.typeParameters = typeParameters;
  }

  parseClassProperty(node) {
    if (!node.optional && this.eat(types.bang)) {
      node.definite = true;
    }

    const type = this.tsTryParseTypeAnnotation();
    if (type) node.typeAnnotation = type;
    return super.parseClassProperty(node);
  }

  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) method.typeParameters = typeParameters;
    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor);
  }

  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) method.typeParameters = typeParameters;
    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
  }

  parseClassSuper(node) {
    super.parseClassSuper(node);

    if (node.superClass && this.isRelational("<")) {
      node.superTypeParameters = this.tsParseTypeArguments();
    }

    if (this.eatContextual("implements")) {
      node.implements = this.tsParseHeritageClause("implements");
    }
  }

  parseObjPropValue(prop, ...args) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) prop.typeParameters = typeParameters;
    super.parseObjPropValue(prop, ...args);
  }

  parseFunctionParams(node, allowModifiers) {
    const typeParameters = this.tsTryParseTypeParameters();
    if (typeParameters) node.typeParameters = typeParameters;
    super.parseFunctionParams(node, allowModifiers);
  }

  parseVarId(decl, kind) {
    super.parseVarId(decl, kind);

    if (decl.id.type === "Identifier" && this.eat(types.bang)) {
      decl.definite = true;
    }

    const type = this.tsTryParseTypeAnnotation();

    if (type) {
      decl.id.typeAnnotation = type;
      this.finishNode(decl.id, decl.id.type);
    }
  }

  parseAsyncArrowFromCallExpression(node, call) {
    if (this.match(types.colon)) {
      node.returnType = this.tsParseTypeAnnotation();
    }

    return super.parseAsyncArrowFromCallExpression(node, call);
  }

  parseMaybeAssign(...args) {
    let jsxError;

    if (this.match(types.jsxTagStart)) {
      const context = this.curContext();
      assert(context === types$1.j_oTag);
      assert(this.state.context[this.state.context.length - 2] === types$1.j_expr);
      const state = this.state.clone();

      try {
        return super.parseMaybeAssign(...args);
      } catch (err) {
        if (!(err instanceof SyntaxError)) {
          throw err;
        }

        this.state = state;
        assert(this.curContext() === types$1.j_oTag);
        this.state.context.pop();
        assert(this.curContext() === types$1.j_expr);
        this.state.context.pop();
        jsxError = err;
      }
    }

    if (jsxError === undefined && !this.isRelational("<")) {
      return super.parseMaybeAssign(...args);
    }

    let arrowExpression;
    let typeParameters;
    const state = this.state.clone();

    try {
      typeParameters = this.tsParseTypeParameters();
      arrowExpression = super.parseMaybeAssign(...args);

      if (arrowExpression.type !== "ArrowFunctionExpression") {
        this.unexpected();
      }
    } catch (err) {
      if (!(err instanceof SyntaxError)) {
        throw err;
      }

      if (jsxError) {
        throw jsxError;
      }

      assert(!this.hasPlugin("jsx"));
      this.state = state;
      return super.parseMaybeAssign(...args);
    }

    if (typeParameters && typeParameters.params.length !== 0) {
      this.resetStartLocationFromNode(arrowExpression, typeParameters);
    }

    arrowExpression.typeParameters = typeParameters;
    return arrowExpression;
  }

  parseMaybeUnary(refShorthandDefaultPos) {
    if (!this.hasPlugin("jsx") && this.isRelational("<")) {
      return this.tsParseTypeAssertion();
    } else {
      return super.parseMaybeUnary(refShorthandDefaultPos);
    }
  }

  parseArrow(node) {
    if (this.match(types.colon)) {
      const state = this.state.clone();

      try {
        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
        if (this.canInsertSemicolon()) this.unexpected();
        if (!this.match(types.arrow)) this.unexpected();
        node.returnType = returnType;
      } catch (err) {
        if (err instanceof SyntaxError) {
          this.state = state;
        } else {
          throw err;
        }
      }
    }

    return super.parseArrow(node);
  }

  parseAssignableListItemTypes(param) {
    if (this.eat(types.question)) {
      if (param.type !== "Identifier") {
        throw this.raise(param.start, "A binding pattern parameter cannot be optional in an implementation signature.");
      }

      param.optional = true;
    }

    const type = this.tsTryParseTypeAnnotation();
    if (type) param.typeAnnotation = type;
    return this.finishNode(param, param.type);
  }

  toAssignable(node, isBinding, contextDescription) {
    switch (node.type) {
      case "TSTypeCastExpression":
        return super.toAssignable(this.typeCastToParameter(node), isBinding, contextDescription);

      case "TSParameterProperty":
        return super.toAssignable(node, isBinding, contextDescription);

      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        node.expression = this.toAssignable(node.expression, isBinding, contextDescription);
        return node;

      default:
        return super.toAssignable(node, isBinding, contextDescription);
    }
  }

  checkLVal(expr, isBinding, checkClashes, contextDescription) {
    switch (expr.type) {
      case "TSTypeCastExpression":
        return;

      case "TSParameterProperty":
        this.checkLVal(expr.parameter, isBinding, checkClashes, "parameter property");
        return;

      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        this.checkLVal(expr.expression, isBinding, checkClashes, contextDescription);
        return;

      default:
        super.checkLVal(expr, isBinding, checkClashes, contextDescription);
        return;
    }
  }

  parseBindingAtom() {
    switch (this.state.type) {
      case types._this:
        return this.parseIdentifier(true);

      default:
        return super.parseBindingAtom();
    }
  }

  parseMaybeDecoratorArguments(expr) {
    if (this.isRelational("<")) {
      const typeArguments = this.tsParseTypeArguments();

      if (this.match(types.parenL)) {
        const call = super.parseMaybeDecoratorArguments(expr);
        call.typeParameters = typeArguments;
        return call;
      }

      this.unexpected(this.state.start, types.parenL);
    }

    return super.parseMaybeDecoratorArguments(expr);
  }

  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }

  isClassProperty() {
    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();
  }

  parseMaybeDefault(...args) {
    const node = super.parseMaybeDefault(...args);

    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
      this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, " + "e.g. instead of `age = 25: number` use `age: number = 25`");
    }

    return node;
  }

  getTokenFromCode(code) {
    if (this.state.inType && (code === 62 || code === 60)) {
      return this.finishOp(types.relational, 1);
    } else {
      return super.getTokenFromCode(code);
    }
  }

  toAssignableList(exprList, isBinding, contextDescription) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];

      if (expr && expr.type === "TSTypeCastExpression") {
        exprList[i] = this.typeCastToParameter(expr);
      }
    }

    return super.toAssignableList(exprList, isBinding, contextDescription);
  }

  typeCastToParameter(node) {
    node.expression.typeAnnotation = node.typeAnnotation;
    return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
  }

  toReferencedList(exprList, isInParens) {
    for (let i = 0; i < exprList.length; i++) {
      const expr = exprList[i];

      if (expr && expr._exprListItem && expr.type === "TsTypeCastExpression") {
        this.raise(expr.start, "Did not expect a type annotation here.");
      }
    }

    return exprList;
  }

  shouldParseArrow() {
    return this.match(types.colon) || super.shouldParseArrow();
  }

  shouldParseAsyncArrow() {
    return this.match(types.colon) || super.shouldParseAsyncArrow();
  }

  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }

  jsxParseOpeningElementAfterName(node) {
    const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
    if (typeArguments) node.typeParameters = typeArguments;
    return super.jsxParseOpeningElementAfterName(node);
  }

});

function hasPlugin(plugins, name) {
  return plugins.some(plugin => {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });
}
function getPluginOption(plugins, name, option) {
  const plugin = plugins.find(plugin => {
    if (Array.isArray(plugin)) {
      return plugin[0] === name;
    } else {
      return plugin === name;
    }
  });

  if (plugin && Array.isArray(plugin)) {
    return plugin[1][option];
  }

  return null;
}
const PIPELINE_PROPOSALS = ["minimal", "smart"];
function validatePlugins(plugins) {
  if (hasPlugin(plugins, "decorators")) {
    if (hasPlugin(plugins, "decorators-legacy")) {
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    }

    const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

    if (decoratorsBeforeExport == null) {
      throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
    } else if (typeof decoratorsBeforeExport !== "boolean") {
      throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
  }

  if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
    throw new Error("Cannot combine flow and typescript plugins.");
  }

  if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
    throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(", "));
  }
}
const mixinPluginNames = ["estree", "jsx", "flow", "typescript"];
const mixinPlugins = {
  estree,
  jsx,
  flow,
  typescript
};

function parse(input, options) {
  if (options && options.sourceType === "unambiguous") {
    options = Object.assign({}, options);

    try {
      options.sourceType = "module";
      const parser = getParser(options, input);
      const ast = parser.parse();
      if (!parser.sawUnambiguousESM) ast.program.sourceType = "script";
      return ast;
    } catch (moduleError) {
      try {
        options.sourceType = "script";
        return getParser(options, input).parse();
      } catch (scriptError) {}

      throw moduleError;
    }
  } else {
    return getParser(options, input).parse();
  }
}
function parseExpression(input, options) {
  const parser = getParser(options, input);

  if (parser.options.strictMode) {
    parser.state.strict = true;
  }

  return parser.getExpression();
}
function getParser(options, input) {
  let cls = Parser;

  if (options && options.plugins) {
    validatePlugins(options.plugins);
    cls = getParserClass(options.plugins);
  }

  return new cls(options, input);
}

const parserClassCache = {};

function getParserClass(pluginsFromOptions) {
  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));
  const key = pluginList.join("/");
  let cls = parserClassCache[key];

  if (!cls) {
    cls = Parser;

    for (let _i = 0; _i < pluginList.length; _i++) {
      const plugin = pluginList[_i];
      cls = mixinPlugins[plugin](cls);
    }

    parserClassCache[key] = cls;
  }

  return cls;
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.codeFrameColumns = codeFrameColumns;
exports.default = _default;

function _highlight() {
  const data = _interopRequireWildcard(__webpack_require__(249));

  _highlight = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

let deprecationWarningShown = false;

function getDefs(chalk) {
  return {
    gutter: chalk.grey,
    marker: chalk.red.bold,
    message: chalk.red.bold
  };
}

const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

function getMarkerLines(loc, source, opts) {
  const startLoc = Object.assign({
    column: 0,
    line: -1
  }, loc.start);
  const endLoc = Object.assign({}, startLoc, loc.end);
  const {
    linesAbove = 2,
    linesBelow = 3
  } = opts || {};
  const startLine = startLoc.line;
  const startColumn = startLoc.column;
  const endLine = endLoc.line;
  const endColumn = endLoc.column;
  let start = Math.max(startLine - (linesAbove + 1), 0);
  let end = Math.min(source.length, endLine + linesBelow);

  if (startLine === -1) {
    start = 0;
  }

  if (endLine === -1) {
    end = source.length;
  }

  const lineDiff = endLine - startLine;
  const markerLines = {};

  if (lineDiff) {
    for (let i = 0; i <= lineDiff; i++) {
      const lineNumber = i + startLine;

      if (!startColumn) {
        markerLines[lineNumber] = true;
      } else if (i === 0) {
        const sourceLength = source[lineNumber - 1].length;
        markerLines[lineNumber] = [startColumn, sourceLength - startColumn];
      } else if (i === lineDiff) {
        markerLines[lineNumber] = [0, endColumn];
      } else {
        const sourceLength = source[lineNumber - i].length;
        markerLines[lineNumber] = [0, sourceLength];
      }
    }
  } else {
    if (startColumn === endColumn) {
      if (startColumn) {
        markerLines[startLine] = [startColumn, 0];
      } else {
        markerLines[startLine] = true;
      }
    } else {
      markerLines[startLine] = [startColumn, endColumn - startColumn];
    }
  }

  return {
    start,
    end,
    markerLines
  };
}

function codeFrameColumns(rawLines, loc, opts = {}) {
  const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight().shouldHighlight)(opts);
  const chalk = (0, _highlight().getChalk)(opts);
  const defs = getDefs(chalk);

  const maybeHighlight = (chalkFn, string) => {
    return highlighted ? chalkFn(string) : string;
  };

  if (highlighted) rawLines = (0, _highlight().default)(rawLines, opts);
  const lines = rawLines.split(NEWLINE);
  const {
    start,
    end,
    markerLines
  } = getMarkerLines(loc, lines, opts);
  const hasColumns = loc.start && typeof loc.start.column === "number";
  const numberMaxWidth = String(end).length;
  let frame = lines.slice(start, end).map((line, index) => {
    const number = start + 1 + index;
    const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
    const gutter = ` ${paddedNumber} | `;
    const hasMarker = markerLines[number];
    const lastMarkerLine = !markerLines[number + 1];

    if (hasMarker) {
      let markerLine = "";

      if (Array.isArray(hasMarker)) {
        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
        const numberOfMarkers = hasMarker[1] || 1;
        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

        if (lastMarkerLine && opts.message) {
          markerLine += " " + maybeHighlight(defs.message, opts.message);
        }
      }

      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
    } else {
      return ` ${maybeHighlight(defs.gutter, gutter)}${line}`;
    }
  }).join("\n");

  if (opts.message && !hasColumns) {
    frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
  }

  if (highlighted) {
    return chalk.reset(frame);
  } else {
    return frame;
  }
}

function _default(rawLines, lineNumber, colNumber, opts = {}) {
  if (!deprecationWarningShown) {
    deprecationWarningShown = true;
    const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";

    if (process.emitWarning) {
      process.emitWarning(message, "DeprecationWarning");
    } else {
      const deprecationError = new Error(message);
      deprecationError.name = "DeprecationWarning";
      console.warn(new Error(message));
    }
  }

  colNumber = Math.max(colNumber, 0);
  const location = {
    start: {
      column: colNumber,
      line: lineNumber
    }
  };
  return codeFrameColumns(rawLines, location, opts);
}

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldHighlight = shouldHighlight;
exports.getChalk = getChalk;
exports.default = highlight;

function _jsTokens() {
  const data = _interopRequireWildcard(__webpack_require__(250));

  _jsTokens = function () {
    return data;
  };

  return data;
}

function _esutils() {
  const data = _interopRequireDefault(__webpack_require__(251));

  _esutils = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(__webpack_require__(255));

  _chalk = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsx_tag: chalk.yellow,
    punctuator: chalk.yellow,
    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold
  };
}

const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
const JSX_TAG = /^[a-z][\w-]*$/i;
const BRACKET = /^[()[\]{}]$/;

function getTokenType(match) {
  const [offset, text] = match.slice(-2);
  const token = (0, _jsTokens().matchToToken)(match);

  if (token.type === "name") {
    if (_esutils().default.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }

    if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
      return "jsx_tag";
    }

    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }

  if (token.type === "punctuator" && BRACKET.test(token.value)) {
    return "bracket";
  }

  if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
    return "punctuator";
  }

  return token.type;
}

function highlightTokens(defs, text) {
  return text.replace(_jsTokens().default, function (...args) {
    const type = getTokenType(args);
    const colorize = defs[type];

    if (colorize) {
      return args[0].split(NEWLINE).map(str => colorize(str)).join("\n");
    } else {
      return args[0];
    }
  });
}

function shouldHighlight(options) {
  return _chalk().default.supportsColor || options.forceColor;
}

function getChalk(options) {
  let chalk = _chalk().default;

  if (options.forceColor) {
    chalk = new (_chalk().default.constructor)({
      enabled: true,
      level: 1
    });
  }

  return chalk;
}

function highlight(code, options = {}) {
  if (shouldHighlight(options)) {
    const chalk = getChalk(options);
    const defs = getDefs(chalk);
    return highlightTokens(defs, code);
  } else {
    return code;
  }
}

/***/ }),
/* 250 */
/***/ (function(module, exports) {

// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
// License: MIT. (See LICENSE.)

Object.defineProperty(exports, "__esModule", {
  value: true
})

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g

exports.matchToToken = function(match) {
  var token = {type: "invalid", value: match[0], closed: undefined}
       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4])
  else if (match[ 5]) token.type = "comment"
  else if (match[ 6]) token.type = "comment", token.closed = !!match[7]
  else if (match[ 8]) token.type = "regex"
  else if (match[ 9]) token.type = "number"
  else if (match[10]) token.type = "name"
  else if (match[11]) token.type = "punctuator"
  else if (match[12]) token.type = "whitespace"
  return token
}


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = __webpack_require__(252);
    exports.code = __webpack_require__(253);
    exports.keyword = __webpack_require__(254);
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 252 */
/***/ (function(module, exports) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 253 */
/***/ (function(module, exports) {

/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = __webpack_require__(253);

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const escapeStringRegexp = __webpack_require__(256);
const ansiStyles = __webpack_require__(257);
const stdoutColor = __webpack_require__(262).stdout;

const template = __webpack_require__(265);

const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

// `color-convert` models to exclude from the Chalk API due to conflicts and such
const skipModels = new Set(['gray']);

const styles = Object.create(null);

function applyOptions(obj, options) {
	options = options || {};

	// Detect level if not set manually
	const scLevel = stdoutColor ? stdoutColor.level : 0;
	obj.level = options.level === undefined ? scLevel : options.level;
	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
	// We check for this.template here since calling `chalk.constructor()`
	// by itself will have a `this` of a previously constructed chalk object
	if (!this || !(this instanceof Chalk) || this.template) {
		const chalk = {};
		applyOptions(chalk, options);

		chalk.template = function () {
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		};

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = Chalk;

		return chalk.template;
	}

	applyOptions(this, options);
}

// Use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001B[94m';
}

for (const key of Object.keys(ansiStyles)) {
	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

	styles[key] = {
		get() {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	};
}

styles.visible = {
	get() {
		return build.call(this, this._styles || [], true, 'visible');
	}
};

ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
for (const model of Object.keys(ansiStyles.color.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, styles);

function build(_styles, _empty, key) {
	const builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder._empty = _empty;

	const self = this;

	Object.defineProperty(builder, 'level', {
		enumerable: true,
		get() {
			return self.level;
		},
		set(level) {
			self.level = level;
		}
	});

	Object.defineProperty(builder, 'enabled', {
		enumerable: true,
		get() {
			return self.enabled;
		},
		set(enabled) {
			self.enabled = enabled;
		}
	});

	// See below for fix regarding invisible grey/dim combination on Windows
	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	return builder;
}

function applyStyle() {
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) {
		return '';
	}

	if (argsLen > 1) {
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || this.level <= 0 || !str) {
		return this._empty ? '' : str;
	}

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) {
		ansiStyles.dim.open = '';
	}

	for (const code of this._styles.slice().reverse()) {
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;

		// Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS
		// https://github.com/chalk/chalk/pull/92
		str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
	}

	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
	ansiStyles.dim.open = originalDim;

	return str;
}

function chalkTag(chalk, strings) {
	if (!Array.isArray(strings)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	}

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}

	return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);

module.exports = Chalk(); // eslint-disable-line new-cap
module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports; // For TypeScript


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
const colorConvert = __webpack_require__(258);

const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39],

			// Bright color
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Fix humans
	styles.color.grey = styles.color.gray;

	for (const groupName of Object.keys(styles)) {
		const group = styles[groupName];

		for (const styleName of Object.keys(group)) {
			const style = group[styleName];

			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});
	}

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 0)
	};
	styles.color.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 0)
	};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 10)
	};
	styles.bgColor.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 10)
	};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (let key of Object.keys(colorConvert)) {
		if (typeof colorConvert[key] !== 'object') {
			continue;
		}

		const suite = colorConvert[key];

		if (key === 'ansi16') {
			key = 'ansi';
		}

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(259);
var route = __webpack_require__(261);

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var cssKeywords = __webpack_require__(260);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(259);

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const os = __webpack_require__(263);
const hasFlag = __webpack_require__(264);

const env = process.env;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false')) {
	forceColor = false;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = true;
}
if ('FORCE_COLOR' in env) {
	forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(stream) {
	if (forceColor === false) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (stream && !stream.isTTY && forceColor !== true) {
		return 0;
	}

	const min = forceColor ? 1 : 0;

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors. Windows 10 build 14931 is the first release
		// that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(process.versions.node.split('.')[0]) >= 8 &&
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return min;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel(process.stdout),
	stderr: getSupportLevel(process.stderr)
};


/***/ }),
/* 263 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__263__;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = (flag, argv) => {
	argv = argv || process.argv;
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const pos = argv.indexOf(prefix + flag);
	const terminatorPos = argv.indexOf('--');
	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		if (!isNaN(chunk)) {
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const styleName of Object.keys(enabled)) {
		if (Array.isArray(enabled[styleName])) {
			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			if (enabled[styleName].length > 0) {
				current = current[styleName].apply(current, enabled[styleName]);
			} else {
				current = current[styleName];
			}
		}
	}

	return current;
}

module.exports = (chalk, tmp) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
		if (escapeChar) {
			chunk.push(unescape(escapeChar));
		} else if (style) {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = populatePlaceholders;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function populatePlaceholders(metadata, replacements) {
  const ast = t().cloneNode(metadata.ast);

  if (replacements) {
    metadata.placeholders.forEach(placeholder => {
      if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
        const placeholderName = placeholder.name;
        throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
      }
    });
    Object.keys(replacements).forEach(key => {
      if (!metadata.placeholderNames.has(key)) {
        throw new Error(`Unknown substitution "${key}" given`);
      }
    });
  }

  metadata.placeholders.slice().reverse().forEach(placeholder => {
    try {
      applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
    } catch (e) {
      e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
      throw e;
    }
  });
  return ast;
}

function applyReplacement(placeholder, ast, replacement) {
  if (placeholder.isDuplicate) {
    if (Array.isArray(replacement)) {
      replacement = replacement.map(node => t().cloneNode(node));
    } else if (typeof replacement === "object") {
      replacement = t().cloneNode(replacement);
    }
  }

  const {
    parent,
    key,
    index
  } = placeholder.resolve(ast);

  if (placeholder.type === "string") {
    if (typeof replacement === "string") {
      replacement = t().stringLiteral(replacement);
    }

    if (!replacement || !t().isStringLiteral(replacement)) {
      throw new Error("Expected string substitution");
    }
  } else if (placeholder.type === "statement") {
    if (index === undefined) {
      if (!replacement) {
        replacement = t().emptyStatement();
      } else if (Array.isArray(replacement)) {
        replacement = t().blockStatement(replacement);
      } else if (typeof replacement === "string") {
        replacement = t().expressionStatement(t().identifier(replacement));
      } else if (!t().isStatement(replacement)) {
        replacement = t().expressionStatement(replacement);
      }
    } else {
      if (replacement && !Array.isArray(replacement)) {
        if (typeof replacement === "string") {
          replacement = t().identifier(replacement);
        }

        if (!t().isStatement(replacement)) {
          replacement = t().expressionStatement(replacement);
        }
      }
    }
  } else if (placeholder.type === "param") {
    if (typeof replacement === "string") {
      replacement = t().identifier(replacement);
    }

    if (index === undefined) throw new Error("Assertion failure.");
  } else {
    if (typeof replacement === "string") {
      replacement = t().identifier(replacement);
    }

    if (Array.isArray(replacement)) {
      throw new Error("Cannot replace single expression with an array.");
    }
  }

  if (index === undefined) {
    t().validate(parent, key, replacement);
    parent[key] = replacement;
  } else {
    const items = parent[key].slice();

    if (placeholder.type === "statement" || placeholder.type === "param") {
      if (replacement == null) {
        items.splice(index, 1);
      } else if (Array.isArray(replacement)) {
        items.splice(index, 1, ...replacement);
      } else {
        items[index] = replacement;
      }
    } else {
      items[index] = replacement;
    }

    t().validate(parent, key, items);
    parent[key] = items;
  }
}

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = literalTemplate;

var _options = __webpack_require__(244);

var _parse = _interopRequireDefault(__webpack_require__(246));

var _populate = _interopRequireDefault(__webpack_require__(266));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function literalTemplate(formatter, tpl, opts) {
  const {
    metadata,
    names
  } = buildLiteralData(formatter, tpl, opts);
  return arg => {
    const defaultReplacements = arg.reduce((acc, replacement, i) => {
      acc[names[i]] = replacement;
      return acc;
    }, {});
    return arg => {
      const replacements = (0, _options.normalizeReplacements)(arg);

      if (replacements) {
        Object.keys(replacements).forEach(key => {
          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
            throw new Error("Unexpected replacement overlap.");
          }
        });
      }

      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
    };
  };
}

function buildLiteralData(formatter, tpl, opts) {
  let names;
  let nameSet;
  let metadata;
  let prefix = "";

  do {
    prefix += "$";
    const result = buildTemplateCode(tpl, prefix);
    names = result.names;
    nameSet = new Set(names);
    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments
    });
  } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));

  return {
    metadata,
    names
  };
}

function buildTemplateCode(tpl, prefix) {
  const names = [];
  let code = tpl[0];

  for (let i = 1; i < tpl.length; i++) {
    const value = `${prefix}${i - 1}`;
    names.push(value);
    code += value + tpl[i];
  }

  return {
    names,
    code
  };
}

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneDescriptor = cloneDescriptor;
exports.equalDescriptors = equalDescriptors;
exports.AbstractJoinedDescriptor = exports.InternalSlotDescriptor = exports.PropertyDescriptor = exports.Descriptor = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _errors = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class Descriptor {
  constructor() {
    (0, _invariant.default)(this.constructor !== Descriptor, "Descriptor is an abstract base class");
  }

  throwIfNotConcrete(realm) {
    let error = new _errors.CompilerDiagnostic("only known descriptors supported", realm.currentLocation, "PP0042", "FatalError");
    realm.handleError(error);
    throw new _errors.FatalError();
  }

  mightHaveBeenDeleted() {
    (0, _invariant.default)(false, "should have been overridden by subclass");
  }

}

exports.Descriptor = Descriptor;

// Normal descriptors are returned just like spec descriptors
class PropertyDescriptor extends Descriptor {
  // If value instanceof EmptyValue, then this descriptor indicates that the
  // corresponding property has been deleted.
  constructor(desc) {
    super();
    this.writable = desc.writable;
    this.enumerable = desc.enumerable;
    this.configurable = desc.configurable;
    this.value = desc.value;
    this.get = desc.get;
    this.set = desc.set;
  }

  throwIfNotConcrete(realm) {
    return this;
  }

  mightHaveBeenDeleted() {
    if (this.value === undefined) return false;
    return this.value.mightHaveBeenDeleted();
  }

} // Only internal properties (those starting with $ / where internalSlot of owning property binding is true) will ever have array values.


exports.PropertyDescriptor = PropertyDescriptor;

class InternalSlotDescriptor extends Descriptor {
  constructor(value) {
    super();
    this.value = Array.isArray(value) ? value.slice(0) : value;
  }

  mightHaveBeenDeleted() {
    return false;
  }

} // Only used if the result of a join of two descriptors is not a data descriptor with identical attribute values.
// When present, any update to the property must produce effects that are the join of updating both descriptors,
// using joinCondition as the condition of the join.


exports.InternalSlotDescriptor = InternalSlotDescriptor;

class AbstractJoinedDescriptor extends Descriptor {
  // An undefined descriptor means it might be empty in this branch.
  constructor(joinCondition, descriptor1, descriptor2) {
    super();
    this.joinCondition = joinCondition;
    this.descriptor1 = descriptor1;
    this.descriptor2 = descriptor2;
  }

  mightHaveBeenDeleted() {
    if (!this.descriptor1 || this.descriptor1.mightHaveBeenDeleted()) {
      return true;
    }

    if (!this.descriptor2 || this.descriptor2.mightHaveBeenDeleted()) {
      return true;
    }

    return false;
  }

}

exports.AbstractJoinedDescriptor = AbstractJoinedDescriptor;

function cloneDescriptor(d) {
  if (d === undefined) return undefined;
  return new PropertyDescriptor(d);
} // does not check if the contents of value properties are the same


function equalDescriptors(d1, d2) {
  if (d1.writable !== d2.writable) return false;
  if (d1.enumerable !== d2.enumerable) return false;
  if (d1.configurable !== d2.configurable) return false;

  if (d1.value !== undefined) {
    if (d2.value === undefined) return false;
  }

  if (d1.get !== d2.get) return false;
  if (d1.set !== d2.set) return false;
  return true;
}
//# sourceMappingURL=descriptors.js.map

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HasName = HasName;
exports.HasProperty = HasProperty;
exports.HasOwnProperty = HasOwnProperty;
exports.OrdinaryHasProperty = OrdinaryHasProperty;
exports.HasCompatibleType = HasCompatibleType;
exports.HasSomeCompatibleType = HasSomeCompatibleType;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// 12.2.1.2 Static Semantics: HasName
// 14.1.9 Static Semantics: HasName
// 14.2.7 Static Semantics: HasName
// 14.5.6 Static Semantics: HasName
// 14.2.7 Static Semantics: HasName
function HasName(realm, ast) {
  // 12.2.1.2 Static Semantics: HasName
  // CoverParenthesizedExpressionAndArrowParameterList
  // 14.2.7 Static Semantics: HasName
  if (ast.type === "ArrowFunctionExpression") return false; // 14.1.9 Static Semantics: HasName

  if (ast.type === "FunctionExpression") {
    // FunctionExpression: function (FormalParameters) {FunctionBody}
    if (ast.id === null) // 1. Return false.
      return false; // FunctionExpression: functionBindingIdentifier (FormalParameters) {FunctionBody}

    if (ast.id !== null) // 2. Return true
      return true;
  } // 14.5.6 Static Semantics: HasName


  if (ast.type === "ClassExpression") {
    // ClassExpression : class ClassTail
    if (ast.id === null) //1. Return false.
      return false; // ClassExpression : class BindingIdentifier ClassTail

    if (ast.id !== null) //1. return true;
      return true;
  } // 14.4.7 Static Semantics: HasName
  // GeneratorExpression


  throw Error("Unexpected AST node type  : " + ast.type);
} // ECMA262 7.3.10


function HasProperty(realm, O, P) {
  // 1. Assert: Type(O) is Object.
  // 2. Assert: IsPropertyKey(P) is true.
  (0, _invariant.default)((0, _index.IsPropertyKey)(realm, P), "expected property key"); // 3. Return ? O.[[HasProperty]](P).

  return O.$HasProperty(P);
} // ECMA262 7.3.11


function HasOwnProperty(realm, O, P) {
  // 1. Assert: Type(O) is Object.
  // 2. Assert: IsPropertyKey(P) is true.
  (0, _invariant.default)((0, _index.IsPropertyKey)(realm, P), "not a valid property key"); // 3. Let desc be ? O.[[GetOwnProperty]](P).

  let desc = O.$GetOwnProperty(P); // 4. If desc is undefined, return false.

  if (desc === undefined) return false;

  _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc); // 5. Return true.


  return true;
} // ECMA262 9.1.7.1


function OrdinaryHasProperty(realm, O, P) {
  // 1. Assert: IsPropertyKey(P) is true.
  (0, _invariant.default)(typeof P === "string" || (0, _index.IsPropertyKey)(realm, P), "expected property key"); // 2. Let hasOwn be ? O.[[GetOwnProperty]](P).

  let hasOwn = O.$GetOwnProperty(P); // 3. If hasOwn is not undefined, return true.

  if (hasOwn !== undefined) {
    _singletons.Properties.ThrowIfMightHaveBeenDeleted(hasOwn);

    return true;
  } // 4. Let parent be ? O.[[GetPrototypeOf]]().


  let parent = O.$GetPrototypeOf(); // 5. If parent is not null, then

  if (!(parent instanceof _index2.NullValue)) {
    (0, _invariant.default)(parent instanceof _index2.ObjectValue); // a. Return ? parent.[[HasProperty]](P).

    return parent.$HasProperty(P);
  } // 6. Return false.


  return false;
} // Checks if the given value is equal to or a subtype of the given type.
// If the value is an abstract value without precise type information,
// an introspection error is thrown.


function HasCompatibleType(value, type) {
  let valueType = value.getType();

  if (valueType === _index2.Value) {
    (0, _invariant.default)(value instanceof _index2.AbstractValue);

    _index2.AbstractValue.reportIntrospectionError(value);

    throw new _errors.FatalError();
  }

  return _index2.Value.isTypeCompatibleWith(valueType, type);
}

function HasSomeCompatibleType(value, ...manyTypes) {
  let valueType = value.getType();

  if (valueType === _index2.Value) {
    (0, _invariant.default)(value instanceof _index2.AbstractValue);

    _index2.AbstractValue.reportIntrospectionError(value);

    throw new _errors.FatalError();
  }

  return manyTypes.some(_index2.Value.isTypeCompatibleWith.bind(null, valueType));
}
//# sourceMappingURL=has.js.map

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Day = Day;
exports.TimeWithinDay = TimeWithinDay;
exports.DaysInYear = DaysInYear;
exports.DayFromYear = DayFromYear;
exports.TimeFromYear = TimeFromYear;
exports.YearFromTime = YearFromTime;
exports.InLeapYear = InLeapYear;
exports.MonthFromTime = MonthFromTime;
exports.DayWithinYear = DayWithinYear;
exports.DateFromTime = DateFromTime;
exports.WeekDay = WeekDay;
exports.DaylightSavingTA = DaylightSavingTA;
exports.LocalTime = LocalTime;
exports.UTC = UTC;
exports.HourFromTime = HourFromTime;
exports.MinFromTime = MinFromTime;
exports.SecFromTime = SecFromTime;
exports.msFromTime = msFromTime;
exports.MakeTime = MakeTime;
exports.MakeDay = MakeDay;
exports.MakeDate = MakeDate;
exports.TimeClip = TimeClip;
exports.thisTimeValue = thisTimeValue;
exports.ToDateString = ToDateString;
exports.msPerDay = exports.msPerHour = exports.msPerMinute = exports.msPerSecond = exports.HoursPerDay = exports.MinutesPerHour = exports.SecondsPerMinute = void 0;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// Constants
const SecondsPerMinute = 60;
exports.SecondsPerMinute = SecondsPerMinute;
const MinutesPerHour = 60;
exports.MinutesPerHour = MinutesPerHour;
const HoursPerDay = 24;
exports.HoursPerDay = HoursPerDay;
const msPerSecond = 1000;
exports.msPerSecond = msPerSecond;
const msPerMinute = msPerSecond * SecondsPerMinute;
exports.msPerMinute = msPerMinute;
const msPerHour = msPerMinute * MinutesPerHour;
exports.msPerHour = msPerHour;
const msPerDay = msPerHour * HoursPerDay;
exports.msPerDay = msPerDay;
let LocalTZA = -new Date(0).getTimezoneOffset() * msPerMinute; // ECMA262 20.3.1.2

function Day(realm, t) {
  return Math.floor(t / msPerDay);
} // ECMA262 20.3.1.2


function TimeWithinDay(realm, t) {
  return t % msPerDay;
} // ECMA262 20.3.1.3


function DaysInYear(realm, y) {
  if (y % 4 !== 0) return 365;
  if (y % 4 === 0 && y % 100 !== 0) return 366;
  if (y % 100 === 0 && y % 400 !== 0) return 365;
  if (y % 400 === 0) return 366;
  (0, _invariant.default)(false, "Invalid condition");
} // ECMA262 20.3.1.3


function DayFromYear(realm, y) {
  return 365 * (y - 1970) + Math.floor((y - 1969) / 4) - Math.floor((y - 1901) / 100) + Math.floor((y - 1601) / 400);
} // ECMA262 20.3.1.3


function TimeFromYear(realm, y) {
  return msPerDay * DayFromYear(realm, y);
} // ECMA262 20.3.1.3


function YearFromTime(realm, t) {
  let y = Math.floor(t / (msPerDay * 365.2425)) + 1970;
  let t2 = TimeFromYear(realm, y);

  if (t2 > t) {
    y--;
  } else {
    if (t2 + msPerDay * DaysInYear(realm, y) <= t) {
      y++;
    }
  }

  return y;
} // ECMA262 20.3.1.3


function InLeapYear(realm, t) {
  let daysInYear = DaysInYear(realm, YearFromTime(realm, t));
  if (daysInYear === 365) return 0;
  if (daysInYear === 366) return 1;
  (0, _invariant.default)(false, "invalid condition");
} // ECMA262 20.3.1.4


function MonthFromTime(realm, t) {
  let step;
  let d = DayWithinYear(realm, t);
  if (d < (step = 31)) return 0;
  step += InLeapYear(realm, t) ? 29 : 28;
  if (d < step) return 1;
  if (d < (step += 31)) return 2;
  if (d < (step += 30)) return 3;
  if (d < (step += 31)) return 4;
  if (d < (step += 30)) return 5;
  if (d < (step += 31)) return 6;
  if (d < (step += 31)) return 7;
  if (d < (step += 30)) return 8;
  if (d < (step += 31)) return 9;
  if (d < (step += 30)) return 10;
  return 11;
} // ECMA262 20.3.1.4


function DayWithinYear(realm, t) {
  return Day(realm, t) - DayFromYear(realm, YearFromTime(realm, t));
} // ECMA262 20.3.1.5


function DateFromTime(realm, t) {
  let step;
  let next;
  let d = DayWithinYear(realm, t);
  if (d <= (next = 30)) return d + 1;
  step = next;
  next += InLeapYear(realm, t) ? 29 : 28;
  if (d <= next) return d - step;
  step = next;
  if (d <= (next += 31)) return d - step;
  step = next;
  if (d <= (next += 30)) return d - step;
  step = next;
  if (d <= (next += 31)) return d - step;
  step = next;
  if (d <= (next += 30)) return d - step;
  step = next;
  if (d <= (next += 31)) return d - step;
  step = next;
  if (d <= (next += 31)) return d - step;
  step = next;
  if (d <= (next += 30)) return d - step;
  step = next;
  if (d <= (next += 31)) return d - step;
  step = next;
  if (d <= (next += 30)) return d - step;
  step = next;
  return d - step;
} // ECMA262 20.3.1.6


function WeekDay(realm, t) {
  return (Day(realm, t) + 4) % 7;
} // ECMA262 20.3.1.7


function DaylightSavingTA(realm, t) {
  // TODO #1014: Implement DaylightSavingTA
  return 0;
} // ECMA262 20.3.1.9


function LocalTime(realm, t) {
  // 1. Return t + LocalTZA + DaylightSavingTA(t).
  return t + LocalTZA + DaylightSavingTA(realm, t);
} // ECMA262 20.3.1.10


function UTC(realm, _t) {
  let t = _t;
  if (t instanceof _index.Value) t = t.throwIfNotConcreteNumber().value; // 1. Return t - LocalTZA - DaylightSavingTA(t - LocalTZA).

  return new _index.NumberValue(realm, t - LocalTZA - DaylightSavingTA(realm, t - LocalTZA));
} // ECMA262 20.3.1.11


function HourFromTime(realm, t) {
  return Math.floor(t / msPerHour) % HoursPerDay;
} // ECMA262 20.3.1.11


function MinFromTime(realm, t) {
  return Math.floor(t / msPerMinute) % MinutesPerHour;
} // ECMA262 20.3.1.11


function SecFromTime(realm, t) {
  return Math.floor(t / msPerSecond) % SecondsPerMinute;
} // ECMA262 20.3.1.11


function msFromTime(realm, t) {
  return t % msPerSecond;
} // ECMA262 20.3.1.12


function MakeTime(realm, hour, min, sec, ms) {
  // 1. If hour is not finite or min is not finite or sec is not finite or ms is not finite, return NaN.
  if (!isFinite(hour) || !isFinite(min) || !isFinite(sec) || !isFinite(ms)) return NaN; // 2. Let h be ToInteger(hour).

  let h = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, hour)); // 3. Let m be ToInteger(min).


  let m = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, min)); // 4. Let s be ToInteger(sec).


  let s = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, sec)); // 5. Let milli be ToInteger(ms).


  let milli = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, ms)); // 6. Let t be h * msPerHour + m * msPerMinute + s * msPerSecond + milli, performing the arithmetic
  //    according to IEEE 754-2008 rules (that is, as if using the ECMAScript operators * and +).


  let t = h * msPerHour + m * msPerMinute + s * msPerSecond + milli; // 7. Return t.

  return t;
} // ECMA262 20.3.1.13


function MakeDay(realm, year, month, date) {
  // 1. If year is not finite or month is not finite or date is not finite, return NaN.
  if (!isFinite(year) || !isFinite(month) || !isFinite(date)) return NaN; // 2. Let y be ToInteger(year).

  let y = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, year)); // 3. Let m be ToInteger(month).


  let m = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, month)); // 4. Let dt be ToInteger(date).


  let dt = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, date)); // 5. Let ym be y + floor(m / 12).


  let ym = y + Math.floor(m / 12); // 6. Let mn be m modulo 12.

  let mn = m < 0 ? m % 12 + 12 : m % 12; // 7. Find a value t such that YearFromTime(t) is ym and MonthFromTime(t) is mn and DateFromTime(t) is 1;
  //    but if this is not possible (because some argument is out of range), return NaN.
  //    Inspired by the V8 implementation.

  if (Math.abs(ym) >= 1000000.0 || Math.abs(mn) >= 1000000.0) {
    return NaN;
  }

  const yearDelta = 399999;
  const baseDay = 365 * (1970 + yearDelta) + Math.floor((1970 + yearDelta) / 4) - Math.floor((1970 + yearDelta) / 100) + Math.floor((1970 + yearDelta) / 400);
  let t = 365 * (ym + yearDelta) + Math.floor((ym + yearDelta) / 4) - Math.floor((ym + yearDelta) / 100) + Math.floor((ym + yearDelta) / 400) - baseDay;

  if (ym % 4 !== 0 || ym % 100 === 0 && ym % 400 !== 0) {
    t += [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334][mn];
  } else {
    t += [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335][mn];
  } // 8. Return Day(t) + dt - 1.


  return t + dt - 1;
} // ECMA262 20.3.1.14


function MakeDate(realm, day, time) {
  // 1. If day is not finite or time is not finite, return NaN.
  if (!isFinite(day) || !isFinite(time)) return NaN; // 2. Return day  msPerDay + time.

  return day * msPerDay + time;
} // ECMA262 20.3.1.15


function TimeClip(realm, _time) {
  let time = _time;
  if (time instanceof _index.Value) time = time.throwIfNotConcreteNumber().value; // 1. If time is not finite, return NaN.

  if (!isFinite(time)) return realm.intrinsics.NaN; // 2. If abs(time) > 8.64  10^15, return NaN.

  if (Math.abs(time) > 8640000000000000) {
    return realm.intrinsics.NaN;
  } // 3. Let clippedTime be ToInteger(time).


  let clippedTime = _singletons.To.ToInteger(realm, new _index.NumberValue(realm, time)); // 4. If clippedTime is -0, let clippedTime be +0.


  if (Object.is(clippedTime, -0)) clippedTime = +0; // 5. Return clippedTime.

  return new _index.NumberValue(realm, clippedTime);
} // ECMA262 20.3.4


function thisTimeValue(realm, value) {
  // 1. If Type(value) is Object and value has a [[DateValue]] internal slot, then
  if (value instanceof _index.ObjectValue && value.$DateValue !== undefined) {
    // a. Return the value of value's [[DateValue]] internal slot.
    return value.$DateValue;
  } // 2. Throw a TypeError exception.


  throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
} // ECMA262 20.3.4.41.1


function ToDateString(realm, tv) {
  // 1. Assert: Type(tv) is Number.
  (0, _invariant.default)(typeof tv === "number", "expected tv to be a number"); // 2. If tv is NaN, return "Invalid Date".

  if (isNaN(tv)) return "Invalid Date"; // 3. Return an implementation-dependent String value that represents tv as a date and time in the current
  //    time zone using a convenient, human-readable form.

  return new Date(tv).toString();
}
//# sourceMappingURL=date.js.map

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hashBinary = hashBinary;
exports.hashCall = hashCall;
exports.hashTernary = hashTernary;
exports.hashString = hashString;
exports.hashUnary = hashUnary;
exports.HashSet = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function hashBinary(op, x, y) {
  let xHash = x.getHash();
  let yHash = y.getHash();

  if (yHash < xHash) {
    // Check if the operation is commutative so that we can normalize the arguments on hash value order.
    let commutative;

    switch (op) {
      case "*":
      case "==":
      case "!=":
      case "===":
      case "!==":
        // If both operands might be objects, the operation does not commute because of the possibility
        // that arbitrary code can run on both operands while converting them, in which case the order of the
        // operands must be maintained to make sure any side-effects happen in the right order.
        commutative = !(x.mightBeObject() && y.mightBeObject());
        break;

      case "+":
        // As above, but in addition, if one of the operands might be a string the operation does not commute
        commutative = !(x.mightBeObject() && y.mightBeObject()) && !(x.mightBeString() || y.mightBeString());
        break;

      default:
        // The operation itself is not commutative
        commutative = false;
        break;
    }

    if (commutative) {
      [x, y] = [y, x];
      [xHash, yHash] = [yHash, xHash];
    }
  }

  let hash = (hashString(op) * 13 ^ xHash) * 13 ^ yHash;
  return [hash, [x, y]];
}

function hashCall(calleeName, ...args) {
  let hash = hashString(calleeName);

  for (let a of args) hash = hash * 13 ^ a.getHash();

  return [hash, args];
}

function hashTernary(x, y, z) {
  let hash = (x.getHash() * 13 ^ y.getHash()) * 13 ^ z.getHash();
  return [hash, [x, y, z]];
}

function hashString(value) {
  let hash = 5381;

  for (let i = value.length - 1; i >= 0; i--) {
    hash = hash * 33 ^ value.charCodeAt(i);
  }

  return hash;
}

function hashUnary(op, x) {
  return hashString(op) * 13 ^ x.getHash();
}

class HashSet {
  constructor(expectedEntries = 32 * 1024) {
    let initialSize = 16;
    expectedEntries *= 2;

    while (initialSize < expectedEntries) initialSize *= 2;

    this._entries = new Array(initialSize);
    this._count = 0;
  }

  add(e) {
    let entries = this._entries;
    let n = entries.length;
    let key = e.getHash();
    let i = key & n - 1;

    while (true) {
      let entry = entries[i];

      if (entry === undefined) {
        entries[i] = e;
        if (++this._count > n / 2) this.expand();
        return e;
      } else if (e.equals(entry)) {
        return entry;
      }

      if (++i >= n) i = 0;
    }

    (0, _invariant.default)(false); // otherwise Flow thinks this method can return undefined
  }

  expand() {
    let oldEntries = this._entries;
    let n = oldEntries.length;
    let m = n * 2;
    if (m <= 0) return;
    let entries = new Array(m);

    for (let i = 0; i < n; i++) {
      let oldEntry = oldEntries[i];
      if (oldEntry === undefined) continue;
      let key = oldEntry.getHash();
      let j = key & m - 1;

      while (true) {
        let entry = entries[j];

        if (entry === undefined) {
          entries[j] = oldEntry;
          break;
        }

        if (++j >= m) j = 0;
      }
    }

    this._entries = entries;
  }

}

exports.HashSet = HashSet;
//# sourceMappingURL=hash.js.map

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetIterator = GetIterator;
exports.IteratorStep = IteratorStep;
exports.IteratorValue = IteratorValue;
exports.IteratorComplete = IteratorComplete;
exports.IteratorNext = IteratorNext;
exports.CreateListIterator = CreateListIterator;
exports.CreateMapIterator = CreateMapIterator;
exports.CreateSetIterator = CreateSetIterator;
exports.IteratorClose = IteratorClose;
exports.IterableToList = IterableToList;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _abstract = __webpack_require__(233);

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 7.4.1
function GetIterator(realm, obj = realm.intrinsics.undefined, _method) {
  let method = _method; // 1. If method was not passed, then

  if (!method) {
    // a. Let method be ? GetMethod(obj, @@iterator).
    method = (0, _index2.GetMethod)(realm, obj, realm.intrinsics.SymbolIterator);
  } // 2. Let iterator be ? Call(method, obj).


  let iterator = (0, _index2.Call)(realm, method, obj); // 3. If Type(iterator) is not Object, throw a TypeError exception.

  if (!(iterator instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 4. Return iterator.


  return iterator;
} // ECMA262 7.4.5


function IteratorStep(realm, iterator) {
  // 1. Let result be ? IteratorNext(iterator).
  let result = IteratorNext(realm, iterator); // 2. Let done be ? IteratorComplete(result).

  let done = IteratorComplete(realm, result); // 3. If done is true, return false.

  if (done) return false; // 4. Return result.

  return result;
} // ECMA262 7.4.4


function IteratorValue(realm, iterResult) {
  // 1. Assert: Type(iterResult) is Object.
  (0, _invariant.default)(iterResult instanceof _index.ObjectValue, "expected obj"); // 2. Return ? Get(iterResult, "value").

  return (0, _index2.Get)(realm, iterResult, "value");
} // ECMA262 7.4.2


function IteratorComplete(realm, iterResult) {
  // 1. Assert: Type(iterResult) is Object.
  (0, _invariant.default)(iterResult instanceof _index.ObjectValue, "expected obj"); // 2. Return ToBoolean(? Get(iterResult, "done")).

  return _singletons.To.ToBooleanPartial(realm, (0, _index2.Get)(realm, iterResult, "done"));
} // ECMA262 7.4.2


function IteratorNext(realm, iterator, value) {
  // 1. If value was not passed, then
  let result;

  if (!value) {
    // a. Let result be ? Invoke(iterator, "next",  ).
    result = (0, _index2.Invoke)(realm, iterator, "next", []);
  } else {
    // 2. Else,
    // a. Let result be ? Invoke(iterator, "next",  value ).
    result = (0, _index2.Invoke)(realm, iterator, "next", [value]);
  } // 3. If Type(result) is not Object, throw a TypeError exception.


  if (!(result instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 4. Return result.


  return result;
} // ECMA262 7.4.8


function CreateListIterator(realm, list) {
  // 1. Let iterator be ObjectCreate(%IteratorPrototype%,  [[IteratorNext]], [[IteratedList]], [[ListIteratorNextIndex]] ).
  let iterator = _singletons.Create.ObjectCreate(realm, realm.intrinsics.IteratorPrototype, {
    $IteratorNext: undefined,
    $IteratedList: undefined,
    $ListIteratorNextIndex: undefined
  }); // 2. Set iterator's [[IteratedList]] internal slot to list.


  iterator.$IteratedList = list; // 3. Set iterator's [[ListIteratorNextIndex]] internal slot to 0.

  iterator.$ListIteratorNextIndex = 0; // 4. Let next be a new built-in function object as defined in ListIterator next (7.4.8.1).

  let next = ListIterator_next(realm); // 5. Set iterator's [[IteratorNext]] internal slot to next.

  iterator.$IteratorNext = next; // 6. Perform CreateMethodProperty(iterator, "next", next).

  _singletons.Create.CreateMethodProperty(realm, iterator, new _index.StringValue(realm, "next"), next); // 7. Return iterator.


  return iterator;
} // ECMA262 7.4.8.1


function ListIterator_next(realm) {
  let func = new _index.NativeFunctionValue(realm, undefined, "next", 0, context => {
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 1. Let O be the this value.

    let O = context; // 2. Let f be the active function object.

    let f = func; // 3. If O does not have a [[IteratorNext]] internal slot, throw a TypeError exception.

    if (!O.$IteratorNext) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have an [[IteratorNext]] internal slot");
    } // 4. Let next be the value of the [[IteratorNext]] internal slot of O.


    let next = O.$IteratorNext; // 5. If SameValue(f, next) is false, throw a TypeError exception.

    if (!(0, _abstract.SameValue)(realm, f, next)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 6. If O does not have an [[IteratedList]] internal slot, throw a TypeError exception.


    if (!O.$IteratedList) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have an [[IteratedList]] internal slot");
    } // 7. Let list be the value of the [[IteratedList]] internal slot of O.


    let list = O.$IteratedList;
    (0, _invariant.default)(typeof O.$ListIteratorNextIndex === "number"); // 8. Let index be the value of the [[ListIteratorNextIndex]] internal slot of O.
    // Default to 0 for Flow.

    let index = O.$ListIteratorNextIndex; // 9. Let len be the number of elements of list.

    let len = list.length; // 10. If index  len, then

    if (index >= len) {
      // a. Return CreateIterResultObject(undefined, true).
      return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
    } // 11. Set the value of the [[ListIteratorNextIndex]] internal slot of O to index+1.


    O.$ListIteratorNextIndex = index + 1; // 12. Return CreateIterResultObject(list[index], false).

    return _singletons.Create.CreateIterResultObject(realm, list[index], false);
  });
  return func;
} // ECMA262 23.1.5.1


function CreateMapIterator(realm, map, kind) {
  // 1. If Type(map) is not Object, throw a TypeError exception.
  if (!(map instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 2. If map does not have a [[MapData]] internal slot, throw a TypeError exception.


  if (!map.$MapData) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 3. Let iterator be ObjectCreate(%MapIteratorPrototype%,  [[Map]], [[MapNextIndex]], [[MapIterationKind]] ).


  let iterator = _singletons.Create.ObjectCreate(realm, realm.intrinsics.MapIteratorPrototype, {
    $Map: undefined,
    $MapNextIndex: undefined,
    $MapIterationKind: undefined
  }); // 4. Set iterator's [[Map]] internal slot to map.


  iterator.$Map = map; // 5. Set iterator's [[MapNextIndex]] internal slot to 0.

  iterator.$MapNextIndex = new _index.NumberValue(realm, 0); // 6. Set iterator's [[MapIterationKind]] internal slot to kind.

  iterator.$MapIterationKind = kind; // 7. Return iterator.

  return iterator;
} // ECMA262 23.2.5.1


function CreateSetIterator(realm, set, kind) {
  // 1. If Type(set) is not Object, throw a TypeError exception.
  if (!(set instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 2. If set does not have a [[SetData]] internal slot, throw a TypeError exception.


  if (!set.$SetData) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 3. Let iterator be ObjectCreate(%SetIteratorPrototype%,  [[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]] ).


  let iterator = _singletons.Create.ObjectCreate(realm, realm.intrinsics.SetIteratorPrototype, {
    $IteratedSet: undefined,
    $SetNextIndex: undefined,
    $SetIterationKind: undefined
  }); // 4. Set iterator's [[IteratedSet]] internal slot to set.


  iterator.$IteratedSet = set; // 5. Set iterator's [[SetNextIndex]] internal slot to 0.

  iterator.$SetNextIndex = 0; // 6. Set iterator's [[SetIterationKind]] internal slot to kind.

  iterator.$SetIterationKind = kind; // 7. Return iterator.

  return iterator;
} // ECMA262 7.4.6


function IteratorClose(realm, iterator, completion) {
  // 1. Assert: Type(iterator) is Object.
  (0, _invariant.default)(iterator instanceof _index.ObjectValue, "expected object"); // 2. Assert: completion is a Completion Record.

  (0, _invariant.default)(completion instanceof _completions.Completion, "expected completion record"); // 3. Let return be ? GetMethod(iterator, "return").

  let ret = (0, _index2.GetMethod)(realm, iterator, "return"); // 4. If return is undefined, return Completion(completion).

  if (ret instanceof _index.UndefinedValue) return completion; // 5. Let innerResult be Call(return, iterator,  ).

  let innerResult;

  try {
    innerResult = (0, _index2.Call)(realm, ret.throwIfNotConcrete(), iterator, []);
  } catch (error) {
    if (error instanceof _completions.AbruptCompletion) {
      innerResult = error;
    } else {
      throw error;
    }
  } // 6. If completion.[[Type]] is throw, return Completion(completion).


  if (completion instanceof _completions.ThrowCompletion) return completion; // 7. If innerResult.[[Type]] is throw, return Completion(innerResult).

  if (innerResult instanceof _completions.ThrowCompletion) return innerResult; // 8. If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.

  if (!(innerResult instanceof _index.ObjectValue)) {
    return realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 9. Return Completion(completion).


  return completion;
} // ECMA262 22.2.2.1.1


function IterableToList(realm, items, method) {
  // 1. Let iterator be ? GetIterator(items, method).
  let iterator = GetIterator(realm, items, method); // 2. Let values be a new empty List.

  let values = []; // 3. Let next be true.

  let next = true; // 4. Repeat, while next is not false

  while (next !== false) {
    // a. Let next be ? IteratorStep(iterator).
    next = IteratorStep(realm, iterator); // b. If next is not false, then

    if (next !== false) {
      // i. Let nextValue be ? IteratorValue(next).
      let nextValue = IteratorValue(realm, next); // ii. Append nextValue to the end of the List values.

      values.push(nextValue);
    }
  } // 5. Return values.


  return values;
}
//# sourceMappingURL=iterator.js.map

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetOwnPropertyKeys = GetOwnPropertyKeys;
exports.OrdinaryOwnPropertyKeys = OrdinaryOwnPropertyKeys;
exports.EnumerableOwnProperties = EnumerableOwnProperties;

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 19.1.2.8.1
function GetOwnPropertyKeys(realm, O, Type) {
  // 1. Let obj be ? ToObject(O).
  let obj = _singletons.To.ToObject(realm, O); // 2. Let keys be ? obj.[[OwnPropertyKeys]]().


  let keys = obj.$OwnPropertyKeys(); // 3. Let nameList be a new empty List.

  let nameList = []; // 4. Repeat for each element nextKey of keys in List order,

  for (let nextKey of keys) {
    // a. If Type(nextKey) is Type, then
    if (nextKey instanceof Type) {
      // i. Append nextKey as the last element of nameList.
      nameList.push(nextKey);
    }
  } // 1. Return CreateArrayFromList(nameList).


  return _singletons.Create.CreateArrayFromList(realm, nameList);
} // ECMA262 9.1.11.1


function OrdinaryOwnPropertyKeys(realm, o, getOwnPropertyKeysEvenIfPartial = false) {
  // 1. Let keys be a new empty List.
  let keys = []; // 2. For each own property key P of O that is an integer index, in ascending numeric index order

  let properties = _singletons.Properties.GetOwnPropertyKeysArray(realm, o, false, getOwnPropertyKeysEvenIfPartial);

  for (let key of properties.filter(x => (0, _index.IsArrayIndex)(realm, x)).map(x => parseInt(x, 10)).sort((x, y) => x - y)) {
    // i. Add P as the last element of keys.
    keys.push(new _index2.StringValue(realm, key + ""));
  } // 3. For each own property key P of O that is a String but is not an integer index, in ascending chronological order of property creation


  for (let key of properties.filter(x => !(0, _index.IsArrayIndex)(realm, x))) {
    // i. Add P as the last element of keys.
    keys.push(new _index2.StringValue(realm, key));
  } // 4. For each own property key P of O that is a Symbol, in ascending chronological order of property creation


  for (let key of o.symbols.keys()) {
    // i. Add P as the last element of keys.
    keys.push(key);
  } // 5. Return keys.


  return keys;
} // ECMA262 7.3.21


function EnumerableOwnProperties(realm, O, kind, getOwnPropertyKeysEvenIfPartial = false) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant.default)(O instanceof _index2.ObjectValue, "expected object"); // 2. Let ownKeys be ? O.[[OwnPropertyKeys]]().

  let ownKeys = O.$OwnPropertyKeys(getOwnPropertyKeysEvenIfPartial); // 3. Let properties be a new empty List.

  let properties = []; // 4. Repeat, for each element key of ownKeys in List order

  for (let key of ownKeys) {
    // a. If Type(key) is String, then
    if (key instanceof _index2.StringValue) {
      // i. Let desc be ? O.[[GetOwnProperty]](key).
      let desc = O.$GetOwnProperty(key); // ii. If desc is not undefined and desc.[[Enumerable]] is true, then

      if (desc && desc.throwIfNotConcrete(realm).enumerable) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc); // 1. If kind is "key", append key to properties.


        if (kind === "key") {
          properties.push(key);
        } else {
          // 2. Else,
          // a. Let value be ? Get(O, key).
          let value = (0, _index.Get)(realm, O, key); // b. If kind is "value", append value to properties.

          if (kind === "value") {
            properties.push(value);
          } else {
            // c. Else,
            // i. Assert: kind is "key+value".
            (0, _invariant.default)(kind === "key+value", "expected kind to be key+value"); // ii. Let entry be CreateArrayFromList( key, value ).

            let entry = _singletons.Create.CreateArrayFromList(realm, [key, value]); // iii. Append entry to properties.


            properties.push(entry);
          }
        }
      }
    }
  } // 5. Order the elements of properties so they are in the same relative order as would be produced by the Iterator that would be returned if the EnumerateObjectProperties internal method was invoked with O.
  // 6. Return properties.


  return properties;
}
//# sourceMappingURL=own.js.map

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DestructuringAssignmentEvaluation = DestructuringAssignmentEvaluation;
exports.IteratorDestructuringAssignmentEvaluation = IteratorDestructuringAssignmentEvaluation;
exports.KeyedDestructuringAssignmentEvaluation = KeyedDestructuringAssignmentEvaluation;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _ObjectExpression = __webpack_require__(275);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function RestDestructuringAssignmentEvaluation(realm, property, value, excludedNames, strictCode, env) {
  let DestructuringAssignmentTarget = property.argument;
  let lref; // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then

  if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
    lref = env.evaluate(DestructuringAssignmentTarget, strictCode); // b. ReturnIfAbrupt(lref).
  } // 2. Let restObj be ObjectCreate(%ObjectPrototype%).


  let restObj = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 3. Let assignStatus be CopyDataProperties(restObj, value, excludedNames).

  /* let assignStatus = */


  _singletons.Create.CopyDataProperties(realm, restObj, value, excludedNames); // 4. ReturnIfAbrupt(assignStatus).
  // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then


  if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
    (0, _invariant.default)(lref); // Return PutValue(lref, restObj).

    return _singletons.Properties.PutValue(realm, lref, restObj);
  } // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern[?Yield, ?Await] as the goal symbol, adopting the parameter values from AssignmentRestElement.


  let nestedAssignmentPattern = DestructuringAssignmentTarget;
  return DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, restObj, strictCode, env);
}

function PropertyDestructuringAssignmentEvaluation(realm, properties, value, strictCode, env) {
  // Base condition for recursive call below
  if (properties.length === 0) {
    return [];
  }

  let AssignmentProperty = properties.slice(-1)[0];
  let AssignmentPropertyList = properties.slice(0, -1); // 1. Let propertyNames be the result of performing PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.

  let propertyNames = PropertyDestructuringAssignmentEvaluation(realm, AssignmentPropertyList, value, strictCode, env); // 2. ReturnIfAbrupt(status propertyNames).
  // Let nextNames be the result of performing PropertyDestructuringAssignmentEvaluation for AssignmentProperty using value as the argument.

  let nextNames; // AssignmentProperty : IdentifierReference Initializer

  if (AssignmentProperty.key.type === "Identifier" && (AssignmentProperty.value.type === "Identifier" && AssignmentProperty.value.name === AssignmentProperty.key.name || AssignmentProperty.value.type === "AssignmentPattern" && AssignmentProperty.value.left.name === AssignmentProperty.key.name) && AssignmentProperty.computed === false) {
    let Initializer;

    if (AssignmentProperty.value.type === "AssignmentPattern") {
      Initializer = AssignmentProperty.value.right;
    } // 1. Let P be StringValue of IdentifierReference.


    let P = AssignmentProperty.key.name; // 2. Let lref be ? ResolveBinding(P).

    let lref = _singletons.Environment.ResolveBinding(realm, P, strictCode, env); // 3. Let v be ? GetV(value, P).


    let v = (0, _index2.GetV)(realm, value, P); // 4. If Initializer is present and v is undefined, then

    if (Initializer !== undefined && v instanceof _index.UndefinedValue) {
      // 4a. Let defaultValue be the result of evaluating Initializer.
      let defaultValue = env.evaluate(Initializer, strictCode); // 4b. Let v be ? GetValue(defaultValue).

      v = _singletons.Environment.GetValue(realm, defaultValue); // 4c. If IsAnonymousFunctionDefinition(Initializer) is true, then

      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer)) {
        (0, _invariant.default)(v instanceof _index.ObjectValue); // i. Let hasNameProperty be ? HasOwnProperty(v, "name").

        let hasNameProperty = (0, _index2.HasOwnProperty)(realm, v, "name"); // j. If hasNameProperty is false, perform SetFunctionName(v, P).

        if (hasNameProperty === false) {
          _singletons.Functions.SetFunctionName(realm, v, P);
        }
      }
    } // Perform ? PutValue(lref, v).


    _singletons.Properties.PutValue(realm, lref, v); // Return a new List containing P.


    nextNames = [new _index.StringValue(realm, P)];
  } else {
    // AssignmentProperty : PropertyName:AssignmentElement
    // 1. Let name be the result of evaluating PropertyName.
    let name = (0, _ObjectExpression.EvalPropertyName)(AssignmentProperty, env, realm, strictCode); // 2. ReturnIfAbrupt(name).
    // 3. Let status be the result of performing KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.

    /* let status = */

    KeyedDestructuringAssignmentEvaluation(realm, // $FlowFixMe
    AssignmentProperty.value, value, name, strictCode, env); // 4. ReturnIfAbrupt(status).
    // 5. Return a new List containing name.

    nextNames = [name];
  } // 4. ReturnIfAbrupt(nextNames).


  (0, _invariant.default)(nextNames instanceof Array); // 5. Append each item in nextNames to the end of propertyNames.

  propertyNames = propertyNames.concat(nextNames); // 6. Return propertyNames.

  return propertyNames;
} // 2.1 Object Rest/Spread Properties


function DestructuringAssignmentEvaluation(realm, pattern, value, strictCode, env) {
  if (pattern.type === "ObjectPattern") {
    let AssignmentPropertyList = [],
        AssignmentRestElement = null;

    for (let property of pattern.properties) {
      if (property.type === "RestElement") {
        AssignmentRestElement = property;
      } else {
        AssignmentPropertyList.push(property);
      }
    } // ObjectAssignmentPattern:
    //   { AssignmentPropertyList }
    //   { AssignmentPropertyList, }


    if (!AssignmentRestElement) {
      // 1. Perform ? RequireObjectCoercible(value).
      (0, _index2.RequireObjectCoercible)(realm, value); // 2. Perform ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.

      PropertyDestructuringAssignmentEvaluation(realm, AssignmentPropertyList, value, strictCode, env); // 3. Return NormalCompletion(empty).

      return realm.intrinsics.empty;
    } // ObjectAssignmentPattern : { AssignmentRestElement }


    if (AssignmentPropertyList.length === 0) {
      // 1. Let excludedNames be a new empty List.
      let excludedNames = []; // 2. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestElement with value and excludedNames as the arguments.

      return RestDestructuringAssignmentEvaluation(realm, AssignmentRestElement, value, excludedNames, strictCode, env);
    } else {
      // ObjectAssignmentPattern : { AssignmentPropertyList, AssignmentRestElement }
      // 1. Let excludedNames be the result of performing ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.
      let excludedNames = PropertyDestructuringAssignmentEvaluation(realm, AssignmentPropertyList, value, strictCode, env); // 2. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestElement with value and excludedNames as the arguments.

      return RestDestructuringAssignmentEvaluation(realm, AssignmentRestElement, value, excludedNames, strictCode, env);
    }
  } else if (pattern.type === "ArrayPattern") {
    // 1. Let iterator be ? GetIterator(value).
    let iterator = (0, _index2.GetIterator)(realm, value); // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.

    let iteratorRecord = {
      $Iterator: iterator,
      $Done: false
    }; // 3. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.

    let result;

    try {
      result = IteratorDestructuringAssignmentEvaluation(realm, pattern.elements, iteratorRecord, strictCode, env);
    } catch (error) {
      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).
      if (iteratorRecord.$Done === false && error instanceof _completions.AbruptCompletion) {
        throw (0, _index2.IteratorClose)(realm, iterator, error);
      }

      throw error;
    } // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).


    if (iteratorRecord.$Done === false) {
      let completion = (0, _index2.IteratorClose)(realm, iterator, new _completions.SimpleNormalCompletion(realm.intrinsics.undefined));

      if (completion instanceof _completions.AbruptCompletion) {
        throw completion;
      }
    } // 5. Return result.


    return result;
  }
} // ECMA262 12.15.5.3


function IteratorDestructuringAssignmentEvaluation(realm, _elements, iteratorRecord, strictCode, env) {
  let elements = _elements; // Check if the last element is a rest element. If so then we want to save the
  // element and handle it separately after we iterate through the other
  // formals. This also enforces that a rest element may only ever be in the
  // last position.

  let restEl;

  if (elements.length > 0) {
    let lastEl = elements[elements.length - 1];

    if (lastEl !== null && lastEl.type === "RestElement") {
      restEl = lastEl;
      elements = elements.slice(0, -1);
    }
  }

  for (let element of elements) {
    if (element === null) {
      // Elision handling
      // 1. If iteratorRecord.[[Done]] is false, then
      if (iteratorRecord.$Done === false) {
        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
        let next;

        try {
          next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
        } catch (e) {
          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
          if (e instanceof _completions.AbruptCompletion) {
            iteratorRecord.$Done = true;
          } // c. ReturnIfAbrupt(next).


          throw e;
        } // d. If next is false, set iteratorRecord.[[Done]] to true.


        if (next === false) {
          iteratorRecord.$Done = true;
        }
      } // 2. Return NormalCompletion(empty).


      continue;
    } // AssignmentElement : DestructuringAssignmentTarget Initializer


    let DestructuringAssignmentTarget;
    let Initializer;

    if (element.type === "AssignmentPattern") {
      Initializer = element.right;
      DestructuringAssignmentTarget = element.left;
    } else {
      DestructuringAssignmentTarget = element;
    }

    let lref; // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    //
    // The spec assumes we haven't yet distinguished between literals and
    // patterns, but our parser does that work for us. That means we check for
    // "*Pattern" instead of "*Literal" like the spec text suggests.

    if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
      lref = env.evaluate(DestructuringAssignmentTarget, strictCode); // b. ReturnIfAbrupt(lref).
    }

    let value; // 2. If iteratorRecord.[[Done]] is false, then

    if (iteratorRecord.$Done === false) {
      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
      let next;

      try {
        next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
      } catch (e) {
        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        if (e instanceof _completions.AbruptCompletion) {
          iteratorRecord.$Done = true;
        } // c. ReturnIfAbrupt(next).


        throw e;
      } // d. If next is false, set iteratorRecord.[[Done]] to true.


      if (next === false) {
        iteratorRecord.$Done = true; // Normally this assignment would be done in step 3, but we do it
        // here so that Flow knows `value` will always be initialized by step 4.

        value = realm.intrinsics.undefined;
      } else {
        // e. Else,
        // i. Let value be IteratorValue(next).
        try {
          value = (0, _index2.IteratorValue)(realm, next);
        } catch (e) {
          // ii. If value is an abrupt completion, set iteratorRecord.[[Done]] to true.
          if (e instanceof _completions.AbruptCompletion) {
            iteratorRecord.$Done = true;
          } // iii. ReturnIfAbrupt(v).


          throw e;
        }
      }
    } else {
      // 3. If iteratorRecord.[[Done]] is true, let value be undefined.
      value = realm.intrinsics.undefined;
    }

    let v; // 4. If Initializer is present and value is undefined, then

    if (Initializer && value instanceof _index.UndefinedValue) {
      // a. Let defaultValue be the result of evaluating Initializer.
      let defaultValue = env.evaluate(Initializer, strictCode); // b. Let v be ? GetValue(defaultValue).

      v = _singletons.Environment.GetValue(realm, defaultValue);
    } else {
      // 5. Else, let v be value.
      v = value;
    } // 6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
    //
    // The spec assumes we haven't yet distinguished between literals and
    // patterns, but our parser does that work for us. That means we check for
    // "*Pattern" instead of "*Literal" like the spec text suggests.


    if (DestructuringAssignmentTarget.type === "ObjectPattern" || DestructuringAssignmentTarget.type === "ArrayPattern") {
      // a. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.
      let nestedAssignmentPattern = DestructuringAssignmentTarget; // b. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.

      DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, v, strictCode, env);
      continue;
    } // We know `lref` exists because of how the algorithm is setup, but tell
    // Flow that `lref` exists with an `invariant()`.


    (0, _invariant.default)(lref); // 7. If Initializer is present and value is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then

    if (Initializer && value instanceof _index.UndefinedValue && (0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer) && (0, _index2.IsIdentifierRef)(realm, DestructuringAssignmentTarget) && v instanceof _index.ObjectValue) {
      // a. Let hasNameProperty be ? HasOwnProperty(v, "name").
      let hasNameProperty = (0, _index2.HasOwnProperty)(realm, v, "name"); // b. If hasNameProperty is false, perform SetFunctionName(v, GetReferencedName(lref)).

      if (hasNameProperty === false) {
        // All of the nodes that may be evaluated to produce lref create
        // references. Assert this with an invariant as GetReferencedName may
        // not be called with a value.
        (0, _invariant.default)(lref instanceof _environment.Reference);

        _singletons.Functions.SetFunctionName(realm, v, _singletons.Environment.GetReferencedName(realm, lref));
      }
    } // 8. Return ? PutValue(lref, v).


    _singletons.Properties.PutValue(realm, lref, v);

    continue;
  } // Handle the rest element if we have one.


  if (restEl) {
    // AssignmentRestElement : ...DestructuringAssignmentTarget
    let DestructuringAssignmentTarget = restEl.argument;
    let lref; // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
    //
    // The spec assumes we haven't yet distinguished between literals and
    // patterns, but our parser does that work for us. That means we check for
    // "*Pattern" instead of "*Literal" like the spec text suggests.

    if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
      lref = env.evaluate(DestructuringAssignmentTarget, strictCode); // b. ReturnIfAbrupt(lref).
    } // 2. Let A be ArrayCreate(0).


    let A = _singletons.Create.ArrayCreate(realm, 0); // 3. Let n be 0.


    let n = 0; // 4. Repeat while iteratorRecord.[[Done]] is false,

    while (iteratorRecord.$Done === false) {
      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
      let next;

      try {
        next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
      } catch (e) {
        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        if (e instanceof _completions.AbruptCompletion) {
          iteratorRecord.$Done = true;
        } // c. ReturnIfAbrupt(next).


        throw e;
      } // d. If next is false, set iteratorRecord.[[Done]] to true.


      if (next === false) {
        iteratorRecord.$Done = true;
      } else {
        // e. Else,
        // i. Let nextValue be IteratorValue(next).
        let nextValue;

        try {
          nextValue = (0, _index2.IteratorValue)(realm, next);
        } catch (e) {
          // ii. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
          if (e instanceof _completions.AbruptCompletion) {
            iteratorRecord.$Done = true;
          } // iii. ReturnIfAbrupt(nextValue).


          throw e;
        } // iv. Let status be CreateDataProperty(A, ! ToString(n), nextValue).


        let status = _singletons.Create.CreateDataProperty(realm, A, n.toString(), nextValue); // v. Assert: status is true.


        (0, _invariant.default)(status, "expected to create data property"); // vi. Increment n by 1.

        n += 1;
      }
    } // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then


    if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
      // `lref` will always be defined at this point. Let Flow know with an
      // invariant.
      (0, _invariant.default)(lref); // a. Return ? PutValue(lref, A).

      return _singletons.Properties.PutValue(realm, lref, A);
    } else {
      // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.
      let nestedAssignmentPattern = DestructuringAssignmentTarget; // 7. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.

      return DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, A, strictCode, env);
    }
  }
} // ECMA262 12.15.5.4


function KeyedDestructuringAssignmentEvaluation(realm, node, value, propertyName, strictCode, env) {
  let DestructuringAssignmentTarget;
  let Initializer;

  if (node.type === "AssignmentPattern") {
    Initializer = node.right;
    DestructuringAssignmentTarget = node.left;
  } else {
    DestructuringAssignmentTarget = node;
  }

  let lref; // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then
  //
  // The spec assumes we haven't yet distinguished between literals and
  // patterns, but our parser does that work for us. That means we check for
  // "*Pattern" instead of "*Literal" like the spec text suggests.

  if (DestructuringAssignmentTarget.type !== "ObjectPattern" && DestructuringAssignmentTarget.type !== "ArrayPattern") {
    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.
    lref = env.evaluate(DestructuringAssignmentTarget, strictCode); // b. ReturnIfAbrupt(lref).
  }

  let rhsValue; // 2. Let v be ? GetV(value, propertyName).

  let v = (0, _index2.GetV)(realm, value, propertyName); // 3. If Initializer is present and v is undefined, then

  if (Initializer && v instanceof _index.UndefinedValue) {
    // a. Let defaultValue be the result of evaluating Initializer.
    let defaultValue = env.evaluate(Initializer, strictCode); // b. Let rhsValue be ? GetValue(defaultValue).

    rhsValue = _singletons.Environment.GetValue(realm, defaultValue);
  } else {
    // 4. Else, let rhsValue be v.
    rhsValue = v;
  } // 5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then
  //
  // The spec assumes we haven't yet distinguished between literals and
  // patterns, but our parser does that work for us. That means we check for
  // "*Pattern" instead of "*Literal" like the spec text suggests.


  if (DestructuringAssignmentTarget.type === "ObjectPattern" || DestructuringAssignmentTarget.type === "ArrayPattern") {
    // a. Let assignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.
    let assignmentPattern = DestructuringAssignmentTarget; // b. Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.

    return DestructuringAssignmentEvaluation(realm, assignmentPattern, rhsValue, strictCode, env);
  } // `lref` will always be defined at this point. Let Flow know with an
  // invariant.


  (0, _invariant.default)(lref); // 6. If Initializer is present and v is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then

  if (Initializer && v instanceof _index.UndefinedValue && (0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer) && (0, _index2.IsIdentifierRef)(realm, DestructuringAssignmentTarget) && rhsValue instanceof _index.ObjectValue) {
    // a. Let hasNameProperty be ? HasOwnProperty(rhsValue, "name").
    let hasNameProperty = (0, _index2.HasOwnProperty)(realm, rhsValue, "name"); // b. If hasNameProperty is false, perform SetFunctionName(rhsValue, GetReferencedName(lref)).

    if (hasNameProperty === false) {
      // All of the nodes that may be evaluated to produce lref create
      // references. Assert this with an invariant as GetReferencedName may
      // not be called with a value.
      (0, _invariant.default)(lref instanceof _environment.Reference);

      _singletons.Functions.SetFunctionName(realm, rhsValue, _singletons.Environment.GetReferencedName(realm, lref));
    }
  } // 7. Return ? PutValue(lref, rhsValue).


  return _singletons.Properties.PutValue(realm, lref, rhsValue);
}
//# sourceMappingURL=destructuring.js.map

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EvalPropertyName = EvalPropertyName;
exports.default = _default;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// Returns the result of evaluating PropertyName.
function EvalPropertyName(prop, env, realm, strictCode) {
  let result = EvalPropertyNamePartial(prop, env, realm, strictCode);

  if (result instanceof _index.AbstractValue) {
    let error = new _errors.CompilerDiagnostic("unknown computed property name", prop.loc, "PP0014", "FatalError");
    realm.handleError(error);
    throw new _errors.FatalError();
  }

  return result;
}

function EvalPropertyNamePartial(prop, env, realm, strictCode) {
  if (prop.computed) {
    let propertyKeyName = _singletons.Environment.GetValue(realm, env.evaluate(prop.key, strictCode));

    if (propertyKeyName instanceof _index.AbstractValue) return propertyKeyName;
    (0, _invariant.default)(propertyKeyName instanceof _index.ConcreteValue);
    return _singletons.To.ToPropertyKey(realm, propertyKeyName);
  } else {
    if (prop.key.type === "Identifier") {
      return new _index.StringValue(realm, prop.key.name);
    } else {
      let propertyKeyName = _singletons.Environment.GetValue(realm, env.evaluate(prop.key, strictCode));

      (0, _invariant.default)(propertyKeyName instanceof _index.ConcreteValue); // syntax only allows literals if !prop.computed

      return _singletons.To.ToString(realm, propertyKeyName);
    }
  }
} // ECMA262 12.2.6.8


function _default(ast, strictCode, env, realm) {
  // 1. Let obj be ObjectCreate(%ObjectPrototype%).
  let obj = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 2. Let status be the result of performing PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.


  for (let prop of ast.properties) {
    if (prop.type === "ObjectProperty") {
      // 12.2.6.9 case 3
      // 1. Let propKey be the result of evaluating PropertyName.
      let propKey = EvalPropertyNamePartial(prop, env, realm, strictCode); // 2. ReturnIfAbrupt(propKey).
      // 3. Let exprValueRef be the result of evaluating AssignmentExpression.

      let exprValueRef = env.evaluate(prop.value, strictCode); // 4. Let propValue be ? GetValue(exprValueRef).

      let propValue = _singletons.Environment.GetValue(realm, exprValueRef); // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then


      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, prop.value)) {
        (0, _invariant.default)(propValue instanceof _index.ObjectValue); // a. Let hasNameProperty be ? HasOwnProperty(propValue, "name").

        let hasNameProperty = (0, _index2.HasOwnProperty)(realm, propValue, "name"); // b. If hasNameProperty is false, perform SetFunctionName(propValue, propKey).

        (0, _invariant.default)(!hasNameProperty); // No expression that passes through IsAnonymousFunctionDefinition can have it here

        _singletons.Functions.SetFunctionName(realm, propValue, propKey);
      } // 6. Assert: enumerable is true.
      // 7. Return CreateDataPropertyOrThrow(object, propKey, propValue).


      if (propKey instanceof _index.AbstractValue) {
        if (propKey.mightNotBeString()) {
          let error = new _errors.CompilerDiagnostic("property key value is unknown", prop.loc, "PP0011", "FatalError");
          if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
          continue; // recover by ignoring the property, which is only ever safe to do if the property is dead,
          // which is assuming a bit much, hence the designation as a FatalError.
        }

        obj.$SetPartial(propKey, propValue, obj);
      } else {
        _singletons.Create.CreateDataPropertyOrThrow(realm, obj, propKey, propValue);
      }
    } else if (prop.type === "SpreadElement") {
      // 1. Let exprValue be the result of evaluating AssignmentExpression.
      let exprValue = env.evaluate(prop.argument, strictCode); // 2. Let fromValue be GetValue(exprValue).

      let fromValue = _singletons.Environment.GetValue(realm, exprValue); // 3. ReturnIfAbrupt(fromValue).
      // 4. Let excludedNames be a new empty List.


      let excludedNames = []; // 4. Return ? CopyDataProperties(object, fromValue, excludedNames).

      _singletons.Create.CopyDataProperties(realm, obj, fromValue, excludedNames);
    } else {
      (0, _invariant.default)(prop.type === "ObjectMethod");

      _singletons.Properties.PropertyDefinitionEvaluation(realm, prop, obj, env, strictCode, true);
    }
  } // 3. ReturnIfAbrupt(status).
  // 4. Return obj.


  return obj;
}
//# sourceMappingURL=ObjectExpression.js.map

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegExpCreate = RegExpCreate;
exports.RegExpAlloc = RegExpAlloc;
exports.RegExpInitialize = RegExpInitialize;
exports.RegExpExec = RegExpExec;
exports.RegExpBuiltinExec = RegExpBuiltinExec;
exports.AdvanceStringIndex = AdvanceStringIndex;
exports.EscapeRegExpPattern = EscapeRegExpPattern;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(10);

var _get = __webpack_require__(230);

var _is = __webpack_require__(229);

var _call = __webpack_require__(234);

var _has = __webpack_require__(269);

var _singletons = __webpack_require__(236);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 21.2.3.2.3
function RegExpCreate(realm, P, F) {
  // 1. Let obj be ? RegExpAlloc(%RegExp%).
  let obj = RegExpAlloc(realm, realm.intrinsics.RegExp); // 2. Return ? RegExpInitialize(obj, P, F).

  return RegExpInitialize(realm, obj, P, F);
} // ECMA262 21.2.3.2.1


function RegExpAlloc(realm, newTarget) {
  // 1. Let obj be ? OrdinaryCreateFromConstructor(newTarget, "%RegExpPrototype%",  [[RegExpMatcher]],
  //    [[OriginalSource]], [[OriginalFlags]] ).
  let obj = _singletons.Create.OrdinaryCreateFromConstructor(realm, newTarget, "RegExpPrototype", {
    $RegExpMatcher: undefined,
    // always initialized to not undefined before use
    $OriginalSource: undefined,
    // ditto
    $OriginalFlags: undefined // ditto

  }); // 2. Perform ! DefinePropertyOrThrow(obj, "lastIndex", PropertyDescriptor {[[Writable]]: true,
  //    [[Enumerable]]: false, [[Configurable]]: false}).


  _singletons.Properties.DefinePropertyOrThrow(realm, obj, "lastIndex", new _descriptors.PropertyDescriptor({
    writable: true,
    enumerable: false,
    configurable: false
  })); // 3. Return obj.


  return obj;
} // ECMA262 21.2.3.2.2


function RegExpInitialize(realm, obj, pattern, flags) {
  // Note that obj is a new object, and we can thus write to internal slots
  (0, _invariant.default)(realm.isNewObject(obj)); // 1. If pattern is undefined, let P be the empty String.

  let P;

  if (!pattern || (0, _has.HasCompatibleType)(pattern, _index.UndefinedValue)) {
    P = "";
  } else {
    // 2. Else, let P be ? ToString(pattern).
    P = _singletons.To.ToStringPartial(realm, pattern);
  } // 3. If flags is undefined, let F be the empty String.


  let F;

  if (!flags || (0, _has.HasCompatibleType)(flags, _index.UndefinedValue)) {
    F = "";
  } else {
    // 4. Else, let F be ? ToString(flags).
    F = _singletons.To.ToStringPartial(realm, flags);
  } // 5. If F contains any code unit other than "g", "i", "m", "u", or "y" or if it contains the same code unit more than once, throw a SyntaxError exception.


  for (let i = 0; i < F.length; ++i) {
    if ("gimuy".indexOf(F.charAt(i)) < 0) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "invalid RegExp flag");
    }

    for (let j = i + 1; j < F.length; ++j) {
      if (F.charAt(i) === F.charAt(j)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "duplicate RegExp flag");
      }
    }
  } // 6. If F contains "u", let BMP be false; else let BMP be true.


  let BMP = F.indexOf("u") >= 0 ? false : true; // 7. If BMP is true, then

  if (BMP) {// a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP
    //    code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is
    //    Pattern. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P
    //    were not matched by the parse, or if any Early Error conditions exist.
    // b. Let patternCharacters be a List whose elements are the code unit elements of P.
  } else {} // 8. Else,
    // a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points
    //    (6.1.4). The goal symbol for the parse is Pattern[U]. Throw a SyntaxError exception if P did not
    //    conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error
    //    conditions exist.
    // b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16
    //    decoding to P's sequence of elements.
    // 9. Set the value of obj's [[OriginalSource]] internal slot to P.


  obj.$OriginalSource = P; // 10. Set the value of obj's [[OriginalFlags]] internal slot to F.

  obj.$OriginalFlags = F; // 11. Set obj's [[RegExpMatcher]] internal slot to the internal procedure that evaluates the above parse of
  //     P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern's List of
  //     SourceCharacter values and F as the flag parameters.

  try {
    let computedFlags = "y";
    if (F.indexOf("i") >= 0) computedFlags += "i";
    if (F.indexOf("u") >= 0) computedFlags += "u";
    if (F.indexOf("m") >= 0) computedFlags += "m";
    let matcher = new RegExp(P, computedFlags);

    obj.$RegExpMatcher = (S, lastIndex) => {
      matcher.lastIndex = lastIndex;
      let match = matcher.exec(S);

      if (!match) {
        return null;
      }

      return {
        endIndex: match.index + match[0].length,
        captures: match
      };
    };
  } catch (e) {
    if (e instanceof SyntaxError) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "invalid RegExp");
    } else throw e;
  } // 12. Perform ? Set(obj, "lastIndex", 0, true).


  _singletons.Properties.Set(realm, obj, "lastIndex", realm.intrinsics.zero, true); // 13. Return obj.


  return obj;
} // ECMA262 21.2.5.2.1


function RegExpExec(realm, R, S) {
  // 1. Assert: Type(R) is Object.
  (0, _invariant.default)(R instanceof _index.ObjectValue, "Type(R) is Object"); // 2. Assert: Type(S) is String.

  (0, _invariant.default)(typeof S === "string", "Type(S) is String"); // 3. Let exec be ? Get(R, "exec").

  let exec = (0, _get.Get)(realm, R, "exec"); // 4. If IsCallable(exec) is true, then

  if ((0, _is.IsCallable)(realm, exec)) {
    // a. Let result be ? Call(exec, R,  S ).
    let result = (0, _call.Call)(realm, exec, R, [new _index.StringValue(realm, S)]); // b. If Type(result) is neither Object or Null, throw a TypeError exception.

    if (!(0, _has.HasSomeCompatibleType)(result, _index.ObjectValue, _index.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(result) is neither Object or Null");
    } // c. Return result.


    return result.throwIfNotConcrete();
  } // 5. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.


  if (R.$RegExpMatcher === undefined) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "R does not have a [[RegExpMatcher]] internal slot");
  } // 6. Return ? RegExpBuiltinExec(R, S).


  return RegExpBuiltinExec(realm, R, S);
} // ECMA262 21.2.5.2.2


function RegExpBuiltinExec(realm, R, S) {
  // 1. Assert: R is an initialized RegExp instance.
  (0, _invariant.default)(R.$RegExpMatcher !== undefined && R.$OriginalSource !== undefined && R.$OriginalFlags !== undefined, "R is an initialized RegExp instance"); // 2. Assert: Type(S) is String.

  (0, _invariant.default)(typeof S === "string", "Type(S) is String"); // 3. Let length be the number of code units in S.

  let length = S.length; // 4. Let lastIndex be ? ToLength(? Get(R, "lastIndex")).

  let lastIndex = _singletons.To.ToLength(realm, (0, _get.Get)(realm, R, "lastIndex")); // 5. Let flags be R.[[OriginalFlags]].


  let flags = R.$OriginalFlags;
  (0, _invariant.default)(typeof flags === "string"); // 6 .If flags contains "g", let global be true, else let global be false.

  let global = flags.indexOf("g") >= 0 ? true : false; // 7. If flags contains "y", let sticky be true, else let sticky be false.

  let sticky = flags.indexOf("y") >= 0 ? true : false; // 8. If global is false and sticky is false, let lastIndex be 0.

  if (global === false && sticky === false) lastIndex = 0; // 9. Let matcher be the value of R's [[RegExpMatcher]] internal slot.

  let matcher = R.$RegExpMatcher;
  (0, _invariant.default)(matcher !== undefined); // 10. If flags contains "u", let fullUnicode be true, else let fullUnicode be false.

  let fullUnicode = flags.indexOf("u") >= 0 ? true : false; // 11. Let matchSucceeded be false.

  let matchSucceeded = false;
  let r = null; // 12. Repeat, while matchSucceeded is false

  while (!matchSucceeded) {
    // a. If lastIndex > length, then
    if (lastIndex > length) {
      // i. Perform ? Set(R, "lastIndex", 0, true).
      _singletons.Properties.Set(realm, R, "lastIndex", realm.intrinsics.zero, true); // ii. Return null.


      return realm.intrinsics.null;
    } // b. Let r be matcher(S, lastIndex).


    r = matcher(S, lastIndex); // c. If r is failure, then

    if (r == null) {
      // i. If sticky is true, then
      if (sticky) {
        // 1. Perform ? Set(R, "lastIndex", 0, true).
        _singletons.Properties.Set(realm, R, "lastIndex", realm.intrinsics.zero, true); // 2. Return null.


        return realm.intrinsics.null;
      } // ii. Let lastIndex be AdvanceStringIndex(S, lastIndex, fullUnicode).


      lastIndex = AdvanceStringIndex(realm, S, lastIndex, fullUnicode);
    } else {
      // d. Else,
      // i. Assert: r is a State.
      (0, _invariant.default)(r, "r is a State"); // ii. Set matchSucceeded to true.

      matchSucceeded = true; // (not in standard) Let lastIndex be the index of the captures

      lastIndex = r.captures.index;
    }
  }

  (0, _invariant.default)(r != null); // 13. Let e be r's endIndex value.

  let e = r.endIndex; // 14. If fullUnicode is true, then

  if (fullUnicode) {} // TODO #1018 a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S.
  // b. Let e be eUTF.
  // 15. If global is true or sticky is true, then


  if (global === true || sticky === true) {
    // a. Perform ? Set(R, "lastIndex", e, true).
    _singletons.Properties.Set(realm, R, "lastIndex", new _index.NumberValue(realm, e), true);
  } // 16. Let n be the length of r's captures List. (This is the same value as 21.2.2.1's NcapturingParens.)


  let n = r.captures.length - 1; // 17. Let A be ArrayCreate(n + 1).

  let A = _singletons.Create.ArrayCreate(realm, n + 1); // 18. Assert: The value of A's "length" property is n + 1.


  let lengthOfA = (0, _get.Get)(realm, A, "length").throwIfNotConcrete();
  (0, _invariant.default)(lengthOfA instanceof _index.NumberValue);
  (0, _invariant.default)(lengthOfA.value === n + 1, 'The value of A\'s "length" property is n + 1'); // 19. Let matchIndex be lastIndex.

  let matchIndex = lastIndex; // 20. Perform ! CreateDataProperty(A, "index", matchIndex).

  _singletons.Create.CreateDataProperty(realm, A, "index", new _index.NumberValue(realm, matchIndex)); // 21. Perform ! CreateDataProperty(A, "input", S).


  _singletons.Create.CreateDataProperty(realm, A, "input", new _index.StringValue(realm, S)); // 22. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive).


  let matchedSubstr = S.substr(lastIndex, e - lastIndex); // 23. Perform ! CreateDataProperty(A, "0", matchedSubstr).

  _singletons.Create.CreateDataProperty(realm, A, "0", new _index.StringValue(realm, matchedSubstr)); // 24. For each integer i such that i > 0 and i  n


  for (let i = 1; i <= n; ++i) {
    // a. Let captureI be ith element of r's captures List.
    let captureI = r.captures[i];
    let capturedValue; // b. If captureI is undefined, let capturedValue be undefined.

    if (captureI === undefined) {
      capturedValue = realm.intrinsics.undefined;
    } else if (fullUnicode) {
      // c. Else if fullUnicode is true, then
      // TODO #1018: i. Assert: captureI is a List of code points.
      // ii. Let capturedValue be a string whose code units are the UTF16Encoding of the code points of captureI.
      capturedValue = realm.intrinsics.undefined;
    } else {
      // d. Else, fullUnicode is false,
      // i. Assert: captureI is a List of code units.
      (0, _invariant.default)(typeof captureI === "string"); // ii. Let capturedValue be a string consisting of the code units of captureI.

      capturedValue = new _index.StringValue(realm, captureI);
    } // e. Perform ! CreateDataProperty(A, ! ToString(i), capturedValue).


    _singletons.Create.CreateDataProperty(realm, A, _singletons.To.ToString(realm, new _index.NumberValue(realm, i)), capturedValue);
  } // 25. Return A.


  return A;
}

function AdvanceStringIndex(realm, S, index, unicode) {
  // 1. Assert: Type(S) is String.
  (0, _invariant.default)(typeof S === "string", "Type(S) is String"); // 2. Assert: index is an integer such that 0index253-1.

  (0, _invariant.default)(index >= 0 && index <= Math.pow(2, 53) - 1, "index is an integer such that 0index253-1"); // 3. Assert: Type(unicode) is Boolean.

  (0, _invariant.default)(typeof unicode === "boolean", "Type(unicode) is Boolean"); // 4. If unicode is false, return index+1.

  if (unicode === false) return index + 1; // 5. Let length be the number of code units in S.

  let length = S.length; // 6. If index+1  length, return index+1.

  if (index + 1 >= length) return index + 1; // 7. Let first be the code unit value at index index in S.

  let first = S.charCodeAt(index); // 8. If first < 0xD800 or first > 0xDBFF, return index+1.

  if (first < 0xd800 || first > 0xdbff) return index + 1; // 9. Let second be the code unit value at index index+1 in S.

  let second = S.charCodeAt(index + 1); // 10. If second < 0xDC00 or second > 0xDFFF, return index+1.

  if (second < 0xdc00 || second > 0xdfff) return index + 1; // 11. Return index+2.

  return index + 2;
}

function EscapeRegExpPattern(realm, P, F) {
  return P.replace("/", "/");
}
//# sourceMappingURL=regexp.js.map

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnqueueJob = EnqueueJob;
exports.NewPromiseCapability = NewPromiseCapability;
exports.PerformPromiseAll = PerformPromiseAll;
exports.PerformPromiseRace = PerformPromiseRace;
exports.PerformPromiseThen = PerformPromiseThen;
exports.PromiseReactionJob = PromiseReactionJob;
exports.CreateResolvingFunctions = CreateResolvingFunctions;
exports.FulfillPromise = FulfillPromise;
exports.RejectPromise = RejectPromise;
exports.TriggerPromiseReactions = TriggerPromiseReactions;
exports.HostPromiseRejectionTracker = HostPromiseRejectionTracker;
exports.PromiseResolveThenableJob = PromiseResolveThenableJob;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _abstract = __webpack_require__(233);

var _construct = __webpack_require__(228);

var _get = __webpack_require__(230);

var _call = __webpack_require__(234);

var _is = __webpack_require__(229);

var _iterator = __webpack_require__(272);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 8.4.1
function EnqueueJob(realm, queueName, job, args) {} // ECMA262 25.4.1.5


function NewPromiseCapability(realm, C) {
  // 1. If IsConstructor(C) is false, throw a TypeError exception.
  if ((0, _is.IsConstructor)(realm, C) === false) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsConstructor(C) is false");
  }

  (0, _invariant.default)(C instanceof _index.ObjectValue); // 2. NOTE C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 25.4.3.1).
  // 3. Let promiseCapability be a new PromiseCapability { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.

  let promiseCapability = {
    promise: realm.intrinsics.undefined,
    resolve: realm.intrinsics.undefined,
    reject: realm.intrinsics.undefined
  }; // 4. Let executor be a new built-in function object as defined in GetCapabilitiesExecutor Functions (25.4.1.5.1).

  let executor = new _index.NativeFunctionValue(realm, undefined, undefined, 2, (context, [resolve, reject]) => {
    // 1. Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.
    (0, _invariant.default)(executor.$Capability, "F has a [[Capability]] internal slot whose value is a PromiseCapability Record"); // 2. Let promiseCapability be the value of F's [[Capability]] internal slot.

    (0, _invariant.default)(promiseCapability === executor.$Capability); // 3. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.

    if (!promiseCapability.resolve.mightBeUndefined()) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "promiseCapability.[[Resolve]] is not undefined");
    }

    promiseCapability.resolve.throwIfNotConcrete(); // 4. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.

    if (!promiseCapability.reject.mightBeUndefined()) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "promiseCapability.[[Reject]] is not undefined");
    }

    promiseCapability.reject.throwIfNotConcrete(); // 5. Set promiseCapability.[[Resolve]] to resolve.

    promiseCapability.resolve = resolve; // 6. Set promiseCapability.[[Reject]] to reject.

    promiseCapability.reject = reject; // 7. Return undefined.

    return realm.intrinsics.undefined;
  }, false); // 5. Set the [[Capability]] internal slot of executor to promiseCapability.

  executor.$Capability = promiseCapability; // 6. Let promise be ? Construct(C,  executor ).

  let promise = (0, _construct.Construct)(realm, C, [executor]).throwIfNotConcreteObject(); // 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.

  if ((0, _is.IsCallable)(realm, promiseCapability.resolve) === false) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(promiseCapability.[[Resolve]]) is false");
  } // 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.


  if ((0, _is.IsCallable)(realm, promiseCapability.reject) === false) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(promiseCapability.[[Reject]]) is false");
  } // 9. Set promiseCapability.[[Promise]] to promise.


  promiseCapability.promise = promise; // 10. Return promiseCapability.

  return promiseCapability;
} // ECMA262 25.4.4.1.1j


function createResolveElementFunction(realm) {
  let resolveElement = new _index.NativeFunctionValue(realm, undefined, undefined, 1, (context, [x]) => {
    // 1. Let alreadyCalled be the value of F's [[AlreadyCalled]] internal slot.
    let alreadyCalled = resolveElement.$AlreadyCalled;
    (0, _invariant.default)(alreadyCalled); // 2. If alreadyCalled.[[Value]] is true, return undefined.

    if (alreadyCalled.value === true) {
      return realm.intrinsics.undefined;
    } // 3. Set alreadyCalled.[[Value]] to true.


    alreadyCalled.value = true; // 4. Let index be the value of F's [[Index]] internal slot.

    let myIndex = resolveElement.$Index;
    (0, _invariant.default)(typeof myIndex === "number"); // 5. Let values be the value of F's [[Values]] internal slot.

    let values = resolveElement.$Values;
    (0, _invariant.default)(values instanceof Array); // 6. Let promiseCapability be the value of F's [[Capabilities]] internal slot.

    let promiseCapability = resolveElement.$Capabilities;
    (0, _invariant.default)(promiseCapability); // 7. Let remainingElementsCount be the value of F's [[RemainingElements]] internal slot.

    let remainingElementsCount = resolveElement.$RemainingElements;
    (0, _invariant.default)(remainingElementsCount); // 8. Set values[index] to x.

    values[myIndex] = x; // 9. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.

    remainingElementsCount.value = remainingElementsCount.value - 1; // 10. If remainingElementsCount.[[Value]] is 0, then

    if (remainingElementsCount.value === 0) {
      // a. Let valuesArray be CreateArrayFromList(values).
      let valuesArray = _singletons.Create.CreateArrayFromList(realm, values); // b. Return ? Call(promiseCapability.[[Resolve]], undefined,  valuesArray ).


      (0, _call.Call)(realm, promiseCapability.resolve, realm.intrinsics.undefined, [valuesArray]);
    } // 11. Return undefined.


    return realm.intrinsics.undefined;
  }, false);
  return resolveElement;
} // ECMA262 25.4.4.1.1


function PerformPromiseAll(realm, iteratorRecord, constructor, resultCapability) {
  // 1. Assert: constructor is a constructor function.
  (0, _invariant.default)(constructor instanceof _index.FunctionValue && (0, _is.IsConstructor)(realm, constructor), "constructor is a constructor function"); // 2. Assert: resultCapability is a PromiseCapability record.

  resultCapability; // 3. Let values be a new empty List.

  let values = []; // 4. Let remainingElementsCount be a new Record { [[Value]]: 1 }.

  let remainingElementsCount = {
    value: 1
  }; // 5. Let index be 0.

  let index = 0; // 6. Repeat

  while (true) {
    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
    let next;

    try {
      next = (0, _iterator.IteratorStep)(realm, iteratorRecord.$Iterator);
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) {
        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        iteratorRecord.$Done = true;
      } // c. ReturnIfAbrupt(next).


      throw e;
    } // d. If next is false, then


    if (next === false) {
      // i. Set iteratorRecord.[[Done]] to true.
      iteratorRecord.$Done = true; // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.

      remainingElementsCount.value = remainingElementsCount.value - 1; // iii. If remainingElementsCount.[[Value]] is 0, then

      if (remainingElementsCount.value === 0) {
        // 1. Let valuesArray be CreateArrayFromList(values).
        let valuesArray = _singletons.Create.CreateArrayFromList(realm, values); // 2. Perform ? Call(resultCapability.[[Resolve]], undefined,  valuesArray ).


        (0, _call.Call)(realm, resultCapability.resolve, realm.intrinsics.undefined, [valuesArray]);
      } // iv. Return resultCapability.[[Promise]].


      return resultCapability.promise;
    } // e. Let nextValue be IteratorValue(next).


    let nextValue;

    try {
      nextValue = (0, _iterator.IteratorValue)(realm, next);
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) {
        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
        iteratorRecord.$Done = true;
      } // g. ReturnIfAbrupt(nextValue).


      throw e;
    } // h. Append undefined to values.


    values.push(realm.intrinsics.undefined); // i. Let nextPromise be ? Invoke(constructor, "resolve",  nextValue ).

    let nextPromise = (0, _call.Invoke)(realm, constructor, "resolve", [nextValue]); // j. Let resolveElement be a new built-in function object as defined in Promise.all Resolve Element Functions.

    let resolveElement = createResolveElementFunction(realm); // k. Set the [[AlreadyCalled]] internal slot of resolveElement to a new Record {[[Value]]: false }.

    resolveElement.$AlreadyCalled = {
      value: false
    }; // l. Set the [[Index]] internal slot of resolveElement to index.

    resolveElement.$Index = index; // m. Set the [[Values]] internal slot of resolveElement to values.

    resolveElement.$Values = values; // n. Set the [[Capabilities]] internal slot of resolveElement to resultCapability.

    resolveElement.$Capabilities = resultCapability; // o. Set the [[RemainingElements]] internal slot of resolveElement to remainingElementsCount.

    resolveElement.$RemainingElements = remainingElementsCount; // p. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.

    remainingElementsCount.value = remainingElementsCount.value + 1; // q. Perform ? Invoke(nextPromise, "then",  resolveElement, resultCapability.[[Reject]] ).

    (0, _call.Invoke)(realm, nextPromise, "then", [resolveElement, resultCapability.reject]); // r. Set index to index + 1.

    index = index + 1;
  }

  (0, _invariant.default)(false);
} // ECMA262 25.4.4.3.1


function PerformPromiseRace(realm, iteratorRecord, resultCapability, C) {
  // 1. Assert: constructor is a constructor function.
  (0, _invariant.default)((0, _is.IsConstructor)(realm, C), "constructor is a constructor function"); // 2. Assert: resultCapability is a PromiseCapability Record.

  resultCapability; // 3. Repeat

  while (true) {
    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
    let next;

    try {
      next = (0, _iterator.IteratorStep)(realm, iteratorRecord.$Iterator);
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) {
        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        iteratorRecord.$Done = true;
      } // c. ReturnIfAbrupt(next).


      throw e;
    } // d. If next is false, then


    if (next === false) {
      // i. Set iteratorRecord.[[Done]] to true.
      iteratorRecord.$Done = true; // ii. Return resultCapability.[[Promise]].

      (0, _invariant.default)(resultCapability.promise instanceof _index.ObjectValue);
      return resultCapability.promise;
    } // e. Let nextValue be IteratorValue(next).


    let nextValue;

    try {
      nextValue = (0, _iterator.IteratorValue)(realm, next);
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) {
        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
        iteratorRecord.$Done = true;
      } // g. ReturnIfAbrupt(nextValue).


      throw e;
    } // h. Let nextPromise be ? Invoke(C, "resolve",  nextValue ).


    let nextPromise = (0, _call.Invoke)(realm, C, "resolve", [nextValue]); // i. Perform ? Invoke(nextPromise, "then",  resultCapability.[[Resolve]], resultCapability.[[Reject]] ).

    (0, _call.Invoke)(realm, nextPromise, "then", [resultCapability.resolve, resultCapability.reject]);
  }

  (0, _invariant.default)(false);
} // ECMA262 25.4.5.3.1


function PerformPromiseThen(realm, promise, onFulfilled, onRejected, resultCapability) {
  // 1. Assert: IsPromise(promise) is true.
  (0, _invariant.default)((0, _is.IsPromise)(realm, promise), "IsPromise(promise) is true"); // 2. Assert: resultCapability is a PromiseCapability record.

  resultCapability; // 3. If IsCallable(onFulfilled) is false, then

  if ((0, _is.IsCallable)(realm, onFulfilled) === false) {
    // a. Let onFulfilled be "Identity".
    onFulfilled = new _index.StringValue(realm, "Identity");
  } // 4. If IsCallable(onRejected) is false, then


  if ((0, _is.IsCallable)(realm, onRejected)) {
    // a. Let onRejected be "Thrower".
    onRejected = new _index.StringValue(realm, "Thrower");
  } // 5. Let fulfillReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onFulfilled }.


  let fulfillReaction = {
    capabilities: resultCapability,
    handler: onFulfilled
  }; // 6. Let rejectReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onRejected}.

  let rejectReaction = {
    capabilities: resultCapability,
    handler: onRejected
  }; // 7. If the value of promise's [[PromiseState]] internal slot is "pending", then

  if (promise.$PromiseState === "pending") {
    // a. Append fulfillReaction as the last element of the List that is the value of promise's [[PromiseFulfillReactions]] internal slot.
    _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseFulfillReactions");

    (0, _invariant.default)(promise.$PromiseFulfillReactions);
    promise.$PromiseFulfillReactions.push(fulfillReaction); // b. Append rejectReaction as the last element of the List that is the value of promise's [[PromiseRejectReactions]] internal slot.

    _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseRejectReactions");

    (0, _invariant.default)(promise.$PromiseRejectReactions);
    promise.$PromiseRejectReactions.push(rejectReaction);
  } else if (promise.$PromiseState === "fulfilled") {
    // 8. Else if the value of promise's [[PromiseState]] internal slot is "fulfilled", then
    // a. Let value be the value of promise's [[PromiseResult]] internal slot.
    let value = promise.$PromiseResult; // b. Perform EnqueueJob("PromiseJobs", PromiseReactionJob,  fulfillReaction, value ).

    EnqueueJob(realm, "PromiseJobs", PromiseReactionJob, [fulfillReaction, value]);
  } else {
    // 9. Else,
    // a. Assert: The value of promise's [[PromiseState]] internal slot is "rejected".
    (0, _invariant.default)(promise.$PromiseState === "rejected"); // b. Let reason be the value of promise's [[PromiseResult]] internal slot.

    let reason = promise.$PromiseResult; // c. If the value of promise's [[PromiseIsHandled]] internal slot is false, perform HostPromiseRejectionTracker(promise, "handle").

    if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, "handle"); // d. Perform EnqueueJob("PromiseJobs", PromiseReactionJob,  rejectReaction, reason ).

    EnqueueJob(realm, "PromiseJobs", PromiseReactionJob, [rejectReaction, reason]);
  } // 10. Set promise's [[PromiseIsHandled]] internal slot to true.


  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseIsHandled").$PromiseIsHandled = true; // 11. Return resultCapability.[[Promise]].

  (0, _invariant.default)(resultCapability.promise instanceof _index.ObjectValue);
  return resultCapability.promise;
} // ECMA262 25.4.2.1


function PromiseReactionJob(realm, reaction, argument) {
  return realm.intrinsics.undefined;
} // ECMA262 25.4.1.3.2


function createResolveFunction(realm) {
  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).
  let resolve = new _index.NativeFunctionValue(realm, undefined, undefined, 1, (context, [resolution]) => {
    // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.
    (0, _invariant.default)(resolve.$Promise instanceof _index.ObjectValue, "F has a [[Promise]] internal slot whose value is an Object"); // 2. Let promise be the value of F's [[Promise]] internal slot.

    let promise = resolve.$Promise; // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.

    let alreadyResolved = resolve.$AlreadyResolved;
    (0, _invariant.default)(alreadyResolved !== undefined); // 4. If alreadyResolved.[[Value]] is true, return undefined.

    if (alreadyResolved.value === true) return realm.intrinsics.undefined; // 5. Set alreadyResolved.[[Value]] to true.

    alreadyResolved.value = true; // 6. If SameValue(resolution, promise) is true, then

    if ((0, _abstract.SameValue)(realm, resolution.throwIfNotConcrete(), promise)) {
      // a. Let selfResolutionError be a newly created TypeError object.
      let selfResolutionError = (0, _construct.Construct)(realm, realm.intrinsics.TypeError, [new _index.StringValue(realm, "resolve")]); // b. Return RejectPromise(promise, selfResolutionError).

      return RejectPromise(realm, promise, selfResolutionError);
    } // 7. If Type(resolution) is not Object, then


    if (!(resolution instanceof _index.ObjectValue)) {
      // a. Return FulfillPromise(promise, resolution).
      return FulfillPromise(realm, promise, resolution);
    } // 8. Let then be Get(resolution, "then").


    let then;

    try {
      then = (0, _get.Get)(realm, resolution, "then");
    } catch (e) {
      // 9. If then is an abrupt completion, then
      if (e instanceof _completions.AbruptCompletion) {
        // a. Return RejectPromise(promise, then.[[Value]]).
        return RejectPromise(realm, promise, e);
      } else throw e;
    } // 10. Let thenAction be then.[[Value]].


    let thenAction = then; // 11. If IsCallable(thenAction) is false, then

    if ((0, _is.IsCallable)(realm, thenAction)) {
      // a. Return FulfillPromise(promise, resolution).
      return FulfillPromise(realm, promise, resolution);
    } // 12. Perform EnqueueJob("PromiseJobs", PromiseResolveThenableJob,  promise, resolution, thenAction ).


    EnqueueJob(realm, "PromiseJobs", PromiseResolveThenableJob, [promise, resolution, thenAction]); // 13. Return undefined.

    return realm.intrinsics.undefined;
  }, false);
  return resolve;
} // ECMA262 25.4.1.3.1


function createRejectFunction(realm) {
  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).
  let reject = new _index.NativeFunctionValue(realm, undefined, undefined, 1, (context, [reason]) => {
    // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.
    (0, _invariant.default)(reject.$Promise instanceof _index.ObjectValue, "F has a [[Promise]] internal slot whose value is an Object"); // 2. Let promise be the value of F's [[Promise]] internal slot.

    let promise = reject.$Promise; // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.

    let alreadyResolved = reject.$AlreadyResolved;
    (0, _invariant.default)(alreadyResolved !== undefined); // 4. If alreadyResolved.[[Value]] is true, return undefined.

    if (alreadyResolved.value === true) return realm.intrinsics.undefined; // 5. Set alreadyResolved.[[Value]] to true.

    alreadyResolved.value = true; // 6. Return RejectPromise(promise, reason).

    return RejectPromise(realm, promise, reason);
  }, false);
  return reject;
} // ECMA262 25.4.1.3


function CreateResolvingFunctions(realm, promise) {
  // 1. Let alreadyResolved be a new Record { [[Value]]: false }.
  let alreadyResolved = {
    value: false
  }; // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).

  let resolve = createResolveFunction(realm); // 3. Set the [[Promise]] internal slot of resolve to promise.

  resolve.$Promise = promise; // 4. Set the [[AlreadyResolved]] internal slot of resolve to alreadyResolved.

  resolve.$AlreadyResolved = alreadyResolved; // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).

  let reject = createRejectFunction(realm); // 6. Set the [[Promise]] internal slot of reject to promise.

  reject.$Promise = promise; // 7. Set the [[AlreadyResolved]] internal slot of reject to alreadyResolved.

  reject.$AlreadyResolved = alreadyResolved; // 8. Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject }.

  return {
    resolve: resolve,
    reject: reject
  };
} // ECMA262 25.4.1.4


function FulfillPromise(realm, promise, value) {
  // 1. Assert: The value of promise.[[PromiseState]] is "pending".
  (0, _invariant.default)(promise.$PromiseState === "pending"); // 2. Let reactions be promise.[[PromiseFulfillReactions]].

  let reactions = promise.$PromiseFulfillReactions;
  (0, _invariant.default)(reactions); // 3. Set promise.[[PromiseResult]] to value.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseResult").$PromiseResult = value; // 4. Set promise.[[PromiseFulfillReactions]] to undefined.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseFulfillReactions").$PromiseFulfillReactions = undefined; // 5. Set promise.[[PromiseRejectReactions]] to undefined.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseRejectReactions").$PromiseRejectReactions = undefined; // 6. Set promise.[[PromiseState]] to "fulfilled".

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseState").$PromiseState = "fulfilled"; // 7. Return TriggerPromiseReactions(reactions, value).

  return TriggerPromiseReactions(realm, reactions, value);
} // ECMA262 25.4.1.7


function RejectPromise(realm, promise, reason) {
  // 1. Assert: The value of promise.[[PromiseState]] is "pending".
  (0, _invariant.default)(promise.$PromiseState === "pending"); // 2. Let reactions be promise.[[PromiseRejectReactions]].

  let reactions = promise.$PromiseFulfillReactions;
  (0, _invariant.default)(reactions); // 3. Set promise.[[PromiseResult]] to reason.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseResult").$PromiseResult = reason; // 4. Set promise.[[PromiseFulfillReactions]] to undefined.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseFulfillReactions").$PromiseFulfillReactions = undefined; // 5. Set promise.[[PromiseRejectReactions]] to undefined.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseRejectReactions").$PromiseRejectReactions = undefined; // 6. Set promise.[[PromiseState]] to "rejected".

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, promise, "$PromiseState").$PromiseState = "rejected"; // 7. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, "reject").

  if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, "reject"); // 8. Return TriggerPromiseReactions(reactions, reason).

  return TriggerPromiseReactions(realm, reactions, reason);
} // ECMA262 25.4.1.8


function TriggerPromiseReactions(realm, reactions, argument) {
  // 1. Repeat for each reaction in reactions, in original insertion order
  for (let reaction of reactions) {
    // a. Perform EnqueueJob("PromiseJobs", PromiseReactionJob,  reaction, argument ).
    EnqueueJob(realm, "PromiseJobs", PromiseReactionJob, [reaction, argument]);
  } // 2. Return undefined.


  return realm.intrinsics.undefined;
} // ECMA262 25.4.1.9


function HostPromiseRejectionTracker(realm, promise, operation) {} // ECMA262 25.4.2.2


function PromiseResolveThenableJob(realm, promiseToResolve, thenable, then) {}
//# sourceMappingURL=promise.js.map

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CreateByteDataBlock = CreateByteDataBlock;
exports.CopyDataBlockBytes = CopyDataBlockBytes;
exports.AllocateArrayBuffer = AllocateArrayBuffer;
exports.DetachArrayBuffer = DetachArrayBuffer;
exports.GetViewValue = GetViewValue;
exports.GetValueFromBuffer = GetValueFromBuffer;
exports.SetViewValue = SetViewValue;
exports.CloneArrayBuffer = CloneArrayBuffer;
exports.SetValueInBuffer = SetValueInBuffer;

var _index = __webpack_require__(10);

var _construct = __webpack_require__(228);

var _index2 = __webpack_require__(232);

var _is = __webpack_require__(229);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _types = __webpack_require__(19);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 6.2.6.1
function CreateByteDataBlock(realm, size) {
  // 1. Assert: size0.
  (0, _invariant.default)(size >= 0, "size >= 0"); // 2. Let db be a new Data Block value consisting of size bytes. If it is impossible to create such a Data Block, throw a RangeError exception.

  let db;

  try {
    db = new Uint8Array(size);
  } catch (e) {
    if (e instanceof RangeError) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "Invalid typed array length");
    } else {
      throw e;
    }
  } // 3. Set all of the bytes of db to 0.


  for (let i = 0; i < size; ++i) {
    db[i] = 0;
  } // 4. Return db.


  return db;
} // ECMA262 6.2.6.2


function CopyDataBlockBytes(realm, toBlock, _toIndex, fromBlock, _fromIndex, _count) {
  let toIndex = _toIndex;
  let fromIndex = _fromIndex;
  let count = _count; // 1. Assert: fromBlock and toBlock are distinct Data Block values.

  (0, _invariant.default)(toBlock instanceof Uint8Array && fromBlock instanceof Uint8Array && toBlock !== fromBlock); // 2. Assert: fromIndex, toIndex, and count are integer values  0.

  (0, _invariant.default)(toIndex >= 0 && fromIndex >= 0 && count >= 0); // 3. Let fromSize be the number of bytes in fromBlock.

  let fromSize = fromBlock.length; // 4. Assert: fromIndex+count  fromSize.

  (0, _invariant.default)(fromIndex + count <= fromSize, "fromIndex+count  fromSize"); // 5. Let toSize be the number of bytes in toBlock.

  let toSize = toBlock.length; // 6. Assert: toIndex+count  toSize.

  (0, _invariant.default)(toIndex + count <= toSize, "toIndex+count  toSize"); // 7. Repeat, while count>0

  while (count > 0) {
    // a. Set toBlock[toIndex] to the value of fromBlock[fromIndex].
    toBlock[toIndex] = fromBlock[fromIndex]; // b. Increment toIndex and fromIndex each by 1.

    toIndex += 1;
    fromIndex += 1; // c. Decrement count by 1.

    count -= 1;
  } // 8. Return NormalCompletion(empty).


  return realm.intrinsics.empty;
} // ECMA262 24.1.1.1


function AllocateArrayBuffer(realm, constructor, byteLength) {
  // 1. Let obj be ? OrdinaryCreateFromConstructor(constructor, "%ArrayBufferPrototype%",  [[ArrayBufferData]], [[ArrayBufferByteLength]] ).
  let obj = _singletons.Create.OrdinaryCreateFromConstructor(realm, constructor, "ArrayBufferPrototype", {
    $ArrayBufferData: undefined,
    $ArrayBufferByteLength: undefined
  }); // 2. Assert: byteLength is an integer value  0.


  (0, _invariant.default)(typeof byteLength === "number" && byteLength >= 0, "byteLength is an integer value  0"); // 3. Let block be ? CreateByteDataBlock(byteLength).

  let block = CreateByteDataBlock(realm, byteLength); // 4. Set obj's [[ArrayBufferData]] internal slot to block.

  obj.$ArrayBufferData = block; // 5. Set obj's [[ArrayBufferByteLength]] internal slot to byteLength.

  obj.$ArrayBufferByteLength = byteLength; // 6. Return obj.

  return obj;
} // ECMA262 24.1.1.3


function DetachArrayBuffer(realm, arrayBuffer) {
  // 1. Assert: Type(arrayBuffer) is Object and it has [[ArrayBufferData]] and [[ArrayBufferByteLength]] internal slots.
  (0, _invariant.default)(arrayBuffer instanceof _index.ObjectValue && "$ArrayBufferData" in arrayBuffer && "$ArrayBufferByteLength" in arrayBuffer); // 2. Set arrayBuffer.[[ArrayBufferData]] to null.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, arrayBuffer, "$ArrayBufferData").$ArrayBufferData = null; // 3. Set arrayBuffer.[[ArrayBufferByteLength]] to 0.

  _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, arrayBuffer, "$ArrayBufferByteLength").$ArrayBufferByteLength = 0; // 4. Return NormalCompletion(null).

  return realm.intrinsics.null;
} // ECMA262 24.2.1.1


function GetViewValue(realm, _view, requestIndex, isLittleEndian, type) {
  let view = _view.throwIfNotConcrete(); // 1. If Type(view) is not Object, throw a TypeError exception.


  if (!(view instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(view) is not Object");
  } // 2. If view does not have a [[DataView]] internal slot, throw a TypeError exception.


  if (!("$DataView" in view)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "view does not have a [[DataView]] internal slot");
  } // 3. Assert: view has a [[ViewedArrayBuffer]] internal slot.


  (0, _invariant.default)(view.$ViewedArrayBuffer); // 4. Let getIndex be ? ToIndex(requestIndex).

  let getIndex = _singletons.To.ToIndexPartial(realm, requestIndex); // 5. Let littleEndian be ToBoolean(isLittleEndian).


  let littleEndian = _singletons.To.ToBooleanPartial(realm, isLittleEndian); // 6. Let buffer be view.[[ViewedArrayBuffer]].


  let buffer = view.$ViewedArrayBuffer;
  (0, _invariant.default)(buffer); // 7. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  } // 8. Let viewOffset be view.[[ByteOffset]].


  let viewOffset = view.$ByteOffset;
  (0, _invariant.default)(typeof viewOffset === "number"); // 9. Let viewSize be view.[[ByteLength]].

  let viewSize = view.$ByteLength;
  (0, _invariant.default)(typeof viewSize === "number"); // 10. Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.

  let elementSize = _types.ElementSize[type]; // 11. If getIndex + elementSize > viewSize, throw a RangeError exception.

  if (getIndex + elementSize > viewSize) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "getIndex + elementSize > viewSize");
  } // 12. Let bufferIndex be getIndex + viewOffset.


  let bufferIndex = getIndex + viewOffset; // 13. Return GetValueFromBuffer(buffer, bufferIndex, type, littleEndian).

  return GetValueFromBuffer(realm, buffer, bufferIndex, type, littleEndian);
} // ECMA262 24.1.1.5


function GetValueFromBuffer(realm, arrayBuffer, byteIndex, type, _isLittleEndian) {
  let isLittleEndian = _isLittleEndian; // 1. Assert: IsDetachedBuffer(arrayBuffer) is false.

  (0, _invariant.default)((0, _is.IsDetachedBuffer)(realm, arrayBuffer) === false); // 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

  (0, _invariant.default)(arrayBuffer.$ArrayBufferData instanceof Uint8Array && byteIndex + _types.ElementSize[type] <= arrayBuffer.$ArrayBufferData.length); // 3. Assert: byteIndex is an integer value  0.

  (0, _invariant.default)(byteIndex >= 0); // 4. Let block be arrayBuffer.[[ArrayBufferData]].

  let block = arrayBuffer.$ArrayBufferData;
  (0, _invariant.default)(block instanceof Uint8Array); // 5. Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.

  let elementSize = _types.ElementSize[type]; // 6. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].

  let rawValue = new DataView(block.buffer, byteIndex, elementSize); // 7. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.

  if (isLittleEndian === undefined) isLittleEndian = true; // 8. If isLittleEndian is false, reverse the order of the elements of rawValue.
  // 9. If type is "Float32", then

  if (type === "Float32") {
    // a. Let value be the byte elements of rawValue concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.
    // b. If value is an IEEE 754-2008 binary32 NaN value, return the NaN Number value.
    // c. Return the Number value that corresponds to value.
    return new _index.NumberValue(realm, rawValue.getFloat32(0, isLittleEndian));
  } // 10. If type is "Float64", then


  if (type === "Float64") {
    // a. Let value be the byte elements of rawValue concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.
    // b. If value is an IEEE 754-2008 binary64 NaN value, return the NaN Number value.
    // c. Return the Number value that corresponds to value.
    return new _index.NumberValue(realm, rawValue.getFloat64(0, isLittleEndian));
  }

  let intValue; // 11. If the first code unit of type is "U", then

  if (type === "Uint8" || type === "Uint16" || type === "Uint32" || type === "Uint8Clamped") {
    // a. Let intValue be the byte elements of rawValue concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
    if (elementSize === 1) {
      intValue = rawValue.getUint8(0);
    } else if (elementSize === 2) {
      intValue = rawValue.getUint16(0, isLittleEndian);
    } else {
      intValue = rawValue.getUint32(0, isLittleEndian);
    }
  } else {
    // 12. Else,
    // a. Let intValue be the byte elements of rawValue concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length elementSize  8.
    if (elementSize === 1) {
      intValue = rawValue.getInt8(0);
    } else if (elementSize === 2) {
      intValue = rawValue.getInt16(0, isLittleEndian);
    } else {
      intValue = rawValue.getInt32(0, isLittleEndian);
    }
  } // 13. Return the Number value that corresponds to intValue.


  return new _index.NumberValue(realm, intValue);
} // ECMA262 24.2.1.2


function SetViewValue(realm, _view, requestIndex, isLittleEndian, type, value) {
  let view = _view.throwIfNotConcrete(); // 1. If Type(view) is not Object, throw a TypeError exception.


  if (!(view instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(view) is not Object");
  } // 2. If view does not have a [[DataView]] internal slot, throw a TypeError exception.


  if (!("$DataView" in view)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "view does not have a [[DataView]] internal slot");
  } // 3. Assert: view has a [[ViewedArrayBuffer]] internal slot.


  (0, _invariant.default)(view.$ViewedArrayBuffer); // 4. Let getIndex be ? ToIndex(requestIndex).

  let getIndex = _singletons.To.ToIndexPartial(realm, requestIndex); // 5. Let numberValue be ? ToNumber(value).


  let numberValue = _singletons.To.ToNumber(realm, value); // 6. Let littleEndian be ToBoolean(isLittleEndian).


  let littleEndian = _singletons.To.ToBooleanPartial(realm, isLittleEndian); // 7. Let buffer be view.[[ViewedArrayBuffer]].


  let buffer = view.$ViewedArrayBuffer;
  (0, _invariant.default)(buffer); // 8. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  } // 9. Let viewOffset be view.[[ByteOffset]].


  let viewOffset = view.$ByteOffset;
  (0, _invariant.default)(typeof viewOffset === "number"); // 10. Let viewSize be view.[[ByteLength]].

  let viewSize = view.$ByteLength;
  (0, _invariant.default)(typeof viewSize === "number"); // 11. Let elementSize be the Number value of the Element Size value specified in Table 50 for Element Type type.

  let elementSize = _types.ElementSize[type]; // 12. If getIndex + elementSize > viewSize, throw a RangeError exception.

  if (getIndex + elementSize > viewSize) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "getIndex + elementSize > viewSize");
  } // 13. Let bufferIndex be getIndex + viewOffset.


  let bufferIndex = getIndex + viewOffset; // 14. Return SetValueInBuffer(buffer, bufferIndex, type, numberValue, littleEndian).

  return SetValueInBuffer(realm, buffer, bufferIndex, type, numberValue, littleEndian);
} // ECMA262 24.1.1.4


function CloneArrayBuffer(realm, srcBuffer, srcByteOffset, _cloneConstructor) {
  let cloneConstructor = _cloneConstructor; // 1. Assert: Type(srcBuffer) is Object and it has an [[ArrayBufferData]] internal slot.

  (0, _invariant.default)(srcBuffer instanceof _index.ObjectValue && srcBuffer.$ArrayBufferData); // 2. If cloneConstructor is not present, then

  if (cloneConstructor === undefined) {
    // a. Let cloneConstructor be ? SpeciesConstructor(srcBuffer, %ArrayBuffer%).
    cloneConstructor = (0, _construct.SpeciesConstructor)(realm, srcBuffer, realm.intrinsics.ArrayBuffer); // b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.

    if ((0, _is.IsDetachedBuffer)(realm, srcBuffer) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcBuffer) is true");
    }
  } else {
    // 3. Else, Assert: IsConstructor(cloneConstructor) is true.
    (0, _invariant.default)((0, _index2.IsConstructor)(realm, cloneConstructor) === true, "IsConstructor(cloneConstructor) is true");
  } // 4. Let srcLength be the value of srcBuffer's [[ArrayBufferByteLength]] internal slot.


  let srcLength = srcBuffer.$ArrayBufferByteLength;
  (0, _invariant.default)(typeof srcLength === "number"); // 5. Assert: srcByteOffset  srcLength.

  (0, _invariant.default)(srcByteOffset <= srcLength, "srcByteOffset  srcLength"); // 6. Let cloneLength be srcLength - srcByteOffset.

  let cloneLength = srcLength - srcByteOffset; // 7. Let srcBlock be srcBuffer.[[ArrayBufferData]].

  let srcBlock = srcBuffer.$ArrayBufferData;
  (0, _invariant.default)(srcBlock); // 8. Let targetBuffer be ? AllocateArrayBuffer(cloneConstructor, srcLength).

  let targetBuffer = AllocateArrayBuffer(realm, cloneConstructor, srcLength); // 9. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.

  if ((0, _is.IsDetachedBuffer)(realm, srcBuffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcBuffer) is true");
  } // 10. Let targetBlock be targetBuffer.[[ArrayBufferData]].


  let targetBlock = targetBuffer.$ArrayBufferData;
  (0, _invariant.default)(targetBlock); // 11. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock, srcByteOffset, cloneLength).

  CopyDataBlockBytes(realm, targetBlock, 0, srcBlock, srcByteOffset, cloneLength); // 12. Return targetBuffer.

  return targetBuffer;
} // ECMA262 24.1.1.6


function SetValueInBuffer(realm, arrayBuffer, byteIndex, type, value, _isLittleEndian) {
  let isLittleEndian = _isLittleEndian; // 1. Assert: IsDetachedBuffer(arrayBuffer) is false.

  (0, _invariant.default)((0, _is.IsDetachedBuffer)(realm, arrayBuffer) === false); // 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

  (0, _invariant.default)(arrayBuffer.$ArrayBufferData instanceof Uint8Array && byteIndex + _types.ElementSize[type] <= arrayBuffer.$ArrayBufferData.length); // 3. Assert: byteIndex is an integer value  0.

  (0, _invariant.default)(byteIndex >= 0); // 4. Assert: Type(value) is Number.

  (0, _invariant.default)(typeof value === "number"); // 5. Let block be arrayBuffer.[[ArrayBufferData]].

  let block = _singletons.Properties.ThrowIfInternalSlotNotWritable(realm, arrayBuffer, "$ArrayBufferData").$ArrayBufferData; // 6. Assert: block is not undefined.


  (0, _invariant.default)(block instanceof Uint8Array); // 7. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.

  if (isLittleEndian === undefined) isLittleEndian = true;
  let rawBytes = new Uint8Array(_types.ElementSize[type]); // 8. If type is "Float32", then

  if (type === "Float32") {
    // a. Set rawBytes to a List containing the 4 bytes that are the result of converting value to IEEE 754-2008 binary32 format using Round to nearest, ties to even rounding mode. If isLittleEndian is false, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If value is NaN, rawValue may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable NaN value.
    new DataView(rawBytes.buffer).setFloat32(0, value, isLittleEndian);
  } else if (type === "Float64") {
    // 9. Else if type is "Float64", then
    // a. Set rawBytes to a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of value. If isLittleEndian is false, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If value is NaN, rawValue may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable NaN value.
    new DataView(rawBytes.buffer).setFloat64(0, value, isLittleEndian);
  } else {
    // 10. Else,
    // a. Let n be the Number value of the Element Size specified in Table 50 for Element Type type.
    let n = _types.ElementSize[type]; // b. Let convOp be the abstract operation named in the Conversion Operation column in Table 50 for Element Type type.

    let convOp = _singletons.To.ElementConv[type]; // c. Let intValue be convOp(value).

    let intValue = convOp(realm, value); // d. If intValue  0, then

    if (intValue > 0) {
      // i. Let rawBytes be a List containing the n-byte binary encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
      if (n === 1) {
        new DataView(rawBytes.buffer).setUint8(0, intValue);
      } else if (n === 2) {
        new DataView(rawBytes.buffer).setUint16(0, intValue, isLittleEndian);
      } else if (n === 4) {
        new DataView(rawBytes.buffer).setUint32(0, intValue, isLittleEndian);
      } else {
        (0, _invariant.default)(false);
      }
    } else {
      // e. Else,
      // i. Let rawBytes be a List containing the n-byte binary 2's complement encoding of intValue. If isLittleEndian is false, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
      if (n === 1) {
        new DataView(rawBytes.buffer).setInt8(0, intValue);
      } else if (n === 2) {
        new DataView(rawBytes.buffer).setInt16(0, intValue, isLittleEndian);
      } else if (n === 4) {
        new DataView(rawBytes.buffer).setInt32(0, intValue, isLittleEndian);
      } else {
        (0, _invariant.default)(false);
      }
    }
  } // 11. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].


  for (let i = 0; i < rawBytes.length; ++i) {
    block[byteIndex + i] = rawBytes[i];
  } // 12. Return NormalCompletion(undefined).


  return realm.intrinsics.undefined;
}
//# sourceMappingURL=arraybuffer.js.map

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// This is a variation of traverseFast from
// https://github.com/babel/babel/blob/28ae47a174f67a8ae6f4527e0a66e88896814170/packages/babel-types/src/index.js
// This version...
// - takes a callback function that returns a boolean to indicate whether to short-circuit the traversal
// - doesn't pass around or allocate an optional parameter value to the callback.
function traverse(node, enter) {
  if (!node) return;
  let keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;
  let stop = enter(node);
  if (stop) return;

  for (let key of keys) {
    let subNode = node[key];

    if (Array.isArray(subNode)) {
      for (let elementNode of subNode) {
        traverse(elementNode, enter);
      }
    } else {
      traverse(subNode, enter);
    }
  }
}
//# sourceMappingURL=traverse-fast.js.map

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(281).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(287).SourceMapConsumer;
exports.SourceNode = __webpack_require__(290).SourceNode;


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(282);
var util = __webpack_require__(284);
var ArraySet = __webpack_require__(285).ArraySet;
var MappingList = __webpack_require__(286).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(283);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),
/* 283 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),
/* 284 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(284);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(284);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(284);
var binarySearch = __webpack_require__(288);
var ArraySet = __webpack_require__(285).ArraySet;
var base64VLQ = __webpack_require__(282);
var quickSort = __webpack_require__(289).quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),
/* 288 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),
/* 289 */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(281).SourceMapGenerator;
var util = __webpack_require__(284);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReactElement = isReactElement;
exports.isReactPropsObject = isReactPropsObject;
exports.getReactSymbol = getReactSymbol;
exports.isTagName = isTagName;
exports.isReactComponent = isReactComponent;
exports.valueIsClassComponent = valueIsClassComponent;
exports.valueIsKnownReactAbstraction = valueIsKnownReactAbstraction;
exports.valueIsReactLibraryObject = valueIsReactLibraryObject;
exports.valueIsLegacyCreateClassComponent = valueIsLegacyCreateClassComponent;
exports.valueIsFactoryClassComponent = valueIsFactoryClassComponent;
exports.addKeyToReactElement = addKeyToReactElement;
exports.getUniqueReactElementKey = getUniqueReactElementKey;
exports.forEachArrayValue = forEachArrayValue;
exports.mapArrayValue = mapArrayValue;
exports.convertSimpleClassComponentToFunctionalComponent = convertSimpleClassComponentToFunctionalComponent;
exports.convertFunctionalComponentToComplexClassComponent = convertFunctionalComponentToComplexClassComponent;
exports.normalizeFunctionalComponentParamaters = normalizeFunctionalComponentParamaters;
exports.createReactHintObject = createReactHintObject;
exports.getComponentTypeFromRootValue = getComponentTypeFromRootValue;
exports.flagPropsWithNoPartialKeyOrRef = flagPropsWithNoPartialKeyOrRef;
exports.hasNoPartialKeyOrRef = hasNoPartialKeyOrRef;
exports.getMaxLength = getMaxLength;
exports.flattenChildren = flattenChildren;
exports.getProperty = getProperty;
exports.createReactEvaluatedNode = createReactEvaluatedNode;
exports.getComponentName = getComponentName;
exports.convertConfigObjectToReactComponentTreeConfig = convertConfigObjectToReactComponentTreeConfig;
exports.getValueFromFunctionCall = getValueFromFunctionCall;
exports.createNoopFunction = createNoopFunction;
exports.doNotOptimizeComponent = doNotOptimizeComponent;
exports.createDefaultPropsHelper = createDefaultPropsHelper;
exports.createInternalReactElement = createInternalReactElement;
exports.cloneProps = cloneProps;
exports.applyObjectAssignConfigsForReactElement = applyObjectAssignConfigsForReactElement;
exports.canExcludeReactElementObjectProperty = canExcludeReactElementObjectProperty;
exports.cloneReactElement = cloneReactElement;
exports.hardModifyReactObjectPropertyBinding = hardModifyReactObjectPropertyBinding;

var _realm = __webpack_require__(7);

var _completions = __webpack_require__(18);

var _parser = __webpack_require__(247);

var _index = __webpack_require__(10);

var _generator = __webpack_require__(237);

var _index2 = __webpack_require__(232);

var _BinaryExpression = __webpack_require__(292);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _singletons = __webpack_require__(236);

var _traverse = _interopRequireDefault(__webpack_require__(293));

var t = _interopRequireWildcard(__webpack_require__(21));

var _errors = __webpack_require__(3);

var _descriptors = __webpack_require__(268);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function isReactElement(val) {
  if (!(val instanceof _index.ObjectValue)) {
    return false;
  }

  let realm = val.$Realm;

  if (!realm.react.enabled) {
    return false;
  }

  if (realm.react.reactElements.has(val)) {
    return true;
  }

  if (!val.properties.has("type") || !val.properties.has("props") || !val.properties.has("$$typeof")) {
    return false;
  }

  let $$typeof = getProperty(realm, val, "$$typeof");
  let globalObject = realm.$GlobalObject;
  let globalSymbolValue = getProperty(realm, globalObject, "Symbol");

  if (globalSymbolValue === realm.intrinsics.undefined) {
    if ($$typeof instanceof _index.NumberValue) {
      return $$typeof.value === 0xeac7;
    }
  } else if ($$typeof instanceof _index.SymbolValue) {
    let symbolFromRegistry = realm.globalSymbolRegistry.find(e => e.$Symbol === $$typeof);

    let _isReactElement = symbolFromRegistry !== undefined && symbolFromRegistry.$Key === "react.element";

    if (_isReactElement) {
      // If we get there, it means the ReactElement was created in manual user-space
      realm.react.reactElements.set(val, {
        createdDuringReconcilation: false,
        firstRenderOnly: false
      });
      return true;
    }
  }

  return false;
}

function isReactPropsObject(val) {
  if (!(val instanceof _index.ObjectValue)) {
    return false;
  }

  let realm = val.$Realm;

  if (!realm.react.enabled) {
    return false;
  }

  if (realm.react.reactProps.has(val)) {
    return true;
  }

  return false;
}

function getReactSymbol(symbolKey, realm) {
  let reactSymbol = realm.react.symbols.get(symbolKey);

  if (reactSymbol !== undefined) {
    return reactSymbol;
  }

  let SymbolFor = realm.intrinsics.Symbol.properties.get("for");

  if (SymbolFor !== undefined) {
    let SymbolForDescriptor = SymbolFor.descriptor;

    if (SymbolForDescriptor !== undefined) {
      (0, _invariant.default)(SymbolForDescriptor instanceof _descriptors.PropertyDescriptor);
      let SymbolForValue = SymbolForDescriptor.value;

      if (SymbolForValue instanceof _index.ObjectValue && typeof SymbolForValue.$Call === "function") {
        reactSymbol = SymbolForValue.$Call(realm.intrinsics.Symbol, [new _index.StringValue(realm, symbolKey)]);
        (0, _invariant.default)(reactSymbol instanceof _index.SymbolValue);
        realm.react.symbols.set(symbolKey, reactSymbol);
      }
    }
  }

  (0, _invariant.default)(reactSymbol instanceof _index.SymbolValue, `Symbol("${symbolKey}") could not be found in realm`);
  return reactSymbol;
}

function isTagName(ast) {
  return ast.type === "JSXIdentifier" && /^[a-z]|\-/.test(ast.name);
}

function isReactComponent(name) {
  return name.length > 0 && name[0] === name[0].toUpperCase();
}

function valueIsClassComponent(realm, value) {
  if (!(value instanceof _index.FunctionValue)) {
    return false;
  }

  let prototype = (0, _index2.Get)(realm, value, "prototype");

  if (prototype instanceof _index.ObjectValue) {
    return _singletons.To.ToBooleanPartial(realm, (0, _index2.Get)(realm, prototype, "isReactComponent"));
  }

  return false;
}

function valueIsKnownReactAbstraction(realm, value) {
  return value instanceof _index.AbstractObjectValue && realm.react.abstractHints.has(value);
} // logger isn't typed otherwise it will increase flow cycle length :()


function valueIsReactLibraryObject(realm, value, logger) {
  if (realm.fbLibraries.react === value) {
    return true;
  } // we check that the object is the React or React-like library by checking for
  // core properties that should exist on it


  let reactVersion = logger.tryQuery(() => (0, _index2.Get)(realm, value, "version"), undefined);

  if (!(reactVersion instanceof _index.StringValue)) {
    return false;
  }

  let reactCreateElement = logger.tryQuery(() => (0, _index2.Get)(realm, value, "createElement"), undefined);

  if (!(reactCreateElement instanceof _index.FunctionValue)) {
    return false;
  }

  let reactCloneElement = logger.tryQuery(() => (0, _index2.Get)(realm, value, "cloneElement"), undefined);

  if (!(reactCloneElement instanceof _index.FunctionValue)) {
    return false;
  }

  let reactIsValidElement = logger.tryQuery(() => (0, _index2.Get)(realm, value, "isValidElement"), undefined);

  if (!(reactIsValidElement instanceof _index.FunctionValue)) {
    return false;
  }

  let reactComponent = logger.tryQuery(() => (0, _index2.Get)(realm, value, "Component"), undefined);

  if (!(reactComponent instanceof _index.FunctionValue)) {
    return false;
  }

  let reactChildren = logger.tryQuery(() => (0, _index2.Get)(realm, value, "Children"), undefined);

  if (!(reactChildren instanceof _index.ObjectValue)) {
    return false;
  }

  return false;
}

function valueIsLegacyCreateClassComponent(realm, value) {
  if (!(value instanceof _index.FunctionValue)) {
    return false;
  }

  let prototype = (0, _index2.Get)(realm, value, "prototype");

  if (prototype instanceof _index.ObjectValue) {
    return prototype.properties.has("__reactAutoBindPairs");
  }

  return false;
}

function valueIsFactoryClassComponent(realm, value) {
  if (value instanceof _index.ObjectValue && !_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(value)) {
    return _singletons.To.ToBooleanPartial(realm, (0, _index2.Get)(realm, value, "render"));
  }

  return false;
}

function addKeyToReactElement(realm, reactElement) {
  let typeValue = getProperty(realm, reactElement, "type");
  let refValue = getProperty(realm, reactElement, "ref");
  let propsValue = getProperty(realm, reactElement, "props"); // we need to apply a key when we're branched

  let currentKeyValue = getProperty(realm, reactElement, "key") || realm.intrinsics.null;
  let uniqueKey = getUniqueReactElementKey("", realm.react.usedReactElementKeys);
  let newKeyValue = new _index.StringValue(realm, uniqueKey);

  if (currentKeyValue !== realm.intrinsics.null) {
    newKeyValue = (0, _BinaryExpression.computeBinary)(realm, "+", currentKeyValue, newKeyValue);
  }

  (0, _invariant.default)(propsValue instanceof _index.ObjectValue);
  return createInternalReactElement(realm, typeValue, newKeyValue, refValue, propsValue);
} // we create a unique key for each JSXElement to prevent collisions
// otherwise React will detect a missing/conflicting key at runtime and
// this can break the reconcilation of JSXElements in arrays


function getUniqueReactElementKey(index, usedReactElementKeys) {
  let key;

  do {
    key = Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 2);
  } while (usedReactElementKeys.has(key));

  usedReactElementKeys.add(key);

  if (index !== undefined) {
    return `${key}${index}`;
  }

  return key;
} // a helper function to loop over ArrayValues


function forEachArrayValue(realm, array, mapFunc) {
  let lengthValue = (0, _index2.Get)(realm, array, "length");
  let isConditionalLength = lengthValue instanceof _index.AbstractValue && lengthValue.kind === "conditional";
  let length;

  if (isConditionalLength) {
    length = getMaxLength(lengthValue, 0);
  } else {
    (0, _invariant.default)(lengthValue instanceof _index.NumberValue, "TODO: support other types of array length value");
    length = lengthValue.value;
  }

  for (let i = 0; i < length; i++) {
    let elementProperty = array.properties.get("" + i);
    let elementPropertyDescriptor = elementProperty && elementProperty.descriptor;

    if (elementPropertyDescriptor) {
      (0, _invariant.default)(elementPropertyDescriptor instanceof _descriptors.PropertyDescriptor);
      let elementValue = elementPropertyDescriptor.value; // If we are in an array with conditional length, the element might be a conditional join
      // of the same type as the length of the array

      if (isConditionalLength && elementValue instanceof _index.AbstractValue && elementValue.kind === "conditional") {
        (0, _invariant.default)(lengthValue instanceof _index.AbstractValue);
        let lengthCondition = lengthValue.args[0];
        let elementCondition = elementValue.args[0]; // If they are the same condition

        (0, _invariant.default)(lengthCondition.equals(elementCondition), "TODO: support cases where the condition is not the same");
      }

      (0, _invariant.default)(elementValue instanceof _index.Value);
      mapFunc(elementValue, i);
    }
  }
}

function mapArrayValue(realm, array, mapFunc) {
  let returnTheNewArray = false;
  let newArray;

  const mapArray = lengthValue => {
    let length = lengthValue.value;

    for (let i = 0; i < length; i++) {
      let elementProperty = array.properties.get("" + i);
      let elementPropertyDescriptor = elementProperty && elementProperty.descriptor;

      if (elementPropertyDescriptor) {
        (0, _invariant.default)(elementPropertyDescriptor instanceof _descriptors.PropertyDescriptor);
        let elementValue = elementPropertyDescriptor.value;

        if (elementValue instanceof _index.Value) {
          let newElement = mapFunc(elementValue, elementPropertyDescriptor);

          if (newElement !== elementValue) {
            returnTheNewArray = true;
          }

          _singletons.Create.CreateDataPropertyOrThrow(realm, newArray, "" + i, newElement);

          continue;
        }
      }

      _singletons.Create.CreateDataPropertyOrThrow(realm, newArray, "" + i, realm.intrinsics.undefined);
    }
  };

  let lengthValue = (0, _index2.Get)(realm, array, "length");

  if (lengthValue instanceof _index.AbstractValue && lengthValue.kind === "conditional") {
    returnTheNewArray = true;
    let [condValue, consequentVal, alternateVal] = lengthValue.args;
    newArray = _singletons.Create.ArrayCreate(realm, 0);
    realm.evaluateWithAbstractConditional(condValue, () => {
      return realm.evaluateForEffects(() => {
        (0, _invariant.default)(consequentVal instanceof _index.NumberValue);
        mapArray(consequentVal);
        return realm.intrinsics.undefined;
      }, null, "mapArrayValue consequent");
    }, () => {
      return realm.evaluateForEffects(() => {
        (0, _invariant.default)(alternateVal instanceof _index.NumberValue);
        mapArray(alternateVal);
        return realm.intrinsics.undefined;
      }, null, "mapArrayValue alternate");
    });
  } else if (lengthValue instanceof _index.NumberValue) {
    newArray = _singletons.Create.ArrayCreate(realm, lengthValue.value);
    mapArray(lengthValue);
  } else {
    (0, _invariant.default)(false, "TODO: support other types of array length value");
  }

  return returnTheNewArray ? newArray : array;
}

function GetDescriptorForProperty(value, propertyName) {
  let object = value.properties.get(propertyName);
  (0, _invariant.default)(object);
  return object.descriptor;
}

function convertSimpleClassComponentToFunctionalComponent(realm, complexComponentType, transforms) {
  let prototype = complexComponentType.properties.get("prototype");
  (0, _invariant.default)(prototype);
  (0, _invariant.default)(prototype.descriptor instanceof _descriptors.PropertyDescriptor);
  prototype.descriptor.configurable = true;

  _singletons.Properties.DeletePropertyOrThrow(realm, complexComponentType, "prototype"); // change the function kind


  complexComponentType.$FunctionKind = "normal"; // set the prototype back to an object

  complexComponentType.$Prototype = realm.intrinsics.FunctionPrototype; // give the function the functional components params

  complexComponentType.$FormalParameters = [t.identifier("props"), t.identifier("context")]; // add a transform to occur after the additional function has serialized the body of the class

  transforms.push(body => {
    // as this was a class before and is now a functional component, we need to replace
    // this.props and this.context to props and context, via the function arugments
    let funcNode = t.functionExpression(null, [], t.blockStatement(body));
    (0, _traverse.default)(t.file(t.program([t.expressionStatement(funcNode)])), {
      "Identifier|ThisExpression"(path) {
        let node = path.node;

        if (t.isIdentifier(node) && node.name === "this" || t.isThisExpression(node)) {
          let parentPath = path.parentPath;
          let parentNode = parentPath.node;

          if (t.isMemberExpression(parentNode)) {
            // remove the "this" from the member
            parentPath.replaceWith(parentNode.property);
          } else {
            throw new _errors.FatalError(`conversion of a simple class component to functional component failed due to "this" not being replaced`);
          }
        }
      }

    }, undefined, {}, undefined);

    _traverse.default.cache.clear();
  });
}

function createBinding(descriptor, key, object) {
  return {
    descriptor,
    key,
    object
  };
}

function cloneProperties(realm, properties, object) {
  let newProperties = new Map();

  for (let [propertyName, {
    descriptor
  }] of properties) {
    newProperties.set(propertyName, createBinding((0, _descriptors.cloneDescriptor)(descriptor.throwIfNotConcrete(realm)), propertyName, object));
  }

  return newProperties;
}

function cloneSymbols(realm, symbols, object) {
  let newSymbols = new Map();

  for (let [symbol, {
    descriptor
  }] of symbols) {
    newSymbols.set(symbol, createBinding((0, _descriptors.cloneDescriptor)(descriptor.throwIfNotConcrete(realm)), symbol, object));
  }

  return newSymbols;
}

function cloneValue(realm, originalValue, _prototype, copyToObject) {
  if (originalValue instanceof _index.FunctionValue) {
    return cloneFunction(realm, originalValue, _prototype, copyToObject);
  }

  (0, _invariant.default)(false, "TODO: add support to cloneValue() for more value types");
}

function cloneFunction(realm, originalValue, _prototype, copyToObject) {
  let newValue;

  if (originalValue instanceof _index.ECMAScriptSourceFunctionValue) {
    newValue = copyToObject || new _index.ECMAScriptSourceFunctionValue(realm, originalValue.intrinsicName);
    (0, _invariant.default)(newValue instanceof _index.ECMAScriptSourceFunctionValue); // $FlowFixMe: complains about Object.assign

    Object.assign(newValue, originalValue);
    let properties = cloneProperties(realm, originalValue.properties, newValue);
    newValue.properties = properties;
    let symbols = cloneSymbols(realm, originalValue.symbols, newValue);
    newValue.symbols = symbols; // handle home object + prototype

    let originalPrototype = originalValue.$HomeObject;
    (0, _invariant.default)(originalPrototype instanceof _index.ObjectValue);

    let prototype = _prototype || clonePrototype(realm, originalPrototype);

    newValue.$HomeObject = prototype;

    if (originalPrototype.properties.has("constructor")) {
      _singletons.Properties.Set(realm, prototype, "constructor", newValue, false);
    }

    if (originalValue.properties.has("prototype")) {
      _singletons.Properties.Set(realm, newValue, "prototype", prototype, false);
    }
  }

  (0, _invariant.default)(newValue instanceof _index.FunctionValue, "TODO: add support to cloneValue() for more function types");
  return newValue;
}

function clonePrototype(realm, prototype) {
  (0, _invariant.default)(prototype instanceof _index.ObjectValue);
  let newPrototype = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, prototype.intrinsicName);
  Object.assign(newPrototype, prototype);

  for (let [propertyName] of prototype.properties) {
    if (propertyName !== "constructor") {
      let originalValue = (0, _index2.Get)(realm, prototype, propertyName);
      let newValue = cloneValue(realm, originalValue, prototype);

      _singletons.Properties.Set(realm, newPrototype, propertyName, newValue, false);
    }
  }

  for (let [symbol] of prototype.symbols) {
    let originalValue = (0, _index2.Get)(realm, prototype, symbol);
    let newValue = cloneValue(realm, originalValue, prototype);

    _singletons.Properties.Set(realm, newPrototype, symbol, newValue, false);
  }

  return newPrototype;
}

const skipFunctionProperties = new Set(["length", "prototype", "arguments", "name", "caller"]);

function convertFunctionalComponentToComplexClassComponent(realm, functionalComponentType, complexComponentType, transforms) {
  (0, _invariant.default)(complexComponentType instanceof _index.ECMAScriptSourceFunctionValue || complexComponentType instanceof _index.BoundFunctionValue); // get all properties on the functional component that were added in user-code
  // we add defaultProps as undefined, as merging a class component's defaultProps on to
  // a differnet component isn't right, we can discard defaultProps instead via folding
  // we also don't want propTypes from the class component, so we remove that too

  let userCodePropertiesToAdd = new Map([["defaultProps", createBinding(undefined, "defaultProps", functionalComponentType)], ["propTypes", createBinding(undefined, "propTypes", functionalComponentType)]]);
  let userCodeSymbolsToAdd = new Map();

  for (let [propertyName, binding] of functionalComponentType.properties) {
    if (!skipFunctionProperties.has(propertyName)) {
      userCodePropertiesToAdd.set(propertyName, binding);
    }
  }

  for (let [symbol, binding] of functionalComponentType.symbols) {
    userCodeSymbolsToAdd.set(symbol, binding);
  }

  cloneValue(realm, complexComponentType, null, functionalComponentType); // then copy back and properties that were on the original functional component
  // ensuring we overwrite any existing ones

  for (let [propertyName, binding] of userCodePropertiesToAdd) {
    functionalComponentType.properties.set(propertyName, binding);
  }

  for (let [symbol, binding] of userCodeSymbolsToAdd) {
    functionalComponentType.symbols.set(symbol, binding);
  } // add a transform to occur after the additional function has serialized the body of the class


  transforms.push(body => {
    // as we've converted a functional component to a complex one, we are going to have issues with
    // "props" and "context" references, as they're now going to be "this.props" and "this.context".
    // we simply need a to add to vars to beginning of the body to get around this
    // if they're not used, any DCE tool post-Prepack (GCC or Uglify) will remove them
    body.unshift(t.variableDeclaration("var", [t.variableDeclarator(t.identifier("props"), t.memberExpression(t.thisExpression(), t.identifier("props"))), t.variableDeclarator(t.identifier("context"), t.memberExpression(t.thisExpression(), t.identifier("context")))]));
  });
}

function normalizeFunctionalComponentParamaters(func) {
  // fix the length as we may change the arguments
  let lengthProperty = GetDescriptorForProperty(func, "length");
  (0, _invariant.default)(lengthProperty instanceof _descriptors.PropertyDescriptor);
  lengthProperty.writable = false;
  lengthProperty.enumerable = false;
  lengthProperty.configurable = true;
  func.$FormalParameters = func.$FormalParameters.map((param, i) => {
    if (i === 0) {
      return t.isIdentifier(param) ? param : t.identifier("props");
    } else {
      return t.isIdentifier(param) ? param : t.identifier("context");
    }
  });

  if (func.$FormalParameters.length === 1) {
    func.$FormalParameters.push(t.identifier("context"));
  } // ensure the length value is set to the correct value after
  // we've made mutations to the arguments of this function


  let lengthValue = lengthProperty.value;
  (0, _invariant.default)(lengthValue instanceof _index.NumberValue);
  lengthValue.value = func.$FormalParameters.length;
}

function createReactHintObject(object, propertyName, args, firstRenderValue) {
  return {
    firstRenderValue,
    object,
    propertyName,
    args
  };
}

function getComponentTypeFromRootValue(realm, value) {
  let _valueIsKnownReactAbstraction = valueIsKnownReactAbstraction(realm, value);

  if (!(value instanceof _index.ECMAScriptSourceFunctionValue || value instanceof _index.BoundFunctionValue || _valueIsKnownReactAbstraction)) {
    return null;
  }

  if (_valueIsKnownReactAbstraction) {
    (0, _invariant.default)(value instanceof _index.AbstractValue);
    let reactHint = realm.react.abstractHints.get(value);
    (0, _invariant.default)(reactHint);

    if (typeof reactHint !== "string" && reactHint.object === realm.fbLibraries.reactRelay) {
      switch (reactHint.propertyName) {
        case "createFragmentContainer":
        case "createPaginationContainer":
        case "createRefetchContainer":
          (0, _invariant.default)(Array.isArray(reactHint.args)); // componentType is the 1st argument of a ReactRelay container

          let componentType = reactHint.args[0];
          (0, _invariant.default)(componentType instanceof _index.ECMAScriptSourceFunctionValue || componentType instanceof _index.BoundFunctionValue);
          return componentType;

        default:
          (0, _invariant.default)(false, `unsupported known React abstraction - ReactRelay property "${reactHint.propertyName}" not supported`);
      }
    }

    (0, _invariant.default)(false, "unsupported known React abstraction");
  } else {
    (0, _invariant.default)(value instanceof _index.ECMAScriptSourceFunctionValue || value instanceof _index.BoundFunctionValue);
    return value;
  }
}

function flagPropsWithNoPartialKeyOrRef(realm, props) {
  realm.react.propsWithNoPartialKeyOrRef.add(props);
}

function hasNoPartialKeyOrRef(realm, props) {
  if (realm.react.propsWithNoPartialKeyOrRef.has(props)) {
    return true;
  }

  if (props instanceof _index.ObjectValue && !props.isPartialObject()) {
    return true;
  }

  if (props instanceof _index.AbstractObjectValue) {
    if (props.values.isTop()) {
      return false;
    }

    let elements = props.values.getElements();

    for (let element of elements) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);
      let wasSafe = hasNoPartialKeyOrRef(realm, element);

      if (!wasSafe) {
        return false;
      }
    }

    return true;
  }

  if (props instanceof _index.ObjectValue && props.properties.has("key") && props.properties.has("ref")) {
    return true;
  }

  return false;
}

function getMaxLength(value, maxLength) {
  if (value instanceof _index.NumberValue) {
    if (value.value > maxLength) {
      return value.value;
    } else {
      return maxLength;
    }
  } else if (value instanceof _index.AbstractValue && value.kind === "conditional") {
    let [, consequentVal, alternateVal] = value.args;
    let consequentMaxVal = getMaxLength(consequentVal, maxLength);
    let alternateMaxVal = getMaxLength(alternateVal, maxLength);

    if (consequentMaxVal > maxLength && consequentMaxVal >= alternateMaxVal) {
      return consequentMaxVal;
    } else if (alternateMaxVal > maxLength && alternateMaxVal >= consequentMaxVal) {
      return alternateMaxVal;
    }

    return maxLength;
  }

  (0, _invariant.default)(false, "TODO: support other types of array length value");
}

function recursivelyFlattenArray(realm, array, targetArray, noHoles) {
  forEachArrayValue(realm, array, _item => {
    let element = _item;

    if (element instanceof _index.ArrayValue && !element.intrinsicName) {
      recursivelyFlattenArray(realm, element, targetArray, noHoles);
    } else {
      let lengthValue = (0, _index2.Get)(realm, targetArray, "length");
      (0, _invariant.default)(lengthValue instanceof _index.NumberValue);

      if (noHoles && element instanceof _index.EmptyValue) {
        // We skip holely elements
        return;
      } else if (noHoles && element instanceof _index.AbstractValue && element.kind === "conditional") {
        let [condValue, consequentVal, alternateVal] = element.args;
        (0, _invariant.default)(condValue instanceof _index.AbstractValue);
        let consquentIsHolely = consequentVal instanceof _index.EmptyValue;
        let alternateIsHolely = alternateVal instanceof _index.EmptyValue;

        if (consquentIsHolely && alternateIsHolely) {
          // We skip holely elements
          return;
        }

        if (consquentIsHolely) {
          element = _index.AbstractValue.createFromLogicalOp(realm, "&&", _index.AbstractValue.createFromUnaryOp(realm, "!", condValue), alternateVal);
        }

        if (alternateIsHolely) {
          element = _index.AbstractValue.createFromLogicalOp(realm, "&&", condValue, consequentVal);
        }
      }

      _singletons.Properties.Set(realm, targetArray, "" + lengthValue.value, element, true);
    }
  });
}

function flattenChildren(realm, array, noHoles) {
  let flattenedChildren = _singletons.Create.ArrayCreate(realm, 0);

  recursivelyFlattenArray(realm, array, flattenedChildren, noHoles);
  flattenedChildren.makeFinal();
  return flattenedChildren;
} // This function is mainly use to get internal properties
// on objects that we know are safe to access internally
// such as ReactElements. Getting properties here does
// not emit change to modified bindings and is intended
// for only internal usage  not for user-land code


function getProperty(realm, object, property) {
  if (object instanceof _index.AbstractObjectValue) {
    if (object.values.isTop()) {
      return realm.intrinsics.undefined;
    }

    let elements = object.values.getElements();
    (0, _invariant.default)(elements.size === 1, "TODO: deal with multiple elements");

    for (let element of elements) {
      (0, _invariant.default)(element instanceof _index.ObjectValue, "TODO: deal with object set templates");
      object = element;
    }

    (0, _invariant.default)(object instanceof _index.ObjectValue);
  }

  let binding;

  if (typeof property === "string") {
    binding = object.properties.get(property);
  } else {
    binding = object.symbols.get(property);
  }

  if (!binding) {
    return realm.intrinsics.undefined;
  }

  let descriptor = binding.descriptor;

  if (!descriptor) {
    return realm.intrinsics.undefined;
  }

  (0, _invariant.default)(descriptor instanceof _descriptors.PropertyDescriptor);
  let value = descriptor.value;

  if (value === undefined) {
    _index.AbstractValue.reportIntrospectionError(object, `react/utils/getProperty unsupported getter/setter property`);

    throw new _errors.FatalError();
  }

  (0, _invariant.default)(value instanceof _index.Value, `react/utils/getProperty should not be called on internal properties`);
  return value;
}

function createReactEvaluatedNode(status, name) {
  return {
    children: [],
    message: "",
    name,
    status
  };
}

function getComponentName(realm, componentType) {
  if (componentType instanceof _index.SymbolValue && componentType === getReactSymbol("react.fragment", realm)) {
    return "React.Fragment";
  } else if (componentType instanceof _index.SymbolValue) {
    return "unknown symbol";
  } // $FlowFixMe: this code is fine, Flow thinks that coponentType is bound to string...


  if (isReactComponent(componentType)) {
    return "ReactElement";
  }

  if (componentType === realm.intrinsics.undefined || componentType === realm.intrinsics.null) {
    return "no name";
  }

  (0, _invariant.default)(componentType instanceof _index.ECMAScriptSourceFunctionValue || componentType instanceof _index.BoundFunctionValue || componentType instanceof _index.AbstractObjectValue || componentType instanceof _index.AbstractValue || componentType instanceof _index.ObjectValue);
  let boundText = componentType instanceof _index.BoundFunctionValue ? "bound " : "";

  if (componentType.__originalName) {
    return boundText + componentType.__originalName;
  }

  if (realm.fbLibraries.reactRelay !== undefined) {
    if (componentType === (0, _index2.Get)(realm, realm.fbLibraries.reactRelay, "QueryRenderer")) {
      return boundText + "QueryRenderer";
    }
  }

  if (componentType instanceof _index.ECMAScriptSourceFunctionValue && componentType.$Prototype !== undefined) {
    let name = (0, _index2.Get)(realm, componentType, "name");

    if (name instanceof _index.StringValue) {
      return boundText + name.value;
    }
  }

  if (componentType instanceof _index.ObjectValue) {
    let $$typeof = getProperty(realm, componentType, "$$typeof");

    if ($$typeof === getReactSymbol("react.forward_ref", realm)) {
      return "forwarded ref";
    }
  }

  if (componentType instanceof _index.FunctionValue) {
    return boundText + "anonymous";
  }

  return "unknown";
}

function convertConfigObjectToReactComponentTreeConfig(realm, config) {
  // defaults
  let firstRenderOnly = false;
  let isRoot = false;
  let modelString;

  if (!(config instanceof _index.UndefinedValue)) {
    for (let [key] of config.properties) {
      let propValue = getProperty(realm, config, key);

      if (propValue instanceof _index.StringValue || propValue instanceof _index.NumberValue || propValue instanceof _index.BooleanValue) {
        let value = propValue.value;

        if (typeof value === "boolean") {
          // boolean options
          if (key === "firstRenderOnly") {
            firstRenderOnly = value;
          } else if (key === "isRoot") {
            isRoot = value;
          }
        } else if (typeof value === "string") {
          try {
            // result here is ignored as the main point here is to
            // check and produce error
            JSON.parse(value);
          } catch (e) {
            let componentModelError = new _errors.CompilerDiagnostic("Failed to parse model for component", realm.currentLocation, "PP1008", "FatalError");

            if (realm.handleError(componentModelError) !== "Recover") {
              throw new _errors.FatalError();
            }
          } // string options


          if (key === "model") {
            modelString = value;
          }
        }
      } else {
        let diagnostic = new _errors.CompilerDiagnostic("__optimizeReactComponentTree(rootComponent, config) has been called with invalid arguments", realm.currentLocation, "PP0024", "FatalError");
        realm.handleError(diagnostic);
        if (realm.handleError(diagnostic) === "Fail") throw new _errors.FatalError();
      }
    }
  }

  return {
    firstRenderOnly,
    isRoot,
    modelString
  };
}

function getValueFromFunctionCall(realm, func, funcThis, args, isConstructor = false) {
  (0, _invariant.default)(func.$Call, "Expected function to be a FunctionValue with $Call method");
  let funcCall = func.$Call;
  let newCall = func.$Construct;
  let completion;

  try {
    let value;

    if (isConstructor) {
      (0, _invariant.default)(newCall);
      value = newCall(args, func);
    } else {
      value = funcCall(funcThis, args);
    }

    completion = new _completions.SimpleNormalCompletion(value);
  } catch (error) {
    if (error instanceof _completions.AbruptCompletion) {
      completion = error;
    } else {
      throw error;
    }
  }

  return realm.returnOrThrowCompletion(completion);
}

function isEventProp(name) {
  return name.length > 2 && name[0].toLowerCase() === "o" && name[1].toLowerCase() === "n";
}

function createNoopFunction(realm) {
  if (realm.react.noopFunction !== undefined) {
    return realm.react.noopFunction;
  }

  let noOpFunc = new _index.ECMAScriptSourceFunctionValue(realm);
  noOpFunc.initialize([], t.blockStatement([]));
  realm.react.noopFunction = noOpFunc;
  return noOpFunc;
}

function doNotOptimizeComponent(realm, componentType) {
  if (componentType instanceof _index.ObjectValue) {
    let doNotOptimize = (0, _index2.Get)(realm, componentType, "__reactCompilerDoNotOptimize");

    if (doNotOptimize instanceof _index.BooleanValue) {
      return doNotOptimize.value;
    }
  }

  return false;
}

function createDefaultPropsHelper(realm) {
  let defaultPropsHelper = `
    function defaultPropsHelper(props, defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
      return props;
    }
  `;
  let escapeHelperAst = (0, _parser.parseExpression)(defaultPropsHelper, {
    plugins: ["flow"]
  });
  let helper = new _index.ECMAScriptSourceFunctionValue(realm);
  helper.initialize(escapeHelperAst.params, escapeHelperAst.body);
  return helper;
}

function createInternalReactElement(realm, type, key, ref, props) {
  let obj = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // Sanity check the type is not conditional


  if (type instanceof _index.AbstractValue && type.kind === "conditional") {
    (0, _invariant.default)(false, "createInternalReactElement should never encounter a conditional type");
  }

  _singletons.Create.CreateDataPropertyOrThrow(realm, obj, "$$typeof", getReactSymbol("react.element", realm));

  _singletons.Create.CreateDataPropertyOrThrow(realm, obj, "type", type);

  _singletons.Create.CreateDataPropertyOrThrow(realm, obj, "key", key);

  _singletons.Create.CreateDataPropertyOrThrow(realm, obj, "ref", ref);

  _singletons.Create.CreateDataPropertyOrThrow(realm, obj, "props", props);

  _singletons.Create.CreateDataPropertyOrThrow(realm, obj, "_owner", realm.intrinsics.null);

  obj.makeFinal(); // If we're in "rendering" a React component tree, we should have an active reconciler

  let activeReconciler = realm.react.activeReconciler;
  let createdDuringReconcilation = activeReconciler !== undefined;
  let firstRenderOnly = createdDuringReconcilation ? activeReconciler.componentTreeConfig.firstRenderOnly : false;
  realm.react.reactElements.set(obj, {
    createdDuringReconcilation,
    firstRenderOnly
  }); // Sanity check to ensure no bugs have crept in

  (0, _invariant.default)(realm.react.reactProps.has(props) && props.mightBeFinalObject(), "React props object is not correctly setup");
  return obj;
}

function applyClonedTemporalAlias(realm, props, clonedProps) {
  let temporalAlias = props.temporalAlias;
  (0, _invariant.default)(temporalAlias !== undefined);

  if (temporalAlias.kind === "conditional") {
    // Leave in for now, we should deal with this later, but there might
    // be a better option.
    (0, _invariant.default)(false, "TODO applyClonedTemporalAlias conditional");
  }

  let temporalOperationEntry = realm.getTemporalOperationEntryFromDerivedValue(temporalAlias);

  if (!(temporalOperationEntry instanceof _generator.TemporalObjectAssignEntry)) {
    (0, _invariant.default)(false, "TODO nont TemporalObjectAssignEntry");
  }

  (0, _invariant.default)(temporalOperationEntry !== undefined);
  let temporalArgs = temporalOperationEntry.args; // replace the original props with the cloned one

  let [to, ...sources] = temporalArgs.map(arg => arg === props ? clonedProps : arg);
  (0, _invariant.default)(to instanceof _index.ObjectValue || to instanceof _index.AbstractObjectValue);

  _index.AbstractValue.createTemporalObjectAssign(realm, to, sources);
}

function cloneProps(realm, props, newChildren) {
  let clonedProps = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);

  for (let [propName, binding] of props.properties) {
    if (binding && binding.descriptor) {
      (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

      if (binding.descriptor.enumerable) {
        if (newChildren !== undefined && propName === "children") {
          _singletons.Properties.Set(realm, clonedProps, propName, newChildren, true);
        } else {
          _singletons.Properties.Set(realm, clonedProps, propName, getProperty(realm, props, propName), true);
        }
      }
    }
  }

  if (props.isPartialObject()) {
    clonedProps.makePartial();
  }

  if (props.isSimpleObject()) {
    clonedProps.makeSimple();
  }

  if (realm.react.propsWithNoPartialKeyOrRef.has(props)) {
    flagPropsWithNoPartialKeyOrRef(realm, clonedProps);
  }

  if (props.temporalAlias !== undefined) {
    applyClonedTemporalAlias(realm, props, clonedProps);
  }

  clonedProps.makeFinal();
  realm.react.reactProps.add(clonedProps);
  return clonedProps;
}

function applyObjectAssignConfigsForReactElement(realm, to, sources) {
  // Get the global Object.assign
  let globalObj = (0, _index2.Get)(realm, realm.$GlobalObject, "Object");
  (0, _invariant.default)(globalObj instanceof _index.ObjectValue);
  let objAssign = (0, _index2.Get)(realm, globalObj, "assign");
  (0, _invariant.default)(objAssign instanceof _index.ECMAScriptFunctionValue);
  let objectAssignCall = objAssign.$Call;
  (0, _invariant.default)(objectAssignCall !== undefined); // Use the existing internal Prepack Object.assign model

  objectAssignCall(realm.intrinsics.undefined, [to, ...sources]);
} // In firstRenderOnly mode, we strip off onEventHanlders and any props
// that are functions as they are not required for init render.


function canExcludeReactElementObjectProperty(realm, reactElement, name, value) {
  let reactElementData = realm.react.reactElements.get(reactElement);
  (0, _invariant.default)(reactElementData !== undefined);
  let {
    firstRenderOnly
  } = reactElementData;

  let isHostComponent = getProperty(realm, reactElement, "type") instanceof _index.StringValue;

  return firstRenderOnly && isHostComponent && (isEventProp(name) || value instanceof _index.FunctionValue);
}

function cloneReactElement(realm, reactElement, shouldCloneProps) {
  let typeValue = getProperty(realm, reactElement, "type");
  let keyValue = getProperty(realm, reactElement, "key");
  let refValue = getProperty(realm, reactElement, "ref");
  let propsValue = getProperty(realm, reactElement, "props");
  (0, _invariant.default)(propsValue instanceof _index.ObjectValue);

  if (shouldCloneProps) {
    propsValue = cloneProps(realm, propsValue);
  }

  return createInternalReactElement(realm, typeValue, keyValue, refValue, propsValue);
} // This function changes an object's property value by changing it's binding
// and descriptor, thus bypassing the binding detection system. This is a
// dangerous function and should only be used on objects created by React.
// It's primary use is to update ReactElement / React props properties
// during the visitor equivalence stage as an optimization feature.
// It will invariant if used on objects that are not final.


function hardModifyReactObjectPropertyBinding(realm, object, propName, value) {
  (0, _invariant.default)(object.mightBeFinalObject() && !object.mightNotBeFinalObject(), "hardModifyReactObjectPropertyBinding can only be used on final objects!");
  let binding = object.properties.get(propName);

  if (binding === undefined) {
    binding = {
      object,
      descriptor: new _descriptors.PropertyDescriptor({
        configurable: true,
        enumerable: true,
        value: undefined,
        writable: true
      }),
      key: propName
    };
  }

  let descriptor = binding.descriptor;
  (0, _invariant.default)(descriptor instanceof _descriptors.PropertyDescriptor && (0, _index2.IsDataDescriptor)(realm, descriptor));
  let newDescriptor = new _descriptors.PropertyDescriptor(descriptor);
  newDescriptor.value = value;
  let newBinding = Object.assign({}, binding, {
    descriptor: newDescriptor
  });
  object.properties.set(propName, newBinding);
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.getPureBinaryOperationResultType = getPureBinaryOperationResultType;
exports.computeBinary = computeBinary;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(15);

var _errors = __webpack_require__(3);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _generator = __webpack_require__(237);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  // evaluate left
  let lref = env.evaluate(ast.left, strictCode);

  let lval = _singletons.Environment.GetValue(realm, lref); // evaluate right


  let rref = env.evaluate(ast.right, strictCode);

  let rval = _singletons.Environment.GetValue(realm, rref);

  return computeBinary(realm, ast.operator, lval, rval, ast.left.loc, ast.right.loc, ast.loc);
}

let unknownValueOfOrToString = "might be an object with an unknown valueOf or toString or Symbol.toPrimitive method"; // Returns result type if binary operation is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.

function getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc) {
  function reportErrorIfNotPure(purityTest, typeIfPure) {
    let leftPure = purityTest(realm, lval);
    let rightPure = purityTest(realm, rval);
    if (leftPure && rightPure) return typeIfPure;
    let loc = !leftPure ? lloc : rloc;
    let error = new _errors.CompilerDiagnostic(unknownValueOfOrToString, loc, "PP0002", "RecoverableError");

    if (realm.handleError(error) === "Recover") {
      // Assume that an unknown value is actually a primitive or otherwise a well behaved object.
      return typeIfPure;
    }

    throw new _errors.FatalError();
  }

  if (op === "+") {
    let ltype = _singletons.To.GetToPrimitivePureResultType(realm, lval);

    let rtype = _singletons.To.GetToPrimitivePureResultType(realm, rval);

    if (ltype === _index2.StringValue || rtype === _index2.StringValue) {
      // If either type is a string, the other one will be called with ToString, so that has to be pure.
      if (!_singletons.To.IsToStringPure(realm, rval)) {
        rtype = undefined;
      }

      if (!_singletons.To.IsToStringPure(realm, lval)) {
        ltype = undefined;
      }
    } else {
      // Otherwise, they will be called with ToNumber, so that has to be pure.
      if (!_singletons.To.IsToNumberPure(realm, rval)) {
        rtype = undefined;
      }

      if (!_singletons.To.IsToNumberPure(realm, lval)) {
        ltype = undefined;
      }
    }

    if (ltype === undefined || rtype === undefined) {
      if (lval.getType() === _index2.SymbolValue || rval.getType() === _index2.SymbolValue) {
        // Symbols never implicitly coerce to primitives.
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      let loc = ltype === undefined ? lloc : rloc;
      let error = new _errors.CompilerDiagnostic(unknownValueOfOrToString, loc, "PP0002", "RecoverableError");

      if (realm.handleError(error) === "Recover") {
        // Assume that the unknown value is actually a primitive or otherwise a well behaved object.
        ltype = lval.getType();
        rtype = rval.getType();
        if (ltype === _index2.StringValue || rtype === _index2.StringValue) return _index2.StringValue;
        if (ltype === _index2.IntegralValue && rtype === _index2.IntegralValue) return _index2.IntegralValue;
        if ((ltype === _index2.NumberValue || ltype === _index2.IntegralValue) && (rtype === _index2.NumberValue || rtype === _index2.IntegralValue)) return _index2.NumberValue;
        return _index2.Value;
      }

      throw new _errors.FatalError();
    }

    if (ltype === _index2.StringValue || rtype === _index2.StringValue) return _index2.StringValue;
    return _index2.NumberValue;
  } else if (op === "<" || op === ">" || op === ">=" || op === "<=") {
    return reportErrorIfNotPure(_singletons.To.IsToPrimitivePure.bind(_singletons.To), _index2.BooleanValue);
  } else if (op === "!=" || op === "==") {
    let ltype = lval.getType();
    let rtype = rval.getType();
    if (ltype === _index2.NullValue || ltype === _index2.UndefinedValue || rtype === _index2.NullValue || rtype === _index2.UndefinedValue) return _index2.BooleanValue;
    return reportErrorIfNotPure(_singletons.To.IsToPrimitivePure.bind(_singletons.To), _index2.BooleanValue);
  } else if (op === "===" || op === "!==") {
    return _index2.BooleanValue;
  } else if (op === ">>>" || op === "<<" || op === ">>" || op === "&" || op === "|" || op === "^" || op === "**" || op === "%" || op === "/" || op === "*" || op === "-") {
    if (lval.getType() === _index2.SymbolValue || rval.getType() === _index2.SymbolValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    return reportErrorIfNotPure(_singletons.To.IsToNumberPure.bind(_singletons.To), _index2.NumberValue);
  } else if (op === "in" || op === "instanceof") {
    if (rval.mightNotBeObject()) {
      let error = new _errors.CompilerDiagnostic(`might not be an object, hence the ${op} operator might throw a TypeError`, rloc, "PP0003", "RecoverableError");

      if (realm.handleError(error) === "Recover") {
        // Assume that the object is actually a well behaved object.
        return _index2.BooleanValue;
      }

      throw new _errors.FatalError();
    }

    if (!rval.mightNotBeObject()) {
      // Simple object won't throw here, aren't proxy objects or typed arrays and do not have @@hasInstance properties.
      if (rval.isSimpleObject()) return _index2.BooleanValue;
    }

    let error = new _errors.CompilerDiagnostic(`might be an object that behaves badly for the ${op} operator`, rloc, "PP0004", "RecoverableError");

    if (realm.handleError(error) === "Recover") {
      // Assume that the object is actually a well behaved object.
      return _index2.BooleanValue;
    }

    throw new _errors.FatalError();
  }

  (0, _invariant.default)(false, "unimplemented " + op);
}

function computeBinary(realm, op, lval, rval, lloc, rloc, loc) {
  // partial evaluation shortcut for a particular pattern
  if (realm.useAbstractInterpretation && (op === "==" || op === "===" || op === "!=" || op === "!==")) {
    if (!lval.mightNotBeObject() && (rval instanceof _index2.NullValue || rval instanceof _index2.UndefinedValue) || (lval instanceof _index2.NullValue || lval instanceof _index2.UndefinedValue) && !rval.mightNotBeObject()) {
      return new _index2.BooleanValue(realm, op[0] !== "=");
    }
  }

  let resultType;

  const compute = () => {
    let lvalIsAbstract = lval instanceof _index2.AbstractValue;
    let rvalIsAbstract = rval instanceof _index2.AbstractValue;

    if (lvalIsAbstract || rvalIsAbstract) {
      // If the left-hand side of an instanceof operation is a primitive,
      // and the right-hand side is a simple object (it does not have [Symbol.hasInstance]),
      // then the result should always compute to `false`.
      if (op === "instanceof" && _index2.Value.isTypeCompatibleWith(lval.getType(), _index2.PrimitiveValue) && rval instanceof _index2.AbstractObjectValue && rval.isSimpleObject()) {
        return realm.intrinsics.false;
      }

      try {
        // generate error if binary operation might throw or have side effects
        resultType = getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc);

        let result = _index2.AbstractValue.createFromBinaryOp(realm, op, lval, rval, loc);

        if ((op === "in" || op === "instanceof") && result instanceof _index2.AbstractValue && rvalIsAbstract) // This operation is a conditional atemporal
          // See #2327
          result = _index2.AbstractValue.convertToTemporalIfArgsAreTemporal(realm, result, [rval]
          /* throwing does not depend upon lval */
          );
        return result;
      } catch (x) {
        if (x instanceof _errors.FatalError) {
          // There is no need to revert any effects, because the above operation is pure.
          // If this failed and one of the arguments was conditional, try each value
          // and join the effects based on the condition.
          if (lval instanceof _index2.AbstractValue && lval.kind === "conditional") {
            let [condition, consequentL, alternateL] = lval.args;
            (0, _invariant.default)(condition instanceof _index2.AbstractValue);
            return realm.evaluateWithAbstractConditional(condition, () => realm.evaluateForEffects(() => computeBinary(realm, op, consequentL, rval, lloc, rloc, loc), undefined, "ConditionalBinaryExpression/1"), () => realm.evaluateForEffects(() => computeBinary(realm, op, alternateL, rval, lloc, rloc, loc), undefined, "ConditionalBinaryExpression/2"));
          }

          if (rval instanceof _index2.AbstractValue && rval.kind === "conditional") {
            let [condition, consequentR, alternateR] = rval.args;
            (0, _invariant.default)(condition instanceof _index2.AbstractValue);
            return realm.evaluateWithAbstractConditional(condition, () => realm.evaluateForEffects(() => computeBinary(realm, op, lval, consequentR, lloc, rloc, loc), undefined, "ConditionalBinaryExpression/3"), () => realm.evaluateForEffects(() => computeBinary(realm, op, lval, alternateR, lloc, rloc, loc), undefined, "ConditionalBinaryExpression/4"));
          }
        }

        throw x;
      }
    } else {
      // ECMA262 12.10.3
      // 5. If Type(rval) is not Object, throw a TypeError exception.
      if (op === "in" && !(rval instanceof _index2.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      (0, _invariant.default)(lval instanceof _index2.ConcreteValue);
      (0, _invariant.default)(rval instanceof _index2.ConcreteValue);

      const result = _index.ValuesDomain.computeBinary(realm, op, lval, rval);

      resultType = result.getType();
      return result;
    }
  };

  if (realm.isInPureScope()) {
    // If we're in pure mode we can recover even if this operation might not be pure.
    // To do that, we'll temporarily override the error handler.
    const previousErrorHandler = realm.errorHandler;
    let isPure = true;

    realm.errorHandler = diagnostic => {
      isPure = false;
      return "Recover";
    };

    let effects;

    try {
      effects = realm.evaluateForEffects(compute, undefined, "computeBinary");
    } catch (x) {
      if (x instanceof _errors.FatalError) {
        isPure = false;
      } else {
        throw x;
      }
    } finally {
      realm.errorHandler = previousErrorHandler;
    }

    if (isPure && effects) {
      realm.applyEffects(effects);
      if (effects.result instanceof _completions.SimpleNormalCompletion) return effects.result.value;
    } // If this ended up reporting an error, it might not be pure, so we'll leave it in
    // as a temporal operation with a known return type.
    // Some of these values may trigger side-effectful user code such as valueOf.
    // To be safe, we have to leak them.


    _singletons.Leak.value(realm, lval, loc);

    if (op !== "in") {
      // The "in" operator have side-effects on its right val other than throw.
      _singletons.Leak.value(realm, rval, loc);
    }

    return realm.evaluateWithPossibleThrowCompletion(() => _index2.AbstractValue.createTemporalFromBuildFunction(realm, resultType, [lval, rval], (0, _generator.createOperationDescriptor)("BINARY_EXPRESSION", {
      binaryOperator: op
    }), {
      isPure: true
    }), _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
  }

  return compute();
}
//# sourceMappingURL=BinaryExpression.js.map

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;
Object.defineProperty(exports, "NodePath", {
  enumerable: true,
  get: function () {
    return _path.default;
  }
});
Object.defineProperty(exports, "Scope", {
  enumerable: true,
  get: function () {
    return _scope.default;
  }
});
Object.defineProperty(exports, "Hub", {
  enumerable: true,
  get: function () {
    return _hub.default;
  }
});
exports.visitors = void 0;

var _context = _interopRequireDefault(__webpack_require__(294));

var visitors = _interopRequireWildcard(__webpack_require__(374));

exports.visitors = visitors;

function _includes() {
  const data = _interopRequireDefault(__webpack_require__(306));

  _includes = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var cache = _interopRequireWildcard(__webpack_require__(334));

var _path = _interopRequireDefault(__webpack_require__(295));

var _scope = _interopRequireDefault(__webpack_require__(305));

var _hub = _interopRequireDefault(__webpack_require__(375));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function traverse(parent, opts, scope, state, parentPath) {
  if (!parent) return;
  if (!opts) opts = {};

  if (!opts.noScope && !scope) {
    if (parent.type !== "Program" && parent.type !== "File") {
      throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${parent.type} node without ` + "passing scope and parentPath.");
    }
  }

  visitors.explode(opts);
  traverse.node(parent, opts, scope, state, parentPath);
}

traverse.visitors = visitors;
traverse.verify = visitors.verify;
traverse.explode = visitors.explode;

traverse.cheap = function (node, enter) {
  return t().traverseFast(node, enter);
};

traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
  const keys = t().VISITOR_KEYS[node.type];
  if (!keys) return;
  const context = new _context.default(scope, opts, state, parentPath);

  for (const key of keys) {
    if (skipKeys && skipKeys[key]) continue;
    if (context.visit(node, key)) return;
  }
};

traverse.clearNode = function (node, opts) {
  t().removeProperties(node, opts);
  cache.path.delete(node);
};

traverse.removeProperties = function (tree, opts) {
  t().traverseFast(tree, traverse.clearNode, opts);
  return tree;
};

function hasBlacklistedType(path, state) {
  if (path.node.type === state.type) {
    state.has = true;
    path.stop();
  }
}

traverse.hasType = function (tree, type, blacklistTypes) {
  if ((0, _includes().default)(blacklistTypes, tree.type)) return false;
  if (tree.type === type) return true;
  const state = {
    has: false,
    type: type
  };
  traverse(tree, {
    noScope: true,
    blacklist: blacklistTypes,
    enter: hasBlacklistedType
  }, null, state);
  return state.has;
};

traverse.cache = cache;

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(__webpack_require__(295));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const testing = "none" === "test";

class TraversalContext {
  constructor(scope, opts, state, parentPath) {
    this.queue = null;
    this.parentPath = parentPath;
    this.scope = scope;
    this.state = state;
    this.opts = opts;
  }

  shouldVisit(node) {
    const opts = this.opts;
    if (opts.enter || opts.exit) return true;
    if (opts[node.type]) return true;
    const keys = t().VISITOR_KEYS[node.type];
    if (!keys || !keys.length) return false;

    for (const key of keys) {
      if (node[key]) return true;
    }

    return false;
  }

  create(node, obj, key, listKey) {
    return _path.default.get({
      parentPath: this.parentPath,
      parent: node,
      container: obj,
      key: key,
      listKey
    });
  }

  maybeQueue(path, notPriority) {
    if (this.trap) {
      throw new Error("Infinite cycle detected");
    }

    if (this.queue) {
      if (notPriority) {
        this.queue.push(path);
      } else {
        this.priorityQueue.push(path);
      }
    }
  }

  visitMultiple(container, parent, listKey) {
    if (container.length === 0) return false;
    const queue = [];

    for (let key = 0; key < container.length; key++) {
      const node = container[key];

      if (node && this.shouldVisit(node)) {
        queue.push(this.create(parent, container, key, listKey));
      }
    }

    return this.visitQueue(queue);
  }

  visitSingle(node, key) {
    if (this.shouldVisit(node[key])) {
      return this.visitQueue([this.create(node, node, key)]);
    } else {
      return false;
    }
  }

  visitQueue(queue) {
    this.queue = queue;
    this.priorityQueue = [];
    const visited = [];
    let stop = false;

    for (const path of queue) {
      path.resync();

      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
        path.pushContext(this);
      }

      if (path.key === null) continue;

      if (testing && queue.length >= 10000) {
        this.trap = true;
      }

      if (visited.indexOf(path.node) >= 0) continue;
      visited.push(path.node);

      if (path.visit()) {
        stop = true;
        break;
      }

      if (this.priorityQueue.length) {
        stop = this.visitQueue(this.priorityQueue);
        this.priorityQueue = [];
        this.queue = queue;
        if (stop) break;
      }
    }

    for (const path of queue) {
      path.popContext();
    }

    this.queue = null;
    return stop;
  }

  visit(node, key) {
    const nodes = node[key];
    if (!nodes) return false;

    if (Array.isArray(nodes)) {
      return this.visitMultiple(nodes, node, key);
    } else {
      return this.visitSingle(node, key);
    }
  }

}

exports.default = TraversalContext;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var virtualTypes = _interopRequireWildcard(__webpack_require__(296));

function _debug() {
  const data = _interopRequireDefault(__webpack_require__(297));

  _debug = function () {
    return data;
  };

  return data;
}

var _index = _interopRequireDefault(__webpack_require__(293));

var _scope = _interopRequireDefault(__webpack_require__(305));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var _cache = __webpack_require__(334);

function _generator() {
  const data = _interopRequireDefault(__webpack_require__(335));

  _generator = function () {
    return data;
  };

  return data;
}

var NodePath_ancestry = _interopRequireWildcard(__webpack_require__(357));

var NodePath_inference = _interopRequireWildcard(__webpack_require__(358));

var NodePath_replacement = _interopRequireWildcard(__webpack_require__(361));

var NodePath_evaluation = _interopRequireWildcard(__webpack_require__(362));

var NodePath_conversion = _interopRequireWildcard(__webpack_require__(363));

var NodePath_introspection = _interopRequireWildcard(__webpack_require__(366));

var NodePath_context = _interopRequireWildcard(__webpack_require__(367));

var NodePath_removal = _interopRequireWildcard(__webpack_require__(368));

var NodePath_modification = _interopRequireWildcard(__webpack_require__(370));

var NodePath_family = _interopRequireWildcard(__webpack_require__(372));

var NodePath_comments = _interopRequireWildcard(__webpack_require__(373));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const debug = (0, _debug().default)("babel");

class NodePath {
  constructor(hub, parent) {
    this.parent = parent;
    this.hub = hub;
    this.contexts = [];
    this.data = {};
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed = false;
    this.state = null;
    this.opts = null;
    this.skipKeys = null;
    this.parentPath = null;
    this.context = null;
    this.container = null;
    this.listKey = null;
    this.inList = false;
    this.parentKey = null;
    this.key = null;
    this.node = null;
    this.scope = null;
    this.type = null;
    this.typeAnnotation = null;
  }

  static get({
    hub,
    parentPath,
    parent,
    container,
    listKey,
    key
  }) {
    if (!hub && parentPath) {
      hub = parentPath.hub;
    }

    if (!parent) {
      throw new Error("To get a node path the parent needs to exist");
    }

    const targetNode = container[key];
    const paths = _cache.path.get(parent) || [];

    if (!_cache.path.has(parent)) {
      _cache.path.set(parent, paths);
    }

    let path;

    for (let i = 0; i < paths.length; i++) {
      const pathCheck = paths[i];

      if (pathCheck.node === targetNode) {
        path = pathCheck;
        break;
      }
    }

    if (!path) {
      path = new NodePath(hub, parent);
      paths.push(path);
    }

    path.setup(parentPath, container, listKey, key);
    return path;
  }

  getScope(scope) {
    return this.isScope() ? new _scope.default(this) : scope;
  }

  setData(key, val) {
    return this.data[key] = val;
  }

  getData(key, def) {
    let val = this.data[key];
    if (!val && def) val = this.data[key] = def;
    return val;
  }

  buildCodeFrameError(msg, Error = SyntaxError) {
    return this.hub.buildError(this.node, msg, Error);
  }

  traverse(visitor, state) {
    (0, _index.default)(this.node, visitor, this.scope, state, this);
  }

  set(key, node) {
    t().validate(this.node, key, node);
    this.node[key] = node;
  }

  getPathLocation() {
    const parts = [];
    let path = this;

    do {
      let key = path.key;
      if (path.inList) key = `${path.listKey}[${key}]`;
      parts.unshift(key);
    } while (path = path.parentPath);

    return parts.join(".");
  }

  debug(message) {
    if (!debug.enabled) return;
    debug(`${this.getPathLocation()} ${this.type}: ${message}`);
  }

  toString() {
    return (0, _generator().default)(this.node).code;
  }

}

exports.default = NodePath;
Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

for (const type of t().TYPES) {
  const typeKey = `is${type}`;
  const fn = t()[typeKey];

  NodePath.prototype[typeKey] = function (opts) {
    return fn(this.node, opts);
  };

  NodePath.prototype[`assert${type}`] = function (opts) {
    if (!fn(this.node, opts)) {
      throw new TypeError(`Expected node path of type ${type}`);
    }
  };
}

for (const type in virtualTypes) {
  if (type[0] === "_") continue;
  if (t().TYPES.indexOf(type) < 0) t().TYPES.push(type);
  const virtualType = virtualTypes[type];

  NodePath.prototype[`is${type}`] = function (opts) {
    return virtualType.checkPath(this, opts);
  };
}

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const ReferencedIdentifier = {
  types: ["Identifier", "JSXIdentifier"],

  checkPath({
    node,
    parent
  }, opts) {
    if (!t().isIdentifier(node, opts) && !t().isJSXMemberExpression(parent, opts)) {
      if (t().isJSXIdentifier(node, opts)) {
        if (t().react.isCompatTag(node.name)) return false;
      } else {
        return false;
      }
    }

    return t().isReferenced(node, parent);
  }

};
exports.ReferencedIdentifier = ReferencedIdentifier;
const ReferencedMemberExpression = {
  types: ["MemberExpression"],

  checkPath({
    node,
    parent
  }) {
    return t().isMemberExpression(node) && t().isReferenced(node, parent);
  }

};
exports.ReferencedMemberExpression = ReferencedMemberExpression;
const BindingIdentifier = {
  types: ["Identifier"],

  checkPath({
    node,
    parent
  }) {
    return t().isIdentifier(node) && t().isBinding(node, parent);
  }

};
exports.BindingIdentifier = BindingIdentifier;
const Statement = {
  types: ["Statement"],

  checkPath({
    node,
    parent
  }) {
    if (t().isStatement(node)) {
      if (t().isVariableDeclaration(node)) {
        if (t().isForXStatement(parent, {
          left: node
        })) return false;
        if (t().isForStatement(parent, {
          init: node
        })) return false;
      }

      return true;
    } else {
      return false;
    }
  }

};
exports.Statement = Statement;
const Expression = {
  types: ["Expression"],

  checkPath(path) {
    if (path.isIdentifier()) {
      return path.isReferencedIdentifier();
    } else {
      return t().isExpression(path.node);
    }
  }

};
exports.Expression = Expression;
const Scope = {
  types: ["Scopable"],

  checkPath(path) {
    return t().isScope(path.node, path.parent);
  }

};
exports.Scope = Scope;
const Referenced = {
  checkPath(path) {
    return t().isReferenced(path.node, path.parent);
  }

};
exports.Referenced = Referenced;
const BlockScoped = {
  checkPath(path) {
    return t().isBlockScoped(path.node);
  }

};
exports.BlockScoped = BlockScoped;
const Var = {
  types: ["VariableDeclaration"],

  checkPath(path) {
    return t().isVar(path.node);
  }

};
exports.Var = Var;
const User = {
  checkPath(path) {
    return path.node && !!path.node.loc;
  }

};
exports.User = User;
const Generated = {
  checkPath(path) {
    return !path.isUser();
  }

};
exports.Generated = Generated;
const Pure = {
  checkPath(path, opts) {
    return path.scope.isPure(path.node, opts);
  }

};
exports.Pure = Pure;
const Flow = {
  types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],

  checkPath({
    node
  }) {
    if (t().isFlow(node)) {
      return true;
    } else if (t().isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (t().isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (t().isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }

};
exports.Flow = Flow;
const RestProperty = {
  types: ["RestElement"],

  checkPath(path) {
    return path.parentPath && path.parentPath.isObjectPattern();
  }

};
exports.RestProperty = RestProperty;
const SpreadProperty = {
  types: ["RestElement"],

  checkPath(path) {
    return path.parentPath && path.parentPath.isObjectExpression();
  }

};
exports.SpreadProperty = SpreadProperty;
const ExistentialTypeParam = {
  types: ["ExistsTypeAnnotation"]
};
exports.ExistentialTypeParam = ExistentialTypeParam;
const NumericLiteralTypeAnnotation = {
  types: ["NumberLiteralTypeAnnotation"]
};
exports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
const ForAwaitStatement = {
  types: ["ForOfStatement"],

  checkPath({
    node
  }) {
    return node.await === true;
  }

};
exports.ForAwaitStatement = ForAwaitStatement;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(298);
} else {
	module.exports = __webpack_require__(301);
}


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(299)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(300);

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),
/* 300 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(302);
const util = __webpack_require__(303);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(304);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(299)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),
/* 302 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__302__;

/***/ }),
/* 303 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__303__;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _includes() {
  const data = _interopRequireDefault(__webpack_require__(306));

  _includes = function () {
    return data;
  };

  return data;
}

function _repeat() {
  const data = _interopRequireDefault(__webpack_require__(315));

  _repeat = function () {
    return data;
  };

  return data;
}

var _renamer = _interopRequireDefault(__webpack_require__(320));

var _index = _interopRequireDefault(__webpack_require__(293));

function _defaults() {
  const data = _interopRequireDefault(__webpack_require__(323));

  _defaults = function () {
    return data;
  };

  return data;
}

var _binding = _interopRequireDefault(__webpack_require__(321));

function _globals() {
  const data = _interopRequireDefault(__webpack_require__(332));

  _globals = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var _cache = __webpack_require__(334);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gatherNodeParts(node, parts) {
  if (t().isModuleDeclaration(node)) {
    if (node.source) {
      gatherNodeParts(node.source, parts);
    } else if (node.specifiers && node.specifiers.length) {
      for (const specifier of node.specifiers) {
        gatherNodeParts(specifier, parts);
      }
    } else if (node.declaration) {
      gatherNodeParts(node.declaration, parts);
    }
  } else if (t().isModuleSpecifier(node)) {
    gatherNodeParts(node.local, parts);
  } else if (t().isMemberExpression(node)) {
    gatherNodeParts(node.object, parts);
    gatherNodeParts(node.property, parts);
  } else if (t().isIdentifier(node)) {
    parts.push(node.name);
  } else if (t().isLiteral(node)) {
    parts.push(node.value);
  } else if (t().isCallExpression(node)) {
    gatherNodeParts(node.callee, parts);
  } else if (t().isObjectExpression(node) || t().isObjectPattern(node)) {
    for (const prop of node.properties) {
      gatherNodeParts(prop.key || prop.argument, parts);
    }
  } else if (t().isPrivateName(node)) {
    gatherNodeParts(node.id, parts);
  } else if (t().isThisExpression(node)) {
    parts.push("this");
  } else if (t().isSuper(node)) {
    parts.push("super");
  }
}

const collectorVisitor = {
  For(path) {
    for (const key of t().FOR_INIT_KEYS) {
      const declar = path.get(key);

      if (declar.isVar()) {
        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    }
  },

  Declaration(path) {
    if (path.isBlockScoped()) return;

    if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) {
      return;
    }

    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
    parent.registerDeclaration(path);
  },

  ReferencedIdentifier(path, state) {
    state.references.push(path);
  },

  ForXStatement(path, state) {
    const left = path.get("left");

    if (left.isPattern() || left.isIdentifier()) {
      state.constantViolations.push(path);
    }
  },

  ExportDeclaration: {
    exit(path) {
      const {
        node,
        scope
      } = path;
      const declar = node.declaration;

      if (t().isClassDeclaration(declar) || t().isFunctionDeclaration(declar)) {
        const id = declar.id;
        if (!id) return;
        const binding = scope.getBinding(id.name);
        if (binding) binding.reference(path);
      } else if (t().isVariableDeclaration(declar)) {
        for (const decl of declar.declarations) {
          const ids = t().getBindingIdentifiers(decl);

          for (const name in ids) {
            const binding = scope.getBinding(name);
            if (binding) binding.reference(path);
          }
        }
      }
    }

  },

  LabeledStatement(path) {
    path.scope.getProgramParent().addGlobal(path.node);
    path.scope.getBlockParent().registerDeclaration(path);
  },

  AssignmentExpression(path, state) {
    state.assignments.push(path);
  },

  UpdateExpression(path, state) {
    state.constantViolations.push(path);
  },

  UnaryExpression(path, state) {
    if (path.node.operator === "delete") {
      state.constantViolations.push(path);
    }
  },

  BlockScoped(path) {
    let scope = path.scope;
    if (scope.path === path) scope = scope.parent;
    scope.getBlockParent().registerDeclaration(path);
  },

  ClassDeclaration(path) {
    const id = path.node.id;
    if (!id) return;
    const name = id.name;
    path.scope.bindings[name] = path.scope.getBinding(name);
  },

  Block(path) {
    const paths = path.get("body");

    for (const bodyPath of paths) {
      if (bodyPath.isFunctionDeclaration()) {
        path.scope.getBlockParent().registerDeclaration(bodyPath);
      }
    }
  }

};
let uid = 0;

class Scope {
  constructor(path) {
    const {
      node
    } = path;

    const cached = _cache.scope.get(node);

    if (cached && cached.path === path) {
      return cached;
    }

    _cache.scope.set(node, this);

    this.uid = uid++;
    this.block = node;
    this.path = path;
    this.labels = new Map();
  }

  get parent() {
    const parent = this.path.findParent(p => p.isScope());
    return parent && parent.scope;
  }

  get parentBlock() {
    return this.path.parent;
  }

  get hub() {
    return this.path.hub;
  }

  traverse(node, opts, state) {
    (0, _index.default)(node, opts, this, state, this.path);
  }

  generateDeclaredUidIdentifier(name) {
    const id = this.generateUidIdentifier(name);
    this.push({
      id
    });
    return t().cloneNode(id);
  }

  generateUidIdentifier(name) {
    return t().identifier(this.generateUid(name));
  }

  generateUid(name = "temp") {
    name = t().toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
    let uid;
    let i = 0;

    do {
      uid = this._generateUid(name, i);
      i++;
    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

    const program = this.getProgramParent();
    program.references[uid] = true;
    program.uids[uid] = true;
    return uid;
  }

  _generateUid(name, i) {
    let id = name;
    if (i > 1) id += i;
    return `_${id}`;
  }

  generateUidBasedOnNode(parent, defaultName) {
    let node = parent;

    if (t().isAssignmentExpression(parent)) {
      node = parent.left;
    } else if (t().isVariableDeclarator(parent)) {
      node = parent.id;
    } else if (t().isObjectProperty(node) || t().isObjectMethod(node)) {
      node = node.key;
    }

    const parts = [];
    gatherNodeParts(node, parts);
    let id = parts.join("$");
    id = id.replace(/^_/, "") || defaultName || "ref";
    return this.generateUid(id.slice(0, 20));
  }

  generateUidIdentifierBasedOnNode(parent, defaultName) {
    return t().identifier(this.generateUidBasedOnNode(parent, defaultName));
  }

  isStatic(node) {
    if (t().isThisExpression(node) || t().isSuper(node)) {
      return true;
    }

    if (t().isIdentifier(node)) {
      const binding = this.getBinding(node.name);

      if (binding) {
        return binding.constant;
      } else {
        return this.hasBinding(node.name);
      }
    }

    return false;
  }

  maybeGenerateMemoised(node, dontPush) {
    if (this.isStatic(node)) {
      return null;
    } else {
      const id = this.generateUidIdentifierBasedOnNode(node);

      if (!dontPush) {
        this.push({
          id
        });
        return t().cloneNode(id);
      }

      return id;
    }
  }

  checkBlockScopedCollisions(local, kind, name, id) {
    if (kind === "param") return;
    if (local.kind === "local") return;
    if (kind === "hoisted" && local.kind === "let") return;
    const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

    if (duplicate) {
      throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
    }
  }

  rename(oldName, newName, block) {
    const binding = this.getBinding(oldName);

    if (binding) {
      newName = newName || this.generateUidIdentifier(oldName).name;
      return new _renamer.default(binding, oldName, newName).rename(block);
    }
  }

  _renameFromMap(map, oldName, newName, value) {
    if (map[oldName]) {
      map[newName] = value;
      map[oldName] = null;
    }
  }

  dump() {
    const sep = (0, _repeat().default)("-", 60);
    console.log(sep);
    let scope = this;

    do {
      console.log("#", scope.block.type);

      for (const name in scope.bindings) {
        const binding = scope.bindings[name];
        console.log(" -", name, {
          constant: binding.constant,
          references: binding.references,
          violations: binding.constantViolations.length,
          kind: binding.kind
        });
      }
    } while (scope = scope.parent);

    console.log(sep);
  }

  toArray(node, i) {
    if (t().isIdentifier(node)) {
      const binding = this.getBinding(node.name);

      if (binding && binding.constant && binding.path.isGenericType("Array")) {
        return node;
      }
    }

    if (t().isArrayExpression(node)) {
      return node;
    }

    if (t().isIdentifier(node, {
      name: "arguments"
    })) {
      return t().callExpression(t().memberExpression(t().memberExpression(t().memberExpression(t().identifier("Array"), t().identifier("prototype")), t().identifier("slice")), t().identifier("call")), [node]);
    }

    let helperName;
    const args = [node];

    if (i === true) {
      helperName = "toConsumableArray";
    } else if (i) {
      args.push(t().numericLiteral(i));
      helperName = "slicedToArray";
    } else {
      helperName = "toArray";
    }

    return t().callExpression(this.hub.addHelper(helperName), args);
  }

  hasLabel(name) {
    return !!this.getLabel(name);
  }

  getLabel(name) {
    return this.labels.get(name);
  }

  registerLabel(path) {
    this.labels.set(path.node.label.name, path);
  }

  registerDeclaration(path) {
    if (path.isLabeledStatement()) {
      this.registerLabel(path);
    } else if (path.isFunctionDeclaration()) {
      this.registerBinding("hoisted", path.get("id"), path);
    } else if (path.isVariableDeclaration()) {
      const declarations = path.get("declarations");

      for (const declar of declarations) {
        this.registerBinding(path.node.kind, declar);
      }
    } else if (path.isClassDeclaration()) {
      this.registerBinding("let", path);
    } else if (path.isImportDeclaration()) {
      const specifiers = path.get("specifiers");

      for (const specifier of specifiers) {
        this.registerBinding("module", specifier);
      }
    } else if (path.isExportDeclaration()) {
      const declar = path.get("declaration");

      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
        this.registerDeclaration(declar);
      }
    } else {
      this.registerBinding("unknown", path);
    }
  }

  buildUndefinedNode() {
    if (this.hasBinding("undefined")) {
      return t().unaryExpression("void", t().numericLiteral(0), true);
    } else {
      return t().identifier("undefined");
    }
  }

  registerConstantViolation(path) {
    const ids = path.getBindingIdentifiers();

    for (const name in ids) {
      const binding = this.getBinding(name);
      if (binding) binding.reassign(path);
    }
  }

  registerBinding(kind, path, bindingPath = path) {
    if (!kind) throw new ReferenceError("no `kind`");

    if (path.isVariableDeclaration()) {
      const declarators = path.get("declarations");

      for (const declar of declarators) {
        this.registerBinding(kind, declar);
      }

      return;
    }

    const parent = this.getProgramParent();
    const ids = path.getBindingIdentifiers(true);

    for (const name in ids) {
      for (const id of ids[name]) {
        const local = this.getOwnBinding(name);

        if (local) {
          if (local.identifier === id) continue;
          this.checkBlockScopedCollisions(local, kind, name, id);
        }

        parent.references[name] = true;

        if (local) {
          this.registerConstantViolation(bindingPath);
        } else {
          this.bindings[name] = new _binding.default({
            identifier: id,
            scope: this,
            path: bindingPath,
            kind: kind
          });
        }
      }
    }
  }

  addGlobal(node) {
    this.globals[node.name] = node;
  }

  hasUid(name) {
    let scope = this;

    do {
      if (scope.uids[name]) return true;
    } while (scope = scope.parent);

    return false;
  }

  hasGlobal(name) {
    let scope = this;

    do {
      if (scope.globals[name]) return true;
    } while (scope = scope.parent);

    return false;
  }

  hasReference(name) {
    let scope = this;

    do {
      if (scope.references[name]) return true;
    } while (scope = scope.parent);

    return false;
  }

  isPure(node, constantsOnly) {
    if (t().isIdentifier(node)) {
      const binding = this.getBinding(node.name);
      if (!binding) return false;
      if (constantsOnly) return binding.constant;
      return true;
    } else if (t().isClass(node)) {
      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
        return false;
      }

      return this.isPure(node.body, constantsOnly);
    } else if (t().isClassBody(node)) {
      for (const method of node.body) {
        if (!this.isPure(method, constantsOnly)) return false;
      }

      return true;
    } else if (t().isBinary(node)) {
      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
    } else if (t().isArrayExpression(node)) {
      for (const elem of node.elements) {
        if (!this.isPure(elem, constantsOnly)) return false;
      }

      return true;
    } else if (t().isObjectExpression(node)) {
      for (const prop of node.properties) {
        if (!this.isPure(prop, constantsOnly)) return false;
      }

      return true;
    } else if (t().isClassMethod(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      if (node.kind === "get" || node.kind === "set") return false;
      return true;
    } else if (t().isProperty(node)) {
      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
      return this.isPure(node.value, constantsOnly);
    } else if (t().isUnaryExpression(node)) {
      return this.isPure(node.argument, constantsOnly);
    } else if (t().isTaggedTemplateExpression(node)) {
      return t().matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
    } else if (t().isTemplateLiteral(node)) {
      for (const expression of node.expressions) {
        if (!this.isPure(expression, constantsOnly)) return false;
      }

      return true;
    } else {
      return t().isPureish(node);
    }
  }

  setData(key, val) {
    return this.data[key] = val;
  }

  getData(key) {
    let scope = this;

    do {
      const data = scope.data[key];
      if (data != null) return data;
    } while (scope = scope.parent);
  }

  removeData(key) {
    let scope = this;

    do {
      const data = scope.data[key];
      if (data != null) scope.data[key] = null;
    } while (scope = scope.parent);
  }

  init() {
    if (!this.references) this.crawl();
  }

  crawl() {
    const path = this.path;
    this.references = Object.create(null);
    this.bindings = Object.create(null);
    this.globals = Object.create(null);
    this.uids = Object.create(null);
    this.data = Object.create(null);

    if (path.isLoop()) {
      for (const key of t().FOR_INIT_KEYS) {
        const node = path.get(key);
        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);
      }
    }

    if (path.isFunctionExpression() && path.has("id")) {
      if (!path.get("id").node[t().NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path.get("id"), path);
      }
    }

    if (path.isClassExpression() && path.has("id")) {
      if (!path.get("id").node[t().NOT_LOCAL_BINDING]) {
        this.registerBinding("local", path);
      }
    }

    if (path.isFunction()) {
      const params = path.get("params");

      for (const param of params) {
        this.registerBinding("param", param);
      }
    }

    if (path.isCatchClause()) {
      this.registerBinding("let", path);
    }

    const parent = this.getProgramParent();
    if (parent.crawling) return;
    const state = {
      references: [],
      constantViolations: [],
      assignments: []
    };
    this.crawling = true;
    path.traverse(collectorVisitor, state);
    this.crawling = false;

    for (const path of state.assignments) {
      const ids = path.getBindingIdentifiers();
      let programParent;

      for (const name in ids) {
        if (path.scope.getBinding(name)) continue;
        programParent = programParent || path.scope.getProgramParent();
        programParent.addGlobal(ids[name]);
      }

      path.scope.registerConstantViolation(path);
    }

    for (const ref of state.references) {
      const binding = ref.scope.getBinding(ref.node.name);

      if (binding) {
        binding.reference(ref);
      } else {
        ref.scope.getProgramParent().addGlobal(ref.node);
      }
    }

    for (const path of state.constantViolations) {
      path.scope.registerConstantViolation(path);
    }
  }

  push(opts) {
    let path = this.path;

    if (!path.isBlockStatement() && !path.isProgram()) {
      path = this.getBlockParent().path;
    }

    if (path.isSwitchStatement()) {
      path = (this.getFunctionParent() || this.getProgramParent()).path;
    }

    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
      path.ensureBlock();
      path = path.get("body");
    }

    const unique = opts.unique;
    const kind = opts.kind || "var";
    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
    const dataKey = `declaration:${kind}:${blockHoist}`;
    let declarPath = !unique && path.getData(dataKey);

    if (!declarPath) {
      const declar = t().variableDeclaration(kind, []);
      declar._blockHoist = blockHoist;
      [declarPath] = path.unshiftContainer("body", [declar]);
      if (!unique) path.setData(dataKey, declarPath);
    }

    const declarator = t().variableDeclarator(opts.id, opts.init);
    declarPath.node.declarations.push(declarator);
    this.registerBinding(kind, declarPath.get("declarations").pop());
  }

  getProgramParent() {
    let scope = this;

    do {
      if (scope.path.isProgram()) {
        return scope;
      }
    } while (scope = scope.parent);

    throw new Error("Couldn't find a Program");
  }

  getFunctionParent() {
    let scope = this;

    do {
      if (scope.path.isFunctionParent()) {
        return scope;
      }
    } while (scope = scope.parent);

    return null;
  }

  getBlockParent() {
    let scope = this;

    do {
      if (scope.path.isBlockParent()) {
        return scope;
      }
    } while (scope = scope.parent);

    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
  }

  getAllBindings() {
    const ids = Object.create(null);
    let scope = this;

    do {
      (0, _defaults().default)(ids, scope.bindings);
      scope = scope.parent;
    } while (scope);

    return ids;
  }

  getAllBindingsOfKind() {
    const ids = Object.create(null);

    for (const kind of arguments) {
      let scope = this;

      do {
        for (const name in scope.bindings) {
          const binding = scope.bindings[name];
          if (binding.kind === kind) ids[name] = binding;
        }

        scope = scope.parent;
      } while (scope);
    }

    return ids;
  }

  bindingIdentifierEquals(name, node) {
    return this.getBindingIdentifier(name) === node;
  }

  getBinding(name) {
    let scope = this;

    do {
      const binding = scope.getOwnBinding(name);
      if (binding) return binding;
    } while (scope = scope.parent);
  }

  getOwnBinding(name) {
    return this.bindings[name];
  }

  getBindingIdentifier(name) {
    const info = this.getBinding(name);
    return info && info.identifier;
  }

  getOwnBindingIdentifier(name) {
    const binding = this.bindings[name];
    return binding && binding.identifier;
  }

  hasOwnBinding(name) {
    return !!this.getOwnBinding(name);
  }

  hasBinding(name, noGlobals) {
    if (!name) return false;
    if (this.hasOwnBinding(name)) return true;
    if (this.parentHasBinding(name, noGlobals)) return true;
    if (this.hasUid(name)) return true;
    if (!noGlobals && (0, _includes().default)(Scope.globals, name)) return true;
    if (!noGlobals && (0, _includes().default)(Scope.contextVariables, name)) return true;
    return false;
  }

  parentHasBinding(name, noGlobals) {
    return this.parent && this.parent.hasBinding(name, noGlobals);
  }

  moveBindingTo(name, scope) {
    const info = this.getBinding(name);

    if (info) {
      info.scope.removeOwnBinding(name);
      info.scope = scope;
      scope.bindings[name] = info;
    }
  }

  removeOwnBinding(name) {
    delete this.bindings[name];
  }

  removeBinding(name) {
    const info = this.getBinding(name);

    if (info) {
      info.scope.removeOwnBinding(name);
    }

    let scope = this;

    do {
      if (scope.uids[name]) {
        scope.uids[name] = false;
      }
    } while (scope = scope.parent);
  }

}

exports.default = Scope;
Scope.globals = Object.keys(_globals().default.builtin);
Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(180),
    isArrayLike = __webpack_require__(104),
    isString = __webpack_require__(307),
    toInteger = __webpack_require__(308),
    values = __webpack_require__(312);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return isString(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
}

module.exports = includes;


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(52),
    isArray = __webpack_require__(90),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var toFinite = __webpack_require__(309);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var toNumber = __webpack_require__(310);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(58),
    isSymbol = __webpack_require__(311);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(52),
    isObjectLike = __webpack_require__(89);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(313),
    keys = __webpack_require__(84);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(314);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),
/* 314 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var baseRepeat = __webpack_require__(316),
    isIterateeCall = __webpack_require__(317),
    toInteger = __webpack_require__(308),
    toString = __webpack_require__(318);

/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function repeat(string, n, guard) {
  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  return baseRepeat(toString(string), n);
}

module.exports = repeat;


/***/ }),
/* 316 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

module.exports = baseRepeat;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(39),
    isArrayLike = __webpack_require__(104),
    isIndex = __webpack_require__(94),
    isObject = __webpack_require__(58);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(319);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(53),
    arrayMap = __webpack_require__(314),
    isArray = __webpack_require__(90),
    isSymbol = __webpack_require__(311);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _binding = _interopRequireDefault(__webpack_require__(321));

function _helperSplitExportDeclaration() {
  const data = _interopRequireDefault(__webpack_require__(322));

  _helperSplitExportDeclaration = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const renameVisitor = {
  ReferencedIdentifier({
    node
  }, state) {
    if (node.name === state.oldName) {
      node.name = state.newName;
    }
  },

  Scope(path, state) {
    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
      path.skip();
    }
  },

  "AssignmentExpression|Declaration"(path, state) {
    const ids = path.getOuterBindingIdentifiers();

    for (const name in ids) {
      if (name === state.oldName) ids[name].name = state.newName;
    }
  }

};

class Renamer {
  constructor(binding, oldName, newName) {
    this.newName = newName;
    this.oldName = oldName;
    this.binding = binding;
  }

  maybeConvertFromExportDeclaration(parentDeclar) {
    const maybeExportDeclar = parentDeclar.parentPath;

    if (!maybeExportDeclar.isExportDeclaration()) {
      return;
    }

    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
      return;
    }

    (0, _helperSplitExportDeclaration().default)(maybeExportDeclar);
  }

  maybeConvertFromClassFunctionDeclaration(path) {
    return;
    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;
    if (this.binding.kind !== "hoisted") return;
    path.node.id = t().identifier(this.oldName);
    path.node._blockHoist = 3;
    path.replaceWith(t().variableDeclaration("let", [t().variableDeclarator(t().identifier(this.newName), t().toExpression(path.node))]));
  }

  maybeConvertFromClassFunctionExpression(path) {
    return;
    if (!path.isFunctionExpression() && !path.isClassExpression()) return;
    if (this.binding.kind !== "local") return;
    path.node.id = t().identifier(this.oldName);
    this.binding.scope.parent.push({
      id: t().identifier(this.newName)
    });
    path.replaceWith(t().assignmentExpression("=", t().identifier(this.newName), path.node));
  }

  rename(block) {
    const {
      binding,
      oldName,
      newName
    } = this;
    const {
      scope,
      path
    } = binding;
    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());

    if (parentDeclar) {
      const bindingIds = parentDeclar.getOuterBindingIdentifiers();

      if (bindingIds[oldName] === binding.identifier) {
        this.maybeConvertFromExportDeclaration(parentDeclar);
      }
    }

    scope.traverse(block || scope.block, renameVisitor, this);

    if (!block) {
      scope.removeOwnBinding(oldName);
      scope.bindings[newName] = binding;
      this.binding.identifier.name = newName;
    }

    if (binding.type === "hoisted") {}

    if (parentDeclar) {
      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
      this.maybeConvertFromClassFunctionExpression(parentDeclar);
    }
  }

}

exports.default = Renamer;

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class Binding {
  constructor({
    identifier,
    scope,
    path,
    kind
  }) {
    this.identifier = identifier;
    this.scope = scope;
    this.path = path;
    this.kind = kind;
    this.constantViolations = [];
    this.constant = true;
    this.referencePaths = [];
    this.referenced = false;
    this.references = 0;
    this.clearValue();
  }

  deoptValue() {
    this.clearValue();
    this.hasDeoptedValue = true;
  }

  setValue(value) {
    if (this.hasDeoptedValue) return;
    this.hasValue = true;
    this.value = value;
  }

  clearValue() {
    this.hasDeoptedValue = false;
    this.hasValue = false;
    this.value = null;
  }

  reassign(path) {
    this.constant = false;

    if (this.constantViolations.indexOf(path) !== -1) {
      return;
    }

    this.constantViolations.push(path);
  }

  reference(path) {
    if (this.referencePaths.indexOf(path) !== -1) {
      return;
    }

    this.referenced = true;
    this.references++;
    this.referencePaths.push(path);
  }

  dereference() {
    this.references--;
    this.referenced = !!this.references;
  }

}

exports.default = Binding;

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = splitExportDeclaration;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function splitExportDeclaration(exportDeclaration) {
  if (!exportDeclaration.isExportDeclaration()) {
    throw new Error("Only export declarations can be splitted.");
  }

  const isDefault = exportDeclaration.isExportDefaultDeclaration();
  const declaration = exportDeclaration.get("declaration");
  const isClassDeclaration = declaration.isClassDeclaration();

  if (isDefault) {
    const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
    let id = declaration.node.id;
    let needBindingRegistration = false;

    if (!id) {
      needBindingRegistration = true;
      id = scope.generateUidIdentifier("default");

      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
        declaration.node.id = t().cloneNode(id);
      }
    }

    const updatedDeclaration = standaloneDeclaration ? declaration : t().variableDeclaration("var", [t().variableDeclarator(t().cloneNode(id), declaration.node)]);
    const updatedExportDeclaration = t().exportNamedDeclaration(null, [t().exportSpecifier(t().cloneNode(id), t().identifier("default"))]);
    exportDeclaration.insertAfter(updatedExportDeclaration);
    exportDeclaration.replaceWith(updatedDeclaration);

    if (needBindingRegistration) {
      scope.registerBinding(isClassDeclaration ? "let" : "var", exportDeclaration);
    }

    return exportDeclaration;
  }

  if (exportDeclaration.get("specifiers").length > 0) {
    throw new Error("It doesn't make sense to split exported specifiers.");
  }

  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
  const specifiers = Object.keys(bindingIdentifiers).map(name => {
    return t().exportSpecifier(t().identifier(name), t().identifier(name));
  });
  const aliasDeclar = t().exportNamedDeclaration(null, specifiers);
  exportDeclaration.insertAfter(aliasDeclar);
  exportDeclaration.replaceWith(declaration.node);
  return exportDeclaration;
}

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(324),
    eq = __webpack_require__(39),
    isIterateeCall = __webpack_require__(317),
    keysIn = __webpack_require__(106);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(325),
    overRest = __webpack_require__(326),
    setToString = __webpack_require__(328);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 325 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(327);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 327 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(329),
    shortOut = __webpack_require__(331);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(330),
    defineProperty = __webpack_require__(81),
    identity = __webpack_require__(325);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 330 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 331 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(333);


/***/ }),
/* 333 */
/***/ (function(module) {

module.exports = {"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}};

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.clearPath = clearPath;
exports.clearScope = clearScope;
exports.scope = exports.path = void 0;
let path = new WeakMap();
exports.path = path;
let scope = new WeakMap();
exports.scope = scope;

function clear() {
  clearPath();
  clearScope();
}

function clearPath() {
  exports.path = path = new WeakMap();
}

function clearScope() {
  exports.scope = scope = new WeakMap();
}

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.CodeGenerator = void 0;

var _sourceMap = _interopRequireDefault(__webpack_require__(336));

var _printer = _interopRequireDefault(__webpack_require__(337));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Generator extends _printer.default {
  constructor(ast, opts = {}, code) {
    const format = normalizeOptions(code, opts);
    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
    super(format, map);
    this.ast = ast;
  }

  generate() {
    return super.generate(this.ast);
  }

}

function normalizeOptions(code, opts) {
  const format = {
    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
    shouldPrintComment: opts.shouldPrintComment,
    retainLines: opts.retainLines,
    retainFunctionParens: opts.retainFunctionParens,
    comments: opts.comments == null || opts.comments,
    compact: opts.compact,
    minified: opts.minified,
    concise: opts.concise,
    jsonCompatibleStrings: opts.jsonCompatibleStrings,
    indent: {
      adjustMultilineComment: true,
      style: "  ",
      base: 0
    },
    decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
    jsescOption: Object.assign({
      quotes: "double",
      wrap: true
    }, opts.jsescOption)
  };

  if (format.minified) {
    format.compact = true;

    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
  } else {
    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);
  }

  if (format.compact === "auto") {
    format.compact = code.length > 500000;

    if (format.compact) {
      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);
    }
  }

  if (format.compact) {
    format.indent.adjustMultilineComment = false;
  }

  return format;
}

class CodeGenerator {
  constructor(ast, opts, code) {
    this._generator = new Generator(ast, opts, code);
  }

  generate() {
    return this._generator.generate();
  }

}

exports.CodeGenerator = CodeGenerator;

function _default(ast, opts, code) {
  const gen = new Generator(ast, opts, code);
  return gen.generate();
}

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _sourceMap() {
  const data = _interopRequireDefault(__webpack_require__(280));

  _sourceMap = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SourceMap {
  constructor(opts, code) {
    this._cachedMap = null;
    this._code = code;
    this._opts = opts;
    this._rawMappings = [];
  }

  get() {
    if (!this._cachedMap) {
      const map = this._cachedMap = new (_sourceMap().default.SourceMapGenerator)({
        sourceRoot: this._opts.sourceRoot
      });
      const code = this._code;

      if (typeof code === "string") {
        map.setSourceContent(this._opts.sourceFileName, code);
      } else if (typeof code === "object") {
        Object.keys(code).forEach(sourceFileName => {
          map.setSourceContent(sourceFileName, code[sourceFileName]);
        });
      }

      this._rawMappings.forEach(map.addMapping, map);
    }

    return this._cachedMap.toJSON();
  }

  getRawMappings() {
    return this._rawMappings.slice();
  }

  mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
    if (this._lastGenLine !== generatedLine && line === null) return;

    if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
      return;
    }

    this._cachedMap = null;
    this._lastGenLine = generatedLine;
    this._lastSourceLine = line;
    this._lastSourceColumn = column;

    this._rawMappings.push({
      name: identifierName || undefined,
      generated: {
        line: generatedLine,
        column: generatedColumn
      },
      source: line == null ? undefined : filename || this._opts.sourceFileName,
      original: line == null ? undefined : {
        line: line,
        column: column
      }
    });
  }

}

exports.default = SourceMap;

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _isInteger() {
  const data = _interopRequireDefault(__webpack_require__(338));

  _isInteger = function () {
    return data;
  };

  return data;
}

function _repeat() {
  const data = _interopRequireDefault(__webpack_require__(315));

  _repeat = function () {
    return data;
  };

  return data;
}

var _buffer = _interopRequireDefault(__webpack_require__(339));

var n = _interopRequireWildcard(__webpack_require__(341));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var generatorFunctions = _interopRequireWildcard(__webpack_require__(344));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SCIENTIFIC_NOTATION = /e/i;
const ZERO_DECIMAL_INTEGER = /\.0+$/;
const NON_DECIMAL_LITERAL = /^0[box]/;

class Printer {
  constructor(format, map) {
    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._insideAux = false;
    this._printedCommentStarts = {};
    this._parenPushNewlineState = null;
    this._noLineTerminator = false;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new WeakSet();
    this._endsWithInteger = false;
    this._endsWithWord = false;
    this.format = format || {};
    this._buf = new _buffer.default(map);
  }

  generate(ast) {
    this.print(ast);

    this._maybeAddAuxComment();

    return this._buf.get();
  }

  indent() {
    if (this.format.compact || this.format.concise) return;
    this._indent++;
  }

  dedent() {
    if (this.format.compact || this.format.concise) return;
    this._indent--;
  }

  semicolon(force = false) {
    this._maybeAddAuxComment();

    this._append(";", !force);
  }

  rightBrace() {
    if (this.format.minified) {
      this._buf.removeLastSemicolon();
    }

    this.token("}");
  }

  space(force = false) {
    if (this.format.compact) return;

    if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
      this._space();
    }
  }

  word(str) {
    if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
      this._space();
    }

    this._maybeAddAuxComment();

    this._append(str);

    this._endsWithWord = true;
  }

  number(str) {
    this.word(str);
    this._endsWithInteger = (0, _isInteger().default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
  }

  token(str) {
    if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
      this._space();
    }

    this._maybeAddAuxComment();

    this._append(str);
  }

  newline(i) {
    if (this.format.retainLines || this.format.compact) return;

    if (this.format.concise) {
      this.space();
      return;
    }

    if (this.endsWith("\n\n")) return;
    if (typeof i !== "number") i = 1;
    i = Math.min(2, i);
    if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
    if (i <= 0) return;

    for (let j = 0; j < i; j++) {
      this._newline();
    }
  }

  endsWith(str) {
    return this._buf.endsWith(str);
  }

  removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  }

  exactSource(loc, cb) {
    this._catchUp("start", loc);

    this._buf.exactSource(loc, cb);
  }

  source(prop, loc) {
    this._catchUp(prop, loc);

    this._buf.source(prop, loc);
  }

  withSource(prop, loc, cb) {
    this._catchUp(prop, loc);

    this._buf.withSource(prop, loc, cb);
  }

  _space() {
    this._append(" ", true);
  }

  _newline() {
    this._append("\n", true);
  }

  _append(str, queue = false) {
    this._maybeAddParen(str);

    this._maybeIndent(str);

    if (queue) this._buf.queue(str);else this._buf.append(str);
    this._endsWithWord = false;
    this._endsWithInteger = false;
  }

  _maybeIndent(str) {
    if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
      this._buf.queue(this._getIndent());
    }
  }

  _maybeAddParen(str) {
    const parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;
    this._parenPushNewlineState = null;
    let i;

    for (i = 0; i < str.length && str[i] === " "; i++) continue;

    if (i === str.length) return;
    const cha = str[i];

    if (cha !== "\n") {
      if (cha !== "/") return;
      if (i + 1 === str.length) return;
      const chaPost = str[i + 1];
      if (chaPost !== "/" && chaPost !== "*") return;
    }

    this.token("(");
    this.indent();
    parenPushNewlineState.printed = true;
  }

  _catchUp(prop, loc) {
    if (!this.format.retainLines) return;
    const pos = loc ? loc[prop] : null;

    if (pos && pos.line !== null) {
      const count = pos.line - this._buf.getCurrentLine();

      for (let i = 0; i < count; i++) {
        this._newline();
      }
    }
  }

  _getIndent() {
    return (0, _repeat().default)(this.format.indent.style, this._indent);
  }

  startTerminatorless(isLabel = false) {
    if (isLabel) {
      this._noLineTerminator = true;
      return null;
    } else {
      return this._parenPushNewlineState = {
        printed: false
      };
    }
  }

  endTerminatorless(state) {
    this._noLineTerminator = false;

    if (state && state.printed) {
      this.dedent();
      this.newline();
      this.token(")");
    }
  }

  print(node, parent) {
    if (!node) return;
    const oldConcise = this.format.concise;

    if (node._compact) {
      this.format.concise = true;
    }

    const printMethod = this[node.type];

    if (!printMethod) {
      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node && node.constructor.name)}`);
    }

    this._printStack.push(node);

    const oldInAux = this._insideAux;
    this._insideAux = !node.loc;

    this._maybeAddAuxComment(this._insideAux && !oldInAux);

    let needsParens = n.needsParens(node, parent, this._printStack);

    if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
      needsParens = true;
    }

    if (needsParens) this.token("(");

    this._printLeadingComments(node);

    const loc = t().isProgram(node) || t().isFile(node) ? null : node.loc;
    this.withSource("start", loc, () => {
      this[node.type](node, parent);
    });

    this._printTrailingComments(node);

    if (needsParens) this.token(")");

    this._printStack.pop();

    this.format.concise = oldConcise;
    this._insideAux = oldInAux;
  }

  _maybeAddAuxComment(enteredPositionlessNode) {
    if (enteredPositionlessNode) this._printAuxBeforeComment();
    if (!this._insideAux) this._printAuxAfterComment();
  }

  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = true;
    const comment = this.format.auxiliaryCommentBefore;

    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
  }

  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = false;
    const comment = this.format.auxiliaryCommentAfter;

    if (comment) {
      this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
  }

  getPossibleRaw(node) {
    const extra = node.extra;

    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
      return extra.raw;
    }
  }

  printJoin(nodes, parent, opts = {}) {
    if (!nodes || !nodes.length) return;
    if (opts.indent) this.indent();
    const newlineOpts = {
      addNewlines: opts.addNewlines
    };

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;
      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
      this.print(node, parent);

      if (opts.iterator) {
        opts.iterator(node, i);
      }

      if (opts.separator && i < nodes.length - 1) {
        opts.separator.call(this);
      }

      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
    }

    if (opts.indent) this.dedent();
  }

  printAndIndentOnComments(node, parent) {
    const indent = node.leadingComments && node.leadingComments.length > 0;
    if (indent) this.indent();
    this.print(node, parent);
    if (indent) this.dedent();
  }

  printBlock(parent) {
    const node = parent.body;

    if (!t().isEmptyStatement(node)) {
      this.space();
    }

    this.print(node, parent);
  }

  _printTrailingComments(node) {
    this._printComments(this._getComments(false, node));
  }

  _printLeadingComments(node) {
    this._printComments(this._getComments(true, node));
  }

  printInnerComments(node, indent = true) {
    if (!node.innerComments || !node.innerComments.length) return;
    if (indent) this.indent();

    this._printComments(node.innerComments);

    if (indent) this.dedent();
  }

  printSequence(nodes, parent, opts = {}) {
    opts.statement = true;
    return this.printJoin(nodes, parent, opts);
  }

  printList(items, parent, opts = {}) {
    if (opts.separator == null) {
      opts.separator = commaSeparator;
    }

    return this.printJoin(items, parent, opts);
  }

  _printNewline(leading, node, parent, opts) {
    if (this.format.retainLines || this.format.compact) return;

    if (this.format.concise) {
      this.space();
      return;
    }

    let lines = 0;

    if (this._buf.hasContent()) {
      if (!leading) lines++;
      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
      if (needs(node, parent)) lines++;
    }

    this.newline(lines);
  }

  _getComments(leading, node) {
    return node && (leading ? node.leadingComments : node.trailingComments) || [];
  }

  _printComment(comment) {
    if (!this.format.shouldPrintComment(comment.value)) return;
    if (comment.ignore) return;
    if (this._printedComments.has(comment)) return;

    this._printedComments.add(comment);

    if (comment.start != null) {
      if (this._printedCommentStarts[comment.start]) return;
      this._printedCommentStarts[comment.start] = true;
    }

    const isBlockComment = comment.type === "CommentBlock";
    this.newline(this._buf.hasContent() && !this._noLineTerminator && isBlockComment ? 1 : 0);
    if (!this.endsWith("[") && !this.endsWith("{")) this.space();
    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\n` : `/*${comment.value}*/`;

    if (isBlockComment && this.format.indent.adjustMultilineComment) {
      const offset = comment.loc && comment.loc.start.column;

      if (offset) {
        const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
        val = val.replace(newlineRegex, "\n");
      }

      const indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
      val = val.replace(/\n(?!$)/g, `\n${(0, _repeat().default)(" ", indentSize)}`);
    }

    if (this.endsWith("/")) this._space();
    this.withSource("start", comment.loc, () => {
      this._append(val);
    });
    this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
  }

  _printComments(comments) {
    if (!comments || !comments.length) return;

    for (const comment of comments) {
      this._printComment(comment);
    }
  }

}

exports.default = Printer;
Object.assign(Printer.prototype, generatorFunctions);

function commaSeparator() {
  this.token(",");
  this.space();
}

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(308);

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */
function isInteger(value) {
  return typeof value == 'number' && value == toInteger(value);
}

module.exports = isInteger;


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _trimRight() {
  const data = _interopRequireDefault(__webpack_require__(340));

  _trimRight = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SPACES_RE = /^[ \t]+$/;

class Buffer {
  constructor(map) {
    this._map = null;
    this._buf = [];
    this._last = "";
    this._queue = [];
    this._position = {
      line: 1,
      column: 0
    };
    this._sourcePosition = {
      identifierName: null,
      line: null,
      column: null,
      filename: null
    };
    this._disallowedPop = null;
    this._map = map;
  }

  get() {
    this._flush();

    const map = this._map;
    const result = {
      code: (0, _trimRight().default)(this._buf.join("")),
      map: null,
      rawMappings: map && map.getRawMappings()
    };

    if (map) {
      Object.defineProperty(result, "map", {
        configurable: true,
        enumerable: true,

        get() {
          return this.map = map.get();
        },

        set(value) {
          Object.defineProperty(this, "map", {
            value,
            writable: true
          });
        }

      });
    }

    return result;
  }

  append(str) {
    this._flush();

    const {
      line,
      column,
      filename,
      identifierName,
      force
    } = this._sourcePosition;

    this._append(str, line, column, identifierName, filename, force);
  }

  queue(str) {
    if (str === "\n") {
      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
        this._queue.shift();
      }
    }

    const {
      line,
      column,
      filename,
      identifierName,
      force
    } = this._sourcePosition;

    this._queue.unshift([str, line, column, identifierName, filename, force]);
  }

  _flush() {
    let item;

    while (item = this._queue.pop()) this._append(...item);
  }

  _append(str, line, column, identifierName, filename, force) {
    if (this._map && str[0] !== "\n") {
      this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
    }

    this._buf.push(str);

    this._last = str[str.length - 1];

    for (let i = 0; i < str.length; i++) {
      if (str[i] === "\n") {
        this._position.line++;
        this._position.column = 0;
      } else {
        this._position.column++;
      }
    }
  }

  removeTrailingNewline() {
    if (this._queue.length > 0 && this._queue[0][0] === "\n") {
      this._queue.shift();
    }
  }

  removeLastSemicolon() {
    if (this._queue.length > 0 && this._queue[0][0] === ";") {
      this._queue.shift();
    }
  }

  endsWith(suffix) {
    if (suffix.length === 1) {
      let last;

      if (this._queue.length > 0) {
        const str = this._queue[0][0];
        last = str[str.length - 1];
      } else {
        last = this._last;
      }

      return last === suffix;
    }

    const end = this._last + this._queue.reduce((acc, item) => item[0] + acc, "");

    if (suffix.length <= end.length) {
      return end.slice(-suffix.length) === suffix;
    }

    return false;
  }

  hasContent() {
    return this._queue.length > 0 || !!this._last;
  }

  exactSource(loc, cb) {
    this.source("start", loc, true);
    cb();
    this.source("end", loc);

    this._disallowPop("start", loc);
  }

  source(prop, loc, force) {
    if (prop && !loc) return;

    this._normalizePosition(prop, loc, this._sourcePosition, force);
  }

  withSource(prop, loc, cb) {
    if (!this._map) return cb();
    const originalLine = this._sourcePosition.line;
    const originalColumn = this._sourcePosition.column;
    const originalFilename = this._sourcePosition.filename;
    const originalIdentifierName = this._sourcePosition.identifierName;
    this.source(prop, loc);
    cb();

    if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
      this._sourcePosition.line = originalLine;
      this._sourcePosition.column = originalColumn;
      this._sourcePosition.filename = originalFilename;
      this._sourcePosition.identifierName = originalIdentifierName;
      this._sourcePosition.force = false;
      this._disallowedPop = null;
    }
  }

  _disallowPop(prop, loc) {
    if (prop && !loc) return;
    this._disallowedPop = this._normalizePosition(prop, loc);
  }

  _normalizePosition(prop, loc, targetObj, force) {
    const pos = loc ? loc[prop] : null;

    if (targetObj === undefined) {
      targetObj = {
        identifierName: null,
        line: null,
        column: null,
        filename: null,
        force: false
      };
    }

    const origLine = targetObj.line;
    const origColumn = targetObj.column;
    const origFilename = targetObj.filename;
    targetObj.identifierName = prop === "start" && loc && loc.identifierName || null;
    targetObj.line = pos ? pos.line : null;
    targetObj.column = pos ? pos.column : null;
    targetObj.filename = loc && loc.filename || null;

    if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
      targetObj.force = force;
    }

    return targetObj;
  }

  getCurrentColumn() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");

    const lastIndex = extra.lastIndexOf("\n");
    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
  }

  getCurrentLine() {
    const extra = this._queue.reduce((acc, item) => item[0] + acc, "");

    let count = 0;

    for (let i = 0; i < extra.length; i++) {
      if (extra[i] === "\n") count++;
    }

    return this._position.line + count;
  }

}

exports.default = Buffer;

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str) {
	var tail = str.length;

	while (/[\s\uFEFF\u00A0]/.test(str[tail - 1])) {
		tail--;
	}

	return str.slice(0, tail);
};


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.needsWhitespace = needsWhitespace;
exports.needsWhitespaceBefore = needsWhitespaceBefore;
exports.needsWhitespaceAfter = needsWhitespaceAfter;
exports.needsParens = needsParens;

var whitespace = _interopRequireWildcard(__webpack_require__(342));

var parens = _interopRequireWildcard(__webpack_require__(343));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function expandAliases(obj) {
  const newObj = {};

  function add(type, func) {
    const fn = newObj[type];
    newObj[type] = fn ? function (node, parent, stack) {
      const result = fn(node, parent, stack);
      return result == null ? func(node, parent, stack) : result;
    } : func;
  }

  for (const type of Object.keys(obj)) {
    const aliases = t().FLIPPED_ALIAS_KEYS[type];

    if (aliases) {
      for (const alias of aliases) {
        add(alias, obj[type]);
      }
    } else {
      add(type, obj[type]);
    }
  }

  return newObj;
}

const expandedParens = expandAliases(parens);
const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
const expandedWhitespaceList = expandAliases(whitespace.list);

function find(obj, node, parent, printStack) {
  const fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}

function isOrHasCallExpression(node) {
  if (t().isCallExpression(node)) {
    return true;
  }

  if (t().isMemberExpression(node)) {
    return isOrHasCallExpression(node.object) || !node.computed && isOrHasCallExpression(node.property);
  } else {
    return false;
  }
}

function needsWhitespace(node, parent, type) {
  if (!node) return 0;

  if (t().isExpressionStatement(node)) {
    node = node.expression;
  }

  let linesInfo = find(expandedWhitespaceNodes, node, parent);

  if (!linesInfo) {
    const items = find(expandedWhitespaceList, node, parent);

    if (items) {
      for (let i = 0; i < items.length; i++) {
        linesInfo = needsWhitespace(items[i], node, type);
        if (linesInfo) break;
      }
    }
  }

  if (typeof linesInfo === "object" && linesInfo !== null) {
    return linesInfo[type] || 0;
  }

  return 0;
}

function needsWhitespaceBefore(node, parent) {
  return needsWhitespace(node, parent, "before");
}

function needsWhitespaceAfter(node, parent) {
  return needsWhitespace(node, parent, "after");
}

function needsParens(node, parent, printStack) {
  if (!parent) return false;

  if (t().isNewExpression(parent) && parent.callee === node) {
    if (isOrHasCallExpression(node)) return true;
  }

  return find(expandedParens, node, parent, printStack);
}

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.list = exports.nodes = void 0;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function crawl(node, state = {}) {
  if (t().isMemberExpression(node)) {
    crawl(node.object, state);
    if (node.computed) crawl(node.property, state);
  } else if (t().isBinary(node) || t().isAssignmentExpression(node)) {
    crawl(node.left, state);
    crawl(node.right, state);
  } else if (t().isCallExpression(node)) {
    state.hasCall = true;
    crawl(node.callee, state);
  } else if (t().isFunction(node)) {
    state.hasFunction = true;
  } else if (t().isIdentifier(node)) {
    state.hasHelper = state.hasHelper || isHelper(node.callee);
  }

  return state;
}

function isHelper(node) {
  if (t().isMemberExpression(node)) {
    return isHelper(node.object) || isHelper(node.property);
  } else if (t().isIdentifier(node)) {
    return node.name === "require" || node.name[0] === "_";
  } else if (t().isCallExpression(node)) {
    return isHelper(node.callee);
  } else if (t().isBinary(node) || t().isAssignmentExpression(node)) {
    return t().isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
  } else {
    return false;
  }
}

function isType(node) {
  return t().isLiteral(node) || t().isObjectExpression(node) || t().isArrayExpression(node) || t().isIdentifier(node) || t().isMemberExpression(node);
}

const nodes = {
  AssignmentExpression(node) {
    const state = crawl(node.right);

    if (state.hasCall && state.hasHelper || state.hasFunction) {
      return {
        before: state.hasFunction,
        after: true
      };
    }
  },

  SwitchCase(node, parent) {
    return {
      before: node.consequent.length || parent.cases[0] === node,
      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
    };
  },

  LogicalExpression(node) {
    if (t().isFunction(node.left) || t().isFunction(node.right)) {
      return {
        after: true
      };
    }
  },

  Literal(node) {
    if (node.value === "use strict") {
      return {
        after: true
      };
    }
  },

  CallExpression(node) {
    if (t().isFunction(node.callee) || isHelper(node)) {
      return {
        before: true,
        after: true
      };
    }
  },

  VariableDeclaration(node) {
    for (let i = 0; i < node.declarations.length; i++) {
      const declar = node.declarations[i];
      let enabled = isHelper(declar.id) && !isType(declar.init);

      if (!enabled) {
        const state = crawl(declar.init);
        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
      }

      if (enabled) {
        return {
          before: true,
          after: true
        };
      }
    }
  },

  IfStatement(node) {
    if (t().isBlockStatement(node.consequent)) {
      return {
        before: true,
        after: true
      };
    }
  }

};
exports.nodes = nodes;

nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
  if (parent.properties[0] === node) {
    return {
      before: true
    };
  }
};

nodes.ObjectTypeCallProperty = function (node, parent) {
  if (parent.callProperties[0] === node && (!parent.properties || !parent.properties.length)) {
    return {
      before: true
    };
  }
};

nodes.ObjectTypeIndexer = function (node, parent) {
  if (parent.indexers[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length)) {
    return {
      before: true
    };
  }
};

nodes.ObjectTypeInternalSlot = function (node, parent) {
  if (parent.internalSlots[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length) && (!parent.indexers || !parent.indexers.length)) {
    return {
      before: true
    };
  }
};

const list = {
  VariableDeclaration(node) {
    return node.declarations.map(decl => decl.init);
  },

  ArrayExpression(node) {
    return node.elements;
  },

  ObjectExpression(node) {
    return node.properties;
  }

};
exports.list = list;
[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function ([type, amounts]) {
  if (typeof amounts === "boolean") {
    amounts = {
      after: amounts,
      before: amounts
    };
  }

  [type].concat(t().FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
    nodes[type] = function () {
      return amounts;
    };
  });
});

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.UpdateExpression = UpdateExpression;
exports.ObjectExpression = ObjectExpression;
exports.DoExpression = DoExpression;
exports.Binary = Binary;
exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.TSAsExpression = TSAsExpression;
exports.TSTypeAssertion = TSTypeAssertion;
exports.BinaryExpression = BinaryExpression;
exports.SequenceExpression = SequenceExpression;
exports.AwaitExpression = exports.YieldExpression = YieldExpression;
exports.ClassExpression = ClassExpression;
exports.UnaryLike = UnaryLike;
exports.FunctionExpression = FunctionExpression;
exports.ArrowFunctionExpression = ArrowFunctionExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.OptionalMemberExpression = OptionalMemberExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.NewExpression = NewExpression;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const PRECEDENCE = {
  "||": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10
};

const isClassExtendsClause = (node, parent) => (t().isClassDeclaration(parent) || t().isClassExpression(parent)) && parent.superClass === node;

function NullableTypeAnnotation(node, parent) {
  return t().isArrayTypeAnnotation(parent);
}

function UpdateExpression(node, parent) {
  return t().isMemberExpression(parent, {
    object: node
  }) || t().isCallExpression(parent, {
    callee: node
  }) || t().isNewExpression(parent, {
    callee: node
  }) || isClassExtendsClause(node, parent);
}

function ObjectExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, {
    considerArrow: true
  });
}

function DoExpression(node, parent, printStack) {
  return isFirstInStatement(printStack);
}

function Binary(node, parent) {
  if (node.operator === "**" && t().isBinaryExpression(parent, {
    operator: "**"
  })) {
    return parent.left === node;
  }

  if (isClassExtendsClause(node, parent)) {
    return true;
  }

  if ((t().isCallExpression(parent) || t().isNewExpression(parent)) && parent.callee === node || t().isUnaryLike(parent) || t().isMemberExpression(parent) && parent.object === node || t().isAwaitExpression(parent)) {
    return true;
  }

  if (t().isBinary(parent)) {
    const parentOp = parent.operator;
    const parentPos = PRECEDENCE[parentOp];
    const nodeOp = node.operator;
    const nodePos = PRECEDENCE[nodeOp];

    if (parentPos === nodePos && parent.right === node && !t().isLogicalExpression(parent) || parentPos > nodePos) {
      return true;
    }
  }

  return false;
}

function UnionTypeAnnotation(node, parent) {
  return t().isArrayTypeAnnotation(parent) || t().isNullableTypeAnnotation(parent) || t().isIntersectionTypeAnnotation(parent) || t().isUnionTypeAnnotation(parent);
}

function TSAsExpression() {
  return true;
}

function TSTypeAssertion() {
  return true;
}

function BinaryExpression(node, parent) {
  return node.operator === "in" && (t().isVariableDeclarator(parent) || t().isFor(parent));
}

function SequenceExpression(node, parent) {
  if (t().isForStatement(parent) || t().isThrowStatement(parent) || t().isReturnStatement(parent) || t().isIfStatement(parent) && parent.test === node || t().isWhileStatement(parent) && parent.test === node || t().isForInStatement(parent) && parent.right === node || t().isSwitchStatement(parent) && parent.discriminant === node || t().isExpressionStatement(parent) && parent.expression === node) {
    return false;
  }

  return true;
}

function YieldExpression(node, parent) {
  return t().isBinary(parent) || t().isUnaryLike(parent) || t().isCallExpression(parent) || t().isMemberExpression(parent) || t().isNewExpression(parent) || t().isAwaitExpression(parent) && t().isYieldExpression(node) || t().isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
}

function ClassExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, {
    considerDefaultExports: true
  });
}

function UnaryLike(node, parent) {
  return t().isMemberExpression(parent, {
    object: node
  }) || t().isCallExpression(parent, {
    callee: node
  }) || t().isNewExpression(parent, {
    callee: node
  }) || t().isBinaryExpression(parent, {
    operator: "**",
    left: node
  }) || isClassExtendsClause(node, parent);
}

function FunctionExpression(node, parent, printStack) {
  return isFirstInStatement(printStack, {
    considerDefaultExports: true
  });
}

function ArrowFunctionExpression(node, parent) {
  return t().isExportDeclaration(parent) || ConditionalExpression(node, parent);
}

function ConditionalExpression(node, parent) {
  if (t().isUnaryLike(parent) || t().isBinary(parent) || t().isConditionalExpression(parent, {
    test: node
  }) || t().isAwaitExpression(parent) || t().isOptionalMemberExpression(parent) || t().isTaggedTemplateExpression(parent) || t().isTSTypeAssertion(parent) || t().isTSAsExpression(parent)) {
    return true;
  }

  return UnaryLike(node, parent);
}

function OptionalMemberExpression(node, parent) {
  return t().isCallExpression(parent) || t().isMemberExpression(parent);
}

function AssignmentExpression(node) {
  if (t().isObjectPattern(node.left)) {
    return true;
  } else {
    return ConditionalExpression(...arguments);
  }
}

function NewExpression(node, parent) {
  return isClassExtendsClause(node, parent);
}

function isFirstInStatement(printStack, {
  considerArrow = false,
  considerDefaultExports = false
} = {}) {
  let i = printStack.length - 1;
  let node = printStack[i];
  i--;
  let parent = printStack[i];

  while (i > 0) {
    if (t().isExpressionStatement(parent, {
      expression: node
    }) || t().isTaggedTemplateExpression(parent) || considerDefaultExports && t().isExportDefaultDeclaration(parent, {
      declaration: node
    }) || considerArrow && t().isArrowFunctionExpression(parent, {
      body: node
    })) {
      return true;
    }

    if (t().isCallExpression(parent, {
      callee: node
    }) || t().isSequenceExpression(parent) && parent.expressions[0] === node || t().isMemberExpression(parent, {
      object: node
    }) || t().isConditional(parent, {
      test: node
    }) || t().isBinary(parent, {
      left: node
    }) || t().isAssignmentExpression(parent, {
      left: node
    })) {
      node = parent;
      i--;
      parent = printStack[i];
    } else {
      return false;
    }
  }

  return false;
}

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _templateLiterals = __webpack_require__(345);

Object.keys(_templateLiterals).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _templateLiterals[key];
    }
  });
});

var _expressions = __webpack_require__(346);

Object.keys(_expressions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _expressions[key];
    }
  });
});

var _statements = __webpack_require__(347);

Object.keys(_statements).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _statements[key];
    }
  });
});

var _classes = __webpack_require__(348);

Object.keys(_classes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _classes[key];
    }
  });
});

var _methods = __webpack_require__(349);

Object.keys(_methods).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _methods[key];
    }
  });
});

var _modules = __webpack_require__(350);

Object.keys(_modules).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modules[key];
    }
  });
});

var _types = __webpack_require__(351);

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});

var _flow = __webpack_require__(353);

Object.keys(_flow).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _flow[key];
    }
  });
});

var _base = __webpack_require__(354);

Object.keys(_base).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _base[key];
    }
  });
});

var _jsx = __webpack_require__(355);

Object.keys(_jsx).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _jsx[key];
    }
  });
});

var _typescript = __webpack_require__(356);

Object.keys(_typescript).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _typescript[key];
    }
  });
});

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.TemplateElement = TemplateElement;
exports.TemplateLiteral = TemplateLiteral;

function TaggedTemplateExpression(node) {
  this.print(node.tag, node);
  this.print(node.typeParameters, node);
  this.print(node.quasi, node);
}

function TemplateElement(node, parent) {
  const isFirst = parent.quasis[0] === node;
  const isLast = parent.quasis[parent.quasis.length - 1] === node;
  const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
  this.token(value);
}

function TemplateLiteral(node) {
  const quasis = node.quasis;

  for (let i = 0; i < quasis.length; i++) {
    this.print(quasis[i], node);

    if (i + 1 < quasis.length) {
      this.print(node.expressions[i], node);
    }
  }
}

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnaryExpression = UnaryExpression;
exports.DoExpression = DoExpression;
exports.ParenthesizedExpression = ParenthesizedExpression;
exports.UpdateExpression = UpdateExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.NewExpression = NewExpression;
exports.SequenceExpression = SequenceExpression;
exports.ThisExpression = ThisExpression;
exports.Super = Super;
exports.Decorator = Decorator;
exports.OptionalMemberExpression = OptionalMemberExpression;
exports.OptionalCallExpression = OptionalCallExpression;
exports.CallExpression = CallExpression;
exports.Import = Import;
exports.EmptyStatement = EmptyStatement;
exports.ExpressionStatement = ExpressionStatement;
exports.AssignmentPattern = AssignmentPattern;
exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;
exports.BindExpression = BindExpression;
exports.MemberExpression = MemberExpression;
exports.MetaProperty = MetaProperty;
exports.PrivateName = PrivateName;
exports.AwaitExpression = exports.YieldExpression = void 0;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var n = _interopRequireWildcard(__webpack_require__(341));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function UnaryExpression(node) {
  if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
    this.word(node.operator);
    this.space();
  } else {
    this.token(node.operator);
  }

  this.print(node.argument, node);
}

function DoExpression(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
}

function ParenthesizedExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.token(")");
}

function UpdateExpression(node) {
  if (node.prefix) {
    this.token(node.operator);
    this.print(node.argument, node);
  } else {
    this.startTerminatorless(true);
    this.print(node.argument, node);
    this.endTerminatorless();
    this.token(node.operator);
  }
}

function ConditionalExpression(node) {
  this.print(node.test, node);
  this.space();
  this.token("?");
  this.space();
  this.print(node.consequent, node);
  this.space();
  this.token(":");
  this.space();
  this.print(node.alternate, node);
}

function NewExpression(node, parent) {
  this.word("new");
  this.space();
  this.print(node.callee, node);

  if (this.format.minified && node.arguments.length === 0 && !node.optional && !t().isCallExpression(parent, {
    callee: node
  }) && !t().isMemberExpression(parent) && !t().isNewExpression(parent)) {
    return;
  }

  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);

  if (node.optional) {
    this.token("?.");
  }

  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function SequenceExpression(node) {
  this.printList(node.expressions, node);
}

function ThisExpression() {
  this.word("this");
}

function Super() {
  this.word("super");
}

function Decorator(node) {
  this.token("@");
  this.print(node.expression, node);
  this.newline();
}

function OptionalMemberExpression(node) {
  this.print(node.object, node);

  if (!node.computed && t().isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  let computed = node.computed;

  if (t().isLiteral(node.property) && typeof node.property.value === "number") {
    computed = true;
  }

  if (node.optional) {
    this.token("?.");
  }

  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    if (!node.optional) {
      this.token(".");
    }

    this.print(node.property, node);
  }
}

function OptionalCallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);

  if (node.optional) {
    this.token("?.");
  }

  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function CallExpression(node) {
  this.print(node.callee, node);
  this.print(node.typeArguments, node);
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.arguments, node);
  this.token(")");
}

function Import() {
  this.word("import");
}

function buildYieldAwait(keyword) {
  return function (node) {
    this.word(keyword);

    if (node.delegate) {
      this.token("*");
    }

    if (node.argument) {
      this.space();
      const terminatorState = this.startTerminatorless();
      this.print(node.argument, node);
      this.endTerminatorless(terminatorState);
    }
  };
}

const YieldExpression = buildYieldAwait("yield");
exports.YieldExpression = YieldExpression;
const AwaitExpression = buildYieldAwait("await");
exports.AwaitExpression = AwaitExpression;

function EmptyStatement() {
  this.semicolon(true);
}

function ExpressionStatement(node) {
  this.print(node.expression, node);
  this.semicolon();
}

function AssignmentPattern(node) {
  this.print(node.left, node);
  if (node.left.optional) this.token("?");
  this.print(node.left.typeAnnotation, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
}

function AssignmentExpression(node, parent) {
  const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);

  if (parens) {
    this.token("(");
  }

  this.print(node.left, node);
  this.space();

  if (node.operator === "in" || node.operator === "instanceof") {
    this.word(node.operator);
  } else {
    this.token(node.operator);
  }

  this.space();
  this.print(node.right, node);

  if (parens) {
    this.token(")");
  }
}

function BindExpression(node) {
  this.print(node.object, node);
  this.token("::");
  this.print(node.callee, node);
}

function MemberExpression(node) {
  this.print(node.object, node);

  if (!node.computed && t().isMemberExpression(node.property)) {
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  }

  let computed = node.computed;

  if (t().isLiteral(node.property) && typeof node.property.value === "number") {
    computed = true;
  }

  if (computed) {
    this.token("[");
    this.print(node.property, node);
    this.token("]");
  } else {
    this.token(".");
    this.print(node.property, node);
  }
}

function MetaProperty(node) {
  this.print(node.meta, node);
  this.token(".");
  this.print(node.property, node);
}

function PrivateName(node) {
  this.token("#");
  this.print(node.id, node);
}

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WithStatement = WithStatement;
exports.IfStatement = IfStatement;
exports.ForStatement = ForStatement;
exports.WhileStatement = WhileStatement;
exports.DoWhileStatement = DoWhileStatement;
exports.LabeledStatement = LabeledStatement;
exports.TryStatement = TryStatement;
exports.CatchClause = CatchClause;
exports.SwitchStatement = SwitchStatement;
exports.SwitchCase = SwitchCase;
exports.DebuggerStatement = DebuggerStatement;
exports.VariableDeclaration = VariableDeclaration;
exports.VariableDeclarator = VariableDeclarator;
exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function WithStatement(node) {
  this.word("with");
  this.space();
  this.token("(");
  this.print(node.object, node);
  this.token(")");
  this.printBlock(node);
}

function IfStatement(node) {
  this.word("if");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.space();
  const needsBlock = node.alternate && t().isIfStatement(getLastStatement(node.consequent));

  if (needsBlock) {
    this.token("{");
    this.newline();
    this.indent();
  }

  this.printAndIndentOnComments(node.consequent, node);

  if (needsBlock) {
    this.dedent();
    this.newline();
    this.token("}");
  }

  if (node.alternate) {
    if (this.endsWith("}")) this.space();
    this.word("else");
    this.space();
    this.printAndIndentOnComments(node.alternate, node);
  }
}

function getLastStatement(statement) {
  if (!t().isStatement(statement.body)) return statement;
  return getLastStatement(statement.body);
}

function ForStatement(node) {
  this.word("for");
  this.space();
  this.token("(");
  this.inForStatementInitCounter++;
  this.print(node.init, node);
  this.inForStatementInitCounter--;
  this.token(";");

  if (node.test) {
    this.space();
    this.print(node.test, node);
  }

  this.token(";");

  if (node.update) {
    this.space();
    this.print(node.update, node);
  }

  this.token(")");
  this.printBlock(node);
}

function WhileStatement(node) {
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.printBlock(node);
}

const buildForXStatement = function (op) {
  return function (node) {
    this.word("for");
    this.space();

    if (op === "of" && node.await) {
      this.word("await");
      this.space();
    }

    this.token("(");
    this.print(node.left, node);
    this.space();
    this.word(op);
    this.space();
    this.print(node.right, node);
    this.token(")");
    this.printBlock(node);
  };
};

const ForInStatement = buildForXStatement("in");
exports.ForInStatement = ForInStatement;
const ForOfStatement = buildForXStatement("of");
exports.ForOfStatement = ForOfStatement;

function DoWhileStatement(node) {
  this.word("do");
  this.space();
  this.print(node.body, node);
  this.space();
  this.word("while");
  this.space();
  this.token("(");
  this.print(node.test, node);
  this.token(")");
  this.semicolon();
}

function buildLabelStatement(prefix, key = "label") {
  return function (node) {
    this.word(prefix);
    const label = node[key];

    if (label) {
      this.space();
      const isLabel = key == "label";
      const terminatorState = this.startTerminatorless(isLabel);
      this.print(label, node);
      this.endTerminatorless(terminatorState);
    }

    this.semicolon();
  };
}

const ContinueStatement = buildLabelStatement("continue");
exports.ContinueStatement = ContinueStatement;
const ReturnStatement = buildLabelStatement("return", "argument");
exports.ReturnStatement = ReturnStatement;
const BreakStatement = buildLabelStatement("break");
exports.BreakStatement = BreakStatement;
const ThrowStatement = buildLabelStatement("throw", "argument");
exports.ThrowStatement = ThrowStatement;

function LabeledStatement(node) {
  this.print(node.label, node);
  this.token(":");
  this.space();
  this.print(node.body, node);
}

function TryStatement(node) {
  this.word("try");
  this.space();
  this.print(node.block, node);
  this.space();

  if (node.handlers) {
    this.print(node.handlers[0], node);
  } else {
    this.print(node.handler, node);
  }

  if (node.finalizer) {
    this.space();
    this.word("finally");
    this.space();
    this.print(node.finalizer, node);
  }
}

function CatchClause(node) {
  this.word("catch");
  this.space();

  if (node.param) {
    this.token("(");
    this.print(node.param, node);
    this.token(")");
    this.space();
  }

  this.print(node.body, node);
}

function SwitchStatement(node) {
  this.word("switch");
  this.space();
  this.token("(");
  this.print(node.discriminant, node);
  this.token(")");
  this.space();
  this.token("{");
  this.printSequence(node.cases, node, {
    indent: true,

    addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    }

  });
  this.token("}");
}

function SwitchCase(node) {
  if (node.test) {
    this.word("case");
    this.space();
    this.print(node.test, node);
    this.token(":");
  } else {
    this.word("default");
    this.token(":");
  }

  if (node.consequent.length) {
    this.newline();
    this.printSequence(node.consequent, node, {
      indent: true
    });
  }
}

function DebuggerStatement() {
  this.word("debugger");
  this.semicolon();
}

function variableDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 4; i++) this.space(true);
}

function constDeclarationIndent() {
  this.token(",");
  this.newline();
  if (this.endsWith("\n")) for (let i = 0; i < 6; i++) this.space(true);
}

function VariableDeclaration(node, parent) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }

  this.word(node.kind);
  this.space();
  let hasInits = false;

  if (!t().isFor(parent)) {
    for (const declar of node.declarations) {
      if (declar.init) {
        hasInits = true;
      }
    }
  }

  let separator;

  if (hasInits) {
    separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
  }

  this.printList(node.declarations, node, {
    separator
  });

  if (t().isFor(parent)) {
    if (parent.left === node || parent.init === node) return;
  }

  this.semicolon();
}

function VariableDeclarator(node) {
  this.print(node.id, node);
  if (node.definite) this.token("!");
  this.print(node.id.typeAnnotation, node);

  if (node.init) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.init, node);
  }
}

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;
exports.ClassBody = ClassBody;
exports.ClassProperty = ClassProperty;
exports.ClassPrivateProperty = ClassPrivateProperty;
exports.ClassMethod = ClassMethod;
exports.ClassPrivateMethod = ClassPrivateMethod;
exports._classMethodHead = _classMethodHead;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function ClassDeclaration(node, parent) {
  if (!this.format.decoratorsBeforeExport || !t().isExportDefaultDeclaration(parent) && !t().isExportNamedDeclaration(parent)) {
    this.printJoin(node.decorators, node);
  }

  if (node.declare) {
    this.word("declare");
    this.space();
  }

  if (node.abstract) {
    this.word("abstract");
    this.space();
  }

  this.word("class");

  if (node.id) {
    this.space();
    this.print(node.id, node);
  }

  this.print(node.typeParameters, node);

  if (node.superClass) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.superClass, node);
    this.print(node.superTypeParameters, node);
  }

  if (node.implements) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }

  this.space();
  this.print(node.body, node);
}

function ClassBody(node) {
  this.token("{");
  this.printInnerComments(node);

  if (node.body.length === 0) {
    this.token("}");
  } else {
    this.newline();
    this.indent();
    this.printSequence(node.body, node);
    this.dedent();
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  }
}

function ClassProperty(node) {
  this.printJoin(node.decorators, node);

  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }

  if (node.static) {
    this.word("static");
    this.space();
  }

  if (node.abstract) {
    this.word("abstract");
    this.space();
  }

  if (node.readonly) {
    this.word("readonly");
    this.space();
  }

  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    this._variance(node);

    this.print(node.key, node);
  }

  if (node.optional) {
    this.token("?");
  }

  if (node.definite) {
    this.token("!");
  }

  this.print(node.typeAnnotation, node);

  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }

  this.semicolon();
}

function ClassPrivateProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this.print(node.key, node);
  this.print(node.typeAnnotation, node);

  if (node.value) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.value, node);
  }

  this.semicolon();
}

function ClassMethod(node) {
  this._classMethodHead(node);

  this.space();
  this.print(node.body, node);
}

function ClassPrivateMethod(node) {
  this._classMethodHead(node);

  this.space();
  this.print(node.body, node);
}

function _classMethodHead(node) {
  this.printJoin(node.decorators, node);

  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }

  if (node.abstract) {
    this.word("abstract");
    this.space();
  }

  if (node.static) {
    this.word("static");
    this.space();
  }

  this._methodHead(node);
}

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._params = _params;
exports._parameters = _parameters;
exports._param = _param;
exports._methodHead = _methodHead;
exports._predicate = _predicate;
exports._functionHead = _functionHead;
exports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;
exports.ArrowFunctionExpression = ArrowFunctionExpression;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _params(node) {
  this.print(node.typeParameters, node);
  this.token("(");

  this._parameters(node.params, node);

  this.token(")");
  this.print(node.returnType, node);
}

function _parameters(parameters, parent) {
  for (let i = 0; i < parameters.length; i++) {
    this._param(parameters[i], parent);

    if (i < parameters.length - 1) {
      this.token(",");
      this.space();
    }
  }
}

function _param(parameter, parent) {
  this.printJoin(parameter.decorators, parameter);
  this.print(parameter, parent);
  if (parameter.optional) this.token("?");
  this.print(parameter.typeAnnotation, parameter);
}

function _methodHead(node) {
  const kind = node.kind;
  const key = node.key;

  if (kind === "get" || kind === "set") {
    this.word(kind);
    this.space();
  }

  if (node.async) {
    this.word("async");
    this.space();
  }

  if (kind === "method" || kind === "init") {
    if (node.generator) {
      this.token("*");
    }
  }

  if (node.computed) {
    this.token("[");
    this.print(key, node);
    this.token("]");
  } else {
    this.print(key, node);
  }

  if (node.optional) {
    this.token("?");
  }

  this._params(node);
}

function _predicate(node) {
  if (node.predicate) {
    if (!node.returnType) {
      this.token(":");
    }

    this.space();
    this.print(node.predicate, node);
  }
}

function _functionHead(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }

  this.word("function");
  if (node.generator) this.token("*");
  this.space();

  if (node.id) {
    this.print(node.id, node);
  }

  this._params(node);

  this._predicate(node);
}

function FunctionExpression(node) {
  this._functionHead(node);

  this.space();
  this.print(node.body, node);
}

function ArrowFunctionExpression(node) {
  if (node.async) {
    this.word("async");
    this.space();
  }

  const firstParam = node.params[0];

  if (node.params.length === 1 && t().isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
    if (this.format.retainLines && node.loc && node.body.loc && node.loc.start.line < node.body.loc.start.line) {
      this.token("(");

      if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {
        this.indent();
        this.print(firstParam, node);
        this.dedent();

        this._catchUp("start", node.body.loc);
      } else {
        this.print(firstParam, node);
      }

      this.token(")");
    } else {
      this.print(firstParam, node);
    }
  } else {
    this._params(node);
  }

  this._predicate(node);

  this.space();
  this.token("=>");
  this.space();
  this.print(node.body, node);
}

function hasTypes(node, param) {
  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
}

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImportSpecifier = ImportSpecifier;
exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
exports.ExportDefaultSpecifier = ExportDefaultSpecifier;
exports.ExportSpecifier = ExportSpecifier;
exports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
exports.ExportAllDeclaration = ExportAllDeclaration;
exports.ExportNamedDeclaration = ExportNamedDeclaration;
exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
exports.ImportDeclaration = ImportDeclaration;
exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function ImportSpecifier(node) {
  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  this.print(node.imported, node);

  if (node.local && node.local.name !== node.imported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }
}

function ImportDefaultSpecifier(node) {
  this.print(node.local, node);
}

function ExportDefaultSpecifier(node) {
  this.print(node.exported, node);
}

function ExportSpecifier(node) {
  this.print(node.local, node);

  if (node.exported && node.local.name !== node.exported.name) {
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
}

function ExportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.exported, node);
}

function ExportAllDeclaration(node) {
  this.word("export");
  this.space();

  if (node.exportKind === "type") {
    this.word("type");
    this.space();
  }

  this.token("*");
  this.space();
  this.word("from");
  this.space();
  this.print(node.source, node);
  this.semicolon();
}

function ExportNamedDeclaration(node) {
  if (this.format.decoratorsBeforeExport && t().isClassDeclaration(node.declaration)) {
    this.printJoin(node.declaration.decorators, node);
  }

  this.word("export");
  this.space();
  ExportDeclaration.apply(this, arguments);
}

function ExportDefaultDeclaration(node) {
  if (this.format.decoratorsBeforeExport && t().isClassDeclaration(node.declaration)) {
    this.printJoin(node.declaration.decorators, node);
  }

  this.word("export");
  this.space();
  this.word("default");
  this.space();
  ExportDeclaration.apply(this, arguments);
}

function ExportDeclaration(node) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!t().isStatement(declar)) this.semicolon();
  } else {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    const specifiers = node.specifiers.slice(0);
    let hasSpecial = false;

    while (true) {
      const first = specifiers[0];

      if (t().isExportDefaultSpecifier(first) || t().isExportNamespaceSpecifier(first)) {
        hasSpecial = true;
        this.print(specifiers.shift(), node);

        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length || !specifiers.length && !hasSpecial) {
      this.token("{");

      if (specifiers.length) {
        this.space();
        this.printList(specifiers, node);
        this.space();
      }

      this.token("}");
    }

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }

    this.semicolon();
  }
}

function ImportDeclaration(node) {
  this.word("import");
  this.space();

  if (node.importKind === "type" || node.importKind === "typeof") {
    this.word(node.importKind);
    this.space();
  }

  const specifiers = node.specifiers.slice(0);

  if (specifiers && specifiers.length) {
    while (true) {
      const first = specifiers[0];

      if (t().isImportDefaultSpecifier(first) || t().isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift(), node);

        if (specifiers.length) {
          this.token(",");
          this.space();
        }
      } else {
        break;
      }
    }

    if (specifiers.length) {
      this.token("{");
      this.space();
      this.printList(specifiers, node);
      this.space();
      this.token("}");
    }

    this.space();
    this.word("from");
    this.space();
  }

  this.print(node.source, node);
  this.semicolon();
}

function ImportNamespaceSpecifier(node) {
  this.token("*");
  this.space();
  this.word("as");
  this.space();
  this.print(node.local, node);
}

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Identifier = Identifier;
exports.SpreadElement = exports.RestElement = RestElement;
exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
exports.ObjectMethod = ObjectMethod;
exports.ObjectProperty = ObjectProperty;
exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
exports.RegExpLiteral = RegExpLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.NumericLiteral = NumericLiteral;
exports.StringLiteral = StringLiteral;
exports.BigIntLiteral = BigIntLiteral;
exports.PipelineTopicExpression = PipelineTopicExpression;
exports.PipelineBareFunction = PipelineBareFunction;
exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _jsesc() {
  const data = _interopRequireDefault(__webpack_require__(352));

  _jsesc = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function Identifier(node) {
  this.exactSource(node.loc, () => {
    this.word(node.name);
  });
}

function RestElement(node) {
  this.token("...");
  this.print(node.argument, node);
}

function ObjectExpression(node) {
  const props = node.properties;
  this.token("{");
  this.printInnerComments(node);

  if (props.length) {
    this.space();
    this.printList(props, node, {
      indent: true,
      statement: true
    });
    this.space();
  }

  this.token("}");
}

function ObjectMethod(node) {
  this.printJoin(node.decorators, node);

  this._methodHead(node);

  this.space();
  this.print(node.body, node);
}

function ObjectProperty(node) {
  this.printJoin(node.decorators, node);

  if (node.computed) {
    this.token("[");
    this.print(node.key, node);
    this.token("]");
  } else {
    if (t().isAssignmentPattern(node.value) && t().isIdentifier(node.key) && node.key.name === node.value.left.name) {
      this.print(node.value, node);
      return;
    }

    this.print(node.key, node);

    if (node.shorthand && t().isIdentifier(node.key) && t().isIdentifier(node.value) && node.key.name === node.value.name) {
      return;
    }
  }

  this.token(":");
  this.space();
  this.print(node.value, node);
}

function ArrayExpression(node) {
  const elems = node.elements;
  const len = elems.length;
  this.token("[");
  this.printInnerComments(node);

  for (let i = 0; i < elems.length; i++) {
    const elem = elems[i];

    if (elem) {
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.token(",");
    } else {
      this.token(",");
    }
  }

  this.token("]");
}

function RegExpLiteral(node) {
  this.word(`/${node.pattern}/${node.flags}`);
}

function BooleanLiteral(node) {
  this.word(node.value ? "true" : "false");
}

function NullLiteral() {
  this.word("null");
}

function NumericLiteral(node) {
  const raw = this.getPossibleRaw(node);
  const value = node.value + "";

  if (raw == null) {
    this.number(value);
  } else if (this.format.minified) {
    this.number(raw.length < value.length ? raw : value);
  } else {
    this.number(raw);
  }
}

function StringLiteral(node) {
  const raw = this.getPossibleRaw(node);

  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }

  const opts = this.format.jsescOption;

  if (this.format.jsonCompatibleStrings) {
    opts.json = true;
  }

  const val = (0, _jsesc().default)(node.value, opts);
  return this.token(val);
}

function BigIntLiteral(node) {
  const raw = this.getPossibleRaw(node);

  if (!this.format.minified && raw != null) {
    this.token(raw);
    return;
  }

  this.token(node.value);
}

function PipelineTopicExpression(node) {
  this.print(node.expression, node);
}

function PipelineBareFunction(node) {
  this.print(node.callee, node);
}

function PipelinePrimaryTopicReference() {
  this.token("#");
}

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const object = {};
const hasOwnProperty = object.hasOwnProperty;
const forOwn = (object, callback) => {
	for (const key in object) {
		if (hasOwnProperty.call(object, key)) {
			callback(key, object[key]);
		}
	}
};

const extend = (destination, source) => {
	if (!source) {
		return destination;
	}
	forOwn(source, (key, value) => {
		destination[key] = value;
	});
	return destination;
};

const forEach = (array, callback) => {
	const length = array.length;
	let index = -1;
	while (++index < length) {
		callback(array[index]);
	}
};

const toString = object.toString;
const isArray = Array.isArray;
const isBuffer = Buffer.isBuffer;
const isObject = (value) => {
	// This is a very simple check, but its good enough for what we need.
	return toString.call(value) == '[object Object]';
};
const isString = (value) => {
	return typeof value == 'string' ||
		toString.call(value) == '[object String]';
};
const isNumber = (value) => {
	return typeof value == 'number' ||
		toString.call(value) == '[object Number]';
};
const isFunction = (value) => {
	return typeof value == 'function';
};
const isMap = (value) => {
	return toString.call(value) == '[object Map]';
};
const isSet = (value) => {
	return toString.call(value) == '[object Set]';
};

/*--------------------------------------------------------------------------*/

// https://mathiasbynens.be/notes/javascript-escapes#single
const singleEscapes = {
	'"': '\\"',
	'\'': '\\\'',
	'\\': '\\\\',
	'\b': '\\b',
	'\f': '\\f',
	'\n': '\\n',
	'\r': '\\r',
	'\t': '\\t'
	// `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
	// '\v': '\\x0B'
};
const regexSingleEscape = /["'\\\b\f\n\r\t]/;

const regexDigit = /[0-9]/;
const regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

const jsesc = (argument, options) => {
	const increaseIndentation = () => {
		oldIndent = indent;
		++options.indentLevel;
		indent = options.indent.repeat(options.indentLevel)
	};
	// Handle options
	const defaults = {
		'escapeEverything': false,
		'minimal': false,
		'isScriptContext': false,
		'quotes': 'single',
		'wrap': false,
		'es6': false,
		'json': false,
		'compact': true,
		'lowercaseHex': false,
		'numbers': 'decimal',
		'indent': '\t',
		'indentLevel': 0,
		'__inline1__': false,
		'__inline2__': false
	};
	const json = options && options.json;
	if (json) {
		defaults.quotes = 'double';
		defaults.wrap = true;
	}
	options = extend(defaults, options);
	if (
		options.quotes != 'single' &&
		options.quotes != 'double' &&
		options.quotes != 'backtick'
	) {
		options.quotes = 'single';
	}
	const quote = options.quotes == 'double' ?
		'"' :
		(options.quotes == 'backtick' ?
			'`' :
			'\''
		);
	const compact = options.compact;
	const lowercaseHex = options.lowercaseHex;
	let indent = options.indent.repeat(options.indentLevel);
	let oldIndent = '';
	const inline1 = options.__inline1__;
	const inline2 = options.__inline2__;
	const newLine = compact ? '' : '\n';
	let result;
	let isEmpty = true;
	const useBinNumbers = options.numbers == 'binary';
	const useOctNumbers = options.numbers == 'octal';
	const useDecNumbers = options.numbers == 'decimal';
	const useHexNumbers = options.numbers == 'hexadecimal';

	if (json && argument && isFunction(argument.toJSON)) {
		argument = argument.toJSON();
	}

	if (!isString(argument)) {
		if (isMap(argument)) {
			if (argument.size == 0) {
				return 'new Map()';
			}
			if (!compact) {
				options.__inline1__ = true;
				options.__inline2__ = false;
			}
			return 'new Map(' + jsesc(Array.from(argument), options) + ')';
		}
		if (isSet(argument)) {
			if (argument.size == 0) {
				return 'new Set()';
			}
			return 'new Set(' + jsesc(Array.from(argument), options) + ')';
		}
		if (isBuffer(argument)) {
			if (argument.length == 0) {
				return 'Buffer.from([])';
			}
			return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
		}
		if (isArray(argument)) {
			result = [];
			options.wrap = true;
			if (inline1) {
				options.__inline1__ = false;
				options.__inline2__ = true;
			}
			if (!inline2) {
				increaseIndentation();
			}
			forEach(argument, (value) => {
				isEmpty = false;
				if (inline2) {
					options.__inline2__ = false;
				}
				result.push(
					(compact || inline2 ? '' : indent) +
					jsesc(value, options)
				);
			});
			if (isEmpty) {
				return '[]';
			}
			if (inline2) {
				return '[' + result.join(', ') + ']';
			}
			return '[' + newLine + result.join(',' + newLine) + newLine +
				(compact ? '' : oldIndent) + ']';
		} else if (isNumber(argument)) {
			if (json) {
				// Some number values (e.g. `Infinity`) cannot be represented in JSON.
				return JSON.stringify(argument);
			}
			if (useDecNumbers) {
				return String(argument);
			}
			if (useHexNumbers) {
				let hexadecimal = argument.toString(16);
				if (!lowercaseHex) {
					hexadecimal = hexadecimal.toUpperCase();
				}
				return '0x' + hexadecimal;
			}
			if (useBinNumbers) {
				return '0b' + argument.toString(2);
			}
			if (useOctNumbers) {
				return '0o' + argument.toString(8);
			}
		} else if (!isObject(argument)) {
			if (json) {
				// For some values (e.g. `undefined`, `function` objects),
				// `JSON.stringify(value)` returns `undefined` (which isnt valid
				// JSON) instead of `'null'`.
				return JSON.stringify(argument) || 'null';
			}
			return String(argument);
		} else { // its an object
			result = [];
			options.wrap = true;
			increaseIndentation();
			forOwn(argument, (key, value) => {
				isEmpty = false;
				result.push(
					(compact ? '' : indent) +
					jsesc(key, options) + ':' +
					(compact ? '' : ' ') +
					jsesc(value, options)
				);
			});
			if (isEmpty) {
				return '{}';
			}
			return '{' + newLine + result.join(',' + newLine) + newLine +
				(compact ? '' : oldIndent) + '}';
		}
	}

	const string = argument;
	// Loop over each code unit in the string and escape it
	let index = -1;
	const length = string.length;
	result = '';
	while (++index < length) {
		const character = string.charAt(index);
		if (options.es6) {
			const first = string.charCodeAt(index);
			if ( // check if its the start of a surrogate pair
				first >= 0xD800 && first <= 0xDBFF && // high surrogate
				length > index + 1 // there is a next code unit
			) {
				const second = string.charCodeAt(index + 1);
				if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					const codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
					let hexadecimal = codePoint.toString(16);
					if (!lowercaseHex) {
						hexadecimal = hexadecimal.toUpperCase();
					}
					result += '\\u{' + hexadecimal + '}';
					++index;
					continue;
				}
			}
		}
		if (!options.escapeEverything) {
			if (regexWhitelist.test(character)) {
				// Its a printable ASCII character that is not `"`, `'` or `\`,
				// so dont escape it.
				result += character;
				continue;
			}
			if (character == '"') {
				result += quote == character ? '\\"' : character;
				continue;
			}
			if (character == '`') {
				result += quote == character ? '\\`' : character;
				continue;
			}
			if (character == '\'') {
				result += quote == character ? '\\\'' : character;
				continue;
			}
		}
		if (
			character == '\0' &&
			!json &&
			!regexDigit.test(string.charAt(index + 1))
		) {
			result += '\\0';
			continue;
		}
		if (regexSingleEscape.test(character)) {
			// no need for a `hasOwnProperty` check here
			result += singleEscapes[character];
			continue;
		}
		const charCode = character.charCodeAt(0);
		if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
			result += character;
			continue;
		}
		let hexadecimal = charCode.toString(16);
		if (!lowercaseHex) {
			hexadecimal = hexadecimal.toUpperCase();
		}
		const longhand = hexadecimal.length > 2 || json;
		const escaped = '\\' + (longhand ? 'u' : 'x') +
			('0000' + hexadecimal).slice(longhand ? -4 : -2);
		result += escaped;
		continue;
	}
	if (options.wrap) {
		result = quote + result + quote;
	}
	if (quote == '`') {
		result = result.replace(/\$\{/g, '\\\$\{');
	}
	if (options.isScriptContext) {
		// https://mathiasbynens.be/notes/etago
		return result
			.replace(/<\/(script|style)/gi, '<\\/$1')
			.replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--');
	}
	return result;
};

jsesc.version = '2.5.2';

module.exports = jsesc;


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.DeclareClass = DeclareClass;
exports.DeclareFunction = DeclareFunction;
exports.InferredPredicate = InferredPredicate;
exports.DeclaredPredicate = DeclaredPredicate;
exports.DeclareInterface = DeclareInterface;
exports.DeclareModule = DeclareModule;
exports.DeclareModuleExports = DeclareModuleExports;
exports.DeclareTypeAlias = DeclareTypeAlias;
exports.DeclareOpaqueType = DeclareOpaqueType;
exports.DeclareVariable = DeclareVariable;
exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.FunctionTypeParam = FunctionTypeParam;
exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
exports._interfaceish = _interfaceish;
exports._variance = _variance;
exports.InterfaceDeclaration = InterfaceDeclaration;
exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.StringTypeAnnotation = StringTypeAnnotation;
exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.TypeAlias = TypeAlias;
exports.TypeAnnotation = TypeAnnotation;
exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.TypeParameter = TypeParameter;
exports.OpaqueType = OpaqueType;
exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.ObjectTypeProperty = ObjectTypeProperty;
exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.TypeCastExpression = TypeCastExpression;
exports.Variance = Variance;
exports.VoidTypeAnnotation = VoidTypeAnnotation;
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _types2.NumericLiteral;
  }
});
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _types2.StringLiteral;
  }
});

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var _modules = __webpack_require__(350);

var _types2 = __webpack_require__(351);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function AnyTypeAnnotation() {
  this.word("any");
}

function ArrayTypeAnnotation(node) {
  this.print(node.elementType, node);
  this.token("[");
  this.token("]");
}

function BooleanTypeAnnotation() {
  this.word("boolean");
}

function BooleanLiteralTypeAnnotation(node) {
  this.word(node.value ? "true" : "false");
}

function NullLiteralTypeAnnotation() {
  this.word("null");
}

function DeclareClass(node, parent) {
  if (!t().isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.word("class");
  this.space();

  this._interfaceish(node);
}

function DeclareFunction(node, parent) {
  if (!t().isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.word("function");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation.typeAnnotation, node);

  if (node.predicate) {
    this.space();
    this.print(node.predicate, node);
  }

  this.semicolon();
}

function InferredPredicate() {
  this.token("%");
  this.word("checks");
}

function DeclaredPredicate(node) {
  this.token("%");
  this.word("checks");
  this.token("(");
  this.print(node.value, node);
  this.token(")");
}

function DeclareInterface(node) {
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
}

function DeclareModule(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id, node);
  this.space();
  this.print(node.body, node);
}

function DeclareModuleExports(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.token(".");
  this.word("exports");
  this.print(node.typeAnnotation, node);
}

function DeclareTypeAlias(node) {
  this.word("declare");
  this.space();
  this.TypeAlias(node);
}

function DeclareOpaqueType(node, parent) {
  if (!t().isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.OpaqueType(node);
}

function DeclareVariable(node, parent) {
  if (!t().isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  }

  this.word("var");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  this.semicolon();
}

function DeclareExportDeclaration(node) {
  this.word("declare");
  this.space();
  this.word("export");
  this.space();

  if (node.default) {
    this.word("default");
    this.space();
  }

  FlowExportDeclaration.apply(this, arguments);
}

function DeclareExportAllDeclaration() {
  this.word("declare");
  this.space();

  _modules.ExportAllDeclaration.apply(this, arguments);
}

function FlowExportDeclaration(node) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar, node);
    if (!t().isStatement(declar)) this.semicolon();
  } else {
    this.token("{");

    if (node.specifiers.length) {
      this.space();
      this.printList(node.specifiers, node);
      this.space();
    }

    this.token("}");

    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
    }

    this.semicolon();
  }
}

function ExistsTypeAnnotation() {
  this.token("*");
}

function FunctionTypeAnnotation(node, parent) {
  this.print(node.typeParameters, node);
  this.token("(");
  this.printList(node.params, node);

  if (node.rest) {
    if (node.params.length) {
      this.token(",");
      this.space();
    }

    this.token("...");
    this.print(node.rest, node);
  }

  this.token(")");

  if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
    this.token(":");
  } else {
    this.space();
    this.token("=>");
  }

  this.space();
  this.print(node.returnType, node);
}

function FunctionTypeParam(node) {
  this.print(node.name, node);
  if (node.optional) this.token("?");

  if (node.name) {
    this.token(":");
    this.space();
  }

  this.print(node.typeAnnotation, node);
}

function InterfaceExtends(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);
}

function _interfaceish(node) {
  this.print(node.id, node);
  this.print(node.typeParameters, node);

  if (node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }

  if (node.mixins && node.mixins.length) {
    this.space();
    this.word("mixins");
    this.space();
    this.printList(node.mixins, node);
  }

  if (node.implements && node.implements.length) {
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
  }

  this.space();
  this.print(node.body, node);
}

function _variance(node) {
  if (node.variance) {
    if (node.variance.kind === "plus") {
      this.token("+");
    } else if (node.variance.kind === "minus") {
      this.token("-");
    }
  }
}

function InterfaceDeclaration(node) {
  this.word("interface");
  this.space();

  this._interfaceish(node);
}

function andSeparator() {
  this.space();
  this.token("&");
  this.space();
}

function InterfaceTypeAnnotation(node) {
  this.word("interface");

  if (node.extends && node.extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
  }

  this.space();
  this.print(node.body, node);
}

function IntersectionTypeAnnotation(node) {
  this.printJoin(node.types, node, {
    separator: andSeparator
  });
}

function MixedTypeAnnotation() {
  this.word("mixed");
}

function EmptyTypeAnnotation() {
  this.word("empty");
}

function NullableTypeAnnotation(node) {
  this.token("?");
  this.print(node.typeAnnotation, node);
}

function NumberTypeAnnotation() {
  this.word("number");
}

function StringTypeAnnotation() {
  this.word("string");
}

function ThisTypeAnnotation() {
  this.word("this");
}

function TupleTypeAnnotation(node) {
  this.token("[");
  this.printList(node.types, node);
  this.token("]");
}

function TypeofTypeAnnotation(node) {
  this.word("typeof");
  this.space();
  this.print(node.argument, node);
}

function TypeAlias(node) {
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(node.right, node);
  this.semicolon();
}

function TypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}

function TypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}

function TypeParameter(node) {
  this._variance(node);

  this.word(node.name);

  if (node.bound) {
    this.print(node.bound, node);
  }

  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}

function OpaqueType(node) {
  this.word("opaque");
  this.space();
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);

  if (node.supertype) {
    this.token(":");
    this.space();
    this.print(node.supertype, node);
  }

  if (node.impltype) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.impltype, node);
  }

  this.semicolon();
}

function ObjectTypeAnnotation(node) {
  if (node.exact) {
    this.token("{|");
  } else {
    this.token("{");
  }

  const props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);

  if (props.length) {
    this.space();
    this.printJoin(props, node, {
      addNewlines(leading) {
        if (leading && !props[0]) return 1;
      },

      indent: true,
      statement: true,
      iterator: () => {
        if (props.length !== 1) {
          this.token(",");
          this.space();
        }
      }
    });
    this.space();
  }

  if (node.exact) {
    this.token("|}");
  } else {
    this.token("}");
  }
}

function ObjectTypeInternalSlot(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this.token("[");
  this.token("[");
  this.print(node.id, node);
  this.token("]");
  this.token("]");
  if (node.optional) this.token("?");

  if (!node.method) {
    this.token(":");
    this.space();
  }

  this.print(node.value, node);
}

function ObjectTypeCallProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this.print(node.value, node);
}

function ObjectTypeIndexer(node) {
  if (node.static) {
    this.word("static");
    this.space();
  }

  this._variance(node);

  this.token("[");

  if (node.id) {
    this.print(node.id, node);
    this.token(":");
    this.space();
  }

  this.print(node.key, node);
  this.token("]");
  this.token(":");
  this.space();
  this.print(node.value, node);
}

function ObjectTypeProperty(node) {
  if (node.proto) {
    this.word("proto");
    this.space();
  }

  if (node.static) {
    this.word("static");
    this.space();
  }

  this._variance(node);

  this.print(node.key, node);
  if (node.optional) this.token("?");

  if (!node.method) {
    this.token(":");
    this.space();
  }

  this.print(node.value, node);
}

function ObjectTypeSpreadProperty(node) {
  this.token("...");
  this.print(node.argument, node);
}

function QualifiedTypeIdentifier(node) {
  this.print(node.qualification, node);
  this.token(".");
  this.print(node.id, node);
}

function orSeparator() {
  this.space();
  this.token("|");
  this.space();
}

function UnionTypeAnnotation(node) {
  this.printJoin(node.types, node, {
    separator: orSeparator
  });
}

function TypeCastExpression(node) {
  this.token("(");
  this.print(node.expression, node);
  this.print(node.typeAnnotation, node);
  this.token(")");
}

function Variance(node) {
  if (node.kind === "plus") {
    this.token("+");
  } else {
    this.token("-");
  }
}

function VoidTypeAnnotation() {
  this.word("void");
}

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.File = File;
exports.Program = Program;
exports.BlockStatement = BlockStatement;
exports.Noop = Noop;
exports.Directive = Directive;
exports.DirectiveLiteral = DirectiveLiteral;
exports.InterpreterDirective = InterpreterDirective;

function File(node) {
  if (node.program) {
    this.print(node.program.interpreter, node);
  }

  this.print(node.program, node);
}

function Program(node) {
  this.printInnerComments(node, false);
  this.printSequence(node.directives, node);
  if (node.directives && node.directives.length) this.newline();
  this.printSequence(node.body, node);
}

function BlockStatement(node) {
  this.token("{");
  this.printInnerComments(node);
  const hasDirectives = node.directives && node.directives.length;

  if (node.body.length || hasDirectives) {
    this.newline();
    this.printSequence(node.directives, node, {
      indent: true
    });
    if (hasDirectives) this.newline();
    this.printSequence(node.body, node, {
      indent: true
    });
    this.removeTrailingNewline();
    this.source("end", node.loc);
    if (!this.endsWith("\n")) this.newline();
    this.rightBrace();
  } else {
    this.source("end", node.loc);
    this.token("}");
  }
}

function Noop() {}

function Directive(node) {
  this.print(node.value, node);
  this.semicolon();
}

const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;

function DirectiveLiteral(node) {
  const raw = this.getPossibleRaw(node);

  if (raw != null) {
    this.token(raw);
    return;
  }

  const {
    value
  } = node;

  if (!unescapedDoubleQuoteRE.test(value)) {
    this.token(`"${value}"`);
  } else if (!unescapedSingleQuoteRE.test(value)) {
    this.token(`'${value}'`);
  } else {
    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
  }
}

function InterpreterDirective(node) {
  this.token(`#!${node.value}\n`);
}

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JSXAttribute = JSXAttribute;
exports.JSXIdentifier = JSXIdentifier;
exports.JSXNamespacedName = JSXNamespacedName;
exports.JSXMemberExpression = JSXMemberExpression;
exports.JSXSpreadAttribute = JSXSpreadAttribute;
exports.JSXExpressionContainer = JSXExpressionContainer;
exports.JSXSpreadChild = JSXSpreadChild;
exports.JSXText = JSXText;
exports.JSXElement = JSXElement;
exports.JSXOpeningElement = JSXOpeningElement;
exports.JSXClosingElement = JSXClosingElement;
exports.JSXEmptyExpression = JSXEmptyExpression;
exports.JSXFragment = JSXFragment;
exports.JSXOpeningFragment = JSXOpeningFragment;
exports.JSXClosingFragment = JSXClosingFragment;

function JSXAttribute(node) {
  this.print(node.name, node);

  if (node.value) {
    this.token("=");
    this.print(node.value, node);
  }
}

function JSXIdentifier(node) {
  this.word(node.name);
}

function JSXNamespacedName(node) {
  this.print(node.namespace, node);
  this.token(":");
  this.print(node.name, node);
}

function JSXMemberExpression(node) {
  this.print(node.object, node);
  this.token(".");
  this.print(node.property, node);
}

function JSXSpreadAttribute(node) {
  this.token("{");
  this.token("...");
  this.print(node.argument, node);
  this.token("}");
}

function JSXExpressionContainer(node) {
  this.token("{");
  this.print(node.expression, node);
  this.token("}");
}

function JSXSpreadChild(node) {
  this.token("{");
  this.token("...");
  this.print(node.expression, node);
  this.token("}");
}

function JSXText(node) {
  const raw = this.getPossibleRaw(node);

  if (raw != null) {
    this.token(raw);
  } else {
    this.token(node.value);
  }
}

function JSXElement(node) {
  const open = node.openingElement;
  this.print(open, node);
  if (open.selfClosing) return;
  this.indent();

  for (const child of node.children) {
    this.print(child, node);
  }

  this.dedent();
  this.print(node.closingElement, node);
}

function spaceSeparator() {
  this.space();
}

function JSXOpeningElement(node) {
  this.token("<");
  this.print(node.name, node);
  this.print(node.typeParameters, node);

  if (node.attributes.length > 0) {
    this.space();
    this.printJoin(node.attributes, node, {
      separator: spaceSeparator
    });
  }

  if (node.selfClosing) {
    this.space();
    this.token("/>");
  } else {
    this.token(">");
  }
}

function JSXClosingElement(node) {
  this.token("</");
  this.print(node.name, node);
  this.token(">");
}

function JSXEmptyExpression(node) {
  this.printInnerComments(node);
}

function JSXFragment(node) {
  this.print(node.openingFragment, node);
  this.indent();

  for (const child of node.children) {
    this.print(child, node);
  }

  this.dedent();
  this.print(node.closingFragment, node);
}

function JSXOpeningFragment() {
  this.token("<");
  this.token(">");
}

function JSXClosingFragment() {
  this.token("</");
  this.token(">");
}

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TSTypeAnnotation = TSTypeAnnotation;
exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
exports.TSTypeParameter = TSTypeParameter;
exports.TSParameterProperty = TSParameterProperty;
exports.TSDeclareFunction = TSDeclareFunction;
exports.TSDeclareMethod = TSDeclareMethod;
exports.TSQualifiedName = TSQualifiedName;
exports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
exports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
exports.TSPropertySignature = TSPropertySignature;
exports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
exports.TSMethodSignature = TSMethodSignature;
exports.TSIndexSignature = TSIndexSignature;
exports.TSAnyKeyword = TSAnyKeyword;
exports.TSUnknownKeyword = TSUnknownKeyword;
exports.TSNumberKeyword = TSNumberKeyword;
exports.TSObjectKeyword = TSObjectKeyword;
exports.TSBooleanKeyword = TSBooleanKeyword;
exports.TSStringKeyword = TSStringKeyword;
exports.TSSymbolKeyword = TSSymbolKeyword;
exports.TSVoidKeyword = TSVoidKeyword;
exports.TSUndefinedKeyword = TSUndefinedKeyword;
exports.TSNullKeyword = TSNullKeyword;
exports.TSNeverKeyword = TSNeverKeyword;
exports.TSThisType = TSThisType;
exports.TSFunctionType = TSFunctionType;
exports.TSConstructorType = TSConstructorType;
exports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
exports.TSTypeReference = TSTypeReference;
exports.TSTypePredicate = TSTypePredicate;
exports.TSTypeQuery = TSTypeQuery;
exports.TSTypeLiteral = TSTypeLiteral;
exports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
exports.tsPrintBraced = tsPrintBraced;
exports.TSArrayType = TSArrayType;
exports.TSTupleType = TSTupleType;
exports.TSOptionalType = TSOptionalType;
exports.TSRestType = TSRestType;
exports.TSUnionType = TSUnionType;
exports.TSIntersectionType = TSIntersectionType;
exports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
exports.TSConditionalType = TSConditionalType;
exports.TSInferType = TSInferType;
exports.TSParenthesizedType = TSParenthesizedType;
exports.TSTypeOperator = TSTypeOperator;
exports.TSIndexedAccessType = TSIndexedAccessType;
exports.TSMappedType = TSMappedType;
exports.TSLiteralType = TSLiteralType;
exports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
exports.TSInterfaceDeclaration = TSInterfaceDeclaration;
exports.TSInterfaceBody = TSInterfaceBody;
exports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
exports.TSAsExpression = TSAsExpression;
exports.TSTypeAssertion = TSTypeAssertion;
exports.TSEnumDeclaration = TSEnumDeclaration;
exports.TSEnumMember = TSEnumMember;
exports.TSModuleDeclaration = TSModuleDeclaration;
exports.TSModuleBlock = TSModuleBlock;
exports.TSImportType = TSImportType;
exports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
exports.TSExternalModuleReference = TSExternalModuleReference;
exports.TSNonNullExpression = TSNonNullExpression;
exports.TSExportAssignment = TSExportAssignment;
exports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
exports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;

function TSTypeAnnotation(node) {
  this.token(":");
  this.space();
  if (node.optional) this.token("?");
  this.print(node.typeAnnotation, node);
}

function TSTypeParameterInstantiation(node) {
  this.token("<");
  this.printList(node.params, node, {});
  this.token(">");
}

function TSTypeParameter(node) {
  this.word(node.name);

  if (node.constraint) {
    this.space();
    this.word("extends");
    this.space();
    this.print(node.constraint, node);
  }

  if (node.default) {
    this.space();
    this.token("=");
    this.space();
    this.print(node.default, node);
  }
}

function TSParameterProperty(node) {
  if (node.accessibility) {
    this.word(node.accessibility);
    this.space();
  }

  if (node.readonly) {
    this.word("readonly");
    this.space();
  }

  this._param(node.parameter);
}

function TSDeclareFunction(node) {
  if (node.declare) {
    this.word("declare");
    this.space();
  }

  this._functionHead(node);

  this.token(";");
}

function TSDeclareMethod(node) {
  this._classMethodHead(node);

  this.token(";");
}

function TSQualifiedName(node) {
  this.print(node.left, node);
  this.token(".");
  this.print(node.right, node);
}

function TSCallSignatureDeclaration(node) {
  this.tsPrintSignatureDeclarationBase(node);
}

function TSConstructSignatureDeclaration(node) {
  this.word("new");
  this.space();
  this.tsPrintSignatureDeclarationBase(node);
}

function TSPropertySignature(node) {
  const {
    readonly,
    initializer
  } = node;

  if (readonly) {
    this.word("readonly");
    this.space();
  }

  this.tsPrintPropertyOrMethodName(node);
  this.print(node.typeAnnotation, node);

  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }

  this.token(";");
}

function tsPrintPropertyOrMethodName(node) {
  if (node.computed) {
    this.token("[");
  }

  this.print(node.key, node);

  if (node.computed) {
    this.token("]");
  }

  if (node.optional) {
    this.token("?");
  }
}

function TSMethodSignature(node) {
  this.tsPrintPropertyOrMethodName(node);
  this.tsPrintSignatureDeclarationBase(node);
  this.token(";");
}

function TSIndexSignature(node) {
  const {
    readonly
  } = node;

  if (readonly) {
    this.word("readonly");
    this.space();
  }

  this.token("[");

  this._parameters(node.parameters, node);

  this.token("]");
  this.print(node.typeAnnotation, node);
  this.token(";");
}

function TSAnyKeyword() {
  this.word("any");
}

function TSUnknownKeyword() {
  this.word("unknown");
}

function TSNumberKeyword() {
  this.word("number");
}

function TSObjectKeyword() {
  this.word("object");
}

function TSBooleanKeyword() {
  this.word("boolean");
}

function TSStringKeyword() {
  this.word("string");
}

function TSSymbolKeyword() {
  this.word("symbol");
}

function TSVoidKeyword() {
  this.word("void");
}

function TSUndefinedKeyword() {
  this.word("undefined");
}

function TSNullKeyword() {
  this.word("null");
}

function TSNeverKeyword() {
  this.word("never");
}

function TSThisType() {
  this.word("this");
}

function TSFunctionType(node) {
  this.tsPrintFunctionOrConstructorType(node);
}

function TSConstructorType(node) {
  this.word("new");
  this.space();
  this.tsPrintFunctionOrConstructorType(node);
}

function tsPrintFunctionOrConstructorType(node) {
  const {
    typeParameters,
    parameters
  } = node;
  this.print(typeParameters, node);
  this.token("(");

  this._parameters(parameters, node);

  this.token(")");
  this.space();
  this.token("=>");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation, node);
}

function TSTypeReference(node) {
  this.print(node.typeName, node);
  this.print(node.typeParameters, node);
}

function TSTypePredicate(node) {
  this.print(node.parameterName);
  this.space();
  this.word("is");
  this.space();
  this.print(node.typeAnnotation.typeAnnotation);
}

function TSTypeQuery(node) {
  this.word("typeof");
  this.space();
  this.print(node.exprName);
}

function TSTypeLiteral(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
}

function tsPrintTypeLiteralOrInterfaceBody(members, node) {
  this.tsPrintBraced(members, node);
}

function tsPrintBraced(members, node) {
  this.token("{");

  if (members.length) {
    this.indent();
    this.newline();

    for (const member of members) {
      this.print(member, node);
      this.newline();
    }

    this.dedent();
    this.rightBrace();
  } else {
    this.token("}");
  }
}

function TSArrayType(node) {
  this.print(node.elementType);
  this.token("[]");
}

function TSTupleType(node) {
  this.token("[");
  this.printList(node.elementTypes, node);
  this.token("]");
}

function TSOptionalType(node) {
  this.print(node.typeAnnotation, node);
  this.token("?");
}

function TSRestType(node) {
  this.token("...");
  this.print(node.typeAnnotation, node);
}

function TSUnionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "|");
}

function TSIntersectionType(node) {
  this.tsPrintUnionOrIntersectionType(node, "&");
}

function tsPrintUnionOrIntersectionType(node, sep) {
  this.printJoin(node.types, node, {
    separator() {
      this.space();
      this.token(sep);
      this.space();
    }

  });
}

function TSConditionalType(node) {
  this.print(node.checkType);
  this.space();
  this.word("extends");
  this.space();
  this.print(node.extendsType);
  this.space();
  this.token("?");
  this.space();
  this.print(node.trueType);
  this.space();
  this.token(":");
  this.space();
  this.print(node.falseType);
}

function TSInferType(node) {
  this.token("infer");
  this.space();
  this.print(node.typeParameter);
}

function TSParenthesizedType(node) {
  this.token("(");
  this.print(node.typeAnnotation, node);
  this.token(")");
}

function TSTypeOperator(node) {
  this.token(node.operator);
  this.space();
  this.print(node.typeAnnotation, node);
}

function TSIndexedAccessType(node) {
  this.print(node.objectType, node);
  this.token("[");
  this.print(node.indexType, node);
  this.token("]");
}

function TSMappedType(node) {
  const {
    readonly,
    typeParameter,
    optional
  } = node;
  this.token("{");
  this.space();

  if (readonly) {
    tokenIfPlusMinus(this, readonly);
    this.word("readonly");
    this.space();
  }

  this.token("[");
  this.word(typeParameter.name);
  this.space();
  this.word("in");
  this.space();
  this.print(typeParameter.constraint, typeParameter);
  this.token("]");

  if (optional) {
    tokenIfPlusMinus(this, optional);
    this.token("?");
  }

  this.token(":");
  this.space();
  this.print(node.typeAnnotation, node);
  this.space();
  this.token("}");
}

function tokenIfPlusMinus(self, tok) {
  if (tok !== true) {
    self.token(tok);
  }
}

function TSLiteralType(node) {
  this.print(node.literal, node);
}

function TSExpressionWithTypeArguments(node) {
  this.print(node.expression, node);
  this.print(node.typeParameters, node);
}

function TSInterfaceDeclaration(node) {
  const {
    declare,
    id,
    typeParameters,
    extends: extendz,
    body
  } = node;

  if (declare) {
    this.word("declare");
    this.space();
  }

  this.word("interface");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);

  if (extendz) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(extendz, node);
  }

  this.space();
  this.print(body, node);
}

function TSInterfaceBody(node) {
  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
}

function TSTypeAliasDeclaration(node) {
  const {
    declare,
    id,
    typeParameters,
    typeAnnotation
  } = node;

  if (declare) {
    this.word("declare");
    this.space();
  }

  this.word("type");
  this.space();
  this.print(id, node);
  this.print(typeParameters, node);
  this.space();
  this.token("=");
  this.space();
  this.print(typeAnnotation, node);
  this.token(";");
}

function TSAsExpression(node) {
  const {
    expression,
    typeAnnotation
  } = node;
  this.print(expression, node);
  this.space();
  this.word("as");
  this.space();
  this.print(typeAnnotation, node);
}

function TSTypeAssertion(node) {
  const {
    typeAnnotation,
    expression
  } = node;
  this.token("<");
  this.print(typeAnnotation, node);
  this.token(">");
  this.space();
  this.print(expression, node);
}

function TSEnumDeclaration(node) {
  const {
    declare,
    const: isConst,
    id,
    members
  } = node;

  if (declare) {
    this.word("declare");
    this.space();
  }

  if (isConst) {
    this.word("const");
    this.space();
  }

  this.word("enum");
  this.space();
  this.print(id, node);
  this.space();
  this.tsPrintBraced(members, node);
}

function TSEnumMember(node) {
  const {
    id,
    initializer
  } = node;
  this.print(id, node);

  if (initializer) {
    this.space();
    this.token("=");
    this.space();
    this.print(initializer, node);
  }

  this.token(",");
}

function TSModuleDeclaration(node) {
  const {
    declare,
    id
  } = node;

  if (declare) {
    this.word("declare");
    this.space();
  }

  if (!node.global) {
    this.word(id.type === "Identifier" ? "namespace" : "module");
    this.space();
  }

  this.print(id, node);

  if (!node.body) {
    this.token(";");
    return;
  }

  let body = node.body;

  while (body.type === "TSModuleDeclaration") {
    this.token(".");
    this.print(body.id, body);
    body = body.body;
  }

  this.space();
  this.print(body, node);
}

function TSModuleBlock(node) {
  this.tsPrintBraced(node.body, node);
}

function TSImportType(node) {
  const {
    argument,
    qualifier,
    typeParameters
  } = node;
  this.word("import");
  this.token("(");
  this.print(argument, node);
  this.token(")");

  if (qualifier) {
    this.token(".");
    this.print(qualifier, node);
  }

  if (typeParameters) {
    this.print(typeParameters, node);
  }
}

function TSImportEqualsDeclaration(node) {
  const {
    isExport,
    id,
    moduleReference
  } = node;

  if (isExport) {
    this.word("export");
    this.space();
  }

  this.word("import");
  this.space();
  this.print(id, node);
  this.space();
  this.token("=");
  this.space();
  this.print(moduleReference, node);
  this.token(";");
}

function TSExternalModuleReference(node) {
  this.token("require(");
  this.print(node.expression, node);
  this.token(")");
}

function TSNonNullExpression(node) {
  this.print(node.expression, node);
  this.token("!");
}

function TSExportAssignment(node) {
  this.word("export");
  this.space();
  this.token("=");
  this.space();
  this.print(node.expression, node);
  this.token(";");
}

function TSNamespaceExportDeclaration(node) {
  this.word("export");
  this.space();
  this.word("as");
  this.space();
  this.word("namespace");
  this.space();
  this.print(node.id, node);
}

function tsPrintSignatureDeclarationBase(node) {
  const {
    typeParameters,
    parameters
  } = node;
  this.print(typeParameters, node);
  this.token("(");

  this._parameters(parameters, node);

  this.token(")");
  this.print(node.typeAnnotation, node);
}

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findParent = findParent;
exports.find = find;
exports.getFunctionParent = getFunctionParent;
exports.getStatementParent = getStatementParent;
exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
exports.getAncestry = getAncestry;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
exports.inType = inType;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var _index = _interopRequireDefault(__webpack_require__(295));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function findParent(callback) {
  let path = this;

  while (path = path.parentPath) {
    if (callback(path)) return path;
  }

  return null;
}

function find(callback) {
  let path = this;

  do {
    if (callback(path)) return path;
  } while (path = path.parentPath);

  return null;
}

function getFunctionParent() {
  return this.findParent(p => p.isFunction());
}

function getStatementParent() {
  let path = this;

  do {
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
      break;
    } else {
      path = path.parentPath;
    }
  } while (path);

  if (path && (path.isProgram() || path.isFile())) {
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  }

  return path;
}

function getEarliestCommonAncestorFrom(paths) {
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
    let earliest;
    const keys = t().VISITOR_KEYS[deepest.type];

    for (const ancestry of ancestries) {
      const path = ancestry[i + 1];

      if (!earliest) {
        earliest = path;
        continue;
      }

      if (path.listKey && earliest.listKey === path.listKey) {
        if (path.key < earliest.key) {
          earliest = path;
          continue;
        }
      }

      const earliestKeyIndex = keys.indexOf(earliest.parentKey);
      const currentKeyIndex = keys.indexOf(path.parentKey);

      if (earliestKeyIndex > currentKeyIndex) {
        earliest = path;
      }
    }

    return earliest;
  });
}

function getDeepestCommonAncestorFrom(paths, filter) {
  if (!paths.length) {
    return this;
  }

  if (paths.length === 1) {
    return paths[0];
  }

  let minDepth = Infinity;
  let lastCommonIndex, lastCommon;
  const ancestries = paths.map(path => {
    const ancestry = [];

    do {
      ancestry.unshift(path);
    } while ((path = path.parentPath) && path !== this);

    if (ancestry.length < minDepth) {
      minDepth = ancestry.length;
    }

    return ancestry;
  });
  const first = ancestries[0];

  depthLoop: for (let i = 0; i < minDepth; i++) {
    const shouldMatch = first[i];

    for (const ancestry of ancestries) {
      if (ancestry[i] !== shouldMatch) {
        break depthLoop;
      }
    }

    lastCommonIndex = i;
    lastCommon = shouldMatch;
  }

  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries);
    } else {
      return lastCommon;
    }
  } else {
    throw new Error("Couldn't find intersection");
  }
}

function getAncestry() {
  let path = this;
  const paths = [];

  do {
    paths.push(path);
  } while (path = path.parentPath);

  return paths;
}

function isAncestor(maybeDescendant) {
  return maybeDescendant.isDescendant(this);
}

function isDescendant(maybeAncestor) {
  return !!this.findParent(parent => parent === maybeAncestor);
}

function inType() {
  let path = this;

  while (path) {
    for (const type of arguments) {
      if (path.node.type === type) return true;
    }

    path = path.parentPath;
  }

  return false;
}

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeAnnotation = getTypeAnnotation;
exports._getTypeAnnotation = _getTypeAnnotation;
exports.isBaseType = isBaseType;
exports.couldBeBaseType = couldBeBaseType;
exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
exports.isGenericType = isGenericType;

var inferers = _interopRequireWildcard(__webpack_require__(359));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function getTypeAnnotation() {
  if (this.typeAnnotation) return this.typeAnnotation;
  let type = this._getTypeAnnotation() || t().anyTypeAnnotation();
  if (t().isTypeAnnotation(type)) type = type.typeAnnotation;
  return this.typeAnnotation = type;
}

function _getTypeAnnotation() {
  const node = this.node;

  if (!node) {
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      const declar = this.parentPath.parentPath;
      const declarParent = declar.parentPath;

      if (declar.key === "left" && declarParent.isForInStatement()) {
        return t().stringTypeAnnotation();
      }

      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return t().anyTypeAnnotation();
      }

      return t().voidTypeAnnotation();
    } else {
      return;
    }
  }

  if (node.typeAnnotation) {
    return node.typeAnnotation;
  }

  let inferer = inferers[node.type];

  if (inferer) {
    return inferer.call(this, node);
  }

  inferer = inferers[this.parentPath.type];

  if (inferer && inferer.validParent) {
    return this.parentPath.getTypeAnnotation();
  }
}

function isBaseType(baseName, soft) {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}

function _isBaseType(baseName, type, soft) {
  if (baseName === "string") {
    return t().isStringTypeAnnotation(type);
  } else if (baseName === "number") {
    return t().isNumberTypeAnnotation(type);
  } else if (baseName === "boolean") {
    return t().isBooleanTypeAnnotation(type);
  } else if (baseName === "any") {
    return t().isAnyTypeAnnotation(type);
  } else if (baseName === "mixed") {
    return t().isMixedTypeAnnotation(type);
  } else if (baseName === "empty") {
    return t().isEmptyTypeAnnotation(type);
  } else if (baseName === "void") {
    return t().isVoidTypeAnnotation(type);
  } else {
    if (soft) {
      return false;
    } else {
      throw new Error(`Unknown base type ${baseName}`);
    }
  }
}

function couldBeBaseType(name) {
  const type = this.getTypeAnnotation();
  if (t().isAnyTypeAnnotation(type)) return true;

  if (t().isUnionTypeAnnotation(type)) {
    for (const type2 of type.types) {
      if (t().isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
        return true;
      }
    }

    return false;
  } else {
    return _isBaseType(name, type, true);
  }
}

function baseTypeStrictlyMatches(right) {
  const left = this.getTypeAnnotation();
  right = right.getTypeAnnotation();

  if (!t().isAnyTypeAnnotation(left) && t().isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  }
}

function isGenericType(genericName) {
  const type = this.getTypeAnnotation();
  return t().isGenericTypeAnnotation(type) && t().isIdentifier(type.id, {
    name: genericName
  });
}

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariableDeclarator = VariableDeclarator;
exports.TypeCastExpression = TypeCastExpression;
exports.NewExpression = NewExpression;
exports.TemplateLiteral = TemplateLiteral;
exports.UnaryExpression = UnaryExpression;
exports.BinaryExpression = BinaryExpression;
exports.LogicalExpression = LogicalExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.SequenceExpression = SequenceExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.UpdateExpression = UpdateExpression;
exports.StringLiteral = StringLiteral;
exports.NumericLiteral = NumericLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.NullLiteral = NullLiteral;
exports.RegExpLiteral = RegExpLiteral;
exports.ObjectExpression = ObjectExpression;
exports.ArrayExpression = ArrayExpression;
exports.RestElement = RestElement;
exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
exports.CallExpression = CallExpression;
exports.TaggedTemplateExpression = TaggedTemplateExpression;
Object.defineProperty(exports, "Identifier", {
  enumerable: true,
  get: function () {
    return _infererReference.default;
  }
});

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

var _infererReference = _interopRequireDefault(__webpack_require__(360));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function VariableDeclarator() {
  const id = this.get("id");
  if (!id.isIdentifier()) return;
  const init = this.get("init");
  let type = init.getTypeAnnotation();

  if (type && type.type === "AnyTypeAnnotation") {
    if (init.isCallExpression() && init.get("callee").isIdentifier({
      name: "Array"
    }) && !init.scope.hasBinding("Array", true)) {
      type = ArrayExpression();
    }
  }

  return type;
}

function TypeCastExpression(node) {
  return node.typeAnnotation;
}

TypeCastExpression.validParent = true;

function NewExpression(node) {
  if (this.get("callee").isIdentifier()) {
    return t().genericTypeAnnotation(node.callee);
  }
}

function TemplateLiteral() {
  return t().stringTypeAnnotation();
}

function UnaryExpression(node) {
  const operator = node.operator;

  if (operator === "void") {
    return t().voidTypeAnnotation();
  } else if (t().NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t().numberTypeAnnotation();
  } else if (t().STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t().stringTypeAnnotation();
  } else if (t().BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
    return t().booleanTypeAnnotation();
  }
}

function BinaryExpression(node) {
  const operator = node.operator;

  if (t().NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t().numberTypeAnnotation();
  } else if (t().BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
    return t().booleanTypeAnnotation();
  } else if (operator === "+") {
    const right = this.get("right");
    const left = this.get("left");

    if (left.isBaseType("number") && right.isBaseType("number")) {
      return t().numberTypeAnnotation();
    } else if (left.isBaseType("string") || right.isBaseType("string")) {
      return t().stringTypeAnnotation();
    }

    return t().unionTypeAnnotation([t().stringTypeAnnotation(), t().numberTypeAnnotation()]);
  }
}

function LogicalExpression() {
  return t().createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
}

function ConditionalExpression() {
  return t().createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
}

function SequenceExpression() {
  return this.get("expressions").pop().getTypeAnnotation();
}

function AssignmentExpression() {
  return this.get("right").getTypeAnnotation();
}

function UpdateExpression(node) {
  const operator = node.operator;

  if (operator === "++" || operator === "--") {
    return t().numberTypeAnnotation();
  }
}

function StringLiteral() {
  return t().stringTypeAnnotation();
}

function NumericLiteral() {
  return t().numberTypeAnnotation();
}

function BooleanLiteral() {
  return t().booleanTypeAnnotation();
}

function NullLiteral() {
  return t().nullLiteralTypeAnnotation();
}

function RegExpLiteral() {
  return t().genericTypeAnnotation(t().identifier("RegExp"));
}

function ObjectExpression() {
  return t().genericTypeAnnotation(t().identifier("Object"));
}

function ArrayExpression() {
  return t().genericTypeAnnotation(t().identifier("Array"));
}

function RestElement() {
  return ArrayExpression();
}

RestElement.validParent = true;

function Func() {
  return t().genericTypeAnnotation(t().identifier("Function"));
}

const isArrayFrom = t().buildMatchMemberExpression("Array.from");
const isObjectKeys = t().buildMatchMemberExpression("Object.keys");
const isObjectValues = t().buildMatchMemberExpression("Object.values");
const isObjectEntries = t().buildMatchMemberExpression("Object.entries");

function CallExpression() {
  const {
    callee
  } = this.node;

  if (isObjectKeys(callee)) {
    return t().arrayTypeAnnotation(t().stringTypeAnnotation());
  } else if (isArrayFrom(callee) || isObjectValues(callee)) {
    return t().arrayTypeAnnotation(t().anyTypeAnnotation());
  } else if (isObjectEntries(callee)) {
    return t().arrayTypeAnnotation(t().tupleTypeAnnotation([t().stringTypeAnnotation(), t().anyTypeAnnotation()]));
  }

  return resolveCall(this.get("callee"));
}

function TaggedTemplateExpression() {
  return resolveCall(this.get("tag"));
}

function resolveCall(callee) {
  callee = callee.resolve();

  if (callee.isFunction()) {
    if (callee.is("async")) {
      if (callee.is("generator")) {
        return t().genericTypeAnnotation(t().identifier("AsyncIterator"));
      } else {
        return t().genericTypeAnnotation(t().identifier("Promise"));
      }
    } else {
      if (callee.node.returnType) {
        return callee.node.returnType;
      } else {}
    }
  }
}

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _default(node) {
  if (!this.isReferenced()) return;
  const binding = this.scope.getBinding(node.name);

  if (binding) {
    if (binding.identifier.typeAnnotation) {
      return binding.identifier.typeAnnotation;
    } else {
      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
    }
  }

  if (node.name === "undefined") {
    return t().voidTypeAnnotation();
  } else if (node.name === "NaN" || node.name === "Infinity") {
    return t().numberTypeAnnotation();
  } else if (node.name === "arguments") {}
}

function getTypeAnnotationBindingConstantViolations(binding, path, name) {
  const types = [];
  const functionConstantViolations = [];
  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
  const testType = getConditionalAnnotation(binding, path, name);

  if (testType) {
    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);
    types.push(testType.typeAnnotation);
  }

  if (constantViolations.length) {
    constantViolations = constantViolations.concat(functionConstantViolations);

    for (const violation of constantViolations) {
      types.push(violation.getTypeAnnotation());
    }
  }

  if (types.length) {
    return t().createUnionTypeAnnotation(types);
  }
}

function getConstantViolationsBefore(binding, path, functions) {
  const violations = binding.constantViolations.slice();
  violations.unshift(binding.path);
  return violations.filter(violation => {
    violation = violation.resolve();

    const status = violation._guessExecutionStatusRelativeTo(path);

    if (functions && status === "function") functions.push(violation);
    return status === "before";
  });
}

function inferAnnotationFromBinaryExpression(name, path) {
  const operator = path.node.operator;
  const right = path.get("right").resolve();
  const left = path.get("left").resolve();
  let target;

  if (left.isIdentifier({
    name
  })) {
    target = right;
  } else if (right.isIdentifier({
    name
  })) {
    target = left;
  }

  if (target) {
    if (operator === "===") {
      return target.getTypeAnnotation();
    }

    if (t().BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return t().numberTypeAnnotation();
    }

    return;
  }

  if (operator !== "===" && operator !== "==") return;
  let typeofPath;
  let typePath;

  if (left.isUnaryExpression({
    operator: "typeof"
  })) {
    typeofPath = left;
    typePath = right;
  } else if (right.isUnaryExpression({
    operator: "typeof"
  })) {
    typeofPath = right;
    typePath = left;
  }

  if (!typeofPath) return;
  if (!typeofPath.get("argument").isIdentifier({
    name
  })) return;
  typePath = typePath.resolve();
  if (!typePath.isLiteral()) return;
  const typeValue = typePath.node.value;
  if (typeof typeValue !== "string") return;
  return t().createTypeAnnotationBasedOnTypeof(typeValue);
}

function getParentConditionalPath(binding, path, name) {
  let parentPath;

  while (parentPath = path.parentPath) {
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
      if (path.key === "test") {
        return;
      }

      return parentPath;
    }

    if (parentPath.isFunction()) {
      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
    }

    path = parentPath;
  }
}

function getConditionalAnnotation(binding, path, name) {
  const ifStatement = getParentConditionalPath(binding, path, name);
  if (!ifStatement) return;
  const test = ifStatement.get("test");
  const paths = [test];
  const types = [];

  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];

    if (path.isLogicalExpression()) {
      if (path.node.operator === "&&") {
        paths.push(path.get("left"));
        paths.push(path.get("right"));
      }
    } else if (path.isBinaryExpression()) {
      const type = inferAnnotationFromBinaryExpression(name, path);
      if (type) types.push(type);
    }
  }

  if (types.length) {
    return {
      typeAnnotation: t().createUnionTypeAnnotation(types),
      ifStatement
    };
  }

  return getConditionalAnnotation(ifStatement, name);
}

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceWithMultiple = replaceWithMultiple;
exports.replaceWithSourceString = replaceWithSourceString;
exports.replaceWith = replaceWith;
exports._replaceWith = _replaceWith;
exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
exports.replaceInline = replaceInline;

function _codeFrame() {
  const data = __webpack_require__(248);

  _codeFrame = function () {
    return data;
  };

  return data;
}

var _index = _interopRequireDefault(__webpack_require__(293));

var _index2 = _interopRequireDefault(__webpack_require__(295));

function _parser() {
  const data = __webpack_require__(247);

  _parser = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const hoistVariablesVisitor = {
  Function(path) {
    path.skip();
  },

  VariableDeclaration(path) {
    if (path.node.kind !== "var") return;
    const bindings = path.getBindingIdentifiers();

    for (const key in bindings) {
      path.scope.push({
        id: bindings[key]
      });
    }

    const exprs = [];

    for (const declar of path.node.declarations) {
      if (declar.init) {
        exprs.push(t().expressionStatement(t().assignmentExpression("=", declar.id, declar.init)));
      }
    }

    path.replaceWithMultiple(exprs);
  }

};

function replaceWithMultiple(nodes) {
  this.resync();
  nodes = this._verifyNodeList(nodes);
  t().inheritLeadingComments(nodes[0], this.node);
  t().inheritTrailingComments(nodes[nodes.length - 1], this.node);
  this.node = this.container[this.key] = null;
  const paths = this.insertAfter(nodes);

  if (this.node) {
    this.requeue();
  } else {
    this.remove();
  }

  return paths;
}

function replaceWithSourceString(replacement) {
  this.resync();

  try {
    replacement = `(${replacement})`;
    replacement = (0, _parser().parse)(replacement);
  } catch (err) {
    const loc = err.loc;

    if (loc) {
      err.message += " - make sure this is an expression.\n" + (0, _codeFrame().codeFrameColumns)(replacement, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      });
      err.code = "BABEL_REPLACE_SOURCE_ERROR";
    }

    throw err;
  }

  replacement = replacement.program.body[0].expression;

  _index.default.removeProperties(replacement);

  return this.replaceWith(replacement);
}

function replaceWith(replacement) {
  this.resync();

  if (this.removed) {
    throw new Error("You can't replace this node, we've already removed it");
  }

  if (replacement instanceof _index2.default) {
    replacement = replacement.node;
  }

  if (!replacement) {
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
  }

  if (this.node === replacement) {
    return [this];
  }

  if (this.isProgram() && !t().isProgram(replacement)) {
    throw new Error("You can only replace a Program root node with another Program node");
  }

  if (Array.isArray(replacement)) {
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
  }

  if (typeof replacement === "string") {
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
  }

  let nodePath = "";

  if (this.isNodeType("Statement") && t().isExpression(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
      replacement = t().expressionStatement(replacement);
      nodePath = "expression";
    }
  }

  if (this.isNodeType("Expression") && t().isStatement(replacement)) {
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
      return this.replaceExpressionWithStatements([replacement]);
    }
  }

  const oldNode = this.node;

  if (oldNode) {
    t().inheritsComments(replacement, oldNode);
    t().removeComments(oldNode);
  }

  this._replaceWith(replacement);

  this.type = replacement.type;
  this.setScope();
  this.requeue();
  return [nodePath ? this.get(nodePath) : this];
}

function _replaceWith(node) {
  if (!this.container) {
    throw new ReferenceError("Container is falsy");
  }

  if (this.inList) {
    t().validate(this.parent, this.key, [node]);
  } else {
    t().validate(this.parent, this.key, node);
  }

  this.debug(`Replace with ${node && node.type}`);
  this.node = this.container[this.key] = node;
}

function replaceExpressionWithStatements(nodes) {
  this.resync();
  const toSequenceExpression = t().toSequenceExpression(nodes, this.scope);

  if (toSequenceExpression) {
    return this.replaceWith(toSequenceExpression)[0].get("expressions");
  }

  const container = t().arrowFunctionExpression([], t().blockStatement(nodes));
  this.replaceWith(t().callExpression(container, []));
  this.traverse(hoistVariablesVisitor);
  const completionRecords = this.get("callee").getCompletionRecords();

  for (const path of completionRecords) {
    if (!path.isExpressionStatement()) continue;
    const loop = path.findParent(path => path.isLoop());

    if (loop) {
      let uid = loop.getData("expressionReplacementReturnUid");

      if (!uid) {
        const callee = this.get("callee");
        uid = callee.scope.generateDeclaredUidIdentifier("ret");
        callee.get("body").pushContainer("body", t().returnStatement(t().cloneNode(uid)));
        loop.setData("expressionReplacementReturnUid", uid);
      } else {
        uid = t().identifier(uid.name);
      }

      path.get("expression").replaceWith(t().assignmentExpression("=", t().cloneNode(uid), path.node.expression));
    } else {
      path.replaceWith(t().returnStatement(path.node.expression));
    }
  }

  const callee = this.get("callee");
  callee.arrowFunctionToExpression();
  return callee.get("body.body");
}

function replaceInline(nodes) {
  this.resync();

  if (Array.isArray(nodes)) {
    if (Array.isArray(this.container)) {
      nodes = this._verifyNodeList(nodes);

      const paths = this._containerInsertAfter(nodes);

      this.remove();
      return paths;
    } else {
      return this.replaceWithMultiple(nodes);
    }
  } else {
    return this.replaceWith(nodes);
  }
}

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.evaluateTruthy = evaluateTruthy;
exports.evaluate = evaluate;
const VALID_CALLEES = ["String", "Number", "Math"];
const INVALID_METHODS = ["random"];

function evaluateTruthy() {
  const res = this.evaluate();
  if (res.confident) return !!res.value;
}

function deopt(path, state) {
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}

function evaluateCached(path, state) {
  const {
    node
  } = path;
  const {
    seen
  } = state;

  if (seen.has(node)) {
    const existing = seen.get(node);

    if (existing.resolved) {
      return existing.value;
    } else {
      deopt(path, state);
      return;
    }
  } else {
    const item = {
      resolved: false
    };
    seen.set(node, item);

    const val = _evaluate(path, state);

    if (state.confident) {
      item.resolved = true;
      item.value = val;
    }

    return val;
  }
}

function _evaluate(path, state) {
  if (!state.confident) return;
  const {
    node
  } = path;

  if (path.isSequenceExpression()) {
    const exprs = path.get("expressions");
    return evaluateCached(exprs[exprs.length - 1], state);
  }

  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
    return node.value;
  }

  if (path.isNullLiteral()) {
    return null;
  }

  if (path.isTemplateLiteral()) {
    return evaluateQuasis(path, node.quasis, state);
  }

  if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
    const object = path.get("tag.object");
    const {
      node: {
        name
      }
    } = object;
    const property = path.get("tag.property");

    if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === "raw") {
      return evaluateQuasis(path, node.quasi.quasis, state, true);
    }
  }

  if (path.isConditionalExpression()) {
    const testResult = evaluateCached(path.get("test"), state);
    if (!state.confident) return;

    if (testResult) {
      return evaluateCached(path.get("consequent"), state);
    } else {
      return evaluateCached(path.get("alternate"), state);
    }
  }

  if (path.isExpressionWrapper()) {
    return evaluateCached(path.get("expression"), state);
  }

  if (path.isMemberExpression() && !path.parentPath.isCallExpression({
    callee: node
  })) {
    const property = path.get("property");
    const object = path.get("object");

    if (object.isLiteral() && property.isIdentifier()) {
      const value = object.node.value;
      const type = typeof value;

      if (type === "number" || type === "string") {
        return value[property.node.name];
      }
    }
  }

  if (path.isReferencedIdentifier()) {
    const binding = path.scope.getBinding(node.name);

    if (binding && binding.constantViolations.length > 0) {
      return deopt(binding.path, state);
    }

    if (binding && path.node.start < binding.path.node.end) {
      return deopt(binding.path, state);
    }

    if (binding && binding.hasValue) {
      return binding.value;
    } else {
      if (node.name === "undefined") {
        return binding ? deopt(binding.path, state) : undefined;
      } else if (node.name === "Infinity") {
        return binding ? deopt(binding.path, state) : Infinity;
      } else if (node.name === "NaN") {
        return binding ? deopt(binding.path, state) : NaN;
      }

      const resolved = path.resolve();

      if (resolved === path) {
        return deopt(path, state);
      } else {
        return evaluateCached(resolved, state);
      }
    }
  }

  if (path.isUnaryExpression({
    prefix: true
  })) {
    if (node.operator === "void") {
      return undefined;
    }

    const argument = path.get("argument");

    if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
      return "function";
    }

    const arg = evaluateCached(argument, state);
    if (!state.confident) return;

    switch (node.operator) {
      case "!":
        return !arg;

      case "+":
        return +arg;

      case "-":
        return -arg;

      case "~":
        return ~arg;

      case "typeof":
        return typeof arg;
    }
  }

  if (path.isArrayExpression()) {
    const arr = [];
    const elems = path.get("elements");

    for (const elem of elems) {
      const elemValue = elem.evaluate();

      if (elemValue.confident) {
        arr.push(elemValue.value);
      } else {
        return deopt(elem, state);
      }
    }

    return arr;
  }

  if (path.isObjectExpression()) {
    const obj = {};
    const props = path.get("properties");

    for (const prop of props) {
      if (prop.isObjectMethod() || prop.isSpreadElement()) {
        return deopt(prop, state);
      }

      const keyPath = prop.get("key");
      let key = keyPath;

      if (prop.node.computed) {
        key = key.evaluate();

        if (!key.confident) {
          return deopt(keyPath, state);
        }

        key = key.value;
      } else if (key.isIdentifier()) {
        key = key.node.name;
      } else {
        key = key.node.value;
      }

      const valuePath = prop.get("value");
      let value = valuePath.evaluate();

      if (!value.confident) {
        return deopt(valuePath, state);
      }

      value = value.value;
      obj[key] = value;
    }

    return obj;
  }

  if (path.isLogicalExpression()) {
    const wasConfident = state.confident;
    const left = evaluateCached(path.get("left"), state);
    const leftConfident = state.confident;
    state.confident = wasConfident;
    const right = evaluateCached(path.get("right"), state);
    const rightConfident = state.confident;

    switch (node.operator) {
      case "||":
        state.confident = leftConfident && (!!left || rightConfident);
        if (!state.confident) return;
        return left || right;

      case "&&":
        state.confident = leftConfident && (!left || rightConfident);
        if (!state.confident) return;
        return left && right;
    }
  }

  if (path.isBinaryExpression()) {
    const left = evaluateCached(path.get("left"), state);
    if (!state.confident) return;
    const right = evaluateCached(path.get("right"), state);
    if (!state.confident) return;

    switch (node.operator) {
      case "-":
        return left - right;

      case "+":
        return left + right;

      case "/":
        return left / right;

      case "*":
        return left * right;

      case "%":
        return left % right;

      case "**":
        return Math.pow(left, right);

      case "<":
        return left < right;

      case ">":
        return left > right;

      case "<=":
        return left <= right;

      case ">=":
        return left >= right;

      case "==":
        return left == right;

      case "!=":
        return left != right;

      case "===":
        return left === right;

      case "!==":
        return left !== right;

      case "|":
        return left | right;

      case "&":
        return left & right;

      case "^":
        return left ^ right;

      case "<<":
        return left << right;

      case ">>":
        return left >> right;

      case ">>>":
        return left >>> right;
    }
  }

  if (path.isCallExpression()) {
    const callee = path.get("callee");
    let context;
    let func;

    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
      func = global[node.callee.name];
    }

    if (callee.isMemberExpression()) {
      const object = callee.get("object");
      const property = callee.get("property");

      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {
        context = global[object.node.name];
        func = context[property.node.name];
      }

      if (object.isLiteral() && property.isIdentifier()) {
        const type = typeof object.node.value;

        if (type === "string" || type === "number") {
          context = object.node.value;
          func = context[property.node.name];
        }
      }
    }

    if (func) {
      const args = path.get("arguments").map(arg => evaluateCached(arg, state));
      if (!state.confident) return;
      return func.apply(context, args);
    }
  }

  deopt(path, state);
}

function evaluateQuasis(path, quasis, state, raw = false) {
  let str = "";
  let i = 0;
  const exprs = path.get("expressions");

  for (const elem of quasis) {
    if (!state.confident) break;
    str += raw ? elem.value.raw : elem.value.cooked;
    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
  }

  if (!state.confident) return;
  return str;
}

function evaluate() {
  const state = {
    confident: true,
    deoptPath: null,
    seen: new Map()
  };
  let value = evaluateCached(this, state);
  if (!state.confident) value = undefined;
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value: value
  };
}

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toComputedKey = toComputedKey;
exports.ensureBlock = ensureBlock;
exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
exports.arrowFunctionToExpression = arrowFunctionToExpression;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _helperFunctionName() {
  const data = _interopRequireDefault(__webpack_require__(364));

  _helperFunctionName = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function toComputedKey() {
  const node = this.node;
  let key;

  if (this.isMemberExpression()) {
    key = node.property;
  } else if (this.isProperty() || this.isMethod()) {
    key = node.key;
  } else {
    throw new ReferenceError("todo");
  }

  if (!node.computed) {
    if (t().isIdentifier(key)) key = t().stringLiteral(key.name);
  }

  return key;
}

function ensureBlock() {
  const body = this.get("body");
  const bodyNode = body.node;

  if (Array.isArray(body)) {
    throw new Error("Can't convert array path to a block statement");
  }

  if (!bodyNode) {
    throw new Error("Can't convert node without a body");
  }

  if (body.isBlockStatement()) {
    return bodyNode;
  }

  const statements = [];
  let stringPath = "body";
  let key;
  let listKey;

  if (body.isStatement()) {
    listKey = "body";
    key = 0;
    statements.push(body.node);
  } else {
    stringPath += ".body.0";

    if (this.isFunction()) {
      key = "argument";
      statements.push(t().returnStatement(body.node));
    } else {
      key = "expression";
      statements.push(t().expressionStatement(body.node));
    }
  }

  this.node.body = t().blockStatement(statements);
  const parentPath = this.get(stringPath);
  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
  return this.node;
}

function arrowFunctionToShadowed() {
  if (!this.isArrowFunctionExpression()) return;
  this.arrowFunctionToExpression();
}

function unwrapFunctionEnvironment() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
  }

  hoistFunctionEnvironment(this);
}

function arrowFunctionToExpression({
  allowInsertArrow = true,
  specCompliant = false
} = {}) {
  if (!this.isArrowFunctionExpression()) {
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
  }

  const thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);
  this.ensureBlock();
  this.node.type = "FunctionExpression";

  if (specCompliant) {
    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

    if (checkBinding) {
      this.parentPath.scope.push({
        id: checkBinding,
        init: t().objectExpression([])
      });
    }

    this.get("body").unshiftContainer("body", t().expressionStatement(t().callExpression(this.hub.addHelper("newArrowCheck"), [t().thisExpression(), checkBinding ? t().identifier(checkBinding.name) : t().identifier(thisBinding)])));
    this.replaceWith(t().callExpression(t().memberExpression((0, _helperFunctionName().default)(this, true) || this.node, t().identifier("bind")), [checkBinding ? t().identifier(checkBinding.name) : t().thisExpression()]));
  }
}

function hoistFunctionEnvironment(fnPath, specCompliant = false, allowInsertArrow = true) {
  const thisEnvFn = fnPath.findParent(p => {
    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
      static: false
    });
  });
  const inConstructor = thisEnvFn && thisEnvFn.node.kind === "constructor";

  if (thisEnvFn.isClassProperty()) {
    throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
  }

  const {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  } = getScopeInformation(fnPath);

  if (inConstructor && superCalls.length > 0) {
    if (!allowInsertArrow) {
      throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
    }

    const allSuperCalls = [];
    thisEnvFn.traverse({
      Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },

      ClassProperty(child) {
        if (child.node.static) return;
        child.skip();
      },

      CallExpression(child) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      }

    });
    const superBinding = getSuperBinding(thisEnvFn);
    allSuperCalls.forEach(superCall => {
      const callee = t().identifier(superBinding);
      callee.loc = superCall.node.callee.loc;
      superCall.get("callee").replaceWith(callee);
    });
  }

  let thisBinding;

  if (thisPaths.length > 0 || specCompliant) {
    thisBinding = getThisBinding(thisEnvFn, inConstructor);

    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {
      thisPaths.forEach(thisChild => {
        const thisRef = thisChild.isJSX() ? t().jsxIdentifier(thisBinding) : t().identifier(thisBinding);
        thisRef.loc = thisChild.node.loc;
        thisChild.replaceWith(thisRef);
      });
      if (specCompliant) thisBinding = null;
    }
  }

  if (argumentsPaths.length > 0) {
    const argumentsBinding = getBinding(thisEnvFn, "arguments", () => t().identifier("arguments"));
    argumentsPaths.forEach(argumentsChild => {
      const argsRef = t().identifier(argumentsBinding);
      argsRef.loc = argumentsChild.node.loc;
      argumentsChild.replaceWith(argsRef);
    });
  }

  if (newTargetPaths.length > 0) {
    const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => t().metaProperty(t().identifier("new"), t().identifier("target")));
    newTargetPaths.forEach(targetChild => {
      const targetRef = t().identifier(newTargetBinding);
      targetRef.loc = targetChild.node.loc;
      targetChild.replaceWith(targetRef);
    });
  }

  if (superProps.length > 0) {
    if (!allowInsertArrow) {
      throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
    }

    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
    flatSuperProps.forEach(superProp => {
      const key = superProp.node.computed ? "" : superProp.get("property").node.name;

      if (superProp.parentPath.isCallExpression({
        callee: superProp.node
      })) {
        const superBinding = getSuperPropCallBinding(thisEnvFn, key);

        if (superProp.node.computed) {
          const prop = superProp.get("property").node;
          superProp.replaceWith(t().identifier(superBinding));
          superProp.parentPath.node.arguments.unshift(prop);
        } else {
          superProp.replaceWith(t().identifier(superBinding));
        }
      } else {
        const isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];

        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }

        if (isAssignment) {
          const value = superProp.parentPath.node.right;
          args.push(value);
          superProp.parentPath.replaceWith(t().callExpression(t().identifier(superBinding), args));
        } else {
          superProp.replaceWith(t().callExpression(t().identifier(superBinding), args));
        }
      }
    });
  }

  return thisBinding;
}

function standardizeSuperProperty(superProp) {
  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
    const assignmentPath = superProp.parentPath;
    const op = assignmentPath.node.operator.slice(0, -1);
    const value = assignmentPath.node.right;
    assignmentPath.node.operator = "=";

    if (superProp.node.computed) {
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      assignmentPath.get("left").replaceWith(t().memberExpression(superProp.node.object, t().assignmentExpression("=", tmp, superProp.node.property), true));
      assignmentPath.get("right").replaceWith(t().binaryExpression(op, t().memberExpression(superProp.node.object, t().identifier(tmp.name), true), value));
    } else {
      assignmentPath.get("left").replaceWith(t().memberExpression(superProp.node.object, superProp.node.property));
      assignmentPath.get("right").replaceWith(t().binaryExpression(op, t().memberExpression(superProp.node.object, t().identifier(superProp.node.property.name)), value));
    }

    return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
  } else if (superProp.parentPath.isUpdateExpression()) {
    const updateExpr = superProp.parentPath;
    const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
    const parts = [t().assignmentExpression("=", tmp, t().memberExpression(superProp.node.object, computedKey ? t().assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t().assignmentExpression("=", t().memberExpression(superProp.node.object, computedKey ? t().identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t().binaryExpression("+", t().identifier(tmp.name), t().numericLiteral(1)))];

    if (!superProp.parentPath.node.prefix) {
      parts.push(t().identifier(tmp.name));
    }

    updateExpr.replaceWith(t().sequenceExpression(parts));
    const left = updateExpr.get("expressions.0.right");
    const right = updateExpr.get("expressions.1.left");
    return [left, right];
  }

  return [superProp];
}

function hasSuperClass(thisEnvFn) {
  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
}

function getThisBinding(thisEnvFn, inConstructor) {
  return getBinding(thisEnvFn, "this", thisBinding => {
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t().thisExpression();
    const supers = new WeakSet();
    thisEnvFn.traverse({
      Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },

      ClassProperty(child) {
        if (child.node.static) return;
        child.skip();
      },

      CallExpression(child) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWithMultiple([child.node, t().assignmentExpression("=", t().identifier(thisBinding), t().identifier("this"))]);
      }

    });
  });
}

function getSuperBinding(thisEnvFn) {
  return getBinding(thisEnvFn, "supercall", () => {
    const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    return t().arrowFunctionExpression([t().restElement(argsBinding)], t().callExpression(t().super(), [t().spreadElement(t().identifier(argsBinding.name))]));
  });
}

function getSuperPropCallBinding(thisEnvFn, propName) {
  return getBinding(thisEnvFn, `superprop_call:${propName || ""}`, () => {
    const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    const argsList = [t().restElement(argsBinding)];
    let fnBody;

    if (propName) {
      fnBody = t().callExpression(t().memberExpression(t().super(), t().identifier(propName)), [t().spreadElement(t().identifier(argsBinding.name))]);
    } else {
      const method = thisEnvFn.scope.generateUidIdentifier("prop");
      argsList.unshift(method);
      fnBody = t().callExpression(t().memberExpression(t().super(), t().identifier(method.name), true), [t().spreadElement(t().identifier(argsBinding.name))]);
    }

    return t().arrowFunctionExpression(argsList, fnBody);
  });
}

function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
  const op = isAssignment ? "set" : "get";
  return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
    const argsList = [];
    let fnBody;

    if (propName) {
      fnBody = t().memberExpression(t().super(), t().identifier(propName));
    } else {
      const method = thisEnvFn.scope.generateUidIdentifier("prop");
      argsList.unshift(method);
      fnBody = t().memberExpression(t().super(), t().identifier(method.name), true);
    }

    if (isAssignment) {
      const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
      argsList.push(valueIdent);
      fnBody = t().assignmentExpression("=", fnBody, t().identifier(valueIdent.name));
    }

    return t().arrowFunctionExpression(argsList, fnBody);
  });
}

function getBinding(thisEnvFn, key, init) {
  const cacheKey = "binding:" + key;
  let data = thisEnvFn.getData(cacheKey);

  if (!data) {
    const id = thisEnvFn.scope.generateUidIdentifier(key);
    data = id.name;
    thisEnvFn.setData(cacheKey, data);
    thisEnvFn.scope.push({
      id: id,
      init: init(data)
    });
  }

  return data;
}

function getScopeInformation(fnPath) {
  const thisPaths = [];
  const argumentsPaths = [];
  const newTargetPaths = [];
  const superProps = [];
  const superCalls = [];
  fnPath.traverse({
    ClassProperty(child) {
      if (child.node.static) return;
      child.skip();
    },

    Function(child) {
      if (child.isArrowFunctionExpression()) return;
      child.skip();
    },

    ThisExpression(child) {
      thisPaths.push(child);
    },

    JSXIdentifier(child) {
      if (child.node.name !== "this") return;

      if (!child.parentPath.isJSXMemberExpression({
        object: child.node
      }) && !child.parentPath.isJSXOpeningElement({
        name: child.node
      })) {
        return;
      }

      thisPaths.push(child);
    },

    CallExpression(child) {
      if (child.get("callee").isSuper()) superCalls.push(child);
    },

    MemberExpression(child) {
      if (child.get("object").isSuper()) superProps.push(child);
    },

    ReferencedIdentifier(child) {
      if (child.node.name !== "arguments") return;
      argumentsPaths.push(child);
    },

    MetaProperty(child) {
      if (!child.get("meta").isIdentifier({
        name: "new"
      })) return;
      if (!child.get("property").isIdentifier({
        name: "target"
      })) return;
      newTargetPaths.push(child);
    }

  });
  return {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  };
}

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _helperGetFunctionArity() {
  const data = _interopRequireDefault(__webpack_require__(365));

  _helperGetFunctionArity = function () {
    return data;
  };

  return data;
}

function _template() {
  const data = _interopRequireDefault(__webpack_require__(241));

  _template = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const buildPropertyMethodAssignmentWrapper = (0, _template().default)(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
const buildGeneratorPropertyMethodAssignmentWrapper = (0, _template().default)(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
const visitor = {
  "ReferencedIdentifier|BindingIdentifier"(path, state) {
    if (path.node.name !== state.name) return;
    const localDeclar = path.scope.getBindingIdentifier(state.name);
    if (localDeclar !== state.outerDeclar) return;
    state.selfReference = true;
    path.stop();
  }

};

function getNameFromLiteralId(id) {
  if (t().isNullLiteral(id)) {
    return "null";
  }

  if (t().isRegExpLiteral(id)) {
    return `_${id.pattern}_${id.flags}`;
  }

  if (t().isTemplateLiteral(id)) {
    return id.quasis.map(quasi => quasi.value.raw).join("");
  }

  if (id.value !== undefined) {
    return id.value + "";
  }

  return "";
}

function wrap(state, method, id, scope) {
  if (state.selfReference) {
    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
      scope.rename(id.name);
    } else {
      if (!t().isFunction(method)) return;
      let build = buildPropertyMethodAssignmentWrapper;

      if (method.generator) {
        build = buildGeneratorPropertyMethodAssignmentWrapper;
      }

      const template = build({
        FUNCTION: method,
        FUNCTION_ID: id,
        FUNCTION_KEY: scope.generateUidIdentifier(id.name)
      }).expression;
      const params = template.callee.body.body[0].params;

      for (let i = 0, len = (0, _helperGetFunctionArity().default)(method); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }

      return template;
    }
  }

  method.id = id;
  scope.getProgramParent().references[id.name] = true;
}

function visit(node, name, scope) {
  const state = {
    selfAssignment: false,
    selfReference: false,
    outerDeclar: scope.getBindingIdentifier(name),
    references: [],
    name: name
  };
  const binding = scope.getOwnBinding(name);

  if (binding) {
    if (binding.kind === "param") {
      state.selfReference = true;
    } else {}
  } else if (state.outerDeclar || scope.hasGlobal(name)) {
    scope.traverse(node, visitor, state);
  }

  return state;
}

function _default({
  node,
  parent,
  scope,
  id
}, localBinding = false) {
  if (node.id) return;

  if ((t().isObjectProperty(parent) || t().isObjectMethod(parent, {
    kind: "method"
  })) && (!parent.computed || t().isLiteral(parent.key))) {
    id = parent.key;
  } else if (t().isVariableDeclarator(parent)) {
    id = parent.id;

    if (t().isIdentifier(id) && !localBinding) {
      const binding = scope.parent.getBinding(id.name);

      if (binding && binding.constant && scope.getBinding(id.name) === binding) {
        node.id = t().cloneNode(id);
        node.id[t().NOT_LOCAL_BINDING] = true;
        return;
      }
    }
  } else if (t().isAssignmentExpression(parent)) {
    id = parent.left;
  } else if (!id) {
    return;
  }

  let name;

  if (id && t().isLiteral(id)) {
    name = getNameFromLiteralId(id);
  } else if (id && t().isIdentifier(id)) {
    name = id.name;
  }

  if (name === undefined) {
    return;
  }

  name = t().toBindingIdentifierName(name);
  id = t().identifier(name);
  id[t().NOT_LOCAL_BINDING] = true;
  const state = visit(node, name, scope);
  return wrap(state, node, id, scope) || node;
}

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _default(node) {
  const params = node.params;

  for (let i = 0; i < params.length; i++) {
    const param = params[i];

    if (t().isAssignmentPattern(param) || t().isRestElement(param)) {
      return i;
    }
  }

  return params.length;
}

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchesPattern = matchesPattern;
exports.has = has;
exports.isStatic = isStatic;
exports.isnt = isnt;
exports.equals = equals;
exports.isNodeType = isNodeType;
exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
exports.isCompletionRecord = isCompletionRecord;
exports.isStatementOrBlock = isStatementOrBlock;
exports.referencesImport = referencesImport;
exports.getSource = getSource;
exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
exports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
exports.resolve = resolve;
exports._resolve = _resolve;
exports.isConstantExpression = isConstantExpression;
exports.isInStrictMode = isInStrictMode;
exports.is = void 0;

function _includes() {
  const data = _interopRequireDefault(__webpack_require__(306));

  _includes = function () {
    return data;
  };

  return data;
}

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matchesPattern(pattern, allowPartial) {
  return t().matchesPattern(this.node, pattern, allowPartial);
}

function has(key) {
  const val = this.node && this.node[key];

  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}

function isStatic() {
  return this.scope.isStatic(this.node);
}

const is = has;
exports.is = is;

function isnt(key) {
  return !this.has(key);
}

function equals(key, value) {
  return this.node[key] === value;
}

function isNodeType(type) {
  return t().isType(this.type, type);
}

function canHaveVariableDeclarationOrExpression() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}

function canSwapBetweenExpressionAndStatement(replacement) {
  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
    return false;
  }

  if (this.isExpression()) {
    return t().isBlockStatement(replacement);
  } else if (this.isBlockStatement()) {
    return t().isExpression(replacement);
  }

  return false;
}

function isCompletionRecord(allowInsideFunction) {
  let path = this;
  let first = true;

  do {
    const container = path.container;

    if (path.isFunction() && !first) {
      return !!allowInsideFunction;
    }

    first = false;

    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());

  return true;
}

function isStatementOrBlock() {
  if (this.parentPath.isLabeledStatement() || t().isBlockStatement(this.container)) {
    return false;
  } else {
    return (0, _includes().default)(t().STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}

function referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) return false;
  const binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;
  const path = binding.path;
  const parent = path.parentPath;
  if (!parent.isImportDeclaration()) return false;

  if (parent.node.source.value === moduleSource) {
    if (!importName) return true;
  } else {
    return false;
  }

  if (path.isImportDefaultSpecifier() && importName === "default") {
    return true;
  }

  if (path.isImportNamespaceSpecifier() && importName === "*") {
    return true;
  }

  if (path.isImportSpecifier() && path.node.imported.name === importName) {
    return true;
  }

  return false;
}

function getSource() {
  const node = this.node;

  if (node.end) {
    const code = this.hub.getCode();
    if (code) return code.slice(node.start, node.end);
  }

  return "";
}

function willIMaybeExecuteBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}

function _guessExecutionStatusRelativeTo(target) {
  const targetFuncParent = target.scope.getFunctionParent() || target.scope.getProgramParent();
  const selfFuncParent = this.scope.getFunctionParent() || target.scope.getProgramParent();

  if (targetFuncParent.node !== selfFuncParent.node) {
    const status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);

    if (status) {
      return status;
    } else {
      target = targetFuncParent.path;
    }
  }

  const targetPaths = target.getAncestry();
  if (targetPaths.indexOf(this) >= 0) return "after";
  const selfPaths = this.getAncestry();
  let commonPath;
  let targetIndex;
  let selfIndex;

  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
    const selfPath = selfPaths[selfIndex];
    targetIndex = targetPaths.indexOf(selfPath);

    if (targetIndex >= 0) {
      commonPath = selfPath;
      break;
    }
  }

  if (!commonPath) {
    return "before";
  }

  const targetRelationship = targetPaths[targetIndex - 1];
  const selfRelationship = selfPaths[selfIndex - 1];

  if (!targetRelationship || !selfRelationship) {
    return "before";
  }

  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {
    return targetRelationship.key > selfRelationship.key ? "before" : "after";
  }

  const keys = t().VISITOR_KEYS[commonPath.type];
  const targetKeyPosition = keys.indexOf(targetRelationship.key);
  const selfKeyPosition = keys.indexOf(selfRelationship.key);
  return targetKeyPosition > selfKeyPosition ? "before" : "after";
}

function _guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {
  const targetFuncPath = targetFuncParent.path;
  if (!targetFuncPath.isFunctionDeclaration()) return;
  const binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);
  if (!binding.references) return "before";
  const referencePaths = binding.referencePaths;

  for (const path of referencePaths) {
    if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
      return;
    }
  }

  let allStatus;

  for (const path of referencePaths) {
    const childOfFunction = !!path.find(path => path.node === targetFuncPath.node);
    if (childOfFunction) continue;

    const status = this._guessExecutionStatusRelativeTo(path);

    if (allStatus) {
      if (allStatus !== status) return;
    } else {
      allStatus = status;
    }
  }

  return allStatus;
}

function resolve(dangerous, resolved) {
  return this._resolve(dangerous, resolved) || this;
}

function _resolve(dangerous, resolved) {
  if (resolved && resolved.indexOf(this) >= 0) return;
  resolved = resolved || [];
  resolved.push(this);

  if (this.isVariableDeclarator()) {
    if (this.get("id").isIdentifier()) {
      return this.get("init").resolve(dangerous, resolved);
    } else {}
  } else if (this.isReferencedIdentifier()) {
    const binding = this.scope.getBinding(this.node.name);
    if (!binding) return;
    if (!binding.constant) return;
    if (binding.kind === "module") return;

    if (binding.path !== this) {
      const ret = binding.path.resolve(dangerous, resolved);
      if (this.find(parent => parent.node === ret.node)) return;
      return ret;
    }
  } else if (this.isTypeCastExpression()) {
    return this.get("expression").resolve(dangerous, resolved);
  } else if (dangerous && this.isMemberExpression()) {
    const targetKey = this.toComputedKey();
    if (!t().isLiteral(targetKey)) return;
    const targetName = targetKey.value;
    const target = this.get("object").resolve(dangerous, resolved);

    if (target.isObjectExpression()) {
      const props = target.get("properties");

      for (const prop of props) {
        if (!prop.isProperty()) continue;
        const key = prop.get("key");
        let match = prop.isnt("computed") && key.isIdentifier({
          name: targetName
        });
        match = match || key.isLiteral({
          value: targetName
        });
        if (match) return prop.get("value").resolve(dangerous, resolved);
      }
    } else if (target.isArrayExpression() && !isNaN(+targetName)) {
      const elems = target.get("elements");
      const elem = elems[targetName];
      if (elem) return elem.resolve(dangerous, resolved);
    }
  }
}

function isConstantExpression() {
  if (this.isIdentifier()) {
    const binding = this.scope.getBinding(this.node.name);
    if (!binding) return false;
    return binding.constant;
  }

  if (this.isLiteral()) {
    if (this.isRegExpLiteral()) {
      return false;
    }

    if (this.isTemplateLiteral()) {
      return this.get("expressions").every(expression => expression.isConstantExpression());
    }

    return true;
  }

  if (this.isUnaryExpression()) {
    if (this.get("operator").node !== "void") {
      return false;
    }

    return this.get("argument").isConstantExpression();
  }

  if (this.isBinaryExpression()) {
    return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
  }

  return false;
}

function isInStrictMode() {
  const start = this.isProgram() ? this : this.parentPath;
  const strictParent = start.find(path => {
    if (path.isProgram({
      sourceType: "module"
    })) return true;
    if (path.isClass()) return true;
    if (!path.isProgram() && !path.isFunction()) return false;

    if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
      return false;
    }

    let {
      node
    } = path;
    if (path.isFunction()) node = node.body;

    for (const directive of node.directives) {
      if (directive.value.value === "use strict") {
        return true;
      }
    }
  });
  return !!strictParent;
}

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.call = call;
exports._call = _call;
exports.isBlacklisted = isBlacklisted;
exports.visit = visit;
exports.skip = skip;
exports.skipKey = skipKey;
exports.stop = stop;
exports.setScope = setScope;
exports.setContext = setContext;
exports.resync = resync;
exports._resyncParent = _resyncParent;
exports._resyncKey = _resyncKey;
exports._resyncList = _resyncList;
exports._resyncRemoved = _resyncRemoved;
exports.popContext = popContext;
exports.pushContext = pushContext;
exports.setup = setup;
exports.setKey = setKey;
exports.requeue = requeue;
exports._getQueueContexts = _getQueueContexts;

var _index = _interopRequireDefault(__webpack_require__(293));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function call(key) {
  const opts = this.opts;
  this.debug(key);

  if (this.node) {
    if (this._call(opts[key])) return true;
  }

  if (this.node) {
    return this._call(opts[this.node.type] && opts[this.node.type][key]);
  }

  return false;
}

function _call(fns) {
  if (!fns) return false;

  for (const fn of fns) {
    if (!fn) continue;
    const node = this.node;
    if (!node) return true;
    const ret = fn.call(this.state, this, this.state);

    if (ret && typeof ret === "object" && typeof ret.then === "function") {
      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support.` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
    }

    if (ret) {
      throw new Error(`Unexpected return value from visitor method ${fn}`);
    }

    if (this.node !== node) return true;
    if (this.shouldStop || this.shouldSkip || this.removed) return true;
  }

  return false;
}

function isBlacklisted() {
  const blacklist = this.opts.blacklist;
  return blacklist && blacklist.indexOf(this.node.type) > -1;
}

function visit() {
  if (!this.node) {
    return false;
  }

  if (this.isBlacklisted()) {
    return false;
  }

  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false;
  }

  if (this.call("enter") || this.shouldSkip) {
    this.debug("Skip...");
    return this.shouldStop;
  }

  this.debug("Recursing into...");

  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);

  this.call("exit");
  return this.shouldStop;
}

function skip() {
  this.shouldSkip = true;
}

function skipKey(key) {
  this.skipKeys[key] = true;
}

function stop() {
  this.shouldStop = true;
  this.shouldSkip = true;
}

function setScope() {
  if (this.opts && this.opts.noScope) return;
  let path = this.parentPath;
  let target;

  while (path && !target) {
    if (path.opts && path.opts.noScope) return;
    target = path.scope;
    path = path.parentPath;
  }

  this.scope = this.getScope(target);
  if (this.scope) this.scope.init();
}

function setContext(context) {
  this.shouldSkip = false;
  this.shouldStop = false;
  this.removed = false;
  this.skipKeys = {};

  if (context) {
    this.context = context;
    this.state = context.state;
    this.opts = context.opts;
  }

  this.setScope();
  return this;
}

function resync() {
  if (this.removed) return;

  this._resyncParent();

  this._resyncList();

  this._resyncKey();
}

function _resyncParent() {
  if (this.parentPath) {
    this.parent = this.parentPath.node;
  }
}

function _resyncKey() {
  if (!this.container) return;
  if (this.node === this.container[this.key]) return;

  if (Array.isArray(this.container)) {
    for (let i = 0; i < this.container.length; i++) {
      if (this.container[i] === this.node) {
        return this.setKey(i);
      }
    }
  } else {
    for (const key in this.container) {
      if (this.container[key] === this.node) {
        return this.setKey(key);
      }
    }
  }

  this.key = null;
}

function _resyncList() {
  if (!this.parent || !this.inList) return;
  const newContainer = this.parent[this.listKey];
  if (this.container === newContainer) return;
  this.container = newContainer || null;
}

function _resyncRemoved() {
  if (this.key == null || !this.container || this.container[this.key] !== this.node) {
    this._markRemoved();
  }
}

function popContext() {
  this.contexts.pop();

  if (this.contexts.length > 0) {
    this.setContext(this.contexts[this.contexts.length - 1]);
  } else {
    this.setContext(undefined);
  }
}

function pushContext(context) {
  this.contexts.push(context);
  this.setContext(context);
}

function setup(parentPath, container, listKey, key) {
  this.inList = !!listKey;
  this.listKey = listKey;
  this.parentKey = listKey || key;
  this.container = container;
  this.parentPath = parentPath || this.parentPath;
  this.setKey(key);
}

function setKey(key) {
  this.key = key;
  this.node = this.container[this.key];
  this.type = this.node && this.node.type;
}

function requeue(pathToQueue = this) {
  if (pathToQueue.removed) return;
  const contexts = this.contexts;

  for (const context of contexts) {
    context.maybeQueue(pathToQueue);
  }
}

function _getQueueContexts() {
  let path = this;
  let contexts = this.contexts;

  while (!contexts.length) {
    path = path.parentPath;
    if (!path) break;
    contexts = path.contexts;
  }

  return contexts;
}

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = remove;
exports._removeFromScope = _removeFromScope;
exports._callRemovalHooks = _callRemovalHooks;
exports._remove = _remove;
exports._markRemoved = _markRemoved;
exports._assertUnremoved = _assertUnremoved;

var _removalHooks = __webpack_require__(369);

function remove() {
  this._assertUnremoved();

  this.resync();

  this._removeFromScope();

  if (this._callRemovalHooks()) {
    this._markRemoved();

    return;
  }

  this.shareCommentsWithSiblings();

  this._remove();

  this._markRemoved();
}

function _removeFromScope() {
  const bindings = this.getBindingIdentifiers();
  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));
}

function _callRemovalHooks() {
  for (const fn of _removalHooks.hooks) {
    if (fn(this, this.parentPath)) return true;
  }
}

function _remove() {
  if (Array.isArray(this.container)) {
    this.container.splice(this.key, 1);
    this.updateSiblingKeys(this.key, -1);
  } else {
    this._replaceWith(null);
  }
}

function _markRemoved() {
  this.shouldSkip = true;
  this.removed = true;
  this.node = null;
}

function _assertUnremoved() {
  if (this.removed) {
    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
}

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hooks = void 0;
const hooks = [function (self, parent) {
  const removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

  if (removeParent) {
    parent.remove();
    return true;
  }
}, function (self, parent) {
  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
    parent.replaceWith(parent.node.expressions[0]);
    return true;
  }
}, function (self, parent) {
  if (parent.isBinary()) {
    if (self.key === "left") {
      parent.replaceWith(parent.node.right);
    } else {
      parent.replaceWith(parent.node.left);
    }

    return true;
  }
}, function (self, parent) {
  if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
    self.replaceWith({
      type: "BlockStatement",
      body: []
    });
    return true;
  }
}];
exports.hooks = hooks;

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insertBefore = insertBefore;
exports._containerInsert = _containerInsert;
exports._containerInsertBefore = _containerInsertBefore;
exports._containerInsertAfter = _containerInsertAfter;
exports.insertAfter = insertAfter;
exports.updateSiblingKeys = updateSiblingKeys;
exports._verifyNodeList = _verifyNodeList;
exports.unshiftContainer = unshiftContainer;
exports.pushContainer = pushContainer;
exports.hoist = hoist;

var _cache = __webpack_require__(334);

var _hoister = _interopRequireDefault(__webpack_require__(371));

var _index = _interopRequireDefault(__webpack_require__(295));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function insertBefore(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);
  const {
    parentPath
  } = this;

  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
    return parentPath.insertBefore(nodes);
  } else if (this.isNodeType("Expression") && this.listKey !== "params" && this.listKey !== "arguments" || parentPath.isForStatement() && this.key === "init") {
    if (this.node) nodes.push(this.node);
    return this.replaceExpressionWithStatements(nodes);
  } else if (Array.isArray(this.container)) {
    return this._containerInsertBefore(nodes);
  } else if (this.isStatementOrBlock()) {
    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
    this.replaceWith(t().blockStatement(shouldInsertCurrentNode ? [this.node] : []));
    return this.unshiftContainer("body", nodes);
  } else {
    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
  }
}

function _containerInsert(from, nodes) {
  this.updateSiblingKeys(from, nodes.length);
  const paths = [];
  this.container.splice(from, 0, ...nodes);

  for (let i = 0; i < nodes.length; i++) {
    const to = from + i;
    const path = this.getSibling(to);
    paths.push(path);

    if (this.context && this.context.queue) {
      path.pushContext(this.context);
    }
  }

  const contexts = this._getQueueContexts();

  for (const path of paths) {
    path.setScope();
    path.debug("Inserted.");

    for (const context of contexts) {
      context.maybeQueue(path, true);
    }
  }

  return paths;
}

function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}

function _containerInsertAfter(nodes) {
  return this._containerInsert(this.key + 1, nodes);
}

function insertAfter(nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);
  const {
    parentPath
  } = this;

  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
    return parentPath.insertAfter(nodes.map(node => {
      return t().isExpression(node) ? t().expressionStatement(node) : node;
    }));
  } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
    if (this.node) {
      let {
        scope
      } = this;

      if (parentPath.isMethod({
        computed: true,
        key: this.node
      })) {
        scope = scope.parent;
      }

      const temp = scope.generateDeclaredUidIdentifier();
      nodes.unshift(t().expressionStatement(t().assignmentExpression("=", t().cloneNode(temp), this.node)));
      nodes.push(t().expressionStatement(t().cloneNode(temp)));
    }

    return this.replaceExpressionWithStatements(nodes);
  } else if (Array.isArray(this.container)) {
    return this._containerInsertAfter(nodes);
  } else if (this.isStatementOrBlock()) {
    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
    this.replaceWith(t().blockStatement(shouldInsertCurrentNode ? [this.node] : []));
    return this.pushContainer("body", nodes);
  } else {
    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
  }
}

function updateSiblingKeys(fromIndex, incrementBy) {
  if (!this.parent) return;

  const paths = _cache.path.get(this.parent);

  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];

    if (path.key >= fromIndex) {
      path.key += incrementBy;
    }
  }
}

function _verifyNodeList(nodes) {
  if (!nodes) {
    return [];
  }

  if (nodes.constructor !== Array) {
    nodes = [nodes];
  }

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    let msg;

    if (!node) {
      msg = "has falsy node";
    } else if (typeof node !== "object") {
      msg = "contains a non-object node";
    } else if (!node.type) {
      msg = "without a type";
    } else if (node instanceof _index.default) {
      msg = "has a NodePath when it expected a raw object";
    }

    if (msg) {
      const type = Array.isArray(node) ? "array" : typeof node;
      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
    }
  }

  return nodes;
}

function unshiftContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);

  const path = _index.default.get({
    parentPath: this,
    parent: this.node,
    container: this.node[listKey],
    listKey,
    key: 0
  });

  return path.insertBefore(nodes);
}

function pushContainer(listKey, nodes) {
  this._assertUnremoved();

  nodes = this._verifyNodeList(nodes);
  const container = this.node[listKey];

  const path = _index.default.get({
    parentPath: this,
    parent: this.node,
    container: container,
    listKey,
    key: container.length
  });

  return path.replaceWithMultiple(nodes);
}

function hoist(scope = this.scope) {
  const hoister = new _hoister.default(this, scope);
  return hoister.run();
}

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const referenceVisitor = {
  ReferencedIdentifier(path, state) {
    if (path.isJSXIdentifier() && t().react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
      return;
    }

    if (path.node.name === "this") {
      let scope = path.scope;

      do {
        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
          break;
        }
      } while (scope = scope.parent);

      if (scope) state.breakOnScopePaths.push(scope.path);
    }

    const binding = path.scope.getBinding(path.node.name);
    if (!binding) return;
    if (binding !== state.scope.getBinding(path.node.name)) return;
    state.bindings[path.node.name] = binding;
  }

};

class PathHoister {
  constructor(path, scope) {
    this.breakOnScopePaths = [];
    this.bindings = {};
    this.scopes = [];
    this.scope = scope;
    this.path = path;
    this.attachAfter = false;
  }

  isCompatibleScope(scope) {
    for (const key in this.bindings) {
      const binding = this.bindings[key];

      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
        return false;
      }
    }

    return true;
  }

  getCompatibleScopes() {
    let scope = this.path.scope;

    do {
      if (this.isCompatibleScope(scope)) {
        this.scopes.push(scope);
      } else {
        break;
      }

      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
        break;
      }
    } while (scope = scope.parent);
  }

  getAttachmentPath() {
    let path = this._getAttachmentPath();

    if (!path) return;
    let targetScope = path.scope;

    if (targetScope.path === path) {
      targetScope = path.scope.parent;
    }

    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
      for (const name in this.bindings) {
        if (!targetScope.hasOwnBinding(name)) continue;
        const binding = this.bindings[name];

        if (binding.kind === "param" || binding.path.parentKey === "params") {
          continue;
        }

        const bindingParentPath = this.getAttachmentParentForPath(binding.path);

        if (bindingParentPath.key >= path.key) {
          this.attachAfter = true;
          path = binding.path;

          for (const violationPath of binding.constantViolations) {
            if (this.getAttachmentParentForPath(violationPath).key > path.key) {
              path = violationPath;
            }
          }
        }
      }
    }

    return path;
  }

  _getAttachmentPath() {
    const scopes = this.scopes;
    const scope = scopes.pop();
    if (!scope) return;

    if (scope.path.isFunction()) {
      if (this.hasOwnParamBindings(scope)) {
        if (this.scope === scope) return;
        const bodies = scope.path.get("body").get("body");

        for (let i = 0; i < bodies.length; i++) {
          if (bodies[i].node._blockHoist) continue;
          return bodies[i];
        }
      } else {
        return this.getNextScopeAttachmentParent();
      }
    } else if (scope.path.isProgram()) {
      return this.getNextScopeAttachmentParent();
    }
  }

  getNextScopeAttachmentParent() {
    const scope = this.scopes.pop();
    if (scope) return this.getAttachmentParentForPath(scope.path);
  }

  getAttachmentParentForPath(path) {
    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        return path;
      }
    } while (path = path.parentPath);
  }

  hasOwnParamBindings(scope) {
    for (const name in this.bindings) {
      if (!scope.hasOwnBinding(name)) continue;
      const binding = this.bindings[name];
      if (binding.kind === "param" && binding.constant) return true;
    }

    return false;
  }

  run() {
    this.path.traverse(referenceVisitor, this);
    this.getCompatibleScopes();
    const attachTo = this.getAttachmentPath();
    if (!attachTo) return;
    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
    let uid = attachTo.scope.generateUidIdentifier("ref");
    const declarator = t().variableDeclarator(uid, this.path.node);
    const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t().variableDeclaration("var", [declarator])]);
    const parent = this.path.parentPath;

    if (parent.isJSXElement() && this.path.container === parent.node.children) {
      uid = t().JSXExpressionContainer(uid);
    }

    this.path.replaceWith(t().cloneNode(uid));
    return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
  }

}

exports.default = PathHoister;

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOpposite = getOpposite;
exports.getCompletionRecords = getCompletionRecords;
exports.getSibling = getSibling;
exports.getPrevSibling = getPrevSibling;
exports.getNextSibling = getNextSibling;
exports.getAllNextSiblings = getAllNextSiblings;
exports.getAllPrevSiblings = getAllPrevSiblings;
exports.get = get;
exports._getKey = _getKey;
exports._getPattern = _getPattern;
exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;

var _index = _interopRequireDefault(__webpack_require__(295));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOpposite() {
  if (this.key === "left") {
    return this.getSibling("right");
  } else if (this.key === "right") {
    return this.getSibling("left");
  }
}

function addCompletionRecords(path, paths) {
  if (path) return paths.concat(path.getCompletionRecords());
  return paths;
}

function getCompletionRecords() {
  let paths = [];

  if (this.isIfStatement()) {
    paths = addCompletionRecords(this.get("consequent"), paths);
    paths = addCompletionRecords(this.get("alternate"), paths);
  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
    paths = addCompletionRecords(this.get("body"), paths);
  } else if (this.isProgram() || this.isBlockStatement()) {
    paths = addCompletionRecords(this.get("body").pop(), paths);
  } else if (this.isFunction()) {
    return this.get("body").getCompletionRecords();
  } else if (this.isTryStatement()) {
    paths = addCompletionRecords(this.get("block"), paths);
    paths = addCompletionRecords(this.get("handler"), paths);
    paths = addCompletionRecords(this.get("finalizer"), paths);
  } else if (this.isCatchClause()) {
    paths = addCompletionRecords(this.get("body"), paths);
  } else {
    paths.push(this);
  }

  return paths;
}

function getSibling(key) {
  return _index.default.get({
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key
  });
}

function getPrevSibling() {
  return this.getSibling(this.key - 1);
}

function getNextSibling() {
  return this.getSibling(this.key + 1);
}

function getAllNextSiblings() {
  let _key = this.key;
  let sibling = this.getSibling(++_key);
  const siblings = [];

  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(++_key);
  }

  return siblings;
}

function getAllPrevSiblings() {
  let _key = this.key;
  let sibling = this.getSibling(--_key);
  const siblings = [];

  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
  }

  return siblings;
}

function get(key, context) {
  if (context === true) context = this.context;
  const parts = key.split(".");

  if (parts.length === 1) {
    return this._getKey(key, context);
  } else {
    return this._getPattern(parts, context);
  }
}

function _getKey(key, context) {
  const node = this.node;
  const container = node[key];

  if (Array.isArray(container)) {
    return container.map((_, i) => {
      return _index.default.get({
        listKey: key,
        parentPath: this,
        parent: node,
        container: container,
        key: i
      }).setContext(context);
    });
  } else {
    return _index.default.get({
      parentPath: this,
      parent: node,
      container: node,
      key: key
    }).setContext(context);
  }
}

function _getPattern(parts, context) {
  let path = this;

  for (const part of parts) {
    if (part === ".") {
      path = path.parentPath;
    } else {
      if (Array.isArray(path)) {
        path = path[part];
      } else {
        path = path.get(part, context);
      }
    }
  }

  return path;
}

function getBindingIdentifiers(duplicates) {
  return t().getBindingIdentifiers(this.node, duplicates);
}

function getOuterBindingIdentifiers(duplicates) {
  return t().getOuterBindingIdentifiers(this.node, duplicates);
}

function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
  const path = this;
  let search = [].concat(path);
  const ids = Object.create(null);

  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    if (!id.node) continue;
    const keys = t().getBindingIdentifiers.keys[id.node.type];

    if (id.isIdentifier()) {
      if (duplicates) {
        const _ids = ids[id.node.name] = ids[id.node.name] || [];

        _ids.push(id);
      } else {
        ids[id.node.name] = id;
      }

      continue;
    }

    if (id.isExportDeclaration()) {
      const declaration = id.get("declaration");

      if (declaration.isDeclaration()) {
        search.push(declaration);
      }

      continue;
    }

    if (outerOnly) {
      if (id.isFunctionDeclaration()) {
        search.push(id.get("id"));
        continue;
      }

      if (id.isFunctionExpression()) {
        continue;
      }
    }

    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const child = id.get(key);

        if (Array.isArray(child) || child.node) {
          search = search.concat(child);
        }
      }
    }
  }

  return ids;
}

function getOuterBindingIdentifierPaths(duplicates) {
  return this.getBindingIdentifierPaths(duplicates, true);
}

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shareCommentsWithSiblings = shareCommentsWithSiblings;
exports.addComment = addComment;
exports.addComments = addComments;

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function shareCommentsWithSiblings() {
  if (typeof this.key === "string") return;
  const node = this.node;
  if (!node) return;
  const trailing = node.trailingComments;
  const leading = node.leadingComments;
  if (!trailing && !leading) return;
  const prev = this.getSibling(this.key - 1);
  const next = this.getSibling(this.key + 1);
  const hasPrev = Boolean(prev.node);
  const hasNext = Boolean(next.node);

  if (hasPrev && hasNext) {} else if (hasPrev) {
    prev.addComments("trailing", trailing);
  } else if (hasNext) {
    next.addComments("leading", leading);
  }
}

function addComment(type, content, line) {
  t().addComment(this.node, type, content, line);
}

function addComments(type, comments) {
  t().addComments(this.node, type, comments);
}

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.explode = explode;
exports.verify = verify;
exports.merge = merge;

var virtualTypes = _interopRequireWildcard(__webpack_require__(296));

function t() {
  const data = _interopRequireWildcard(__webpack_require__(21));

  t = function () {
    return data;
  };

  return data;
}

function _clone() {
  const data = _interopRequireDefault(__webpack_require__(32));

  _clone = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function explode(visitor) {
  if (visitor._exploded) return visitor;
  visitor._exploded = true;

  for (const nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;
    const parts = nodeType.split("|");
    if (parts.length === 1) continue;
    const fns = visitor[nodeType];
    delete visitor[nodeType];

    for (const part of parts) {
      visitor[part] = fns;
    }
  }

  verify(visitor);
  delete visitor.__esModule;
  ensureEntranceObjects(visitor);
  ensureCallbackArrays(visitor);

  for (const nodeType of Object.keys(visitor)) {
    if (shouldIgnoreKey(nodeType)) continue;
    const wrapper = virtualTypes[nodeType];
    if (!wrapper) continue;
    const fns = visitor[nodeType];

    for (const type in fns) {
      fns[type] = wrapCheck(wrapper, fns[type]);
    }

    delete visitor[nodeType];

    if (wrapper.types) {
      for (const type of wrapper.types) {
        if (visitor[type]) {
          mergePair(visitor[type], fns);
        } else {
          visitor[type] = fns;
        }
      }
    } else {
      mergePair(visitor, fns);
    }
  }

  for (const nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;
    const fns = visitor[nodeType];
    let aliases = t().FLIPPED_ALIAS_KEYS[nodeType];
    const deprecratedKey = t().DEPRECATED_KEYS[nodeType];

    if (deprecratedKey) {
      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`);
      aliases = [deprecratedKey];
    }

    if (!aliases) continue;
    delete visitor[nodeType];

    for (const alias of aliases) {
      const existing = visitor[alias];

      if (existing) {
        mergePair(existing, fns);
      } else {
        visitor[alias] = (0, _clone().default)(fns);
      }
    }
  }

  for (const nodeType in visitor) {
    if (shouldIgnoreKey(nodeType)) continue;
    ensureCallbackArrays(visitor[nodeType]);
  }

  return visitor;
}

function verify(visitor) {
  if (visitor._verified) return;

  if (typeof visitor === "function") {
    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
  }

  for (const nodeType in visitor) {
    if (nodeType === "enter" || nodeType === "exit") {
      validateVisitorMethods(nodeType, visitor[nodeType]);
    }

    if (shouldIgnoreKey(nodeType)) continue;

    if (t().TYPES.indexOf(nodeType) < 0) {
      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
    }

    const visitors = visitor[nodeType];

    if (typeof visitors === "object") {
      for (const visitorKey in visitors) {
        if (visitorKey === "enter" || visitorKey === "exit") {
          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
        } else {
          throw new Error("You passed `traverse()` a visitor object with the property " + `${nodeType} that has the invalid property ${visitorKey}`);
        }
      }
    }
  }

  visitor._verified = true;
}

function validateVisitorMethods(path, val) {
  const fns = [].concat(val);

  for (const fn of fns) {
    if (typeof fn !== "function") {
      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
    }
  }
}

function merge(visitors, states = [], wrapper) {
  const rootVisitor = {};

  for (let i = 0; i < visitors.length; i++) {
    const visitor = visitors[i];
    const state = states[i];
    explode(visitor);

    for (const type in visitor) {
      let visitorType = visitor[type];

      if (state || wrapper) {
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
      }

      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
      mergePair(nodeVisitor, visitorType);
    }
  }

  return rootVisitor;
}

function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
  const newVisitor = {};

  for (const key in oldVisitor) {
    let fns = oldVisitor[key];
    if (!Array.isArray(fns)) continue;
    fns = fns.map(function (fn) {
      let newFn = fn;

      if (state) {
        newFn = function (path) {
          return fn.call(state, path, state);
        };
      }

      if (wrapper) {
        newFn = wrapper(state.key, key, newFn);
      }

      return newFn;
    });
    newVisitor[key] = fns;
  }

  return newVisitor;
}

function ensureEntranceObjects(obj) {
  for (const key in obj) {
    if (shouldIgnoreKey(key)) continue;
    const fns = obj[key];

    if (typeof fns === "function") {
      obj[key] = {
        enter: fns
      };
    }
  }
}

function ensureCallbackArrays(obj) {
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}

function wrapCheck(wrapper, fn) {
  const newFn = function (path) {
    if (wrapper.checkPath(path)) {
      return fn.apply(this, arguments);
    }
  };

  newFn.toString = () => fn.toString();

  return newFn;
}

function shouldIgnoreKey(key) {
  if (key[0] === "_") return true;
  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

  if (key === "blacklist" || key === "noScope" || key === "skipKeys") {
    return true;
  }

  return false;
}

function mergePair(dest, src) {
  for (const key in src) {
    dest[key] = [].concat(dest[key] || [], src[key]);
  }
}

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class Hub {
  getCode() {}

  getScope() {}

  addHelper() {
    throw new Error("Helpers are not supported by the default hub.");
  }

  buildError(node, msg, Error = TypeError) {
    return new Error(msg);
  }

}

exports.default = Hub;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/* Abstract base class for all function objects */
class FunctionValue extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.FunctionPrototype, intrinsicName);
  }

  getName() {
    throw new Error("Abstract method");
  }

  getKind() {
    return "Function";
  }

  getLength() {
    let binding = this.properties.get("length");
    (0, _invariant.default)(binding);
    let desc = binding.descriptor;
    (0, _invariant.default)(desc);
    let value = desc.throwIfNotConcrete(this.$Realm).value;
    if (!(value instanceof _index.NumberValue)) return undefined;
    return value.value;
  }

  hasDefaultLength() {
    (0, _invariant.default)(false, "abstract method; please override");
  }

  getDebugName() {
    return super.getDebugName() || this.getName();
  }

}

exports.default = FunctionValue;
//# sourceMappingURL=FunctionValue.js.map

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/* Abstract base class for non-exotic function objects(either with source or built-in) */
class ECMAScriptFunctionValue extends _index.FunctionValue {
  constructor(realm, intrinsicName) {
    super(realm, intrinsicName);
    this.isCalledInMultipleContexts = false;
  }

}

exports.default = ECMAScriptFunctionValue;
//# sourceMappingURL=ECMAScriptFunctionValue.js.map

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/* Non built-in ECMAScript function objects with source code */
class ECMAScriptSourceFunctionValue extends _index.ECMAScriptFunctionValue {
  constructor(realm, intrinsicName) {
    super(realm, intrinsicName);
  }

  initialize(params, body) {
    let node = body;
    this.getHash(); // Record the sequence number, reflecting when this function was initialized for the first time

    if (node.uniqueOrderedTag === undefined) node.uniqueOrderedTag = this.$Realm.functionBodyUniqueTagSeed++;
    this.$ECMAScriptCode = body;
    this.$FormalParameters = params;
  } // Override.


  getName() {
    const uniqueTag = this.$ECMAScriptCode.uniqueOrderedTag; // Should only be called after the function is initialized.

    (0, _invariant.default)(uniqueTag);
    return this.__originalName ? this.__originalName : `function#${uniqueTag}`;
  }

  hasDefaultLength() {
    let params = this.$FormalParameters;
    let expected = params.length;

    for (let i = 0; i < params.length; i++) {
      let param = params[i];

      if (t.isAssignmentPattern(param) || t.isRestElement(param)) {
        expected = i;
        break;
      }
    }

    return expected === this.getLength();
  }

}

exports.default = ECMAScriptSourceFunctionValue;
//# sourceMappingURL=ECMAScriptSourceFunctionValue.js.map

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/* Bound Function Exotic Objects */
class BoundFunctionValue extends _index.FunctionValue {
  constructor(realm, intrinsicName) {
    super(realm, intrinsicName);
  }

  // Override.
  getName() {
    return "Bound";
  }

  hasDefaultLength() {
    let f = this.$BoundTargetFunction;
    if (!(f instanceof _index.FunctionValue) || !f.hasDefaultLength()) return false;
    let fl = f.getLength();
    (0, _invariant.default)(fl !== undefined);
    return this.getLength() === Math.max(fl - this.$BoundArguments.length, 0);
  }

}

exports.default = BoundFunctionValue;
//# sourceMappingURL=BoundFunctionValue.js.map

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _singletons = __webpack_require__(236);

var _descriptors = __webpack_require__(268);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* Built-in Function Objects */
class NativeFunctionValue extends _index.ECMAScriptFunctionValue {
  constructor(realm, intrinsicName, name, length, callback, constructor = true) {
    super(realm, intrinsicName);
    this.$ThisMode = "strict";
    this.$HomeObject = undefined;
    this.$FunctionKind = "normal";

    this.$Call = (thisArgument, argsList) => {
      return _singletons.Functions.$Call(this.$Realm, this, thisArgument, argsList);
    };

    if (constructor) {
      this.$ConstructorKind = "base";

      this.$Construct = (argumentsList, newTarget) => {
        return _singletons.Functions.$Construct(this.$Realm, this, argumentsList, newTarget);
      };
    }

    this.$Environment = realm.$GlobalEnv;
    this.callback = callback;
    this.length = length;
    this.$DefineOwnProperty("length", new _descriptors.PropertyDescriptor({
      value: new _index.NumberValue(realm, length),
      writable: false,
      configurable: true,
      enumerable: false
    }));

    if (name !== undefined && name !== "") {
      if (name instanceof _index.SymbolValue) {
        this.name = name.$Description ? `[${name.$Description.throwIfNotConcreteString().value}]` : "[native]";
      } else {
        this.name = name;
      }

      this.$DefineOwnProperty("name", new _descriptors.PropertyDescriptor({
        value: new _index.StringValue(realm, this.name),
        writable: false,
        configurable: true,
        enumerable: false
      }));
    } else {
      this.name = "native";
    }
  }

  getTrackedPropertyNames() {
    return NativeFunctionValue.trackedPropertyNames;
  }

  hasDefaultLength() {
    return this.getLength() === this.length;
  }

  // Override.
  getName() {
    return this.name;
  }

  callCallback(context, originalArgsList, newTarget) {
    let originalLength = originalArgsList.length;
    let argsList = originalArgsList.slice();

    for (let i = 0; i < this.length; i++) {
      argsList[i] = originalArgsList[i] || this.$Realm.intrinsics.undefined;
    }

    return new _completions.ReturnCompletion(this.callback(context, argsList, originalLength, newTarget), this.$Realm.currentLocation);
  } // for Proxy


}

exports.default = NativeFunctionValue;

_defineProperty(NativeFunctionValue, "trackedPropertyNames", _index.ObjectValue.trackedPropertyNames.concat("$RevocableProxy"));
//# sourceMappingURL=NativeFunctionValue.js.map

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _errors = __webpack_require__(3);

var _descriptors = __webpack_require__(268);

var _completions = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function evaluatePossibleNestedOptimizedFunctionsAndStoreEffects(realm, abstractArrayValue, possibleNestedOptimizedFunctions) {
  for (let _ref of possibleNestedOptimizedFunctions) {
    let {
      func,
      thisValue
    } = _ref;
    let funcToModel = func;

    if (func instanceof _index.BoundFunctionValue) {
      funcToModel = func.$BoundTargetFunction;
      thisValue = func.$BoundThis;
    }

    (0, _invariant.default)(funcToModel instanceof _index.ECMAScriptSourceFunctionValue);
    if (funcToModel.isCalledInMultipleContexts) return;
    let previouslyComputedEffects = realm.collectedNestedOptimizedFunctionEffects.get(funcToModel);

    if (previouslyComputedEffects !== undefined) {
      if (realm.instantRender.enabled) {
        realm.instantRenderBailout("Array operators may only be optimized once", funcToModel.expressionLocation);
      } else {
        // We currently do not support context-sensitive specialization,
        // where the calls we specialize depend on the specialization context.
        // TODO: #2454
        // TODO: Implement context-sensitive specialization instead of giving up
        funcToModel.isCalledInMultipleContexts = true;

        _singletons.Leak.value(realm, func);

        return;
      }
    }

    let funcCall = _singletons.Utils.createModelledFunctionCall(realm, funcToModel, undefined, thisValue); // We take the modelled function and wrap it in a pure evaluation so we can check for
    // side-effects that occur when evaluating the function. If there are side-effects, then
    // we don't try and optimize the nested function.


    let pureFuncCall = () => realm.evaluatePure(funcCall,
    /*bubbles*/
    false, () => {
      throw new _errors.NestedOptimizedFunctionSideEffect();
    });

    let effects;

    try {
      effects = realm.evaluateForEffects(pureFuncCall, null, "temporalArray nestedOptimizedFunction");
    } catch (e) {
      // If the nested optimized function had side-effects, we need to fallback to
      // the default behaviour and leaked the nested functions so any bindings
      // within the function properly leak and materialize.
      if (e instanceof _errors.NestedOptimizedFunctionSideEffect) {
        if (realm.instantRender.enabled) {
          realm.instantRenderBailout("InstantRender does not support impure array operators", funcCall.expressionLocation);
        }

        _singletons.Leak.value(realm, func);

        return;
      }

      throw e;
    } // Check if effects were pure then add them


    if (abstractArrayValue.nestedOptimizedFunctionEffects === undefined) {
      abstractArrayValue.nestedOptimizedFunctionEffects = new Map();
    }

    abstractArrayValue.nestedOptimizedFunctionEffects.set(funcToModel, effects);
    realm.collectedNestedOptimizedFunctionEffects.set(funcToModel, effects);
  }
}
/*
  We track aliases explicitly, because we currently do not have the primitives to model objects created
inside of the loop. TODO: Revisit when #2543 and subsequent modeling work
lands. At that point, instead of of a mayAliasSet, we can return a widened
abstract value.
*/


function modelUnknownPropertyOfSpecializedArray(realm, args, array, possibleNestedOptimizedFunctions) {
  let sentinelProperty = {
    key: undefined,
    descriptor: new _descriptors.PropertyDescriptor({
      writable: true,
      enumerable: true,
      configurable: true
    }),
    object: array
  };
  let mayAliasedObjects = new Set();

  if (realm.arrayNestedOptimizedFunctionsEnabled && possibleNestedOptimizedFunctions) {
    (0, _invariant.default)(possibleNestedOptimizedFunctions.length > 0);

    if (possibleNestedOptimizedFunctions[0].kind === "map") {
      for (let _ref2 of possibleNestedOptimizedFunctions) {
        let {
          func
        } = _ref2;
        let funcToModel;

        if (func instanceof _index.BoundFunctionValue) {
          funcToModel = func.$BoundTargetFunction;
        } else {
          funcToModel = func;
        }

        (0, _invariant.default)(funcToModel instanceof _index.ECMAScriptSourceFunctionValue);

        if (array.nestedOptimizedFunctionEffects !== undefined) {
          let effects = array.nestedOptimizedFunctionEffects.get(funcToModel);

          if (effects !== undefined) {
            (0, _invariant.default)(effects.result instanceof _completions.SimpleNormalCompletion);

            let reachableObjects = _singletons.Materialize.computeReachableObjects(realm, effects.result.value);

            for (let reachableObject of reachableObjects) {
              if (!effects.createdObjects.has(reachableObject)) mayAliasedObjects.add(reachableObject);
            }
          }
        }
      }
    } // For filter, we just collect the may alias set of the mapped array


    if (args.length > 0) {
      let mappedArray = args[0];

      if (ArrayValue.isIntrinsicAndHasWidenedNumericProperty(mappedArray)) {
        (0, _invariant.default)(mappedArray instanceof ArrayValue);
        (0, _invariant.default)(mappedArray.unknownProperty !== undefined);
        (0, _invariant.default)(mappedArray.unknownProperty.descriptor instanceof _descriptors.PropertyDescriptor);
        let unknownPropertyValue = mappedArray.unknownProperty.descriptor.value;
        (0, _invariant.default)(unknownPropertyValue instanceof _index.AbstractValue);
        let aliasSet = unknownPropertyValue.args[0];
        (0, _invariant.default)(aliasSet instanceof _index.AbstractValue && aliasSet.kind === "mayAliasSet");

        for (let aliasedObject of aliasSet.args) {
          (0, _invariant.default)(aliasedObject instanceof _index.ObjectValue);
          mayAliasedObjects.add(aliasedObject);
        }
      }
    }
  }

  let aliasSet = _index.AbstractValue.createFromType(realm, _index.Value, "mayAliasSet", [...mayAliasedObjects]);

  sentinelProperty.descriptor.value = _index.AbstractValue.createFromType(realm, _index.Value, "widened numeric property", [aliasSet]);
  return sentinelProperty;
}

function createArrayWithWidenedNumericProperty(realm, args, intrinsicName, possibleNestedOptimizedFunctions) {
  let abstractArrayValue = new ArrayValue(realm, intrinsicName);

  if (possibleNestedOptimizedFunctions !== undefined && possibleNestedOptimizedFunctions.length > 0) {
    if (realm.arrayNestedOptimizedFunctionsEnabled && (!realm.react.enabled || realm.react.optimizeNestedFunctions)) {
      evaluatePossibleNestedOptimizedFunctionsAndStoreEffects(realm, abstractArrayValue, possibleNestedOptimizedFunctions);
    } else {
      // If nested optimized functions are disabled, we need to fallback to
      // the default behaviour and leaked the nested functions so any bindings
      // within the function properly leak and materialize.
      for (let _ref3 of possibleNestedOptimizedFunctions) {
        let {
          func
        } = _ref3;

        _singletons.Leak.value(realm, func);
      }
    }
  } // Add unknownProperty so we manually handle this object property access


  abstractArrayValue.unknownProperty = modelUnknownPropertyOfSpecializedArray(realm, args, abstractArrayValue, possibleNestedOptimizedFunctions);
  return abstractArrayValue;
}

class ArrayValue extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.ArrayPrototype, intrinsicName);
  }

  getKind() {
    return "Array";
  }

  isSimpleObject() {
    return this.$TypedArrayName === undefined;
  } // ECMA262 9.4.2.1


  $DefineOwnProperty(P, Desc) {
    let A = this; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(this.$Realm, P), "expected a property key"); // 2. If P is "length", then

    if (P === "length" || P instanceof _index.StringValue && P.value === "length") {
      // a. Return ? ArraySetLength(A, Desc).
      return _singletons.Properties.ArraySetLength(this.$Realm, A, Desc);
    } else if ((0, _is.IsArrayIndex)(this.$Realm, P)) {
      if (ArrayValue.isIntrinsicAndHasWidenedNumericProperty(this)) {
        // The length of an array with widenend numeric properties is always abstract
        let succeeded = _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);

        if (succeeded === false) return false;
        return true;
      } // 3. Else if P is an array index, then
      // a. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").


      let oldLenDesc = _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, A, "length"); // b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are
      //    created with a length data property that cannot be deleted or reconfigured.


      (0, _invariant.default)(oldLenDesc !== undefined && !(0, _is.IsAccessorDescriptor)(this.$Realm, oldLenDesc), "cannot be undefined or an accessor descriptor");

      _singletons.Properties.ThrowIfMightHaveBeenDeleted(oldLenDesc);

      oldLenDesc = oldLenDesc.throwIfNotConcrete(this.$Realm); // c. Let oldLen be oldLenDesc.[[Value]].

      let oldLen = oldLenDesc.value;
      (0, _invariant.default)(oldLen instanceof _index.Value);
      oldLen = oldLen.throwIfNotConcrete();
      (0, _invariant.default)(oldLen instanceof _index.NumberValue, "expected number value");
      oldLen = oldLen.value; // d. Let index be ! ToUint32(P).

      let index = _singletons.To.ToUint32(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P); // e. If index  oldLen and oldLenDesc.[[Writable]] is false, return false.


      if (index >= oldLen && oldLenDesc.writable === false) return false; // f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).

      let succeeded = _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc); // g. If succeeded is false, return false.


      if (succeeded === false) return false; // h. If index  oldLen, then

      if (index >= oldLen) {
        // i. Set oldLenDesc.[[Value]] to index + 1.
        oldLenDesc.value = new _index.NumberValue(this.$Realm, index + 1); // ii. Let succeeded be OrdinaryDefineOwnProperty(A, "length", oldLenDesc).

        succeeded = _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, A, "length", oldLenDesc); // iii. Assert: succeeded is true.

        (0, _invariant.default)(succeeded, "expected length definition to succeed");
      } // i. Return true.


      return true;
    } // 1. Return OrdinaryDefineOwnProperty(A, P, Desc).


    return _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);
  }

  static createTemporalWithWidenedNumericProperty(realm, args, operationDescriptor, possibleNestedOptimizedFunctions) {
    (0, _invariant.default)(realm.generator !== undefined);
    let value = realm.generator.deriveConcreteObject(intrinsicName => createArrayWithWidenedNumericProperty(realm, args, intrinsicName, possibleNestedOptimizedFunctions), args, operationDescriptor, {
      isPure: true
    });
    (0, _invariant.default)(value instanceof ArrayValue);
    return value;
  }

  static isIntrinsicAndHasWidenedNumericProperty(obj) {
    if (obj instanceof ArrayValue && obj.intrinsicName !== undefined && obj.isScopedTemplate !== undefined) {
      (0, _invariant.default)(_index.ObjectValue.isIntrinsicDerivedObject(obj));
      const prop = obj.unknownProperty;

      if (prop !== undefined && prop.descriptor !== undefined) {
        const desc = prop.descriptor.throwIfNotConcrete(obj.$Realm);
        return desc.value instanceof _index.AbstractValue && desc.value.kind === "widened numeric property";
      }
    }

    return false;
  }

}

exports.default = ArrayValue;
//# sourceMappingURL=ArrayValue.js.map

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class UndefinedValue extends _index.PrimitiveValue {
  _serialize() {
    return undefined;
  }

  equals(x) {
    return x instanceof UndefinedValue && !(x instanceof _index.EmptyValue);
  }

  getHash() {
    return 792057514635681;
  }

  mightBeFalse() {
    return true;
  }

  toDisplayString() {
    return "undefined";
  }

}

exports.default = UndefinedValue;
//# sourceMappingURL=UndefinedValue.js.map

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class EmptyValue extends _index.UndefinedValue {
  getHash() {
    return 4523845144584502;
  }

  equals(x) {
    return x instanceof EmptyValue;
  }

}

exports.default = EmptyValue;
//# sourceMappingURL=EmptyValue.js.map

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class NullValue extends _index.PrimitiveValue {
  _serialize() {
    return null;
  }

  equals(x) {
    return x instanceof NullValue;
  }

  getHash() {
    return 5613143836447527;
  }

  mightBeFalse() {
    return true;
  }

  toDisplayString() {
    return "null";
  }

}

exports.default = NullValue;
//# sourceMappingURL=NullValue.js.map

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IntegralValue = exports.NumberValue = void 0;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class NumberValue extends _index.PrimitiveValue {
  constructor(realm, value, intrinsicName) {
    super(realm, intrinsicName);
    this.value = value;
  }

  equals(x) {
    return x instanceof NumberValue && Object.is(this.value, x.value);
  }

  getHash() {
    let num = Math.abs(this.value);
    if (num < 100) num *= 10000000;
    return num | 0; // make a 32-bit integer out of this and get rid of NaN
  }

  mightBeFalse() {
    return this.value === 0 || isNaN(this.value);
  }

  throwIfNotConcreteNumber() {
    return this;
  }

  _serialize() {
    return this.value;
  }

  toDisplayString() {
    return this.value.toString();
  }

}

exports.NumberValue = NumberValue;

class IntegralValue extends NumberValue {
  constructor(realm, value, intrinsicName) {
    super(realm, value, intrinsicName);
  }

  static createFromNumberValue(realm, value, intrinsicName) {
    return Number.isInteger(value) ? new IntegralValue(realm, value, intrinsicName) : new NumberValue(realm, value, intrinsicName);
  }

}

exports.IntegralValue = IntegralValue;
//# sourceMappingURL=NumberValue.js.map

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _abstract = __webpack_require__(233);

var _get = __webpack_require__(230);

var _is = __webpack_require__(229);

var _singletons = __webpack_require__(236);

var _call = __webpack_require__(234);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function FindPropertyKey(realm, keys, key) {
  for (let i = 0; i < keys.length; ++i) {
    if ((0, _abstract.SamePropertyKey)(realm, key, keys[i])) {
      return i;
    }
  }

  return -1;
}

class ProxyValue extends _index.ObjectValue {
  constructor(realm) {
    super(realm);
  }

  getTrackedPropertyNames() {
    return ProxyValue.trackedPropertyNames;
  }

  isSimpleObject() {
    return false;
  }

  usesOrdinaryObjectInternalPrototypeMethods() {
    return false;
  } // ECMA262 9.5.1


  $GetPrototypeOf() {
    let realm = this.$Realm; // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 2. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected an object"); // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget;
    (0, _invariant.default)(target instanceof _index.ObjectValue); // 5. Let trap be ? GetMethod(handler, "getPrototypeOf").

    let trap = (0, _get.GetMethod)(realm, handler, "getPrototypeOf"); // 6. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[GetPrototypeOf]]().
      return target.$GetPrototypeOf();
    } // 7. Let handlerProto be ? Call(trap, handler,  target ).


    let handlerProto = (0, _call.Call)(realm, trap, handler, [target]); // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.

    if (!(handlerProto instanceof _index.ObjectValue) && !(handlerProto instanceof _index.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 9. Let extensibleTarget be ? IsExtensible(target).


    let extensibleTarget = (0, _is.IsExtensible)(realm, target); // 10. If extensibleTarget is true, return handlerProto.

    if (extensibleTarget) return handlerProto; // 11. Let targetProto be ? target.[[GetPrototypeOf]]().

    let targetProto = target.$GetPrototypeOf(); // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.

    if (!(0, _abstract.SameValuePartial)(realm, handlerProto, targetProto)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 13. Return handlerProto.


    return handlerProto;
  } // ECMA262 9.5.2


  $SetPrototypeOf(V) {
    let realm = this.$Realm; // 1. Assert: Either Type(V) is Object or Type(V) is Null.

    (0, _invariant.default)(V instanceof _index.ObjectValue || V instanceof _index.NullValue, "expected object or null"); // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 3. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget;
    (0, _invariant.default)(target instanceof _index.ObjectValue); // 6. Let trap be ? GetMethod(handler, "setPrototypeOf").

    let trap = (0, _get.GetMethod)(realm, handler, "setPrototypeOf"); // 7. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[SetPrototypeOf]](V).
      return target.$SetPrototypeOf(V);
    } // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler,  target, V )).


    let booleanTrapResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, trap, handler, [target, V])); // 9. If booleanTrapResult is false, return false.


    if (!booleanTrapResult) return false; // 10. Let extensibleTarget be ? IsExtensible(target).

    let extensibleTarget = (0, _is.IsExtensible)(realm, target); // 11. If extensibleTarget is true, return true.

    if (extensibleTarget) return true; // 12. Let targetProto be ? target.[[GetPrototypeOf]]().

    let targetProto = target.$GetPrototypeOf(); // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.

    if (!(0, _abstract.SameValuePartial)(realm, V, targetProto)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 14. Return true.


    return true;
  } // ECMA262 9.5.3


  $IsExtensible() {
    let realm = this.$Realm; // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 2. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget; // 5. Let trap be ? GetMethod(handler, "isExtensible").

    let trap = (0, _get.GetMethod)(realm, handler, "isExtensible"); // 6. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[IsExtensible]]().
      (0, _invariant.default)(target instanceof _index.ObjectValue);
      return target.$IsExtensible();
    } // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler,  target )).


    let booleanTrapResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, trap, handler, [target])); // 8. Let targetResult be ? target.[[IsExtensible]]().


    (0, _invariant.default)(target instanceof _index.ObjectValue);
    let targetResult = target.$IsExtensible(); // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.

    if (booleanTrapResult !== targetResult) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 10. Return booleanTrapResult.


    return booleanTrapResult;
  } // ECMA262 9.5.4


  $PreventExtensions() {
    let realm = this.$Realm; // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 2. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget; // 5. Let trap be ? GetMethod(handler, "preventExtensions").

    let trap = (0, _get.GetMethod)(realm, handler, "preventExtensions"); // 6. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[PreventExtensions]]().
      (0, _invariant.default)(target instanceof _index.ObjectValue);
      return target.$PreventExtensions();
    } // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler,  target )).


    let booleanTrapResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, trap, handler, [target])); // 8. If booleanTrapResult is true, then


    if (booleanTrapResult) {
      // a. Let targetIsExtensible be ? target.[[IsExtensible]]().
      (0, _invariant.default)(target instanceof _index.ObjectValue);
      let targetIsExtensible = target.$IsExtensible(); // b. If targetIsExtensible is true, throw a TypeError exception.

      if (targetIsExtensible) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }
    } // 9. Return booleanTrapResult.


    return booleanTrapResult;
  } // ECMA262 9.5.5


  $GetOwnProperty(P) {
    let realm = this.$Realm; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "expected property key"); // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 3. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget;
    (0, _invariant.default)(target instanceof _index.ObjectValue); // 6. Let trap be ? GetMethod(handler, "getOwnPropertyDescriptor").

    let trap = (0, _get.GetMethod)(realm, handler, "getOwnPropertyDescriptor"); // 7. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[GetOwnProperty]](P).
      return target.$GetOwnProperty(P);
    } // 8. Let trapResultObj be ? Call(trap, handler,  target, P ).


    let trapResultObj = (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P]); // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.

    if (!(trapResultObj instanceof _index.ObjectValue) && !(trapResultObj instanceof _index.UndefinedValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).


    let targetDesc = target.$GetOwnProperty(P); // 11. If trapResultObj is undefined, then

    if (trapResultObj instanceof _index.UndefinedValue) {
      // a. If targetDesc is undefined, return undefined.
      if (!targetDesc) return undefined;

      _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc);

      targetDesc = targetDesc.throwIfNotConcrete(realm); // b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.

      if (!targetDesc.configurable) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // c. Let extensibleTarget be ? IsExtensible(target).


      let extensibleTarget = (0, _is.IsExtensible)(realm, target); // d. Assert: Type(extensibleTarget) is Boolean.

      (0, _invariant.default)(typeof extensibleTarget === "boolean", "expected boolean"); // e. If extensibleTarget is false, throw a TypeError exception.

      if (!extensibleTarget) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // f. Return undefined.


      return undefined;
    } // 12. Let extensibleTarget be ? IsExtensible(target).


    let extensibleTarget = (0, _is.IsExtensible)(realm, target); // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).

    let resultDesc = _singletons.To.ToPropertyDescriptor(realm, trapResultObj); // 14. Call CompletePropertyDescriptor(resultDesc).


    _singletons.Properties.CompletePropertyDescriptor(realm, resultDesc); // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).


    let valid = _singletons.Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, resultDesc, targetDesc); // 16. If valid is false, throw a TypeError exception.


    if (!valid) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 17. If resultDesc.[[Configurable]] is false, then


    resultDesc = resultDesc.throwIfNotConcrete(realm);

    if (!resultDesc.configurable) {
      // a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then
      if (!targetDesc || targetDesc.throwIfNotConcrete(realm).configurable) {
        // i. Throw a TypeError exception.
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }
    } // 18. Return resultDesc.


    return resultDesc;
  } // ECMA262 9.5.6


  $DefineOwnProperty(P, Desc) {
    let realm = this.$Realm; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "expected property key"); // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 3. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget;
    (0, _invariant.default)(target instanceof _index.ObjectValue); // 6. Let trap be ? GetMethod(handler, "defineProperty").

    let trap = (0, _get.GetMethod)(realm, handler, "defineProperty"); // 7. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[DefineOwnProperty]](P, Desc).
      return target.$DefineOwnProperty(P, Desc);
    } // 8. Let descObj be FromPropertyDescriptor(Desc).


    let descObj = _singletons.Properties.FromPropertyDescriptor(realm, Desc); // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler,  target, P, descObj )).


    let booleanTrapResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P, descObj])); // 10. If booleanTrapResult is false, return false.


    if (!booleanTrapResult) return false; // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).

    let targetDesc = target.$GetOwnProperty(P); // 12. Let extensibleTarget be ? IsExtensible(target).

    let extensibleTarget = (0, _is.IsExtensible)(realm, target); // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then

    let settingConfigFalse;

    if (Desc.throwIfNotConcrete(realm).configurable === false) {
      // a. Let settingConfigFalse be true.
      settingConfigFalse = true;
    } else {
      // 14. Else let settingConfigFalse be false.
      settingConfigFalse = false;
    } // 15. If targetDesc is undefined, then


    if (!targetDesc) {
      // a. If extensibleTarget is false, throw a TypeError exception.
      if (!extensibleTarget) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // b. If settingConfigFalse is true, throw a TypeError exception.


      if (settingConfigFalse) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }
    } else {
      // 16. Else targetDesc is not undefined,
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc); // a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.


      if (!_singletons.Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, Desc, targetDesc)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.


      if (settingConfigFalse && targetDesc.throwIfNotConcrete(realm).configurable) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }
    } // 17. Return true.


    return true;
  } // ECMA262 9.5.7


  $HasProperty(P) {
    let realm = this.$Realm; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "expected property key"); // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 3. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget;
    (0, _invariant.default)(target instanceof _index.ObjectValue); // 6. Let trap be ? GetMethod(handler, "has").

    let trap = (0, _get.GetMethod)(realm, handler, "has"); // 7. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[HasProperty]](P).
      return target.$HasProperty(P);
    } // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler,  target, P )).


    let booleanTrapResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P])); // 9. If booleanTrapResult is false, then


    if (!booleanTrapResult) {
      // a. Let targetDesc be ? target.[[GetOwnProperty]](P).
      let targetDesc = target.$GetOwnProperty(P); // b. If targetDesc is not undefined, then

      if (targetDesc) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc);

        targetDesc = targetDesc.throwIfNotConcrete(realm); // i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.

        if (!targetDesc.configurable) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        } // ii. Let extensibleTarget be ? IsExtensible(target).


        let extensibleTarget = (0, _is.IsExtensible)(realm, target); // iii. If extensibleTarget is false, throw a TypeError exception.

        if (!extensibleTarget) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      }
    } // 10. Return booleanTrapResult.


    return booleanTrapResult;
  } // ECMA262 9.5.8


  $Get(P, Receiver) {
    let realm = this.$Realm; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "expected property key"); // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 3. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget;
    (0, _invariant.default)(target instanceof _index.ObjectValue); // 6. Let trap be ? GetMethod(handler, "get").

    let trap = (0, _get.GetMethod)(realm, handler, "get"); // 7. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[Get]](P, Receiver).
      return target.$Get(P, Receiver);
    } // 8. Let trapResult be ? Call(trap, handler,  target, P, Receiver ).


    let trapResult = (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P, Receiver]); // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).

    let targetDesc = target.$GetOwnProperty(P); // 10. If targetDesc is not undefined, then

    if (targetDesc) {
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc); // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then


      if ((0, _is.IsDataDescriptor)(realm, targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {
        // i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.
        let targetValue = targetDesc.value || realm.intrinsics.undefined;
        (0, _invariant.default)(targetValue instanceof _index.Value);

        if (!(0, _abstract.SameValuePartial)(realm, trapResult, targetValue)) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      } // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, then


      if ((0, _is.IsAccessorDescriptor)(realm, targetDesc) && targetDesc.configurable === false && (!targetDesc.get || targetDesc.get instanceof _index.UndefinedValue)) {
        // i. If trapResult is not undefined, throw a TypeError exception.
        if (!(trapResult instanceof _index.UndefinedValue)) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      }
    } // 11. Return trapResult.


    return trapResult;
  } // ECMA262 9.5.9


  $Set(P, V, Receiver) {
    let realm = this.$Realm; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "expected property key"); // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 3. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget; // 6. Let trap be ? GetMethod(handler, "set").

    let trap = (0, _get.GetMethod)(realm, handler, "set"); // 7. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[Set]](P, V, Receiver).
      (0, _invariant.default)(target instanceof _index.ObjectValue);
      return target.$Set(P, V, Receiver);
    } // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler,  target, P, V, Receiver )).


    let booleanTrapResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P, V, Receiver])); // 9. If booleanTrapResult is false, return false.


    if (!booleanTrapResult) return false; // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).

    (0, _invariant.default)(target instanceof _index.ObjectValue);
    let targetDesc = target.$GetOwnProperty(P); // 11. If targetDesc is not undefined, then

    if (targetDesc) {
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc); // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then


      if ((0, _is.IsDataDescriptor)(realm, targetDesc) && !targetDesc.configurable && !targetDesc.writable) {
        // i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.
        let targetValue = targetDesc.value || realm.intrinsics.undefined;
        (0, _invariant.default)(targetValue instanceof _index.Value);

        if (!(0, _abstract.SameValuePartial)(realm, V, targetValue)) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      } // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false, then


      if ((0, _is.IsAccessorDescriptor)(realm, targetDesc) && !targetDesc.configurable) {
        // i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.
        if (!targetDesc.set || targetDesc.set instanceof _index.UndefinedValue) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
        }
      }
    } // 12. Return true.


    return true;
  } // ECMA262 9.5.10


  $Delete(P) {
    let realm = this.$Realm; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "expected property key"); // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 3. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget; // 6. Let trap be ? GetMethod(handler, "deleteProperty").

    let trap = (0, _get.GetMethod)(realm, handler, "deleteProperty"); // 7. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[Delete]](P).
      (0, _invariant.default)(target instanceof _index.ObjectValue);
      return target.$Delete(P);
    } // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler,  target, P )).


    let booleanTrapResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, trap, handler, [target, typeof P === "string" ? new _index.StringValue(realm, P) : P])); // 9. If booleanTrapResult is false, return false.


    if (!booleanTrapResult) return false; // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).

    (0, _invariant.default)(target instanceof _index.ObjectValue);
    let targetDesc = target.$GetOwnProperty(P); // 11. If targetDesc is undefined, return true.

    if (!targetDesc) return true;

    _singletons.Properties.ThrowIfMightHaveBeenDeleted(targetDesc);

    targetDesc = targetDesc.throwIfNotConcrete(realm); // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.

    if (!targetDesc.configurable) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 13. Return true.


    return true;
  } // ECMA262 9.5.11


  $OwnPropertyKeys() {
    let realm = this.$Realm; // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.

    let handler = this.$ProxyHandler; // 2. If handler is null, throw a TypeError exception.

    if (handler instanceof _index.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Assert: Type(handler) is Object.


    (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected object"); // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.

    let target = this.$ProxyTarget;
    (0, _invariant.default)(target instanceof _index.ObjectValue); // 5. Let trap be ? GetMethod(handler, "ownKeys").

    let trap = (0, _get.GetMethod)(realm, handler, "ownKeys"); // 6. If trap is undefined, then

    if (trap instanceof _index.UndefinedValue) {
      // a. Return ? target.[[OwnPropertyKeys]]().
      return target.$OwnPropertyKeys();
    } // 7. Let trapResultArray be ? Call(trap, handler,  target ).


    let trapResultArray = (0, _call.Call)(realm, trap, handler, [target]); // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray,  String, Symbol ).

    let trapResult = _singletons.Create.CreateListFromArrayLike(realm, trapResultArray, ["String", "Symbol"]); // 9. Let extensibleTarget be ? IsExtensible(target).


    let extensibleTarget = (0, _is.IsExtensible)(realm, target); // 10. Let targetKeys be ? target.[[OwnPropertyKeys]]().

    let targetKeys = target.$OwnPropertyKeys(); // 11. Assert: targetKeys is a List containing only String and Symbol values.

    for (let key of targetKeys) {
      (0, _invariant.default)(key instanceof _index.SymbolValue || key instanceof _index.StringValue, "expected string or symbol");
    } // 12. Let targetConfigurableKeys be a new empty List.


    let targetConfigurableKeys = []; // 13. Let targetNonconfigurableKeys be a new empty List.

    let targetNonconfigurableKeys = []; // 14. Repeat, for each element key of targetKeys,

    for (let key of targetKeys) {
      // a. Let desc be ? target.[[GetOwnProperty]](key).
      let desc = target.$GetOwnProperty(key);
      if (desc) _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc); // b. If desc is not undefined and desc.[[Configurable]] is false, then

      if (desc && desc.throwIfNotConcrete(realm).configurable === false) {
        // i. Append key as an element of targetNonconfigurableKeys.
        targetNonconfigurableKeys.push(key);
      } else {
        // c. Else,
        // i. Append key as an element of targetConfigurableKeys.
        targetConfigurableKeys.push(key);
      }
    } // 15. If extensibleTarget is true and targetNonconfigurableKeys is empty, then


    if (extensibleTarget && !targetNonconfigurableKeys.length) {
      // a. Return trapResult.
      return trapResult;
    } // 16. Let uncheckedResultKeys be a new List which is a copy of trapResult.


    let uncheckedResultKeys = trapResult.slice(); // 17. Repeat, for each key that is an element of targetNonconfigurableKeys,

    for (let key of targetNonconfigurableKeys) {
      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.
      let index = FindPropertyKey(realm, uncheckedResultKeys, key);

      if (index < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "key is not an element of uncheckedResultKeys");
      } // b. Remove key from uncheckedResultKeys.


      uncheckedResultKeys.splice(index, 1);
    } // 18. If extensibleTarget is true, return trapResult.


    if (extensibleTarget) return trapResult; // 19. Repeat, for each key that is an element of targetConfigurableKeys,

    for (let key of targetConfigurableKeys) {
      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.
      let index = FindPropertyKey(realm, uncheckedResultKeys, key);

      if (index < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "key is not an element of uncheckedResultKeys");
      } // b. Remove key from uncheckedResultKeys.


      uncheckedResultKeys.splice(index, 1);
    } // 20. If uncheckedResultKeys is not empty, throw a TypeError exception.


    if (uncheckedResultKeys.length) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 21. Return trapResult.


    return trapResult;
  }

}

exports.default = ProxyValue;

_defineProperty(ProxyValue, "trackedPropertyNames", _index.ObjectValue.trackedPropertyNames.concat(["$ProxyTarget", "$ProxyHandler"]));
//# sourceMappingURL=ProxyValue.js.map

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class StringExotic extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.StringPrototype, intrinsicName);
  } // ECMA262 9.4.3.1


  $GetOwnProperty(P) {
    // 1. Assert: IsPropertyKey(P) is true.
    // 2. Let desc be OrdinaryGetOwnProperty(S, P).
    let desc = _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, this, P); // 3. If desc is not undefined, return desc.


    if (desc !== undefined) {
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc);

      return desc;
    } // 4. If Type(P) is not String, return undefined.


    if (typeof P !== "string" && !(P instanceof _index.StringValue)) return undefined; // 5. Let index be ! CanonicalNumericIndexString(P).

    let index = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P); // 6. If index is undefined, return undefined.


    if (index === undefined || index === null) return undefined; // 7. If IsInteger(index) is false, return undefined.

    if ((0, _is.IsInteger)(this.$Realm, index) === false) return undefined; // 8. If index = -0, return undefined.

    if (1.0 / index === -Infinity) return undefined; // 9. Let str be the String value of S.[[StringData]].

    let str = this.$StringData;
    (0, _invariant.default)(str);
    str = str.throwIfNotConcreteString(); // 10. Let len be the number of elements in str.

    let len = str.value.length; // 11. If index < 0 or len  index, return undefined.

    if (index < 0 || len <= index) return undefined; // 12. Let resultStr be a String value of length 1, containing one code unit from str, specifically the code unit at index index.

    let resultStr = new _index.StringValue(this.$Realm, str.value.charAt(index)); // 13. Return a PropertyDescriptor{[[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}.

    return new _descriptors.PropertyDescriptor({
      value: resultStr,
      writable: false,
      enumerable: true,
      configurable: false
    });
  } // ECMA262 9.4.3.2


  $OwnPropertyKeys() {
    // 1. Let keys be a new empty List.
    let keys = []; // 2. Let str be the String value of O.[[StringData]].

    let str = this.$StringData;
    (0, _invariant.default)(str);
    str = str.throwIfNotConcreteString(); // 3. Let len be the number of elements in str.

    let len = str.value.length;
    let realm = this.$Realm; // 4. For each integer i starting with 0 such that i < len, in ascending order,

    for (let i = 0; i < len; ++i) {
      // a. Add ! ToString(i) as the last element of keys.
      keys.push(new _index.StringValue(realm, _singletons.To.ToString(realm, new _index.NumberValue(realm, i))));
    } // 5. For each own property key P of O such that P is an integer index and ToInteger(P)  len, in ascending numeric index order,


    let properties = _singletons.Properties.GetOwnPropertyKeysArray(realm, this, false, false);

    for (let key of properties.filter(x => (0, _is.IsArrayIndex)(realm, x)).map(x => parseInt(x, 10)).filter(x => _singletons.To.ToInteger(realm, x) >= len).sort((x, y) => x - y)) {
      // i. Add P as the last element of keys.
      keys.push(new _index.StringValue(realm, key + ""));
    } // 6. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation,


    for (let key of properties.filter(x => !(0, _is.IsArrayIndex)(realm, x))) {
      // i. Add P as the last element of keys.
      keys.push(new _index.StringValue(realm, key));
    } // 7. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation,


    for (let key of this.symbols.keys()) {
      // i. Add P as the last element of keys.
      keys.push(key);
    } // 12. Return keys.


    return keys;
  }

}

exports.default = StringExotic;
//# sourceMappingURL=StringExotic.js.map

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _has = __webpack_require__(269);

var _abstract = __webpack_require__(233);

var _get = __webpack_require__(230);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class ArgumentsExotic extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);
  }

  // ECMA262 9.4.4.1
  $GetOwnProperty(P) {
    // 1. Let args be the arguments object.
    let args = this; // 2. Let desc be OrdinaryGetOwnProperty(args, P).

    let desc = _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, args, P); // 3. If desc is undefined, return desc.


    if (desc === undefined) return undefined;

    _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc);

    desc = desc.throwIfNotConcrete(this.$Realm); // 4. Let map be args.[[ParameterMap]].

    let map = args.$ParameterMap;
    (0, _invariant.default)(map); // 5. Let isMapped be ! HasOwnProperty(map, P).

    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P); // 6. If isMapped is true, then

    if (isMapped === true) {
      // a. Set desc.[[Value]] to Get(map, P).
      desc.value = (0, _get.Get)(this.$Realm, map, P);
    } // 7. Return desc.


    return desc;
  } // ECMA262 9.4.4.2


  $DefineOwnProperty(P, _Desc) {
    let Desc = _Desc.throwIfNotConcrete(this.$Realm); // 1. Let args be the arguments object.


    let args = this; // 2. Let map be args.[[ParameterMap]].

    let map = args.$ParameterMap;
    (0, _invariant.default)(map); // 3. Let isMapped be HasOwnProperty(map, P).

    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P); // 4. Let newArgDesc be Desc.

    let newArgDesc = Desc; // 5. If isMapped is true and IsDataDescriptor(Desc) is true, then

    if (isMapped === true && (0, _is.IsDataDescriptor)(this.$Realm, Desc) === true) {
      // a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then
      if (Desc.value === undefined && Desc.writable === false) {
        // i. Let newArgDesc be a copy of Desc.
        newArgDesc = new _descriptors.PropertyDescriptor(Desc); // ii. Set newArgDesc.[[Value]] to Get(map, P).

        newArgDesc.value = (0, _get.Get)(this.$Realm, map, P);
      }
    } // 6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).


    let allowed = _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, args, P, newArgDesc); // 7. If allowed is false, return false.


    if (allowed === false) return false; // 8. If isMapped is true, then

    if (isMapped === true) {
      // a. If IsAccessorDescriptor(Desc) is true, then
      if ((0, _is.IsAccessorDescriptor)(this.$Realm, Desc) === true) {
        // i. Call map.[[Delete]](P).
        map.$Delete(P);
      } else {
        // b. Else,
        // i. If Desc.[[Value]] is present, then
        if (Desc.value !== undefined) {
          // 1. Let setStatus be Set(map, P, Desc.[[Value]], false).
          (0, _invariant.default)(Desc.value instanceof _index.Value);

          let setStatus = _singletons.Properties.Set(this.$Realm, map, P, Desc.value, false); // 2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.


          (0, _invariant.default)(setStatus === true);
        } // ii. If Desc.[[Writable]] is present and its value is false, then


        if (Desc.writable === false) {
          // 1. Call map.[[Delete]](P).
          map.$Delete(P);
        }
      }
    } // 9. Return true.


    return true;
  } // ECMA262 9.4.4.3


  $Get(P, Receiver) {
    // 1. Let args be the arguments object.
    let args = this; // 2. Let map be args.[[ParameterMap]].

    let map = args.$ParameterMap;
    (0, _invariant.default)(map); // 3. Let isMapped be ! HasOwnProperty(map, P).

    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P); // 4. If isMapped is false, then

    if (isMapped === false) {
      // a. Return ? OrdinaryGet(args, P, Receiver).
      return (0, _get.OrdinaryGet)(this.$Realm, args, P, Receiver);
    } else {
      // 5. Else map contains a formal parameter mapping for P,
      // b. Return Get(map, P).
      return (0, _get.Get)(this.$Realm, map, P);
    }
  } // ECMA262 9.4.4.4


  $Set(P, V, Receiver) {
    // 1. Let args be the arguments object.
    let args = this;
    let isMapped, map; // 2. If SameValue(args, Receiver) is false, then

    if ((0, _abstract.SameValuePartial)(this.$Realm, args, Receiver) === false) {
      // a. Let isMapped be false.
      isMapped = false;
    } else {
      // 3. Else,
      // a. Let map be args.[[ParameterMap]].
      map = args.$ParameterMap;
      (0, _invariant.default)(map); // b. Let isMapped be ! HasOwnProperty(map, P).

      isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P);
    } // 4. If isMapped is true, then


    if (isMapped === true) {
      (0, _invariant.default)(map); // a. Let setStatus be Set(map, P, V, false).

      let setStatus = _singletons.Properties.Set(this.$Realm, map, P, V, false); // b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.


      (0, _invariant.default)(setStatus === true);
    } // 5. Return ? OrdinarySet(args, P, V, Receiver).


    return _singletons.Properties.OrdinarySet(this.$Realm, args, P, V, Receiver);
  } // ECMA262 9.4.4.5


  $Delete(P) {
    // 1. Let args be the arguments object.
    let args = this; // 2. Let map be args.[[ParameterMap]].

    let map = args.$ParameterMap;
    (0, _invariant.default)(map); // 3. Let isMapped be ! HasOwnProperty(map, P).

    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P); // 4. Let result be ? OrdinaryDelete(args, P).

    let result = _singletons.Properties.OrdinaryDelete(this.$Realm, args, P); // 5. If result is true and isMapped is true, then


    if (result === true && isMapped === true) {
      // a. Call map.[[Delete]](P).
      map.$Delete(P);
    } // 6. Return result.


    return result;
  }

}

exports.default = ArgumentsExotic;
//# sourceMappingURL=ArgumentsExotic.js.map

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _get = __webpack_require__(230);

var _has = __webpack_require__(269);

var _typedarray = __webpack_require__(390);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class IntegerIndexedExotic extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);
  } // ECMA262 9.4.5.1


  $GetOwnProperty(P) {
    let O = this; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true"); // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.

    (0, _invariant.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer); // 3. If Type(P) is String, then

    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P); // b. If numericIndex is not undefined, then


      if (numericIndex !== undefined) {
        // i. Let value be ? IntegerIndexedElementGet(O, numericIndex).
        let value = (0, _typedarray.IntegerIndexedElementGet)(this.$Realm, O, numericIndex); // ii. If value is undefined, return undefined.

        if (value instanceof _index.UndefinedValue) return undefined; // iii. Return a PropertyDescriptor{[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false}.

        return new _descriptors.PropertyDescriptor({
          value: value,
          writable: true,
          enumerable: true,
          configurable: false
        });
      }
    } // 4. Return OrdinaryGetOwnProperty(O, P).


    return _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, O, P);
  } // ECMA262 9.4.5.2


  $HasProperty(P) {
    let O = this; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true"); // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.

    (0, _invariant.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer); // 3. If Type(P) is String, then

    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P); // b. If numericIndex is not undefined, then


      if (numericIndex !== undefined) {
        // i. Let buffer be O.[[ViewedArrayBuffer]].
        let buffer = O.$ViewedArrayBuffer;
        (0, _invariant.default)(buffer); // ii. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

        if ((0, _is.IsDetachedBuffer)(this.$Realm, buffer) === true) {
          throw this.$Realm.createErrorThrowCompletion(this.$Realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
        } // iii. If IsInteger(numericIndex) is false, return false.


        if ((0, _is.IsInteger)(this.$Realm, numericIndex) === false) return false; // iv. If numericIndex = -0, return false.

        if (Object.is(numericIndex, -0)) return false; // v. If numericIndex < 0, return false.

        if (numericIndex < 0) return false; // vi. If numericIndex  O.[[ArrayLength]], return false.

        (0, _invariant.default)(O.$ArrayLength !== undefined);
        if (numericIndex >= O.$ArrayLength) return false; // vii. Return true.

        return true;
      }
    } // 4. Return ? OrdinaryHasProperty(O, P).


    return (0, _has.OrdinaryHasProperty)(this.$Realm, O, P);
  } // ECMA262 9.4.5.3


  $DefineOwnProperty(P, _Desc) {
    let O = this; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true"); // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.

    (0, _invariant.default)(O instanceof _index.ObjectValue && this.$ViewedArrayBuffer); // 3. If Type(P) is String, then

    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P); // b. If numericIndex is not undefined, then


      if (numericIndex !== undefined) {
        // i. If IsInteger(numericIndex) is false, return false.
        if ((0, _is.IsInteger)(this.$Realm, numericIndex) === false) return false; // ii. If numericIndex = -0, return false.

        if (Object.is(numericIndex, -0)) return false; // iii. If numericIndex < 0, return false.

        if (numericIndex < 0) return false; // iv. Let length be O.[[ArrayLength]].

        let length = this.$ArrayLength;
        (0, _invariant.default)(typeof length === "number"); // v. If numericIndex  length, return false.

        if (numericIndex >= length) return false;

        let Desc = _Desc.throwIfNotConcrete(this.$Realm); // vi. If IsAccessorDescriptor(Desc) is true, return false.


        if ((0, _is.IsAccessorDescriptor)(this.$Realm, Desc) === true) return false; // vii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is true, return false.

        if (Desc.configurable === true) return false; // viii. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.

        if (Desc.enumerable === false) return false; // ix. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.

        if (Desc.writable === false) return false; // x. If Desc has a [[Value]] field, then

        if (Desc.value) {
          // 1. Let value be Desc.[[Value]].
          let value = Desc.value;
          (0, _invariant.default)(value === undefined || value instanceof _index.Value); // 2. Return ? IntegerIndexedElementSet(O, numericIndex, value).

          return (0, _typedarray.IntegerIndexedElementSet)(this.$Realm, O, numericIndex, value);
        } // xi. Return true.


        return true;
      }
    } // 4. Return ! OrdinaryDefineOwnProperty(O, P, Desc).


    return _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, O, P, _Desc);
  } // ECMA262 9.4.5.4


  $Get(P, Receiver) {
    let O = this; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true"); // 2. If Type(P) is String, then

    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P); // b. If numericIndex is not undefined, then


      if (numericIndex !== undefined) {
        // i. Return ? IntegerIndexedElementGet(O, numericIndex).
        return (0, _typedarray.IntegerIndexedElementGet)(this.$Realm, O, numericIndex);
      }
    } // 3. Return ? OrdinaryGet(O, P, Receiver).


    return (0, _get.OrdinaryGet)(this.$Realm, O, P, Receiver);
  } // ECMA262 9.4.5.5


  $Set(P, V, Receiver) {
    let O = this; // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true"); // 2. If Type(P) is String, then

    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P); // b. If numericIndex is not undefined, then


      if (numericIndex !== undefined) {
        // i. Return ? IntegerIndexedElementSet(O, numericIndex, V).
        return (0, _typedarray.IntegerIndexedElementSet)(this.$Realm, O, numericIndex, V);
      }
    } // 3. Return ? OrdinarySet(O, P, V, Receiver).


    return _singletons.Properties.OrdinarySet(this.$Realm, O, P, V, Receiver);
  } // ECMA262 9.4.5.6


  $OwnPropertyKeys() {
    let O = this; // 1. Let keys be a new empty List.

    let keys = []; // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.

    (0, _invariant.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer && O.$ArrayLength !== undefined && O.$ByteOffset !== undefined && O.$TypedArrayName); // 3. Let len be O.[[ArrayLength]].

    let len = O.$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. For each integer i starting with 0 such that i < len, in ascending order,

    for (let i = 0; i < len; ++i) {
      // a. Add ! ToString(i) as the last element of keys.
      keys.push(new _index.StringValue(this.$Realm, _singletons.To.ToString(this.$Realm, new _index.NumberValue(this.$Realm, i))));
    }

    let realm = this.$Realm; // 5. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation

    let properties = _singletons.Properties.GetOwnPropertyKeysArray(realm, O, false, false);

    for (let key of properties.filter(x => !(0, _is.IsArrayIndex)(realm, x))) {
      // i. Add P as the last element of keys.
      keys.push(new _index.StringValue(realm, key));
    } // 6. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation


    for (let key of O.symbols.keys()) {
      // a. Add P as the last element of keys.
      keys.push(key);
    } // 7. Return keys.


    return keys;
  }

}

exports.default = IntegerIndexedExotic;
//# sourceMappingURL=IntegerIndexedExotic.js.map

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IntegerIndexedObjectCreate = IntegerIndexedObjectCreate;
exports.IntegerIndexedElementGet = IntegerIndexedElementGet;
exports.IntegerIndexedElementSet = IntegerIndexedElementSet;
exports.ValidateTypedArray = ValidateTypedArray;
exports.AllocateTypedArray = AllocateTypedArray;
exports.AllocateTypedArrayBuffer = AllocateTypedArrayBuffer;
exports.TypedArrayCreate = TypedArrayCreate;
exports.TypedArraySpeciesCreate = TypedArraySpeciesCreate;
exports.ArrayElementType = exports.ArrayElementSize = void 0;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _get = __webpack_require__(230);

var _arraybuffer = __webpack_require__(278);

var _is = __webpack_require__(229);

var _construct = __webpack_require__(228);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const ArrayElementSize = {
  Float32Array: 4,
  Float64Array: 8,
  Int8Array: 1,
  Int16Array: 2,
  Int32Array: 4,
  Uint8Array: 1,
  Uint16Array: 2,
  Uint32Array: 4,
  Uint8ClampedArray: 1
};
exports.ArrayElementSize = ArrayElementSize;
const ArrayElementType = {
  Float32Array: "Float32",
  Float64Array: "Float64",
  Int8Array: "Int8",
  Int16Array: "Int16",
  Int32Array: "Int32",
  Uint8Array: "Uint8",
  Uint16Array: "Uint16",
  Uint32Array: "Uint32",
  Uint8ClampedArray: "Uint8Clamped"
}; // ECMA262 9.4.5.7

exports.ArrayElementType = ArrayElementType;

function IntegerIndexedObjectCreate(realm, prototype, internalSlotsList) {
  // 1. Assert: internalSlotsList contains the names [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]].
  (0, _invariant.default)("$ViewedArrayBuffer" in internalSlotsList && "$ArrayLength" in internalSlotsList && "$ByteOffset" in internalSlotsList && "$TypedArrayName" in internalSlotsList); // 2. Let A be a newly created object with an internal slot for each name in internalSlotsList.

  let A = new _index.IntegerIndexedExotic(realm);
  Object.assign(A, internalSlotsList); // 3. Set A's essential internal methods to the default ordinary object definitions specified in 9.1.
  // 4. Set the [[GetOwnProperty]] internal method of A as specified in 9.4.5.1.
  // 5. Set the [[HasProperty]] internal method of A as specified in 9.4.5.2.
  // 6. Set the [[DefineOwnProperty]] internal method of A as specified in 9.4.5.3.
  // 7. Set the [[Get]] internal method of A as specified in 9.4.5.4.
  // 8. Set the [[Set]] internal method of A as specified in 9.4.5.5.
  // 9. Set the [[OwnPropertyKeys]] internal method of A as specified in 9.4.5.6.
  // 10. Set A.[[Prototype]] to prototype.

  A.$Prototype = prototype; // 11. Set A.[[Extensible]] to true.

  A.setExtensible(true); // 12. Return A.

  return A;
} // ECMA262 9.4.5.8


function IntegerIndexedElementGet(realm, O, index) {
  // 1. Assert: Type(index) is Number.
  (0, _invariant.default)(typeof index === "number", "Type(index) is Number"); // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.

  (0, _invariant.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer && O.$ArrayLength !== undefined && O.$ByteOffset !== undefined && O.$TypedArrayName); // 3. Let buffer be O.[[ViewedArrayBuffer]].

  let buffer = O.$ViewedArrayBuffer; // 4. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  } // 5. If IsInteger(index) is false, return undefined.


  if ((0, _is.IsInteger)(realm, index) === false) return realm.intrinsics.undefined; // 6. If index = -0, return undefined.

  if (Object.is(index, -0)) return realm.intrinsics.undefined; // 7. Let length be O.[[ArrayLength]].

  let length = O.$ArrayLength;
  (0, _invariant.default)(typeof length === "number"); // 8. If index < 0 or index  length, return undefined.

  if (index < 0 || index >= length) return realm.intrinsics.undefined; // 9. Let offset be O.[[ByteOffset]].

  let offset = O.$ByteOffset;
  (0, _invariant.default)(typeof offset === "number"); // 10. Let arrayTypeName be the String value of O.[[TypedArrayName]].

  let arrayTypeName = O.$TypedArrayName;
  (0, _invariant.default)(typeof arrayTypeName === "string"); // 11. Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.

  let elementSize = ArrayElementSize[arrayTypeName]; // 12. Let indexedPosition be (index  elementSize) + offset.

  let indexedPosition = index * elementSize + offset; // 13. Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.

  let elementType = ArrayElementType[arrayTypeName]; // 14. Return GetValueFromBuffer(buffer, indexedPosition, elementType).

  return (0, _arraybuffer.GetValueFromBuffer)(realm, buffer, indexedPosition, elementType);
} // ECMA262 9.4.5.9


function IntegerIndexedElementSet(realm, O, index, value) {
  // 1. Assert: Type(index) is Number.
  (0, _invariant.default)(typeof index === "number", "Type(index) is Number"); // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.

  (0, _invariant.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer && O.$ArrayLength !== undefined && O.$ByteOffset !== undefined && O.$TypedArrayName); // 3. Let numValue be ? ToNumber(value).

  let numValue = _singletons.To.ToNumber(realm, value); // 4. Let buffer be O.[[ViewedArrayBuffer]].


  let buffer = O.$ViewedArrayBuffer;
  (0, _invariant.default)(buffer); // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  } // 6. If IsInteger(index) is false, return false.


  if ((0, _is.IsInteger)(realm, index) === false) return false; // 7. If index = -0, return false.

  if (Object.is(index, -0)) return false; // 8. Let length be O.[[ArrayLength]].

  let length = O.$ArrayLength;
  (0, _invariant.default)(typeof length === "number"); // 9. If index < 0 or index  length, return false.

  if (index < 0 || index >= length) return false; // 10. Let offset be O.[[ByteOffset]].

  let offset = O.$ByteOffset;
  (0, _invariant.default)(typeof offset === "number"); // 11. Let arrayTypeName be the String value of O.[[TypedArrayName]].

  let arrayTypeName = O.$TypedArrayName;
  (0, _invariant.default)(typeof arrayTypeName === "string"); // 12. Let elementSize be the Number value of the Element Size value specified in Table 50 for arrayTypeName.

  let elementSize = ArrayElementSize[arrayTypeName]; // 13. Let indexedPosition be (index  elementSize) + offset.

  let indexedPosition = index * elementSize + offset; // 14. Let elementType be the String value of the Element Type value in Table 50 for arrayTypeName.

  let elementType = ArrayElementType[arrayTypeName]; // 15. Perform SetValueInBuffer(buffer, indexedPosition, elementType, numValue).

  (0, _arraybuffer.SetValueInBuffer)(realm, buffer, indexedPosition, elementType, numValue); // 16. Return true.

  return true;
} // ECMA262 22.2.3.5.1


function ValidateTypedArray(realm, O) {
  O = O.throwIfNotConcrete(); // 1. If Type(O) is not Object, throw a TypeError exception.

  if (!(O instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
  } // 2. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


  if (!O.$TypedArrayName) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
  } // 3. Assert: O has a [[ViewedArrayBuffer]] internal slot.


  (0, _invariant.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot"); // 4. Let buffer be O.[[ViewedArrayBuffer]].

  let buffer = O.$ViewedArrayBuffer; // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

  if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
  } // 6. Return buffer.


  return buffer;
} // ECMA262 22.2.4.2.1


function AllocateTypedArray(realm, constructorName, newTarget, defaultProto, length) {
  // 1. Let proto be ? GetPrototypeFromConstructor(newTarget, defaultProto).
  let proto = (0, _get.GetPrototypeFromConstructor)(realm, newTarget, defaultProto); // 2. Let obj be IntegerIndexedObjectCreate(proto,  [[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] ).

  let obj = IntegerIndexedObjectCreate(realm, proto, {
    $ViewedArrayBuffer: undefined,
    $TypedArrayName: undefined,
    $ByteLength: undefined,
    $ByteOffset: undefined,
    $ArrayLength: undefined
  }); // 3. Assert: obj.[[ViewedArrayBuffer]] is undefined.

  (0, _invariant.default)(obj.$ViewedArrayBuffer === undefined); // 4. Set obj.[[TypedArrayName]] to constructorName.

  obj.$TypedArrayName = constructorName; // 5. If length was not passed, then

  if (length === undefined) {
    // a. Set obj.[[ByteLength]] to 0.
    obj.$ByteLength = 0; // b. Set obj.[[ByteOffset]] to 0.

    obj.$ByteOffset = 0; // c. Set obj.[[ArrayLength]] to 0.

    obj.$ArrayLength = 0;
  } else {
    // 6. Else,
    // a. Perform ? AllocateTypedArrayBuffer(obj, length).
    AllocateTypedArrayBuffer(realm, obj, length);
  } // 7. Return obj.


  return obj;
} // ECMA262 22.2.4.2.2


function AllocateTypedArrayBuffer(realm, O, length) {
  // Note that O is a new object, and we can thus write to internal slots
  (0, _invariant.default)(realm.isNewObject(O)); // 1. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.

  (0, _invariant.default)(O instanceof _index.ObjectValue && "$ViewedArrayBuffer" in O, "O is an Object that has a [[ViewedArrayBuffer]] internal slot"); // 2. Assert: O.[[ViewedArrayBuffer]] is undefined.

  (0, _invariant.default)(O.$ViewedArrayBuffer === undefined, "O.[[ViewedArrayBuffer]] is undefined"); // 3. Assert: length  0.

  (0, _invariant.default)(length >= 0, "length  0"); // 4. Let constructorName be the String value of O.[[TypedArrayName]].

  let constructorName = O.$TypedArrayName;
  (0, _invariant.default)(constructorName); // 5. Let elementSize be the Element Size value in Table 50 for constructorName.

  let elementSize = ArrayElementSize[constructorName]; // 6. Let byteLength be elementSize  length.

  let byteLength = elementSize * length; // 7. Let data be ? AllocateArrayBuffer(%ArrayBuffer%, byteLength).

  let data = (0, _arraybuffer.AllocateArrayBuffer)(realm, realm.intrinsics.ArrayBuffer, byteLength); // 8. Set O.[[ViewedArrayBuffer]] to data.

  O.$ViewedArrayBuffer = data; // 9. Set O.[[ByteLength]] to byteLength.

  O.$ByteLength = byteLength; // 10. Set O.[[ByteOffset]] to 0.

  O.$ByteOffset = 0; // 11. Set O.[[ArrayLength]] to length.

  O.$ArrayLength = length; // 12. Return O.

  return O;
} // ECMA262 22.2.4.6


function TypedArrayCreate(realm, constructor, argumentList) {
  // 1. Let newTypedArray be ? Construct(constructor, argumentList).
  let newTypedArray = (0, _construct.Construct)(realm, constructor, argumentList).throwIfNotConcreteObject(); // 2. Perform ? ValidateTypedArray(newTypedArray).

  ValidateTypedArray(realm, newTypedArray); // 3. If argumentList is a List of a single Number, then

  if (argumentList.length === 1 && argumentList[0].mightBeNumber()) {
    if (argumentList[0].mightNotBeNumber()) {
      (0, _invariant.default)(argumentList[0] instanceof _index.AbstractValue);

      _index.AbstractValue.reportIntrospectionError(argumentList[0]);

      throw new _errors.FatalError();
    } // a. If newTypedArray.[[ArrayLength]] < argumentList[0], throw a TypeError exception.


    (0, _invariant.default)(typeof newTypedArray.$ArrayLength === "number");

    if (newTypedArray.$ArrayLength < argumentList[0].throwIfNotConcrete().value) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "newTypedArray.[[ArrayLength]] < argumentList[0]");
    }
  } // 4. Return newTypedArray.


  return newTypedArray;
} // ECMA262 22.2.4.7


function TypedArraySpeciesCreate(realm, exemplar, argumentList) {
  // 1. Assert: exemplar is an Object that has a [[TypedArrayName]] internal slot.
  (0, _invariant.default)(exemplar instanceof _index.ObjectValue && typeof exemplar.$TypedArrayName === "string"); // 2. Let defaultConstructor be the intrinsic object listed in column one of Table 50 for exemplar.[[TypedArrayName]].

  (0, _invariant.default)(typeof exemplar.$TypedArrayName === "string");
  let defaultConstructor = {
    Float32Array: realm.intrinsics.Float32Array,
    Float64Array: realm.intrinsics.Float64Array,
    Int8Array: realm.intrinsics.Int8Array,
    Int16Array: realm.intrinsics.Int16Array,
    Int32Array: realm.intrinsics.Int32Array,
    Uint8Array: realm.intrinsics.Uint8Array,
    Uint16Array: realm.intrinsics.Uint16Array,
    Uint32Array: realm.intrinsics.Uint32Array,
    Uint8ClampedArray: realm.intrinsics.Uint8ClampedArray
  }[exemplar.$TypedArrayName]; // 3. Let constructor be ? SpeciesConstructor(exemplar, defaultConstructor).

  let constructor = (0, _construct.SpeciesConstructor)(realm, exemplar, defaultConstructor); // 4. Return ? TypedArrayCreate(constructor, argumentList).

  return TypedArrayCreate(realm, constructor, argumentList);
}
//# sourceMappingURL=typedarray.js.map

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class BooleanValue extends _index.PrimitiveValue {
  constructor(realm, value, intrinsicName) {
    super(realm, intrinsicName);
    this.value = value;
    if (value && realm.intrinsics.true) return realm.intrinsics.true;
    if (!value && realm.intrinsics.false) return realm.intrinsics.false;
  }

  equals(x) {
    return x instanceof BooleanValue && this.value === x.value;
  }

  getHash() {
    return this.value ? 12484058682847432 : 3777063795205331;
  }

  mightBeFalse() {
    return !this.value;
  }

  throwIfNotConcreteBoolean() {
    return this;
  }

  _serialize() {
    return this.value;
  }

  toDisplayString() {
    return this.value.toString();
  }

}

exports.default = BooleanValue;
//# sourceMappingURL=BooleanValue.js.map

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class StringValue extends _index2.PrimitiveValue {
  constructor(realm, value, intrinsicName) {
    super(realm, intrinsicName);
    this.value = value;
  }

  equals(x) {
    return x instanceof StringValue && this.value === x.value;
  }

  getHash() {
    return (0, _index.hashString)(this.value);
  }

  mightBeFalse() {
    return this.value.length === 0;
  }

  throwIfNotConcreteString() {
    return this;
  }

  _serialize() {
    return this.value;
  }

  toDisplayString() {
    return JSON.stringify(this.value);
  }

}

exports.default = StringValue;
//# sourceMappingURL=StringValue.js.map

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class SymbolValue extends _index.PrimitiveValue {
  constructor(realm, desc, intrinsicName) {
    super(realm, intrinsicName);
    this.$Description = desc;
  }

  equals(x) {
    return this === x;
  }

  getHash() {
    if (this.hashValue === undefined) {
      this.hashValue = ++this.$Realm.symbolCount;
    }

    return this.hashValue;
  }

  mightBeFalse() {
    return false;
  }

  throwIfNotConcreteSymbol() {
    return this;
  }

  _serialize() {
    return Symbol(this.$Description);
  }

  toDisplayString() {
    if (this.$Description) {
      if (this.$Description instanceof _index.PrimitiveValue) {
        return `Symbol(${this.$Description.toDisplayString()})`;
      }
    }

    return "Symbol(to be supported)";
  }

}

exports.default = SymbolValue;
//# sourceMappingURL=SymbolValue.js.map

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _completions = __webpack_require__(18);

var _errors = __webpack_require__(3);

var _generator = __webpack_require__(237);

var _PreludeGenerator = __webpack_require__(238);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _index3 = __webpack_require__(15);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class AbstractValue extends _index.Value {
  constructor(realm, types, values, hashValue, args, operationDescriptor, optionalArgs) {
    (0, _invariant.default)(realm.useAbstractInterpretation);
    super(realm, optionalArgs ? optionalArgs.intrinsicName : undefined);
    (0, _invariant.default)(!_index.Value.isTypeCompatibleWith(types.getType(), _index.ObjectValue) || this instanceof _index.AbstractObjectValue);
    (0, _invariant.default)(types.getType() !== _index.NullValue && types.getType() !== _index.UndefinedValue);
    this.types = types;
    this.values = values;
    this.mightBeEmpty = false;
    this.operationDescriptor = operationDescriptor;
    this.args = args;
    this.hashValue = hashValue;
    this.kind = optionalArgs ? optionalArgs.kind : undefined;
    this.shape = optionalArgs ? optionalArgs.shape : undefined;
  }

  toDisplayString() {
    return "[Abstract " + this.hashValue.toString() + "]";
  }

  addSourceLocationsTo(locations, seenValues = new Set()) {
    if (seenValues.has(this)) return;
    seenValues.add(this);

    for (let val of this.args) {
      if (val instanceof AbstractValue) val.addSourceLocationsTo(locations, seenValues);
    }
  }

  addSourceNamesTo(names, visited = new Set()) {
    if (visited.has(this)) return;
    visited.add(this);
    let realm = this.$Realm;

    function add_intrinsic(name) {
      if (name.startsWith("_$")) {
        let temporalOperationEntryArgs = realm.derivedIds.get(name);
        (0, _invariant.default)(temporalOperationEntryArgs !== undefined);
        add_args(temporalOperationEntryArgs.args);
      } else if (names.indexOf(name) < 0) {
        names.push(name);
      }
    }

    function add_args(args) {
      if (args === undefined) return;

      for (let val of args) {
        if (val.intrinsicName) {
          add_intrinsic(val.intrinsicName);
        } else if (val instanceof AbstractValue) {
          val.addSourceNamesTo(names, visited);
        } else if (val instanceof _index.StringValue) {
          if (val.value.startsWith("__")) {
            names.push(val.value.slice(2));
          }
        }
      }
    }

    if (this.intrinsicName) {
      add_intrinsic(this.intrinsicName);
    }

    add_args(this.args);
  }

  equals(x) {
    if (x instanceof _index.ConcreteValue) return false;
    let thisArgs = this.args;
    let n = thisArgs.length;

    let argsAreEqual = () => {
      (0, _invariant.default)(x instanceof AbstractValue);
      let xArgs = x.args;
      let m = xArgs.length;
      (0, _invariant.default)(n === m); // Will be true if kinds are the same. Caller should see to it.

      for (let i = 0; i < n; i++) {
        let a = thisArgs[i];
        let b = xArgs[i];
        if (!a.equals(b)) return false;
      }

      return true;
    };

    return this === x || x instanceof AbstractValue && this.kind === x.kind && this.hashValue === x.hashValue && (this.intrinsicName && this.intrinsicName.length > 0 && this.intrinsicName === x.intrinsicName || n > 0 && argsAreEqual());
  }

  getHash() {
    return this.hashValue;
  }

  getType() {
    return this.types.getType();
  }

  getIdentifier() {
    (0, _invariant.default)(this.hasIdentifier());
    (0, _invariant.default)(this.operationDescriptor !== undefined);
    let {
      id
    } = this.operationDescriptor.data;
    (0, _invariant.default)(id !== undefined);
    return id;
  }

  hasIdentifier() {
    return this.operationDescriptor ? this.operationDescriptor.type === "IDENTIFIER" : false;
  } // this => val. A false value does not imply that !(this => val).


  implies(val, depth = 0) {
    if (depth > 5) return false;
    if (this.equals(val)) return true; // x => x regardless of its value

    if (this.kind === "||") {
      let [x, y] = this.args;
      let xi = x.implies(val, depth + 1) || x instanceof AbstractValue && this.$Realm.pathConditions.impliesNot(x, depth + 1);
      if (!xi) return false;
      let yi = y.implies(val, depth + 1) || y instanceof AbstractValue && this.$Realm.pathConditions.impliesNot(y, depth + 1);
      return yi;
    } else if (this.kind === "&&") {
      let [x, y] = this.args;
      let xi = x.implies(val, depth + 1) || x instanceof AbstractValue && this.$Realm.pathConditions.impliesNot(x, depth + 1);
      if (xi) return true;
      let yi = y.implies(val, depth + 1) || y instanceof AbstractValue && this.$Realm.pathConditions.impliesNot(y, depth + 1);
      return yi;
    } else if (this.kind === "!") {
      let [nx] = this.args;
      (0, _invariant.default)(nx instanceof AbstractValue);

      if (nx.kind === "!") {
        // !!x => val if x => val
        let [x] = nx.args;
        (0, _invariant.default)(x instanceof AbstractValue);
        return x.implies(val, depth + 1);
      }
    } else if (this.kind === "conditional") {
      let [c, x, y] = this.args; // (c ? x : y) => val if x is true and y is false and c = val

      if (!x.mightNotBeTrue() && !y.mightNotBeFalse()) {
        return c.equals(val);
      }

      if (val.kind === "!==" || val.kind === "!=") {
        let [vx, vy] = val.args;

        if (!x.mightNotBeFalse()) {
          // (c ? false : y) => vx !== undefined && vx !== null if y => vx, since val is false unless y is true
          if (vx instanceof AbstractValue && (vy instanceof _index.NullValue || vy instanceof _index.UndefinedValue)) return y.implies(vx, depth + 1); // (c ? false : y) => undefined !== vy && null !== vy if y => vy, since val is false unless y is true

          if ((vx instanceof _index.NullValue || vx instanceof _index.UndefinedValue) && vy instanceof AbstractValue) return y.implies(vy, depth + 1);
        } else if (!y.mightNotBeFalse()) {
          // (c ? x : false) => vx !== undefined && vx !== null if x => vx, since val is false unless x is true
          if (vx instanceof AbstractValue && (vy instanceof _index.NullValue || vy instanceof _index.UndefinedValue)) return x.implies(vx, depth + 1); // (c ? x : false) => undefined !== vy && null !== vy if x => vy, since val is false unless x is true

          if ((vx instanceof _index.NullValue || vx instanceof _index.UndefinedValue) && vy instanceof AbstractValue) return x.implies(vy, depth + 1);
        }
      } // (c ? x : false) => c && x (if c or x were falsy, (c ? x : false) could not be true)


      if (!y.mightNotBeFalse()) {
        if (c.implies(val, depth + 1)) return true;
        if (x.implies(val, depth + 1)) return true;
      }
    } else if (this.kind === "!==") {
      // (0 !== x) => x since undefined, null, false, 0, NaN and "" are excluded by the !== and all other values are thruthy
      let [x, y] = this.args;
      if (x instanceof _index.NumberValue && x.value === 0) return y.equals(val);
      if (y instanceof _index.NumberValue && y.value === 0) return x.equals(val);
    } else if ((this.kind === "===" || this.kind === "==") && (val.kind === "===" || val.kind === "==")) {
      let [x, y] = this.args;
      let [vx, vy] = val.args;

      if (x instanceof _index.NullValue || x instanceof _index.UndefinedValue) {
        if (val.kind === "==") {
          // null/undefined === y && null/undefined === vy && y === vy => null/undefined == vy
          if (vx instanceof _index.NullValue || vx instanceof _index.UndefinedValue) return y.equals(vy); // null/undefined === y && vx === null/undefined && y === vx => null/undefined == vx

          if (vy instanceof _index.NullValue || vy instanceof _index.UndefinedValue) return y.equals(vx);
        } else {
          (0, _invariant.default)(val.kind === "==="); // null === y && null === vy && y === vy => null === vy
          // undefined === y && undefined === vy && y === vy => undefined === vy

          if (x.equals(vx)) return y.equals(vy); // null === y && vx === null && y === vx => vx === null
          // undefined === y && vx === undefined && y === vx => vx === undefined

          if (x.equals(vy)) return y.equals(vx);
        }
      }

      if (y instanceof _index.NullValue || y instanceof _index.UndefinedValue) {
        if (val.kind === "==") {
          // x === null/undefined && null/undefined === vy && x === vy => null/undefined == vy
          if (vx instanceof _index.NullValue || vx instanceof _index.UndefinedValue) return x.equals(vy); // x === null/undefined && vx === null/undefined && x === vx => null/undefined == vx

          if (vy instanceof _index.NullValue || vy instanceof _index.UndefinedValue) return x.equals(vx);
        } else {
          (0, _invariant.default)(val.kind === "==="); // x === null && null === vy && x === vy => null === vy
          // x == undefined && undefined === vy && x === vy => undefined === vy

          if (y.equals(vx)) return x.equals(vy); // x === null && vx === null && x === vx => null == vy
          // x === undefined && vx === undefined && x === vx => vx === undefined

          if (y.equals(vy)) return x.equals(vx);
        }
      }
    } // x => !y if y => !x


    if (val.kind === "!") {
      let [y] = val.args;
      (0, _invariant.default)(y instanceof AbstractValue);
      return y.impliesNot(this, depth + 1);
    }

    return false;
  } // this => !val. A false value does not imply that !(this => !val).


  impliesNot(val, depth = 0) {
    if (depth > 5) return false;
    if (this.equals(val)) return false; // x => x regardless of its value, hence x => !val is false

    if (this.kind === "||") {
      let [x, y] = this.args;
      let xi = x.impliesNot(val, depth + 1);
      if (!xi) return false;
      let yi = y.impliesNot(val, depth + 1);
      return yi;
    } else if (this.kind === "&&") {
      let [x, y] = this.args;
      let xi = x.impliesNot(val, depth + 1);
      if (xi) return true;
      let yi = y.impliesNot(val, depth + 1);
      return yi;
    } else if (this.kind === "!") {
      let [nx] = this.args;
      (0, _invariant.default)(nx instanceof AbstractValue);

      if (nx.kind === "!") {
        // !!x => !y if y => !x
        let [x] = nx.args;
        (0, _invariant.default)(x instanceof AbstractValue);
        return x.impliesNot(val, depth + 1);
      }

      if (nx.kind === "abstractConcreteUnion") return false; // can't use two valued logic for this.
      // !x => !val if val => x since if val is false x can be any value and if val is true then x must be true

      return val.implies(nx);
    } else if (this.kind === "conditional") {
      let [c, x, y] = this.args; // (c ? x : y) => !val if x is false and y is true and c = val

      if (!x.mightNotBeFalse() && !y.mightNotBeTrue()) {
        return c.equals(val);
      }

      if (val.kind === "===" || val.kind === "==") {
        let [vx, vy] = val.args;

        if (!x.mightNotBeFalse()) {
          // (c ? false : y) => !(vx === undefined) && !(vx === null) if y => vx, since val is false unless y is true
          if (vx instanceof AbstractValue && (vy instanceof _index.NullValue || vy instanceof _index.UndefinedValue)) return y.implies(vx, depth + 1); // (c ? false : y) => !(undefined === vy) && !(null === vy) if y => vy, since val is false unless y is true

          if ((vx instanceof _index.NullValue || vx instanceof _index.UndefinedValue) && vy instanceof AbstractValue) return y.implies(vy, depth + 1);
        } else if (!y.mightNotBeFalse()) {
          // (c ? x : false) => !(vx === undefined) && !(vx === null) if x => vx, since val is false unless x is true
          if (vx instanceof AbstractValue && (vy instanceof _index.NullValue || vy instanceof _index.UndefinedValue)) return x.implies(vx, depth + 1); // (c ? x : false) => !(undefined === vy) && !(null !== vy) if x => vy, since val is false unless x is true

          if ((vx instanceof _index.NullValue || vx instanceof _index.UndefinedValue) && vy instanceof AbstractValue) return x.implies(vy, depth + 1);
        }
      } // (c ? x : false) => c && x (if c or x were falsy, (c ? x : false) could not be true)


      if (!y.mightNotBeFalse()) {
        if (c.impliesNot(val, depth + 1)) return true;
        if (x.impliesNot(val, depth + 1)) return true;
      }
    } else if (this.kind === "===" && val.kind === "===") {
      // x === y and y !== z => !(x === z)
      let [x1, y1] = this.args;
      let [x2, y2] = val.args;
      if (x1.equals(x2) && y1 instanceof _index.ConcreteValue && y2 instanceof _index.ConcreteValue && !y1.equals(y2)) return true; // x === y and x !== z => !(z === y)

      if (y1.equals(y2) && x1 instanceof _index.ConcreteValue && x2 instanceof _index.ConcreteValue && !x1.equals(x2)) {
        return true;
      }
    }

    return false;
  }

  isTemporal() {
    return this.$Realm.getTemporalOperationEntryFromDerivedValue(this) !== undefined;
  } // todo: abstract values should never be of type UndefinedValue or NullValue, assert this


  mightBeFalse() {
    let valueType = this.getType();
    if (valueType === _index.UndefinedValue) return true;
    if (valueType === _index.NullValue) return true;
    if (valueType === _index.SymbolValue) return false;
    if (_index.Value.isTypeCompatibleWith(valueType, _index.ObjectValue)) return false;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightBeFalse()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.mightBeFalse();
  }

  mightNotBeFalse() {
    let valueType = this.getType();
    if (valueType === _index.UndefinedValue) return false;
    if (valueType === _index.NullValue) return false;
    if (valueType === _index.SymbolValue) return true;
    if (_index.Value.isTypeCompatibleWith(valueType, _index.ObjectValue)) return true;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightNotBeFalse()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.mightNotBeFalse();
  }

  mightBeNull() {
    let valueType = this.getType();
    if (valueType === _index.NullValue) return true;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return false;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightBeNull()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueOfType(_index.NullValue);
  }

  mightNotBeNull() {
    let valueType = this.getType();
    if (valueType === _index.NullValue) return false;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return true;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightNotBeNull()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueNotOfType(_index.NullValue);
  }

  mightBeNumber() {
    let valueType = this.getType();
    if (_index.Value.isTypeCompatibleWith(valueType, _index.NumberValue)) return true;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return false;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightBeNumber()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueOfType(_index.NumberValue);
  }

  mightNotBeNumber() {
    let valueType = this.getType();
    if (_index.Value.isTypeCompatibleWith(valueType, _index.NumberValue)) return false;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return true;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightNotBeNumber()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueNotOfType(_index.NumberValue);
  }

  mightNotBeObject() {
    let valueType = this.getType();
    if (_index.Value.isTypeCompatibleWith(valueType, _index.PrimitiveValue)) return true;
    if (_index.Value.isTypeCompatibleWith(valueType, _index.ObjectValue)) return false;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightNotBeObject()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueNotOfType(_index.ObjectValue);
  }

  mightBeObject() {
    let valueType = this.getType();
    if (_index.Value.isTypeCompatibleWith(valueType, _index.PrimitiveValue)) return false;
    if (_index.Value.isTypeCompatibleWith(valueType, _index.ObjectValue)) return true;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightBeObject()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueOfType(_index.ObjectValue);
  }

  mightBeString() {
    let valueType = this.getType();
    if (valueType === _index.StringValue) return true;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return false;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightBeString()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueOfType(_index.StringValue);
  }

  mightNotBeString() {
    let valueType = this.getType();
    if (valueType === _index.StringValue) return false;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return true;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightNotBeString()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueNotOfType(_index.StringValue);
  }

  mightBeUndefined() {
    let valueType = this.getType();
    if (valueType === _index.UndefinedValue) return true;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return false;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightBeUndefined()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueOfType(_index.UndefinedValue);
  }

  mightNotBeUndefined() {
    let valueType = this.getType();
    if (valueType === _index.UndefinedValue) return false;
    if (valueType === _index.EmptyValue) return false;
    if (valueType !== _index.PrimitiveValue && valueType !== _index.Value) return true;

    if (this.kind === "abstractConcreteUnion") {
      for (let arg of this.args) if (arg.mightNotBeUndefined()) return true;

      return false;
    }

    if (this.values.isTop()) return true;
    return this.values.includesValueNotOfType(_index.UndefinedValue);
  }

  mightHaveBeenDeleted() {
    return this.mightBeEmpty;
  }

  promoteEmptyToUndefined() {
    if (this.values.isTop()) return this;
    if (!this.mightBeEmpty) return this;
    let cond = AbstractValue.createFromBinaryOp(this.$Realm, "===", this, this.$Realm.intrinsics.empty);
    let result = AbstractValue.createFromConditionalOp(this.$Realm, cond, this.$Realm.intrinsics.undefined, this);
    if (result instanceof AbstractValue) result.values = this.values.promoteEmptyToUndefined();
    return result;
  }

  throwIfNotConcrete() {
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  throwIfNotConcreteNumber() {
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  throwIfNotConcreteString() {
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  throwIfNotConcreteBoolean() {
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  throwIfNotConcreteSymbol() {
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  throwIfNotConcreteObject() {
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  throwIfNotConcretePrimitive() {
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  throwIfNotObject() {
    (0, _invariant.default)(!(this instanceof _index.AbstractObjectValue));
    AbstractValue.reportIntrospectionError(this);
    throw new _errors.FatalError();
  }

  static createJoinConditionForSelectedCompletions(selector, completion) {
    let jcw;
    let jc = completion.joinCondition;
    let realm = jc.$Realm;
    let njc = AbstractValue.createFromUnaryOp(realm, "!", jc, true, undefined, true);

    if (completion instanceof _completions.JoinedNormalAndAbruptCompletions && completion.composedWith !== undefined) {
      jcw = AbstractValue.createJoinConditionForSelectedCompletions(selector, completion.composedWith);
      jc = AbstractValue.createFromLogicalOp(realm, "&&", jcw, jc, undefined, true);
      njc = AbstractValue.createFromLogicalOp(realm, "&&", jcw, njc, undefined, true);
    }

    let c = completion.consequent;
    let a = completion.alternate;
    let cContainsSelectedCompletion = c.containsSelectedCompletion(selector);
    let aContainsSelectedCompletion = a.containsSelectedCompletion(selector);

    if (!cContainsSelectedCompletion && !aContainsSelectedCompletion) {
      if (jcw !== undefined) return jcw;
      return realm.intrinsics.false;
    }

    let cCond = jc;

    if (cContainsSelectedCompletion) {
      if (c instanceof _completions.JoinedAbruptCompletions || c instanceof _completions.JoinedNormalAndAbruptCompletions) {
        let jcc = AbstractValue.createJoinConditionForSelectedCompletions(selector, c);
        cCond = AbstractValue.createFromLogicalOp(realm, "&&", cCond, jcc, undefined, true);
      }

      if (!aContainsSelectedCompletion) return cCond;
    }

    let aCond = njc;

    if (aContainsSelectedCompletion) {
      if (a instanceof _completions.JoinedAbruptCompletions || a instanceof _completions.JoinedNormalAndAbruptCompletions) {
        let jac = AbstractValue.createJoinConditionForSelectedCompletions(selector, a);
        aCond = AbstractValue.createFromLogicalOp(realm, "&&", aCond, jac, undefined, true);
      }

      if (!cContainsSelectedCompletion) return aCond;
    }

    let or = AbstractValue.createFromLogicalOp(realm, "||", cCond, aCond, undefined, true);

    if (completion instanceof _completions.JoinedNormalAndAbruptCompletions && completion.composedWith !== undefined) {
      let composedCond = AbstractValue.createJoinConditionForSelectedCompletions(selector, completion.composedWith);
      let and = AbstractValue.createFromLogicalOp(realm, "&&", composedCond, or, undefined, true);
      return and;
    }

    return or;
  }

  static createFromBinaryOp(realm, op, left, right, loc, kind, isCondition, doNotSimplify) {
    let leftTypes, leftValues;

    if (left instanceof AbstractValue) {
      leftTypes = left.types;
      leftValues = left.values;
    } else {
      leftTypes = new _index3.TypesDomain(left.getType());
      (0, _invariant.default)(left instanceof _index.ConcreteValue);
      leftValues = new _index3.ValuesDomain(left);
    }

    let rightTypes, rightValues;

    if (right instanceof AbstractValue) {
      rightTypes = right.types;
      rightValues = right.values;
    } else {
      rightTypes = new _index3.TypesDomain(right.getType());
      (0, _invariant.default)(right instanceof _index.ConcreteValue);
      rightValues = new _index3.ValuesDomain(right);
    }

    let resultTypes = _index3.TypesDomain.binaryOp(op, leftTypes, rightTypes);

    let resultValues = kind === "template for property name condition" ? _index3.ValuesDomain.topVal : _index3.ValuesDomain.binaryOp(realm, op, leftValues, rightValues);
    let [hash, args] = kind === undefined ? (0, _index2.hashBinary)(op, left, right) : (0, _index2.hashCall)(kind, left, right);
    let operationDescriptor = (0, _generator.createOperationDescriptor)("BINARY_EXPRESSION", {
      binaryOperator: op
    });
    let result = new AbstractValue(realm, resultTypes, resultValues, hash, args, operationDescriptor);
    result.kind = kind || op;
    result.expressionLocation = loc;
    if (doNotSimplify) return result;
    return isCondition ? realm.simplifyAndRefineAbstractCondition(result) : realm.simplifyAndRefineAbstractValue(result);
  }

  static createFromLogicalOp(realm, op, left, right, loc, isCondition, doNotSimplify) {
    let leftTypes, leftValues;

    if (left instanceof AbstractValue) {
      leftTypes = left.types;
      leftValues = left.values;
    } else {
      leftTypes = new _index3.TypesDomain(left.getType());
      (0, _invariant.default)(left instanceof _index.ConcreteValue);
      leftValues = new _index3.ValuesDomain(left);
    }

    let rightTypes, rightValues;

    if (right instanceof AbstractValue) {
      rightTypes = right.types;
      rightValues = right.values;
    } else {
      rightTypes = new _index3.TypesDomain(right.getType());
      (0, _invariant.default)(right instanceof _index.ConcreteValue);
      rightValues = new _index3.ValuesDomain(right);
    }

    let resultTypes = _index3.TypesDomain.logicalOp(op, leftTypes, rightTypes);

    let resultValues = _index3.ValuesDomain.logicalOp(realm, op, leftValues, rightValues);

    let [hash, args] = (0, _index2.hashCall)(op, left, right);
    let Constructor = _index.Value.isTypeCompatibleWith(resultTypes.getType(), _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    let operationDescriptor = (0, _generator.createOperationDescriptor)("LOGICAL_EXPRESSION", {
      logicalOperator: op
    });
    let result = new Constructor(realm, resultTypes, resultValues, hash, args, operationDescriptor);
    result.kind = op;
    result.expressionLocation = loc;
    if (doNotSimplify) return result;
    return isCondition ? realm.simplifyAndRefineAbstractCondition(result) : realm.simplifyAndRefineAbstractValue(result);
  }

  static createFromConditionalOp(realm, condition, left, right, loc, isCondition, doNotSimplify) {
    if (left === right) {
      return left || realm.intrinsics.undefined;
    }

    if (!condition.mightNotBeTrue()) return left || realm.intrinsics.undefined;
    if (!condition.mightNotBeFalse()) return right || realm.intrinsics.undefined;

    let types = _index3.TypesDomain.joinValues(left, right);

    if (types.getType() === _index.NullValue) return realm.intrinsics.null;
    if (types.getType() === _index.UndefinedValue) return realm.intrinsics.undefined;

    let values = _index3.ValuesDomain.joinValues(realm, left, right);

    let [hash, args] = (0, _index2.hashTernary)(condition, left || realm.intrinsics.undefined, right || realm.intrinsics.undefined);
    let Constructor = _index.Value.isTypeCompatibleWith(types.getType(), _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    let operationDescriptor = (0, _generator.createOperationDescriptor)("CONDITIONAL_EXPRESSION");
    let result = new Constructor(realm, types, values, hash, args, operationDescriptor, {
      kind: "conditional"
    });
    result.expressionLocation = loc;
    if (left) result.mightBeEmpty = left.mightHaveBeenDeleted();
    if (right && !result.mightBeEmpty) result.mightBeEmpty = right.mightHaveBeenDeleted();
    if (doNotSimplify || result.mightBeEmpty) return result;
    return isCondition ? realm.simplifyAndRefineAbstractCondition(result) : realm.simplifyAndRefineAbstractValue(result);
  }

  static createFromUnaryOp(realm, op, operand, prefix, loc, isCondition, doNotSimplify) {
    (0, _invariant.default)(op !== "delete" && op !== "++" && op !== "--"); // The operation must be pure

    let resultTypes = _index3.TypesDomain.unaryOp(op, new _index3.TypesDomain(operand.getType()));

    let resultValues = _index3.ValuesDomain.unaryOp(realm, op, operand.values);

    let operationDescriptor = (0, _generator.createOperationDescriptor)("UNARY_EXPRESSION", {
      unaryOperator: op,
      prefix
    });
    let result = new AbstractValue(realm, resultTypes, resultValues, (0, _index2.hashUnary)(op, operand), [operand], operationDescriptor);
    result.kind = op;
    result.expressionLocation = loc;
    if (doNotSimplify) return result;
    return isCondition ? realm.simplifyAndRefineAbstractCondition(result) : realm.simplifyAndRefineAbstractValue(result);
  }
  /* Note that the template is parameterized by the names A, B, C and so on.
     When the abstract value is serialized, the serialized operations are substituted
     for the corresponding parameters and the resulting template is parsed into an AST subtree
     that is incorporated into the AST produced by the serializer. */


  static createFromTemplate(realm, templateSource, resultType, operands, loc) {
    let kind = AbstractValue.makeKind("template", templateSource);
    let resultTypes = new _index3.TypesDomain(resultType);
    let resultValues = _index3.ValuesDomain.topVal;
    let hash;
    [hash, operands] = (0, _index2.hashCall)(kind, ...operands);
    let Constructor = _index.Value.isTypeCompatibleWith(resultType, _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    (0, _invariant.default)(_PreludeGenerator.Placeholders.length >= operands.length);
    let operationDescriptor = (0, _generator.createOperationDescriptor)("ABSTRACT_FROM_TEMPLATE", {
      templateSource
    }); // This doesn't mean that the function is not pure, just that it creates
    // a new object on each call and thus is a future optimization opportunity.

    if (_index.Value.isTypeCompatibleWith(resultType, _index.ObjectValue)) hash = ++realm.objectCount;
    let result = new Constructor(realm, resultTypes, resultValues, hash, operands, operationDescriptor);
    result.kind = kind;
    result.expressionLocation = loc || realm.currentLocation;
    return result;
  }

  static createFromType(realm, resultType, kind, operands) {
    let types = new _index3.TypesDomain(resultType);
    let Constructor = _index.Value.isTypeCompatibleWith(resultType, _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    let [hash, args] = (0, _index2.hashCall)(resultType.name + (kind || ""), ...(operands || []));
    if (_index.Value.isTypeCompatibleWith(resultType, _index.ObjectValue)) hash = ++realm.objectCount;
    let result = new Constructor(realm, types, _index3.ValuesDomain.topVal, hash, args);
    if (kind) result.kind = kind;
    result.expressionLocation = realm.currentLocation;
    return result;
  }
  /* Emits a declaration for an identifier into the generator at the current point in time
     and initializes it with an expression constructed from the given template.
     Returns an abstract value that refers to the newly declared identifier.
     Note that the template must generate an expression which has no side-effects
     on the prepack state. It is assumed, however, that there could be side-effects
     on the native state unless the isPure option is specified.  */


  static createTemporalFromTemplate(realm, templateSource, resultType, operands, optionalArgs) {
    (0, _invariant.default)(resultType !== _index.UndefinedValue);
    let temp = AbstractValue.createFromTemplate(realm, templateSource, resultType, operands);
    let types = temp.types;
    let values = temp.values;
    let args = temp.args;
    (0, _invariant.default)(realm.generator !== undefined);
    (0, _invariant.default)(temp.operationDescriptor !== undefined);
    return realm.generator.deriveAbstract(types, values, args, temp.operationDescriptor, optionalArgs);
  }

  static createFromBuildFunction(realm, resultType, args, operationDescriptor, optionalArgs) {
    let types = new _index3.TypesDomain(resultType);
    let values = _index3.ValuesDomain.topVal;
    let Constructor = _index.Value.isTypeCompatibleWith(resultType, _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    let kind = optionalArgs && optionalArgs.kind || "build function";
    let hash;
    [hash, args] = (0, _index2.hashCall)(kind, ...args);
    let result = new Constructor(realm, types, values, hash, args, operationDescriptor);
    result.kind = kind;
    return result;
  }

  static createTemporalFromBuildFunction(realm, resultType, args, operationDescriptor, optionalArgs) {
    let types = new _index3.TypesDomain(resultType);
    let values = _index3.ValuesDomain.topVal;
    (0, _invariant.default)(realm.generator !== undefined);

    if (resultType === _index.UndefinedValue) {
      return realm.generator.emitVoidExpression(types, values, args, operationDescriptor);
    } else {
      return realm.generator.deriveAbstract(types, values, args, operationDescriptor, optionalArgs);
    }
  }

  static convertToTemporalIfArgsAreTemporal(realm, val, condArgs) {
    if (condArgs === undefined) condArgs = val.args;
    let temporalArg = condArgs.find(arg => arg.isTemporal());

    if (temporalArg !== undefined) {
      let realmGenerator = realm.generator;
      (0, _invariant.default)(realmGenerator !== undefined);
      (0, _invariant.default)(val.operationDescriptor !== undefined);
      return realmGenerator.deriveAbstract(val.types, val.values, val.args, val.operationDescriptor);
    } else {
      return val;
    }
  }

  static dischargeValuesFromUnion(realm, union) {
    (0, _invariant.default)(union instanceof AbstractValue && union.kind === "abstractConcreteUnion");
    let abstractValue = union.args[0];
    (0, _invariant.default)(abstractValue instanceof AbstractValue);
    let concreteValues = union.args.filter(e => e instanceof _index.ConcreteValue);
    (0, _invariant.default)(concreteValues.length === union.args.length - 1);

    if (!abstractValue.isTemporal()) {
      // We make the abstract value in an abstract concrete union temporal, as it is predicated
      // on the conditions that preclude the concrete values in the union. The type invariant
      // also only applies in that condition, so it is skipped when deriving the value
      // See #2327
      let realmGenerator = realm.generator;
      (0, _invariant.default)(realmGenerator !== undefined);
      (0, _invariant.default)(abstractValue.operationDescriptor !== undefined);
      abstractValue = realmGenerator.deriveAbstract(abstractValue.types, abstractValue.values, abstractValue.args, abstractValue.operationDescriptor, {
        isPure: true,
        skipInvariant: true
      });
    }

    return [abstractValue, concreteValues];
  } // Creates a union of an abstract value with one or more concrete values.
  // The operation descriptor for the abstract values becomes the operation descriptor for the union.
  // Use this only to allow instrinsic abstract objects to be null and/or undefined.


  static createAbstractConcreteUnion(realm, abstractValue, concreteValues) {
    (0, _invariant.default)(concreteValues.length > 0);
    (0, _invariant.default)(abstractValue instanceof AbstractValue);
    let checkedConcreteValues = concreteValues.filter(e => e instanceof _index.ConcreteValue);
    (0, _invariant.default)(checkedConcreteValues.length === concreteValues.length);
    let concreteSet = new Set(checkedConcreteValues);
    let values;

    if (!abstractValue.values.isTop()) {
      abstractValue.values.getElements().forEach(v => concreteSet.add(v));
      values = new _index3.ValuesDomain(concreteSet);
    } else {
      values = _index3.ValuesDomain.topVal;
    }

    let types = _index3.TypesDomain.topVal;
    let [hash, operands] = (0, _index2.hashCall)("abstractConcreteUnion", abstractValue, ...checkedConcreteValues);
    let result = new AbstractValue(realm, types, values, hash, operands, (0, _generator.createOperationDescriptor)("SINGLE_ARG"), {
      kind: "abstractConcreteUnion"
    });
    result.expressionLocation = realm.currentLocation;
    return result;
  }

  static createFromWidenedProperty(realm, resultTemplate, args, operationDescriptor) {
    let types = resultTemplate.types;
    let values = resultTemplate.values;
    let [hash] = (0, _index2.hashCall)("widened property", ...args);
    let Constructor = _index.Value.isTypeCompatibleWith(types.getType(), _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    let result = new Constructor(realm, types, values, hash, args, operationDescriptor);
    result.kind = "widened property";
    result.mightBeEmpty = resultTemplate.mightBeEmpty;
    result.expressionLocation = resultTemplate.expressionLocation;
    return result;
  }

  static createFromWidening(realm, value1, value2) {
    // todo: #1174 look at kind and figure out much narrower widenings
    let types = _index3.TypesDomain.joinValues(value1, value2);

    let values = _index3.ValuesDomain.topVal;
    let [hash] = (0, _index2.hashCall)("widened");
    let Constructor = _index.Value.isTypeCompatibleWith(types.getType(), _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    let result = new Constructor(realm, types, values, hash, []);
    result.kind = "widened";
    result.mightBeEmpty = value1.mightHaveBeenDeleted() || value2.mightHaveBeenDeleted();
    result.expressionLocation = value1.expressionLocation;
    return result;
  }

  static createAbstractArgument(realm, name, location, type = _index.Value, shape = undefined) {
    if (!realm.useAbstractInterpretation) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
    }

    let realmPreludeGenerator = realm.preludeGenerator;
    (0, _invariant.default)(realmPreludeGenerator);
    let types = new _index3.TypesDomain(type);
    let values = _index3.ValuesDomain.topVal;
    let Constructor = _index.Value.isTypeCompatibleWith(type, _index.ObjectValue) ? _index.AbstractObjectValue : AbstractValue;
    let operationDescriptor = (0, _generator.createOperationDescriptor)("IDENTIFIER", {
      id: name
    });
    let result = new Constructor(realm, types, values, 943586754858 + (0, _index2.hashString)(name), [], operationDescriptor);
    result.kind = AbstractValue.makeKind("abstractCounted", (realm.objectCount++).toString()); // need not be an object, but must be unique

    result.expressionLocation = location;
    result.shape = shape;
    return result;
  }

  static generateErrorInformationForAbstractVal(val) {
    let names = [];
    val.addSourceNamesTo(names);
    return `abstract value${names.length > 1 ? "s" : ""} ${names.join(" and ")}`;
  }

  static describe(val, propertyName) {
    let realm = val.$Realm;
    let identity;
    if (val === realm.$GlobalObject) identity = "global";else if (val instanceof AbstractValue) {
      identity = this.generateErrorInformationForAbstractVal(val);
    } else identity = val.intrinsicName || "(some value)";
    let source_locations = [];
    if (val instanceof AbstractValue) val.addSourceLocationsTo(source_locations);
    let location;

    if (propertyName instanceof _index.SymbolValue) {
      let desc = propertyName.$Description;

      if (desc) {
        location = `at symbol [${desc.throwIfNotConcreteString().value}]`;
      } else {
        location = `at symbol [${"(no description)"}]`;
      }
    } else if (propertyName instanceof _index.StringValue) location = `at ${propertyName.value}`;else if (typeof propertyName === "string") location = `at ${propertyName}`;else location = source_locations.length === 0 ? "" : `at ${source_locations.join("\n")}`;

    return `${identity} ${location}`;
  }

  static reportIntrospectionError(val, propertyName) {
    let message = "";
    if (!val.$Realm.suppressDiagnostics) message = `This operation is not yet supported on ${AbstractValue.describe(val, propertyName)}`;
    let realm = val.$Realm;
    return realm.reportIntrospectionError(message);
  }

  static createAbstractObject(realm, name, templateOrShape) {
    let value;

    if (templateOrShape === undefined) {
      templateOrShape = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
    }

    value = AbstractValue.createFromTemplate(realm, name, _index.ObjectValue, []);

    if (!realm.isNameStringUnique(name)) {
      value.hashValue = ++realm.objectCount;
    } else {
      realm.saveNameString(name);
    }

    value.intrinsicName = name;

    if (templateOrShape instanceof _index.ObjectValue) {
      templateOrShape.makePartial();
      templateOrShape.makeSimple();
      value.values = new _index3.ValuesDomain(new Set([templateOrShape]));
      realm.rebuildNestedProperties(value, name);
    } else {
      value.shape = templateOrShape;
    }

    (0, _invariant.default)(value instanceof _index.AbstractObjectValue);
    return value;
  }

  static makeKind(prefix, suffix) {
    return `${prefix}:${suffix}`;
  }

  static createTemporalObjectAssign(realm, to, sources) {
    // Tell serializer that it may add properties to to only after temporalTo has been emitted
    let temporalArgs = [to, ...sources];
    let preludeGenerator = realm.preludeGenerator;
    (0, _invariant.default)(preludeGenerator !== undefined);
    let temporalTo = AbstractValue.createTemporalFromBuildFunction(realm, _index.ObjectValue, temporalArgs, (0, _generator.createOperationDescriptor)("OBJECT_ASSIGN"), {
      skipInvariant: true,
      mutatesOnly: [to]
    });
    (0, _invariant.default)(temporalTo instanceof _index.AbstractObjectValue);

    if (to instanceof _index.AbstractObjectValue) {
      temporalTo.values = to.values;
    } else {
      (0, _invariant.default)(to instanceof _index.ObjectValue);
      temporalTo.values = new _index3.ValuesDomain(to);
    }

    to.temporalAlias = temporalTo;
    return temporalTo;
  }

}

exports.default = AbstractValue;
//# sourceMappingURL=AbstractValue.js.map

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(15);

var _index3 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _generator = __webpack_require__(237);

var _realm = __webpack_require__(7);

var _completions = __webpack_require__(18);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class AbstractObjectValue extends _index.AbstractValue {
  constructor(realm, types, values, hashValue, args, operationDescriptor, optionalArgs) {
    super(realm, types, values, hashValue, args, operationDescriptor, optionalArgs);

    if (!values.isTop()) {
      for (let element of this.values.getElements()) (0, _invariant.default)(element instanceof _index.ObjectValue);
    }
  }

  getTemplate() {
    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);

      if (element.isPartialObject()) {
        return element;
      } else {
        break;
      }
    }

    _index.AbstractValue.reportIntrospectionError(this);

    throw new _errors.FatalError();
  }

  set temporalAlias(temporalValue) {
    if (this.values.isTop()) {
      _index.AbstractValue.reportIntrospectionError(this);

      throw new _errors.FatalError();
    }

    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);
      element.temporalAlias = temporalValue;
    }
  }

  hasStringOrSymbolProperties() {
    if (this.values.isTop()) return false;

    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);
      if (element.hasStringOrSymbolProperties()) return true;
    }

    return false;
  }

  isPartialObject() {
    // At the very least, the identity of the object is unknown
    return true;
  }

  isSimpleObject() {
    if (this.cachedIsSimpleObject === undefined) this.cachedIsSimpleObject = this._elementsAreSimpleObjects();
    return this.cachedIsSimpleObject;
  }

  _elementsAreSimpleObjects() {
    if (this.values.isTop()) return false;
    let result;

    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);

      if (result === undefined) {
        result = element.isSimpleObject();
      } else if (result !== element.isSimpleObject()) {
        _index.AbstractValue.reportIntrospectionError(this);

        throw new _errors.FatalError();
      }
    }

    if (result === undefined) {
      _index.AbstractValue.reportIntrospectionError(this);

      throw new _errors.FatalError();
    }

    return result;
  }

  mightBeFinalObject() {
    // modeled objects are always read-only
    if (this.shape) return true;
    if (this.values.isTop()) return false;

    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);
      if (element.mightBeFinalObject()) return true;
    }

    return false;
  }

  mightNotBeFinalObject() {
    // modeled objects are always read-only
    if (this.shape) return false;
    if (this.values.isTop()) return false;

    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);
      if (element.mightNotBeFinalObject()) return true;
    }

    return false;
  }

  mightBeFalse() {
    return false;
  }

  mightNotBeFalse() {
    return true;
  }

  makePartial() {
    if (this.values.isTop()) {
      _index.AbstractValue.reportIntrospectionError(this);

      throw new _errors.FatalError();
    }

    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);
      element.makePartial();
    }
  }

  makeSimple(option) {
    if (this.values.isTop() && this.getType() === _index.ObjectValue) {
      let obj = new _index.ObjectValue(this.$Realm, this.$Realm.intrinsics.ObjectPrototype);
      obj.intrinsicName = this.intrinsicName;
      obj.intrinsicNameGenerated = true;
      obj.makePartial();
      obj._templateFor = this;
      this.values = new _index2.ValuesDomain(obj);
    }

    if (!this.values.isTop()) {
      for (let element of this.values.getElements()) {
        (0, _invariant.default)(element instanceof _index.ObjectValue);
        element.makeSimple(option);
      }
    }

    this.cachedIsSimpleObject = true;
  } // Use this only if it is known that only the string properties of the snapshot will be accessed.


  getSnapshot(options) {
    if (this.isIntrinsic()) return this; // already temporal

    if (this.values.isTop()) return this; // always the same

    if (this.kind === "conditional") {
      let [c, l, r] = this.args;
      (0, _invariant.default)(l instanceof _index.ObjectValue || l instanceof AbstractObjectValue);
      let ls = l.getSnapshot(options);
      (0, _invariant.default)(r instanceof _index.ObjectValue || r instanceof AbstractObjectValue);
      let rs = r.getSnapshot(options);
      (0, _invariant.default)(c instanceof _index.AbstractValue);

      let absVal = _index.AbstractValue.createFromConditionalOp(this.$Realm, c, ls, rs, this.expressionLocation);

      (0, _invariant.default)(absVal instanceof AbstractObjectValue);
      return absVal;
    } // If this is some other kind of abstract object we don't know how to make a copy, so just make this final


    this.makeFinal();
    return this;
  }

  makeFinal() {
    if (this.shape) return;

    if (this.values.isTop()) {
      _index.AbstractValue.reportIntrospectionError(this);

      throw new _errors.FatalError();
    }

    for (let element of this.values.getElements()) {
      (0, _invariant.default)(element instanceof _index.ObjectValue);
      element.makeFinal();
    }
  }

  throwIfNotObject() {
    return this;
  }

  usesOrdinaryObjectInternalPrototypeMethods() {
    return true;
  } // ECMA262 9.1.1


  $GetPrototypeOf() {
    let realm = this.$Realm;

    if (this.values.isTop()) {
      let error = new _errors.CompilerDiagnostic("prototype access on unknown object", this.$Realm.currentLocation, "PP0032", "FatalError");
      this.$Realm.handleError(error);
      throw new _errors.FatalError();
    }

    (0, _invariant.default)(this.kind !== "widened", "widening currently always leads to top values");
    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$GetPrototypeOf();
      }

      (0, _invariant.default)(false);
    } else if (this.kind === "conditional") {
      // this is the join of two concrete/abstract objects
      let [cond, ob1, ob2] = this.args;
      (0, _invariant.default)(cond instanceof _index.AbstractValue);
      (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue);
      let p1 = ob1.$GetPrototypeOf();
      let p2 = ob2.$GetPrototypeOf();

      let joinedObject = _index.AbstractValue.createFromConditionalOp(realm, cond, p1, p2);

      (0, _invariant.default)(joinedObject instanceof AbstractObjectValue || joinedObject instanceof _index.ObjectValue || joinedObject instanceof _index.NullValue);
      return joinedObject;
    } else if (this.kind === "explicit conversion to object") {
      let primitiveValue = this.args[0];
      (0, _invariant.default)(!_index.Value.isTypeCompatibleWith(primitiveValue.getType(), _index.PrimitiveValue));

      let result = _index.AbstractValue.createFromBuildFunction(realm, _index.ObjectValue, [primitiveValue], (0, _generator.createOperationDescriptor)("ABSTRACT_OBJECT_GET_PROTO_OF"));

      (0, _invariant.default)(result instanceof AbstractObjectValue);
      return result;
    } else {
      let joinedObject;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        let p = cv.$GetPrototypeOf();

        if (joinedObject === undefined) {
          joinedObject = p;
        } else {
          let cond = _index.AbstractValue.createFromBinaryOp(realm, "===", this, cv, this.expressionLocation);

          joinedObject = _index.AbstractValue.createFromConditionalOp(realm, cond, p, joinedObject);
        }
      }

      (0, _invariant.default)(joinedObject instanceof AbstractObjectValue || joinedObject instanceof _index.ObjectValue || joinedObject instanceof _index.NullValue);
      return joinedObject;
    }
  } // ECMA262 9.1.3


  $IsExtensible() {
    return false;
  } // ECMA262 9.1.5


  $GetOwnProperty(_P) {
    let P = _P;
    if (P instanceof _index.StringValue) P = P.value;

    if (this.values.isTop()) {
      let error = new _errors.CompilerDiagnostic("property access on unknown object", this.$Realm.currentLocation, "PP0031", "FatalError");
      this.$Realm.handleError(error);
      throw new _errors.FatalError();
    }

    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$GetOwnProperty(P);
      }

      (0, _invariant.default)(false);
    } else if (this.kind === "conditional") {
      // this is the join of two concrete/abstract objects
      let [cond, ob1, ob2] = this.args;
      (0, _invariant.default)(cond instanceof _index.AbstractValue);
      (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue);
      let d1 = ob1.$GetOwnProperty(P);
      let d2 = ob2.$GetOwnProperty(P);
      return _singletons.Join.joinDescriptors(this.$Realm, cond, d1, d2);
    } else if (this.kind === "widened") {
      // This abstract object was created by repeated assignments of freshly allocated objects to the same binding inside a loop
      let [ob1, ob2] = this.args; // ob1: summary of iterations 1...n, ob2: summary of iteration n+1

      (0, _invariant.default)(ob1 instanceof _index.ObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue);
      let d1 = ob1.$GetOwnProperty(P);
      let d2 = ob2.$GetOwnProperty(P);

      if (d1 === undefined || d2 === undefined) {
        // We do not handle the case where different loop iterations result in different kinds of propperties
        _index.AbstractValue.reportIntrospectionError(this, P);

        throw new _errors.FatalError();
      }

      d1 = d1.throwIfNotConcrete(this.$Realm);
      d2 = d2.throwIfNotConcrete(this.$Realm);

      if (!(0, _descriptors.equalDescriptors)(d1, d2)) {
        _index.AbstractValue.reportIntrospectionError(this, P);

        throw new _errors.FatalError();
      }

      let desc = (0, _descriptors.cloneDescriptor)(d1);
      (0, _invariant.default)(desc !== undefined);

      if ((0, _index3.IsDataDescriptor)(this.$Realm, desc)) {
        // Values may be different, i.e. values may be loop variant, so the widened value summarizes the entire loop
        // equalDescriptors guarantees that both have value props and if you have a value prop is value is defined.
        let d1Value = d1.value;
        (0, _invariant.default)(d1Value instanceof _index.Value);
        let d2Value = d2.value;
        (0, _invariant.default)(d2Value instanceof _index.Value);

        let dValue = _singletons.Widen.widenValues(this.$Realm, d1Value, d2Value);

        (0, _invariant.default)(dValue instanceof _index.Value);
        desc.value = dValue;
      } else {// In this case equalDescriptors guarantees exact equality betwee d1 and d2.
        // Inlining the accessors will eventually bring in data properties if the accessors have loop variant behavior
      }

      return desc;
    } else {
      let first = true;
      let joinedDescriptor;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        let desc = cv.$GetOwnProperty(P);

        if (first) {
          first = false;
          joinedDescriptor = desc;
        } else {
          let cond = _index.AbstractValue.createFromBinaryOp(this.$Realm, "===", this, cv, this.expressionLocation);

          (0, _invariant.default)(cond instanceof _index.AbstractValue);
          joinedDescriptor = _singletons.Join.joinDescriptors(this.$Realm, cond, desc, joinedDescriptor);
        }
      }

      return joinedDescriptor;
    }
  } // ECMA262 9.1.6


  $DefineOwnProperty(_P, _Desc) {
    let P = _P;
    if (P instanceof _index.StringValue) P = P.value;

    if (this.values.isTop()) {
      _index.AbstractValue.reportIntrospectionError(this, P);

      throw new _errors.FatalError();
    }

    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$DefineOwnProperty(P, _Desc);
      }

      (0, _invariant.default)(false);
    } else {
      let Desc = _Desc.throwIfNotConcrete(this.$Realm);

      if (!(0, _index3.IsDataDescriptor)(this.$Realm, Desc)) {
        _index.AbstractValue.reportIntrospectionError(this, P);

        throw new _errors.FatalError();
      } // Extract the first existing descriptor to get its existing attributes as defaults.


      let firstExistingDesc;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        firstExistingDesc = cv.$GetOwnProperty(P);

        if (firstExistingDesc) {
          break;
        }
      }

      if (firstExistingDesc) {
        firstExistingDesc = firstExistingDesc.throwIfNotConcrete(this.$Realm);
      }

      let desc = new _descriptors.PropertyDescriptor({
        value: Desc.value !== undefined ? Desc.value : this.$Realm.intrinsics.undefined,
        writable: Desc.writable !== undefined ? Desc.writable : firstExistingDesc ? firstExistingDesc.writable : false,
        enumerable: Desc.enumerable !== undefined ? Desc.enumerable : firstExistingDesc ? firstExistingDesc.enumerable : false,
        configurable: Desc.configurable !== undefined ? Desc.configurable : firstExistingDesc ? firstExistingDesc.configurable : false
      });
      let newVal = desc.value;

      if (this.kind === "conditional") {
        // this is the join of two concrete/abstract objects
        let [cond, ob1, ob2] = this.args;
        (0, _invariant.default)(cond instanceof _index.AbstractValue);
        (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
        (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue);
        let d1 = ob1.$GetOwnProperty(P);
        let d2 = ob2.$GetOwnProperty(P);

        if (d1 !== undefined) {
          d1 = d1.throwIfNotConcrete(this.$Realm);

          if (!(0, _descriptors.equalDescriptors)(d1, desc)) {
            _index.AbstractValue.reportIntrospectionError(this, P);

            throw new _errors.FatalError();
          }
        }

        if (d2 !== undefined) {
          d2 = d2.throwIfNotConcrete(this.$Realm);

          if (!(0, _descriptors.equalDescriptors)(d2, desc)) {
            _index.AbstractValue.reportIntrospectionError(this, P);

            throw new _errors.FatalError();
          }
        }

        let oldVal1 = d1 === undefined || d1.value === undefined ? this.$Realm.intrinsics.empty : d1.value;
        let oldVal2 = d2 === undefined || d2.value === undefined ? this.$Realm.intrinsics.empty : d2.value;
        (0, _invariant.default)(oldVal1 instanceof _index.Value);
        (0, _invariant.default)(oldVal2 instanceof _index.Value);

        let newVal1 = _index.AbstractValue.createFromConditionalOp(this.$Realm, cond, newVal, oldVal1);

        let newVal2 = _index.AbstractValue.createFromConditionalOp(this.$Realm, cond, oldVal2, newVal);

        desc.value = newVal1;
        let result1 = ob1.$DefineOwnProperty(P, desc);
        desc.value = newVal2;
        let result2 = ob2.$DefineOwnProperty(P, desc);

        if (result1 !== result2) {
          _index.AbstractValue.reportIntrospectionError(this, P);

          throw new _errors.FatalError();
        }

        return result1;
      } else {
        (0, _invariant.default)(newVal instanceof _index.Value);
        let sawTrue = false;
        let sawFalse = false;

        for (let cv of elements) {
          (0, _invariant.default)(cv instanceof _index.ObjectValue);
          let d = cv.$GetOwnProperty(P);

          if (d !== undefined) {
            d = d.throwIfNotConcrete(this.$Realm);

            if (!(0, _descriptors.equalDescriptors)(d, desc)) {
              _index.AbstractValue.reportIntrospectionError(this, P);

              throw new _errors.FatalError();
            }
          }

          let dval = d === undefined || d.value === undefined ? this.$Realm.intrinsics.empty : d.value;
          (0, _invariant.default)(dval instanceof _index.Value);

          let cond = _index.AbstractValue.createFromBinaryOp(this.$Realm, "===", this, cv, this.expressionLocation);

          desc.value = _index.AbstractValue.createFromConditionalOp(this.$Realm, cond, newVal, dval);

          if (cv.$DefineOwnProperty(P, desc)) {
            sawTrue = true;
          } else sawFalse = true;
        }

        if (sawTrue && sawFalse) {
          _index.AbstractValue.reportIntrospectionError(this, P);

          throw new _errors.FatalError();
        }

        return sawTrue;
      }
    }
  } // ECMA262 9.1.7


  $HasProperty(_P) {
    let P = _P;
    if (P instanceof _index.StringValue) P = P.value;

    if (this.values.isTop()) {
      let error = new _errors.CompilerDiagnostic("property access on unknown object", this.$Realm.currentLocation, "PP0031", "FatalError");
      this.$Realm.handleError(error);
      throw new _errors.FatalError();
    }

    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$HasProperty(P);
      }

      (0, _invariant.default)(false);
    } else {
      let hasProp = false;
      let doesNotHaveProp = false;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        if (cv.$HasProperty(P)) hasProp = true;else doesNotHaveProp = true;
      }

      if (hasProp && doesNotHaveProp) {
        _index.AbstractValue.reportIntrospectionError(this, P);

        throw new _errors.FatalError();
      }

      return hasProp;
    }
  } // ECMA262 9.1.8


  $Get(_P, Receiver) {
    let P = _P;
    if (P instanceof _index.StringValue) P = P.value;

    if (this.values.isTop()) {
      let generateAbstractGet = () => {
        let ob = Receiver;
        if (this.kind === "explicit conversion to object") ob = this.args[0];
        let type = _index.Value;
        if (P === "length" && _index.Value.isTypeCompatibleWith(this.getType(), _index.ArrayValue)) type = _index.NumberValue; // shape logic

        let shapeContainer = this.kind === "explicit conversion to object" ? this.args[0] : this;
        (0, _invariant.default)(shapeContainer instanceof _index.AbstractValue);
        let realm = this.$Realm;
        let shape = shapeContainer.shape;
        let propertyShape, propertyGetter; // propertyShape expects only a string value

        if ((realm.instantRender.enabled || realm.react.enabled) && shape !== undefined && (typeof P === "string" || P instanceof _index.StringValue)) {
          propertyShape = shape.getPropertyShape(P instanceof _index.StringValue ? P.value : P);

          if (propertyShape !== undefined) {
            type = propertyShape.getAbstractType();
            propertyGetter = propertyShape.getGetter();
          }
        } // P can also be a SymbolValue


        if (typeof P === "string") {
          P = new _index.StringValue(this.$Realm, P);
        } // Create an temporal array with widened properties


        if (type === _index.ArrayValue) {
          return _index.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [ob, P], (0, _generator.createOperationDescriptor)("ABSTRACT_OBJECT_GET", {
            propertyGetter
          }));
        }

        let propAbsVal = _index.AbstractValue.createTemporalFromBuildFunction(realm, type, [ob, P], (0, _generator.createOperationDescriptor)("ABSTRACT_OBJECT_GET", {
          propertyGetter
        }), {
          skipInvariant: true,
          isPure: true,
          shape: propertyShape
        });

        return propAbsVal;
      };

      if (this.isSimpleObject() && this.isIntrinsic()) {
        return generateAbstractGet();
      } else if (this.$Realm.isInPureScope()) {
        // This object might have leaked to a getter.
        _singletons.Leak.value(this.$Realm, Receiver); // The getter might throw anything.


        return this.$Realm.evaluateWithPossibleThrowCompletion(generateAbstractGet, _index2.TypesDomain.topVal, _index2.ValuesDomain.topVal);
      }

      let error = new _errors.CompilerDiagnostic("property access on unknown object", this.$Realm.currentLocation, "PP0031", "FatalError");
      this.$Realm.handleError(error);
      throw new _errors.FatalError();
    }

    let realm = this.$Realm;
    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$Get(P, Receiver);
      }

      (0, _invariant.default)(false);
    } else if (this.kind === "conditional") {
      // this is the join of two concrete/abstract objects
      let [cond, ob1, ob2] = this.args;
      (0, _invariant.default)(cond instanceof _index.AbstractValue);
      (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue); // Evaluate the effect of each getter separately and join the result.

      return realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => ob1.$Get(P, Receiver), undefined, "ConditionalGet/1"), () => realm.evaluateForEffects(() => ob2.$Get(P, Receiver), undefined, "ConditionalGet/2"));
    } else {
      let result;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);

        let cond = _index.AbstractValue.createFromBinaryOp(this.$Realm, "===", this, cv, this.expressionLocation);

        (0, _invariant.default)(cond instanceof _index.AbstractValue);
        result = realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => cv.$Get(P, Receiver), undefined, "AbstractGet"), () => (0, _realm.construct_empty_effects)(realm, result === undefined ? undefined : new _completions.SimpleNormalCompletion(result)));
      }

      (0, _invariant.default)(result !== undefined);
      return result;
    }
  }

  $GetPartial(P, Receiver) {
    if (!(P instanceof _index.AbstractValue)) return this.$Get(P, Receiver);

    if (this.values.isTop() || !this.isSimpleObject()) {
      if (this.isSimpleObject() && this.isIntrinsic()) {
        return _index.AbstractValue.createTemporalFromBuildFunction(this.$Realm, _index.Value, [this, P], (0, _generator.createOperationDescriptor)("ABSTRACT_OBJECT_GET_PARTIAL"), {
          skipInvariant: true,
          isPure: true
        });
      }

      if (this.$Realm.isInPureScope()) {
        // If we're in a pure scope, we can leak the key and the instance,
        // and leave the residual property access in place.
        // We assume that if the receiver is different than this object,
        // then we only got here because there can be no other keys with
        // this name on earlier parts of the prototype chain.
        // We have to leak since the property may be a getter or setter,
        // which can run unknown code that has access to Receiver and
        // (even in pure mode) can modify it in unknown ways.
        _singletons.Leak.value(this.$Realm, Receiver); // Coercion can only have effects on anything reachable from the key.


        _singletons.Leak.value(this.$Realm, P);

        return _index.AbstractValue.createTemporalFromBuildFunction(this.$Realm, _index.Value, [Receiver, P], (0, _generator.createOperationDescriptor)("ABSTRACT_OBJECT_GET_PARTIAL"), {
          skipInvariant: true,
          isPure: true
        });
      }

      let error = new _errors.CompilerDiagnostic("property access on unknown object", this.$Realm.currentLocation, "PP0031", "FatalError");
      this.$Realm.handleError(error);
      throw new _errors.FatalError();
    }

    let realm = this.$Realm;
    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$GetPartial(P, Receiver);
      }

      (0, _invariant.default)(false);
    } else if (this.kind === "conditional") {
      // this is the join of two concrete/abstract objects
      let [cond, ob1, ob2] = this.args;
      (0, _invariant.default)(cond instanceof _index.AbstractValue);
      (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue); // Evaluate the effect of each getter separately and join the result.

      return realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => ob1.$GetPartial(P, Receiver), undefined, "ConditionalGet/1"), () => realm.evaluateForEffects(() => ob2.$GetPartial(P, Receiver), undefined, "ConditionalGet/2"));
    } else {
      let result;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);

        let cond = _index.AbstractValue.createFromBinaryOp(this.$Realm, "===", this, cv, this.expressionLocation);

        (0, _invariant.default)(cond instanceof _index.AbstractValue);
        result = realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => cv.$GetPartial(P, Receiver), undefined, "AbstractGet"), () => (0, _realm.construct_empty_effects)(realm, result === undefined ? undefined : new _completions.SimpleNormalCompletion(result)));
      }

      (0, _invariant.default)(result !== undefined);
      return result;
    }
  } // ECMA262 9.1.9


  $Set(P, V, Receiver) {
    if (this.values.isTop()) {
      return this.$SetPartial(P, V, Receiver);
    }

    let realm = this.$Realm;
    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$Set(P, V, Receiver);
      }

      (0, _invariant.default)(false);
    } else if (this.kind === "conditional") {
      // this is the join of two concrete/abstract objects
      let [cond, ob1, ob2] = this.args;
      (0, _invariant.default)(cond instanceof _index.AbstractValue);
      (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue); // Evaluate the effect of each setter separately and join the effects.

      let result = realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => new _index.BooleanValue(realm, ob1.$Set(P, V, Receiver)), undefined, "ConditionalSet/1"), () => realm.evaluateForEffects(() => new _index.BooleanValue(realm, ob2.$Set(P, V, Receiver)), undefined, "ConditionalSet/2"));

      if (!(result instanceof _index.BooleanValue)) {
        let error = new _errors.CompilerDiagnostic("object could have both succeeded and failed updating", realm.currentLocation, "PP0041", "RecoverableError");

        if (realm.handleError(error) === "Recover") {
          return true;
        }

        throw new _errors.FatalError();
      }

      return result.value;
    } else {
      let sawTrue = false;
      let sawFalse = false;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue); // Evaluate the effect of each setter separately and join the effects.

        let cond = _index.AbstractValue.createFromBinaryOp(this.$Realm, "===", this, cv, this.expressionLocation);

        (0, _invariant.default)(cond instanceof _index.AbstractValue);
        realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => {
          if (cv.$Set(P, V, Receiver)) {
            sawTrue = true;
          } else {
            sawFalse = true;
          }

          return realm.intrinsics.empty;
        }, undefined, "AbstractSet"), () => (0, _realm.construct_empty_effects)(realm));
      }

      if (sawTrue && sawFalse) {
        let error = new _errors.CompilerDiagnostic("object could have both succeeded and failed updating", realm.currentLocation, "PP0041", "RecoverableError");

        if (realm.handleError(error) === "Recover") {
          return true;
        }
      }

      return sawTrue;
    }
  }

  $SetPartial(_P, V, Receiver) {
    let P = _P;
    if (!this.values.isTop() && !(P instanceof _index.AbstractValue)) return this.$Set(P, V, Receiver);

    if (this.values.isTop()) {
      if (this.$Realm.isInPureScope()) {
        // If we're in a pure scope, we can leak the key and the instance,
        // and leave the residual property assignment in place.
        // We assume that if the receiver is different than this object,
        // then we only got here because there can be no other keys with
        // this name on earlier parts of the prototype chain.
        // We have to leak since the property may be a getter or setter,
        // which can run unknown code that has access to Receiver and
        // (even in pure mode) can modify it in unknown ways.
        _singletons.Leak.value(this.$Realm, Receiver); // We also need to leaked the value since it might leak to a setter.


        _singletons.Leak.value(this.$Realm, V);

        this.$Realm.evaluateWithPossibleThrowCompletion(() => {
          let generator = this.$Realm.generator;
          (0, _invariant.default)(generator);

          if (typeof P !== "string" && !(P instanceof _index.StringValue)) {
            // Coercion can only have effects on anything reachable from the key.
            _singletons.Leak.value(this.$Realm, P);
          }

          generator.emitPropertyAssignment(Receiver, P, V);
          return this.$Realm.intrinsics.undefined;
        }, _index2.TypesDomain.topVal, _index2.ValuesDomain.topVal); // The emitted assignment might throw at runtime but if it does, that
        // is handled by evaluateWithPossibleThrowCompletion. Anything that
        // happens after this, can assume we didn't throw and therefore,
        // we return true here.

        return true;
      }

      let error = new _errors.CompilerDiagnostic("property access on unknown object", this.$Realm.currentLocation, "PP0031", "FatalError");
      this.$Realm.handleError(error);
      throw new _errors.FatalError();
    }

    let realm = this.$Realm;
    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$SetPartial(P, V, Receiver);
      }

      (0, _invariant.default)(false);
    } else if (this.kind === "conditional") {
      // this is the join of two concrete/abstract objects
      let [cond, ob1, ob2] = this.args;
      (0, _invariant.default)(cond instanceof _index.AbstractValue);
      (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue); // Evaluate the effect of each setter separately and join the effects.

      let result = realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => new _index.BooleanValue(realm, ob1.$SetPartial(P, V, Receiver)), undefined, "ConditionalSet/1"), () => realm.evaluateForEffects(() => new _index.BooleanValue(realm, ob2.$SetPartial(P, V, Receiver)), undefined, "ConditionalSet/2"));

      if (!(result instanceof _index.BooleanValue)) {
        let error = new _errors.CompilerDiagnostic("object could have both succeeded and failed updating", realm.currentLocation, "PP0041", "RecoverableError");

        if (realm.handleError(error) === "Recover") {
          return true;
        }

        throw new _errors.FatalError();
      }

      return result.value;
    } else {
      let sawTrue = false;
      let sawFalse = false;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue); // Evaluate the effect of each setter separately and join the effects.

        let cond = _index.AbstractValue.createFromBinaryOp(this.$Realm, "===", this, cv, this.expressionLocation);

        (0, _invariant.default)(cond instanceof _index.AbstractValue);
        realm.evaluateWithAbstractConditional(cond, () => realm.evaluateForEffects(() => {
          if (cv.$SetPartial(P, V, Receiver)) {
            sawTrue = true;
          } else {
            sawFalse = true;
          }

          return realm.intrinsics.empty;
        }, undefined, "AbstractSet"), () => (0, _realm.construct_empty_effects)(realm));
      }

      if (sawTrue && sawFalse) {
        let error = new _errors.CompilerDiagnostic("object could have both succeeded and failed updating", realm.currentLocation, "PP0041", "RecoverableError");

        if (realm.handleError(error) === "Recover") {
          return true;
        }
      }

      return sawTrue;
    }
  } // ECMA262 9.1.10


  $Delete(_P) {
    let P = _P;
    if (P instanceof _index.StringValue) P = P.value;

    if (this.values.isTop()) {
      _index.AbstractValue.reportIntrospectionError(this, P);

      throw new _errors.FatalError();
    }

    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$Delete(P);
      }

      (0, _invariant.default)(false);
    } else if (this.kind === "conditional") {
      // this is the join of two concrete/abstract objects
      let [cond, ob1, ob2] = this.args;
      (0, _invariant.default)(cond instanceof _index.AbstractValue);
      (0, _invariant.default)(ob1 instanceof _index.ObjectValue || ob1 instanceof AbstractObjectValue);
      (0, _invariant.default)(ob2 instanceof _index.ObjectValue || ob2 instanceof AbstractObjectValue);
      let d1 = ob1.$GetOwnProperty(P);
      let d2 = ob2.$GetOwnProperty(P);
      let oldVal1 = d1 === undefined ? this.$Realm.intrinsics.empty : (0, _index3.IsDataDescriptor)(this.$Realm, d1) ? d1.value : undefined;
      let oldVal2 = d2 === undefined ? this.$Realm.intrinsics.empty : (0, _index3.IsDataDescriptor)(this.$Realm, d2) ? d2.value : undefined;

      if (oldVal1 === undefined || oldVal2 === undefined) {
        _index.AbstractValue.reportIntrospectionError(this, P);

        throw new _errors.FatalError();
      }

      (0, _invariant.default)(oldVal1 instanceof _index.Value);
      (0, _invariant.default)(oldVal2 instanceof _index.Value);

      let newVal1 = _index.AbstractValue.createFromConditionalOp(this.$Realm, cond, this.$Realm.intrinsics.empty, oldVal1);

      let newVal2 = _index.AbstractValue.createFromConditionalOp(this.$Realm, cond, oldVal2, this.$Realm.intrinsics.empty);

      let result1 = true;
      let result2 = true;

      if (d1 !== undefined) {
        d1 = d1.throwIfNotConcrete(this.$Realm);
        let newDesc1 = (0, _descriptors.cloneDescriptor)(d1);
        (0, _invariant.default)(newDesc1);
        newDesc1 = newDesc1.throwIfNotConcrete(this.$Realm);
        newDesc1.value = newVal1;
        result1 = ob1.$DefineOwnProperty(P, newDesc1);
      }

      if (d2 !== undefined) {
        d2 = d2.throwIfNotConcrete(this.$Realm);
        let newDesc2 = (0, _descriptors.cloneDescriptor)(d2);
        (0, _invariant.default)(newDesc2);
        newDesc2 = newDesc2.throwIfNotConcrete(this.$Realm);
        newDesc2.value = newVal2;
        result2 = ob2.$DefineOwnProperty(P, newDesc2);
      }

      if (result1 !== result2) {
        _index.AbstractValue.reportIntrospectionError(this, P);

        throw new _errors.FatalError();
      }

      return result1;
    } else {
      let sawTrue = false;
      let sawFalse = false;

      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        let d = cv.$GetOwnProperty(P);
        if (d === undefined) continue;

        if (!(0, _index3.IsDataDescriptor)(this.$Realm, d)) {
          _index.AbstractValue.reportIntrospectionError(this, P);

          throw new _errors.FatalError();
        }

        let cond = _index.AbstractValue.createFromBinaryOp(this.$Realm, "===", this, cv, this.expressionLocation);

        let dval = d.value;
        (0, _invariant.default)(dval instanceof _index.Value);

        let v = _index.AbstractValue.createFromConditionalOp(this.$Realm, cond, this.$Realm.intrinsics.empty, dval);

        let newDesc = (0, _descriptors.cloneDescriptor)(d);
        (0, _invariant.default)(newDesc);
        newDesc.value = v;
        if (cv.$DefineOwnProperty(P, newDesc)) sawTrue = true;else sawFalse = true;
      }

      if (sawTrue && sawFalse) {
        let error = new _errors.CompilerDiagnostic("object could have both succeeded and failed updating", this.$Realm.currentLocation, "PP0041", "RecoverableError");

        if (this.$Realm.handleError(error) === "Recover") {
          return true;
        }
      }

      return sawTrue;
    }
  }

  $OwnPropertyKeys(getOwnPropertyKeysEvenIfPartial = false) {
    if (this.values.isTop()) {
      _index.AbstractValue.reportIntrospectionError(this);

      throw new _errors.FatalError();
    }

    let elements = this.values.getElements();

    if (elements.size === 1) {
      for (let cv of elements) {
        (0, _invariant.default)(cv instanceof _index.ObjectValue);
        return cv.$OwnPropertyKeys(getOwnPropertyKeysEvenIfPartial);
      }

      (0, _invariant.default)(false);
    } else {
      _index.AbstractValue.reportIntrospectionError(this);

      throw new _errors.FatalError();
    }
  }

}

exports.default = AbstractObjectValue;
//# sourceMappingURL=AbstractObjectValue.js.map

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(397);

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(400);

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(401);

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(402);

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(403);

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(404);

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(405);

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(398) && __webpack_require__(399)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(398)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 398 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 399 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(398) && __webpack_require__(399)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(398)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(398) && __webpack_require__(399)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(398)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(398) && __webpack_require__(399)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(398)   // present with an AMD loader
);


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(398) && __webpack_require__(399)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__(398)   // present with an AMD loader
);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(398) && __webpack_require__(399)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(398)   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(92)(module)))

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

// Detect the global object, even if operating in strict mode.
// http://stackoverflow.com/a/14387057/265298
var global = (0, eval)('this'),
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(406);
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),
/* 406 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE__406__ === 'undefined') {var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE__406__;

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SerializerStatistics = void 0;

var _statistics = __webpack_require__(8);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class SerializerStatistics extends _statistics.RealmStatistics {
  constructor(getTime, getMemory, forcingGC = false) {
    super(getTime, getMemory);
    this.forcingGC = forcingGC;
    this.functions = 0;
    this.delayedValues = 0;
    this.initializedModules = 0;
    this.acceleratedModules = 0;
    this.delayedModules = 0;
    this.totalModules = 0;
    this.resetBeforePass();
    this.total = new _statistics.PerformanceTracker(getTime, getMemory);
    this.resolveInitializedModules = new _statistics.PerformanceTracker(getTime, getMemory);
    this.modulesToInitialize = new _statistics.PerformanceTracker(getTime, getMemory);
    this.optimizeReactComponentTreeRoots = new _statistics.PerformanceTracker(getTime, getMemory);
    this.checkThatFunctionsAreIndependent = new _statistics.PerformanceTracker(getTime, getMemory);
    this.processCollectedNestedOptimizedFunctions = new _statistics.PerformanceTracker(getTime, getMemory);
    this.deepTraversal = new _statistics.PerformanceTracker(getTime, getMemory);
    this.referentialization = new _statistics.PerformanceTracker(getTime, getMemory);
    this.referenceCounts = new _statistics.PerformanceTracker(getTime, getMemory);
    this.serializePass = new _statistics.PerformanceTracker(getTime, getMemory);
    this.babelGenerate = new _statistics.PerformanceTracker(getTime, getMemory);
    this.dumpIR = new _statistics.PerformanceTracker(getTime, getMemory);
  }

  resetBeforePass() {
    this.objects = 0;
    this.objectProperties = 0;
    this.functionClones = 0;
    this.lazyObjects = 0;
    this.referentialized = 0;
    this.valueIds = 0;
    this.valuesInlined = 0;
    this.generators = 0;
    this.requireCalls = 0;
    this.requireCallsReplaced = 0;
  }

  // legacy projection
  getSerializerStatistics() {
    return {
      objects: this.objects,
      objectProperties: this.objectProperties,
      functions: this.functions,
      functionClones: this.functionClones,
      lazyObjects: this.lazyObjects,
      referentialized: this.referentialized,
      valueIds: this.valueIds,
      valuesInlined: this.valuesInlined,
      delayedValues: this.delayedValues,
      initializedModules: this.initializedModules,
      acceleratedModules: this.acceleratedModules,
      delayedModules: this.delayedModules,
      totalModules: this.totalModules,
      generators: this.generators,
      requireCalls: this.requireCalls,
      requireCallsReplaced: this.requireCallsReplaced
    };
  }

  log() {
    super.log();
    console.log(`=== serialization statistics`);
    console.log(`${this.objects} objects with ${this.objectProperties} properties`);
    console.log(`${this.functions} functions plus ${this.functionClones} clones due to captured variables; ${this.referentialized} captured mutable variables`);
    console.log(`${this.lazyObjects} objects are lazy.`);
    console.log(`${this.valueIds} eager and ${this.delayedValues} delayed value ids generated, and ${this.valuesInlined} values inlined.`);
    console.log(`${this.initializedModules} out of ${this.totalModules} modules initialized, with ${this.acceleratedModules} accelerated and ${this.delayedModules} delayed.`);
    console.log(`${this.requireCallsReplaced} of ${this.requireCalls} require calls inlined.`);
    console.log(`${this.generators} generators`);
  }

  logSerializerPerformanceTrackers(title, note, format) {
    console.log(`=== ${title}: ${format(this.total)} total`);
    if (note !== undefined) console.log(`NOTE: ${note}`);
    this.logPerformanceTrackers(format);
    console.log(`${format(this.resolveInitializedModules)} resolving initialized modules, ${format(this.modulesToInitialize)} initializing more modules, ${format(this.optimizeReactComponentTreeRoots)} optimizing react component tree roots, ${format(this.checkThatFunctionsAreIndependent)} evaluating functions to optimize, ${format(this.dumpIR)} dumping IR`);
    console.log(`${format(this.deepTraversal)} visiting residual heap, ${format(this.referentialization)} referentializing functions, ${format(this.referenceCounts)} reference counting, ${format(this.serializePass)} generating AST, ${format(this.babelGenerate)} generating source code`);
  }

}

exports.SerializerStatistics = SerializerStatistics;
//# sourceMappingURL=statistics.js.map

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AreSameResidualBinding = AreSameResidualBinding;
exports.ReactStatistics = exports.BodyReference = void 0;

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _abstract = __webpack_require__(233);

var _realm = __webpack_require__(7);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function AreSameResidualBinding(realm, x, y) {
  if (x.serializedValue === y.serializedValue) return true;
  if (x.value && x.value === y.value) return true;

  if (x.value instanceof _index.ConcreteValue && y.value instanceof _index.ConcreteValue) {
    return (0, _abstract.SameValue)(realm, x.value, y.value);
  }

  return false;
}

class BodyReference {
  constructor(body, index) {
    (0, _invariant.default)(index >= 0);
    this.body = body;
    this.index = index;
  }

  isNotEarlierThan(other) {
    return this.body === other.body && this.index >= other.index;
  }

}

exports.BodyReference = BodyReference;

class ReactStatistics {
  constructor() {
    this.optimizedTrees = 0;
    this.inlinedComponents = 0;
    this.evaluatedRootNodes = [];
    this.componentsEvaluated = 0;
    this.optimizedNestedClosures = 0;
  }

}

exports.ReactStatistics = ReactStatistics;
//# sourceMappingURL=types.js.map

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Functions = void 0;

var _completions = __webpack_require__(18);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _realm = __webpack_require__(7);

var _errors2 = __webpack_require__(410);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _modules = __webpack_require__(411);

var _utils = __webpack_require__(413);

var _types = __webpack_require__(408);

var _utils2 = __webpack_require__(291);

var _optimizing = __webpack_require__(414);

var _babelhelpers = __webpack_require__(239);

var _singletons = __webpack_require__(236);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class Functions {
  constructor(realm, moduleTracer) {
    this.realm = realm;
    this.moduleTracer = moduleTracer;
    this._writeEffects = new Map();
    this._noopFunction = undefined;
    this._optimizedFunctionId = 0;
    this.reactFunctionMap = new Map();
  }

  _unwrapAbstract(value) {
    let elements = value.values.getElements();

    if (elements) {
      let possibleValues = [...elements].filter(element => !(element instanceof _index.EmptyValue || element instanceof _index.UndefinedValue));

      if (possibleValues.length === 1) {
        return possibleValues[0];
      }
    }

    return value;
  }

  _optimizedFunctionEntryOfValue(value) {
    let realm = this.realm; // if we conditionally called __optimize, we may have an AbstractValue that is the union of Empty or Undefined and
    // a function/component to optimize

    if (value instanceof _index.AbstractValue) {
      value = this._unwrapAbstract(value);
    }

    (0, _invariant.default)(value instanceof _index.ObjectValue); // React component tree logic

    let config = (0, _index2.Get)(realm, value, "config");
    let rootComponent = (0, _index2.Get)(realm, value, "rootComponent");
    let validConfig = config instanceof _index.ObjectValue || config === realm.intrinsics.undefined;
    let validRootComponent = rootComponent instanceof _index.ECMAScriptSourceFunctionValue || rootComponent instanceof _index.BoundFunctionValue || rootComponent instanceof _index.AbstractValue && (0, _utils2.valueIsKnownReactAbstraction)(this.realm, rootComponent);

    if (validConfig && validRootComponent) {
      return {
        value: rootComponent,
        config: (0, _utils2.convertConfigObjectToReactComponentTreeConfig)(realm, config)
      };
    }

    let location = (0, _babelhelpers.optionalStringOfLocation)(value.expressionLocation);
    let result = realm.handleError(new _errors.CompilerDiagnostic(`Optimized Function Value ${location} is an not a function or react element`, realm.currentLocation, "PP0033", "Warning")); // Here we can recover by ignoring the __optimize call and emit correct code

    if (result !== "Recover") throw new _errors.FatalError("Optimized Function Values must be functions or react elements");
  }

  _generateInitialAdditionalFunctions(globalKey) {
    let recordedAdditionalFunctions = [];
    let realm = this.realm;
    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(() => (0, _index2.Get)(realm, realm.$GlobalObject, globalKey), realm.intrinsics.undefined);
    (0, _invariant.default)(globalRecordedAdditionalFunctionsMap instanceof _index.ObjectValue);

    for (let funcId of _singletons.Properties.GetOwnPropertyKeysArray(realm, globalRecordedAdditionalFunctionsMap, true, false)) {
      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);

      if (property) {
        (0, _invariant.default)(property.descriptor instanceof _descriptors.PropertyDescriptor);
        let value = property.descriptor.value;
        (0, _invariant.default)(value !== undefined);

        let entry = this._optimizedFunctionEntryOfValue(value);

        if (entry) recordedAdditionalFunctions.push(entry);
      }
    }

    return recordedAdditionalFunctions;
  }

  _generateOptimizedFunctionsFromRealm() {
    let realm = this.realm;
    let recordedAdditionalFunctions = [];

    for (let [valueToOptimize, argModel] of realm.optimizedFunctions) {
      let value = valueToOptimize instanceof _index.AbstractValue ? this._unwrapAbstract(valueToOptimize) : valueToOptimize;
      (0, _invariant.default)(value instanceof _index.ECMAScriptSourceFunctionValue); // Check for case where __optimize was called in speculative context where effects were discarded

      if (!value.isValid()) {
        let error = new _errors.CompilerDiagnostic("Called __optimize on function in failed speculative context", value.expressionLocation, "PP1008", "RecoverableError");
        if (realm.handleError(error) !== "Recover") throw new _errors.FatalError();
      } else {
        recordedAdditionalFunctions.push({
          value,
          argModel
        });
      }
    }

    return recordedAdditionalFunctions;
  }

  optimizeReactComponentTreeRoots(statistics) {
    let logger = this.moduleTracer.modules.logger;

    let recordedReactRootValues = this._generateInitialAdditionalFunctions("__reactComponentTrees"); // Get write effects of the components


    if (this.realm.react.verbose) {
      logger.logInformation(`Evaluating ${recordedReactRootValues.length} React component tree roots...`);
    }

    let alreadyEvaluated = new Map();

    for (let _ref of recordedReactRootValues) {
      let {
        value: componentRoot,
        config
      } = _ref;
      (0, _invariant.default)(config);
      (0, _optimizing.optimizeReactComponentTreeRoot)(this.realm, componentRoot, config, this._writeEffects, logger, statistics, alreadyEvaluated, this.reactFunctionMap);
    }
  } // Note: this may only be used by nested optimized functions that are known to be evaluated inside of their parent
  // optimized function's __optimize call (e.g. array.map/filter). In this case, lexical nesting is equivalent to the
  // nesting of __optimize calls.


  getDeclaringOptimizedFunction(functionValue) {
    for (let [optimizedFunctionValue, additionalEffects] of this._writeEffects) {
      // CreatedObjects is all objects created by this optimized function but not
      // nested optimized functions.
      let createdObjects = additionalEffects.effects.createdObjects;
      if (createdObjects.has(functionValue)) return optimizedFunctionValue;
    }
  }

  processCollectedNestedOptimizedFunctions() {
    for (let [functionValue, effects] of this.realm.collectedNestedOptimizedFunctionEffects) {
      let additionalFunctionEffects = (0, _utils.createAdditionalEffects)(this.realm, effects, true, "AdditionalFunctionEffects", this._writeEffects, this.reactFunctionMap, functionValue, this.getDeclaringOptimizedFunction(functionValue));
      (0, _invariant.default)(additionalFunctionEffects !== null);

      this._writeEffects.set(functionValue, additionalFunctionEffects);
    }
  }

  _withEmptyOptimizedFunctionList({
    value,
    argModel
  }, func) {
    let oldRealmOptimizedFunctions = this.realm.optimizedFunctions;
    this.realm.optimizedFunctions = new Map();
    let currentOptimizedFunctionId = this._optimizedFunctionId++;
    (0, _invariant.default)(value instanceof _index.ECMAScriptSourceFunctionValue);

    for (let t1 of this.realm.tracers) t1.beginOptimizingFunction(currentOptimizedFunctionId, value);

    this.realm.withNewOptimizedFunction(() => func(value, argModel), value);

    for (let t2 of this.realm.tracers) t2.endOptimizingFunction(currentOptimizedFunctionId);

    for (let [oldValue, model] of oldRealmOptimizedFunctions) this.realm.optimizedFunctions.set(oldValue, model);
  }

  checkThatFunctionsAreIndependent() {
    let additionalFunctionsToProcess = this._generateOptimizedFunctionsFromRealm(); // When we find declarations of nested optimized functions, we need to apply the parent
    // effects.


    let additionalFunctionStack = [];
    let additionalFunctions = new Set(additionalFunctionsToProcess.map(entry => entry.value));

    let recordWriteEffectsForOptimizedFunctionAndNestedFunctions = (functionValue, argModel) => {
      additionalFunctionStack.push(functionValue);

      let call = _singletons.Utils.createModelledFunctionCall(this.realm, functionValue, argModel);

      let realm = this.realm;

      let logCompilerDiagnostic = (msg, location) => {
        let error = new _errors.CompilerDiagnostic(msg, location, "PP1007", "Warning");
        realm.handleError(error);
      };

      let effects = realm.evaluatePure(() => realm.evaluateForEffectsInGlobalEnv(call, undefined, "additional function"),
      /*bubbles*/
      true, (sideEffectType, binding, expressionLocation) => (0, _utils.handleReportedSideEffect)(logCompilerDiagnostic, sideEffectType, binding, expressionLocation));
      (0, _invariant.default)(effects);
      let additionalFunctionEffects = (0, _utils.createAdditionalEffects)(this.realm, effects, true, "AdditionalFunctionEffects", this._writeEffects, this.reactFunctionMap, functionValue, this.getDeclaringOptimizedFunction(functionValue));
      (0, _invariant.default)(additionalFunctionEffects);
      effects = additionalFunctionEffects.effects;

      if (this._writeEffects.has(functionValue)) {
        let error = new _errors.CompilerDiagnostic("Trying to optimize a function with two parent optimized functions, which is not currently allowed.", functionValue.expressionLocation, "PP1009", "RecoverableError"); // we can recover by assuming one set of effects to show further diagnostics

        if (realm.handleError(error) !== "Recover") throw new _errors.FatalError();
      } else {
        this._writeEffects.set(functionValue, additionalFunctionEffects);
      } // Conceptually this will ensure that the nested additional function is defined
      // although for later cases, we'll apply the effects of the parents only.


      this.realm.withEffectsAppliedInGlobalEnv(() => {
        let newOptFuncs = this._generateOptimizedFunctionsFromRealm();

        for (let newEntry of newOptFuncs) {
          additionalFunctions.add(newEntry.value);

          this._withEmptyOptimizedFunctionList(newEntry, recordWriteEffectsForOptimizedFunctionAndNestedFunctions);
        } // Now we have to remember the stack of effects that need to be applied to deal with
        // this additional function.


        return null;
      }, additionalFunctionEffects.effects);
      (0, _invariant.default)(additionalFunctionStack.pop() === functionValue);
    };

    for (let funcObject of additionalFunctionsToProcess) {
      this._withEmptyOptimizedFunctionList(funcObject, recordWriteEffectsForOptimizedFunctionAndNestedFunctions);
    }

    (0, _invariant.default)(additionalFunctionStack.length === 0); // check that functions are independent

    let conflicts = new Map();

    let isParentOf = (possibleParent, fun) => {
      if (fun === undefined) return false;

      let effects = this._writeEffects.get(fun);

      (0, _invariant.default)(effects !== undefined);

      if (effects.parentAdditionalFunction !== undefined) {
        if (effects.parentAdditionalFunction === possibleParent) return true;
        return isParentOf(possibleParent, effects.parentAdditionalFunction);
      }

      return false;
    };

    for (let fun1 of additionalFunctions) {
      (0, _invariant.default)(fun1 instanceof _index.FunctionValue);
      let fun1Location = fun1.expressionLocation;
      let fun1Name = fun1.getDebugName() || (0, _babelhelpers.optionalStringOfLocation)(fun1Location); // Also do argument validation here

      let additionalFunctionEffects = this._writeEffects.get(fun1);

      (0, _invariant.default)(additionalFunctionEffects !== undefined);
      let e1 = additionalFunctionEffects.effects;
      (0, _invariant.default)(e1 !== undefined);

      if (e1.result instanceof _completions.AbruptCompletion) {
        let error = new _errors.CompilerDiagnostic(`Additional function ${fun1Name} will terminate abruptly`, e1.result.location, "PP1002", "RecoverableError"); // We generate correct code in this case, but the user probably doesn't want us to emit an unconditional throw

        if (this.realm.handleError(error) !== "Recover") throw new _errors.FatalError();
      }

      for (let fun2 of additionalFunctions) {
        if (fun1 === fun2) continue;
        (0, _invariant.default)(fun2 instanceof _index.FunctionValue);
        let fun2Location = fun2.expressionLocation;
        let fun2Name = fun2.getDebugName() || (0, _babelhelpers.optionalStringOfLocation)(fun2Location);

        let reportFn = () => {
          this.reportWriteConflicts(fun1Name, fun2Name, conflicts, e1.modifiedProperties, isParentOf(fun1, fun2), _singletons.Utils.createModelledFunctionCall(this.realm, fun2));
          return null;
        }; // Recursively apply all parent effects


        let withPossibleParentEffectsApplied = (toExecute, optimizedFunction) => {
          let funEffects = this._writeEffects.get(optimizedFunction);

          (0, _invariant.default)(funEffects !== undefined);
          let parentAdditionalFunction = funEffects.parentAdditionalFunction;

          if (parentAdditionalFunction !== undefined) {
            let parentEffects = this._writeEffects.get(parentAdditionalFunction);

            (0, _invariant.default)(parentEffects !== undefined);

            let newToExecute = () => this.realm.withEffectsAppliedInGlobalEnv(toExecute, parentEffects.effects);

            withPossibleParentEffectsApplied(newToExecute, parentAdditionalFunction);
          } else {
            toExecute();
          }
        };

        withPossibleParentEffectsApplied(reportFn, fun2);
      }
    }

    if (conflicts.size > 0) {
      for (let diagnostic of conflicts.values()) if (this.realm.handleError(diagnostic) !== "Recover") throw new _errors.FatalError();
    }
  }

  getAdditionalFunctionValuesToEffects() {
    return this._writeEffects;
  }

  reportWriteConflicts(f1name, f2name, conflicts, pbs, f1IsParentOfF2, call2) {
    let reportConflict = (location, object = "", key, originalLocation) => {
      let firstLocationString = (0, _babelhelpers.optionalStringOfLocation)(originalLocation);
      let secondLocationString = (0, _babelhelpers.optionalStringOfLocation)(location);
      let propString = key ? ` "${key}"` : "";
      let objectString = object ? ` on object "${object}" ` : "";
      if (!objectString && key) objectString = " on <unnamed object> ";
      let error = new _errors.CompilerDiagnostic(`Write to property${propString}${objectString}at optimized function ${f1name}${firstLocationString} conflicts with access in function ${f2name}${secondLocationString}`, location, "PP1003", "RecoverableError");
      conflicts.set(location, error);
    };

    let writtenObjects = new Set();
    pbs.forEach((val, key, m) => {
      writtenObjects.add(key.object);
    });
    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;

    this.realm.reportObjectGetOwnProperties = ob => {
      let location = this.realm.currentLocation;
      (0, _invariant.default)(location);
      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location, ob.getDebugName(), undefined, ob.expressionLocation);
    };

    let oldReportPropertyAccess = this.realm.reportPropertyAccess;

    this.realm.reportPropertyAccess = (pb, isWrite) => {
      if (_index.ObjectValue.refuseSerializationOnPropertyBinding(pb)) return;
      let location = this.realm.currentLocation;
      if (!location) return; // happens only when accessing an additional function property

      if (pbs.has(pb) && (!f1IsParentOfF2 || isWrite) && !conflicts.has(location)) {
        let originalLocation = pb.descriptor instanceof _descriptors.PropertyDescriptor && pb.descriptor.value && !Array.isArray(pb.descriptor.value) ? pb.descriptor.value.expressionLocation : undefined;
        let keyString = pb.key instanceof _index.Value ? pb.key.toDisplayString() : pb.key;
        reportConflict(location, pb.object ? pb.object.getDebugName() : undefined, keyString, originalLocation);
      }
    };

    try {
      (0, _errors2.ignoreErrorsIn)(this.realm, () => this.realm.evaluateForEffectsInGlobalEnv(call2));
    } finally {
      this.realm.reportPropertyAccess = oldReportPropertyAccess;
      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;
    }
  }

}

exports.Functions = Functions;
//# sourceMappingURL=functions.js.map

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ignoreErrorsIn = ignoreErrorsIn;

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function ignoreErrorsIn(realm, f) {
  let savedHandler = realm.errorHandler;

  realm.errorHandler = d => "Recover";

  try {
    return f();
  } catch (err) {
    if (err instanceof _errors.FatalError) return undefined;
    throw err;
  } finally {
    realm.errorHandler = savedHandler;
  }
}
//# sourceMappingURL=errors.js.map

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Modules = exports.ModuleTracer = void 0;

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _index = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _index2 = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _logger = __webpack_require__(412);

var _statistics = __webpack_require__(407);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function downgradeErrorsToWarnings(realm, f) {
  let savedHandler = realm.errorHandler;

  function handler(e) {
    e.severity = "Warning";
    realm.errorHandler = savedHandler;

    try {
      return realm.handleError(e);
    } finally {
      realm.errorHandler = handler;
    }
  }

  realm.errorHandler = handler;

  try {
    return f();
  } finally {
    realm.errorHandler = savedHandler;
  }
}

class ModuleTracer extends _realm.Tracer {
  constructor(modules, logModules) {
    super();
    this.modules = modules;
    this.evaluateForEffectsNesting = 0;
    this.requireStack = [];
    this.requireSequence = [];
    this.logModules = logModules;
    this.uninitializedModuleIdsRequiredInEvaluateForEffects = new Set();
  }

  getStatistics() {
    return this.modules.getStatistics();
  }

  log(message) {
    if (this.logModules) console.log(`[modules] ${this.requireStack.map(_ => "  ").join("")}${message}`);
  }

  beginEvaluateForEffects(state) {
    if (state !== this) {
      this.log(">evaluate for effects");
      this.evaluateForEffectsNesting++;
      this.requireStack.push(undefined);
    }
  }

  endEvaluateForEffects(state, effects) {
    if (state !== this) {
      let popped = this.requireStack.pop();
      (0, _invariant.default)(popped === undefined);
      this.evaluateForEffectsNesting--;
      this.log("<evaluate for effects");
    }
  }

  _callRequireAndRecord(moduleIdValue, performCall) {
    if (this.requireStack.length === 0 || this.requireStack[this.requireStack.length - 1] !== moduleIdValue) {
      this.requireStack.push(moduleIdValue);

      try {
        let value = performCall();
        if (this.modules.moduleIds.has(moduleIdValue)) this.modules.recordModuleInitialized(moduleIdValue, value);
        return value;
      } finally {
        (0, _invariant.default)(this.requireStack.pop() === moduleIdValue);
      }
    }

    return undefined;
  }

  _tryExtractDependencies(value) {
    if (value === undefined || value instanceof _index2.NullValue || value instanceof _index2.UndefinedValue) return [];

    if (value instanceof _index2.ArrayValue) {
      const realm = this.modules.realm;
      const lengthValue = (0, _index.Get)(realm, value, "length");

      if (lengthValue instanceof _index2.NumberValue) {
        const dependencies = [];
        const logger = this.modules.logger;

        for (let i = 0; i < lengthValue.value; i++) {
          const elementValue = logger.tryQuery(() => (0, _index.Get)(realm, value, "" + i), realm.intrinsics.undefined);
          dependencies.push(elementValue);
        }

        return dependencies;
      }
    }

    return undefined;
  }

  detourCall(F, thisArgument, argumentsList, newTarget, performCall) {
    let requireInfo = this.modules.getRequireInfo();

    if (requireInfo !== undefined && F === requireInfo.value && argumentsList.length === 1) {
      // Here, we handle calls of the form
      //   require(42)
      let moduleId = argumentsList[0];
      let moduleIdValue; // Do some sanity checks and request require(...) calls with bad arguments

      if (moduleId instanceof _index2.NumberValue || moduleId instanceof _index2.StringValue) moduleIdValue = moduleId.value;else return performCall(); // call require(...); this might cause calls to the define function

      let res = this._callRequireAndRecord(moduleIdValue, performCall);

      if (F.$Realm.eagerlyRequireModuleDependencies) {
        // all dependencies of the required module should now be known
        let dependencies = this.modules.moduleDependencies.get(moduleIdValue);
        if (dependencies === undefined) this.modules.logger.logError(moduleId, `Cannot resolve module dependencies for ${moduleIdValue.toString()}.`);else for (let dependency of dependencies) {
          // We'll try to initialize module dependency on a best-effort basis,
          // ignoring any errors. Note that tryInitializeModule applies effects on success.
          if (dependency instanceof _index2.NumberValue || dependency instanceof _index2.StringValue) this.modules.tryInitializeModule(dependency.value, `Eager initialization of module ${dependency.value}`);
        }
      }

      return res;
    } else if (F === this.modules.getDefine()) {
      // Here, we handle calls of the form
      //   __d(factoryFunction, moduleId, dependencyArray)
      let moduleId = argumentsList[1];

      if (moduleId instanceof _index2.NumberValue || moduleId instanceof _index2.StringValue) {
        let moduleIdValue = moduleId.value;
        let factoryFunction = argumentsList[0];

        if (factoryFunction instanceof _index2.FunctionValue) {
          let dependencies = this._tryExtractDependencies(argumentsList[2]);

          if (dependencies !== undefined) {
            this.modules.moduleDependencies.set(moduleIdValue, dependencies);
            this.modules.factoryFunctionDependencies.set(factoryFunction, dependencies);
          } else this.modules.logger.logError(argumentsList[2], "Third argument to define function is present but not a concrete array.");
        } else this.modules.logger.logError(factoryFunction, "First argument to define function is not a function value.");

        this.modules.moduleIds.add(moduleIdValue);
      } else this.modules.logger.logError(moduleId, "Second argument to define function is not a number or string value.");
    }

    return undefined;
  }

}

exports.ModuleTracer = ModuleTracer;

class Modules {
  constructor(realm, logger, logModules) {
    this.realm = realm;
    this.logger = logger;
    this._define = realm.intrinsics.undefined;
    this.factoryFunctionDependencies = new Map();
    this.moduleDependencies = new Map();
    this.moduleIds = new Set();
    this.initializedModules = new Map();
    realm.tracers.push(this.moduleTracer = new ModuleTracer(this, logModules));
  }

  getStatistics() {
    (0, _invariant.default)(this.realm.statistics instanceof _statistics.SerializerStatistics, "serialization requires SerializerStatistics");
    return this.realm.statistics;
  }

  resolveInitializedModules() {
    let globalInitializedModulesMap = this._getGlobalProperty("__initializedModules");

    (0, _invariant.default)(globalInitializedModulesMap instanceof _index2.ObjectValue);

    for (let moduleId of globalInitializedModulesMap.properties.keys()) {
      let property = globalInitializedModulesMap.properties.get(moduleId);
      (0, _invariant.default)(property);

      if (property.descriptor instanceof _descriptors.PropertyDescriptor) {
        let moduleValue = property.descriptor && property.descriptor.value;

        if (moduleValue instanceof _index2.Value && !moduleValue.mightHaveBeenDeleted()) {
          this.initializedModules.set(moduleId, moduleValue);
        }
      }
    }

    this.getStatistics().initializedModules = this.initializedModules.size;
    this.getStatistics().totalModules = this.moduleIds.size;
  }

  _getGlobalProperty(name) {
    if (this.active) return this.realm.intrinsics.undefined;
    this.active = true;

    try {
      let realm = this.realm;
      return this.logger.tryQuery(() => (0, _index.Get)(realm, realm.$GlobalObject, name), realm.intrinsics.undefined);
    } finally {
      this.active = false;
    }
  }

  getRequireInfo() {
    if (this._requireInfo === undefined) for (let globalName of ["require", "__r"]) {
      let value = this._getGlobalProperty(globalName);

      if (value instanceof _index2.FunctionValue) {
        this._requireInfo = {
          value,
          globalName
        };
        break;
      }
    }
    return this._requireInfo;
  }

  getDefine() {
    if (!(this._define instanceof _index2.FunctionValue)) this._define = this._getGlobalProperty("__d");
    return this._define;
  } // Returns a function that checks if a call node represents a call to a
  // known require function, and if so, what module id that call indicates.
  // A known require function call is either of the form
  //   ... require(42) ...
  // where require resolves to the global require function, or
  //   factoryFunction(, require, , , dependencies) {
  //     ...
  //       ... require(dependencies[3]) ...
  // where factoryFunction and dependencies were announced as part of the
  // global code execution via a global module declaration call such as
  //   global.__d(factoryFunction, , [0,2,4,6,8])


  getGetModuleIdIfNodeIsRequireFunction(formalParameters, functions) {
    let realm = this.realm;
    let logger = this.logger;
    let modules = this;
    return (scope, node) => {
      // Are we calling a function that has a single name and a single argument?
      if (!t.isIdentifier(node.callee) || node.arguments.length !== 1) return undefined;
      let argument = node.arguments[0];
      if (!argument) return undefined;
      if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument) && !t.isMemberExpression(argument)) return undefined;
      (0, _invariant.default)(node.callee);
      let innerName = node.callee.name;
      let moduleId; // Helper function used to give up if we ever come up with different module ids for different functions

      let updateModuleId = newModuleId => {
        if (moduleId !== undefined && moduleId !== newModuleId) return false;
        moduleId = newModuleId;
        return true;
      }; // Helper function that retrieves module id from call argument, possibly chasing dependency array indirection


      const getModuleId = dependencies => {
        if (t.isMemberExpression(argument)) {
          if (dependencies !== undefined) {
            let memberExpression = argument;

            if (t.isIdentifier(memberExpression.object)) {
              let scopedBinding = scope.getBinding(memberExpression.object.name);

              if (scopedBinding && formalParameters[4] === scopedBinding.path.node) {
                if (t.isNumericLiteral(memberExpression.property)) {
                  let dependencyIndex = memberExpression.property.value;

                  if (Number.isInteger(dependencyIndex) && dependencyIndex >= 0 && dependencyIndex < dependencies.length) {
                    let dependency = dependencies[dependencyIndex];
                    if (dependency instanceof _index2.NumberValue || dependency instanceof _index2.StringValue) return dependency.value;
                  }
                }
              }
            }
          }
        } else {
          return argument.value;
        }
      }; // Let's consider each of the function instances (closures for the same code)


      for (let f of functions) {
        // 1. Let's check if we have a match for a factory function like
        //      factoryFunction(, require, , , [dependencies])
        //    which is used with the Metro bundler
        let scopedBinding = scope.getBinding(innerName);

        if (scopedBinding) {
          let dependencies = modules.factoryFunctionDependencies.get(f);

          if (dependencies !== undefined && formalParameters[1] === scopedBinding.path.node) {
            (0, _invariant.default)(scopedBinding.kind === "param");
            let newModuleId = getModuleId(dependencies);
            if (newModuleId !== undefined && !updateModuleId(newModuleId)) return undefined;
            continue;
          } // The name binds to some local entity, but nothing we'd know what exactly it is


          return undefined;
        } // 2. Let's check if we can resolve the called function just by looking at the
        //    function instance environment.
        //    TODO: We should not do this if the current node is in a nested function!
        // We won't have a dependency map here, so this only works for literal arguments.


        if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return undefined;
        let doesNotMatter = true;
        let reference = logger.tryQuery(() => _singletons.Environment.ResolveBinding(realm, innerName, doesNotMatter, f.$Environment), undefined);

        if (reference === undefined) {
          // We couldn't resolve as we came across some behavior that we cannot deal with abstractly
          return undefined;
        }

        if (_singletons.Environment.IsUnresolvableReference(realm, reference)) return undefined;
        let referencedBase = reference.base;
        let referencedName = reference.referencedName;
        if (typeof referencedName !== "string") return undefined;
        let value;

        if (reference.base instanceof _environment.GlobalEnvironmentRecord) {
          value = logger.tryQuery(() => (0, _index.Get)(realm, realm.$GlobalObject, innerName), realm.intrinsics.undefined);
        } else {
          (0, _invariant.default)(referencedBase instanceof _environment.DeclarativeEnvironmentRecord);
          let binding = referencedBase.bindings[referencedName];
          if (!binding.initialized) return undefined;
          value = binding.value;
        }

        let requireInfo = modules.getRequireInfo();
        if (requireInfo === undefined || value !== requireInfo.value) return undefined;
        const newModuleId = getModuleId();
        (0, _invariant.default)(newModuleId !== undefined);
        if (!updateModuleId(newModuleId)) return undefined;
      }

      return moduleId;
    };
  }

  recordModuleInitialized(moduleId, value) {
    this.realm.assignToGlobal(t.memberExpression(t.memberExpression(t.identifier("global"), t.identifier("__initializedModules")), t.identifier("" + moduleId)), value);
  }

  tryInitializeModule(moduleId, message) {
    let realm = this.realm;
    let requireInfo = this.getRequireInfo();
    if (requireInfo === undefined) return undefined;
    return downgradeErrorsToWarnings(realm, () => {
      try {
        let node = t.callExpression(t.identifier(requireInfo.globalName), [t.valueToNode(moduleId)]);
        let effects = realm.evaluateNodeForEffectsInGlobalEnv(node);
        realm.applyEffects(effects, message);
        return effects;
      } catch (err) {
        if (err instanceof _errors.FatalError) return undefined;else throw err;
      }
    });
  }

  initializeMoreModules(modulesToInitialize) {
    // partially evaluate all factory methods by calling require
    let count = 0;

    for (let moduleId of this.moduleIds) {
      if (modulesToInitialize !== "ALL" && !modulesToInitialize.has("" + moduleId)) continue;
      if (this.initializedModules.has(moduleId)) continue;
      let effects = this.tryInitializeModule(moduleId, `Speculative initialization of module ${moduleId}`);
      if (effects === undefined) continue;
      let result = effects.result;
      if (!(result instanceof _index2.Value)) continue; // module might throw

      count++;
      this.initializedModules.set(moduleId, result);
    }

    if (count > 0) console.log(`=== speculatively initialized ${count} additional modules`);
  }

}

exports.Modules = Modules;
//# sourceMappingURL=modules.js.map

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = void 0;

var _realm = __webpack_require__(7);

var _errors = __webpack_require__(3);

var _index = __webpack_require__(232);

var _completions = __webpack_require__(18);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class Logger {
  constructor(realm, internalDebug) {
    this.realm = realm;
    this._hasErrors = false;
    this.internalDebug = internalDebug;
  }

  // Wraps a query that might potentially execute user code.
  tryQuery(f, defaultValue) {
    let realm = this.realm;
    let context = new _realm.ExecutionContext();
    context.isStrict = realm.isStrict;
    let env = realm.$GlobalEnv;
    context.lexicalEnvironment = env;
    context.variableEnvironment = env;
    context.realm = realm;
    realm.pushContext(context); // We use partial evaluation so that we can throw away any state mutations

    let oldErrorHandler = realm.errorHandler;

    realm.errorHandler = d => {
      if (d.severity === "Information" || d.severity === "Warning") return "Recover";
      return "Fail";
    };

    try {
      let result;
      let effects = realm.evaluateForEffects(() => {
        try {
          result = f();
        } catch (e) {
          if (e instanceof _completions.Completion) {
            result = defaultValue;
          } else if (e instanceof _errors.FatalError) {
            result = defaultValue;
          } else {
            throw e;
          }
        }

        return realm.intrinsics.undefined;
      }, undefined, "tryQuery");
      (0, _invariant.default)(effects.result.value === realm.intrinsics.undefined);
      return result;
    } finally {
      realm.errorHandler = oldErrorHandler;
      realm.popContext(context);
    }
  }

  logCompletion(res) {
    let realm = this.realm;
    let value = res.value;
    if (this.internalDebug) console.error(`=== ${res.constructor.name} ===`);

    if (this.tryQuery(() => value instanceof _index2.ObjectValue && (0, _index.InstanceofOperator)(realm, value, realm.intrinsics.Error), false)) {
      let object = value;

      try {
        let err = new _errors.FatalError(this.tryQuery(() => _singletons.To.ToStringPartial(realm, (0, _index.Get)(realm, object, "message")), "(unknown message)"));
        err.stack = this.tryQuery(() => _singletons.To.ToStringPartial(realm, (0, _index.Get)(realm, object, "stack")), "(unknown stack)");
        console.error(err.message);
        console.error(err.stack);
        if (this.internalDebug && res instanceof _completions.ThrowCompletion) console.error(res.nativeStack);
      } catch (err) {
        let message = object.properties.get("message");
        console.error(message && message.descriptor && message.descriptor instanceof _descriptors.PropertyDescriptor && message.descriptor.value instanceof _index2.StringValue ? message.descriptor.value.value : "(no message available)");
        console.error(err.stack);

        if (object.$ErrorData) {
          console.error(object.$ErrorData.contextStack);
        }
      }
    } else {
      try {
        value = _singletons.To.ToStringPartial(realm, value);
      } catch (err) {
        value = err.message;
      }

      console.error(value);
      if (this.internalDebug && res instanceof _completions.ThrowCompletion) console.error(res.nativeStack);
    }

    this._hasErrors = true;
  }

  logError(value, message) {
    this._log(value, message, "RecoverableError");

    this._hasErrors = true;
  }

  logWarning(value, message) {
    this._log(value, message, "Warning");
  }

  logInformation(message) {
    this._log(this.realm.intrinsics.undefined, message, "Information");
  }

  _log(value, message, severity) {
    let loc = value.expressionLocation;

    if (value.intrinsicName) {
      message = `${message}\nintrinsic name: ${value.intrinsicName}`;
    }

    let diagnostic = new _errors.CompilerDiagnostic(message, loc, "PP9000", severity);
    if (this.realm.handleError(diagnostic) === "Fail") throw new _errors.FatalError();
  }

  hasErrors() {
    return this._hasErrors;
  }

}

exports.Logger = Logger;
//# sourceMappingURL=logger.js.map

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSuggestedArrayLiteralLength = getSuggestedArrayLiteralLength;
exports.commonAncestorOf = commonAncestorOf;
exports.getOrDefault = getOrDefault;
exports.withDescriptorValue = withDescriptorValue;
exports.canIgnoreClassLengthProperty = canIgnoreClassLengthProperty;
exports.getObjectPrototypeMetadata = getObjectPrototypeMetadata;
exports.createAdditionalEffects = createAdditionalEffects;
exports.handleReportedSideEffect = handleReportedSideEffect;
exports.ClassPropertiesToIgnore = void 0;

var _index = __webpack_require__(10);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index2 = __webpack_require__(232);

var _logger = __webpack_require__(412);

var _generator = __webpack_require__(237);

var _babelhelpers = __webpack_require__(239);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * Get index property list length by searching array properties list for the max index key value plus 1.
 * If tail elements are conditional, return the minimum length if an assignment to the length property
 * can be avoided because of that. The boolean part of the result is a flag that indicates if the latter is true.
 */
function getSuggestedArrayLiteralLength(realm, val) {
  (0, _invariant.default)((0, _index2.IsArray)(realm, val));
  let instantRenderMode = realm.instantRender.enabled;
  let minLength = 0,
      maxLength = 0;
  let actualLength;

  for (const key of val.properties.keys()) {
    if ((0, _index2.IsArrayIndex)(realm, key) && Number(key) >= maxLength) {
      let prevMax = maxLength;
      maxLength = Number(key) + 1;

      let elem = val._SafeGetDataPropertyValue(key);

      if (instantRenderMode || !elem.mightHaveBeenDeleted()) minLength = maxLength;else if (elem instanceof _index.AbstractValue && elem.kind === "conditional") {
        let maxLengthVal = new _index.IntegralValue(realm, maxLength);
        let [c, x, y] = elem.args;

        if (x instanceof _index.EmptyValue && !y.mightHaveBeenDeleted()) {
          let prevActual = actualLength === undefined ? new _index.IntegralValue(realm, prevMax) : actualLength;
          actualLength = _index.AbstractValue.createFromConditionalOp(realm, c, prevActual, maxLengthVal);
        } else if (y instanceof _index.EmptyValue && !x.mightHaveBeenDeleted()) {
          let prevActual = actualLength === undefined ? new _index.IntegralValue(realm, prevMax) : actualLength;
          actualLength = _index.AbstractValue.createFromConditionalOp(realm, c, maxLengthVal, prevActual);
        } else {
          actualLength = undefined;
        }
      }
    }
  }

  if (maxLength > minLength && actualLength instanceof _index.AbstractValue) {
    let lengthVal = val._SafeGetDataPropertyValue("length");

    if (lengthVal.equals(actualLength)) return [minLength, true];
  }

  return [maxLength, false];
}

function commonAncestorOf(node1, node2, getParent) {
  if (node1 === node2) return node1; // First get the path length to the root node for both nodes while also checking if
  // either node is the parent of the other.

  let n1 = node1,
      n2 = node2,
      count1 = 0,
      count2 = 0;

  while (true) {
    let p1 = n1 && getParent(n1);
    let p2 = n2 && getParent(n2);
    if (p1 === node2) return node2;
    if (p2 === node1) return node1;
    if (p1 !== undefined) count1++;
    if (p2 !== undefined) count2++;
    if (p1 === undefined && p2 === undefined) break;
    n1 = p1;
    n2 = p2;
  } // Now shorten the longest path to the same length as the shorter path


  n1 = node1;

  while (count1 > count2) {
    (0, _invariant.default)(n1 !== undefined);
    n1 = getParent(n1);
    count1--;
  }

  n2 = node2;

  while (count1 < count2) {
    (0, _invariant.default)(n2 !== undefined);
    n2 = getParent(n2);
    count2--;
  } // Now run up both paths in tandem, stopping at the first common entry


  while (n1 !== n2) {
    (0, _invariant.default)(n1 !== undefined);
    n1 = getParent(n1);
    (0, _invariant.default)(n2 !== undefined);
    n2 = getParent(n2);
  }

  return n1;
} // Gets map[key] with default value provided by defaultFn


function getOrDefault(map, key, defaultFn) {
  let value = map.get(key);
  if (value === undefined) map.set(key, value = defaultFn());
  (0, _invariant.default)(value !== undefined);
  return value;
}

function withDescriptorValue(propertyNameOrSymbol, descriptor, func) {
  if (descriptor !== undefined) {
    (0, _invariant.default)(descriptor instanceof _descriptors.PropertyDescriptor); // TODO: Handle joined descriptors.

    if (descriptor.value !== undefined) {
      func(propertyNameOrSymbol, descriptor.value, "value");
    } else {
      if (descriptor.get !== undefined) {
        func(propertyNameOrSymbol, descriptor.get, "get");
      }

      if (descriptor.set !== undefined) {
        func(propertyNameOrSymbol, descriptor.set, "set");
      }
    }
  }
}

const ClassPropertiesToIgnore = new Set(["arguments", "name", "caller"]);
exports.ClassPropertiesToIgnore = ClassPropertiesToIgnore;

function canIgnoreClassLengthProperty(val, desc, logger) {
  if (desc) {
    if (desc instanceof _descriptors.PropertyDescriptor) {
      if (desc.value === undefined) {
        logger.logError(val, "Functions with length accessor properties are not supported in residual heap.");
      }
    } else {
      logger.logError(val, "Functions with length properties with different attributes are not supported in residual heap.");
    }
  }

  return true;
}

function getObjectPrototypeMetadata(realm, obj) {
  let proto = obj.$Prototype;
  let skipPrototype = false;
  let constructor;

  if (obj.$IsClassPrototype) {
    skipPrototype = true;
  }

  if (proto && proto.$IsClassPrototype) {
    (0, _invariant.default)(proto instanceof _index.ObjectValue); // we now need to check if the prototpe has a constructor

    let _constructor = proto.properties.get("constructor");

    if (_constructor !== undefined) {
      // if the contructor has been deleted then we have no way
      // to serialize the original class AST as it won't have been
      // evluated and thus visited
      if (_constructor.descriptor === undefined) {
        throw new _errors.FatalError("TODO #1024: implement object prototype serialization with deleted constructor");
      }

      if (!(_constructor.descriptor instanceof _descriptors.PropertyDescriptor)) {
        throw new _errors.FatalError("TODO #1024: implement object prototype serialization with multiple constructor attributes");
      }

      let classFunc = _constructor.descriptor.value;

      if (classFunc instanceof _index.ECMAScriptSourceFunctionValue) {
        constructor = classFunc;
        skipPrototype = true;
      }
    }
  }

  return {
    skipPrototype,
    constructor
  };
}

function createAdditionalEffects(realm, effects, fatalOnAbrupt, name, additionalFunctionEffects, preEvaluationComponentToWriteEffectFunction, optimizedFunction, parentOptimizedFunction, transforms = []) {
  let generator = _generator.Generator.fromEffects(effects, realm, name, additionalFunctionEffects, preEvaluationComponentToWriteEffectFunction, optimizedFunction);

  let retValue = {
    parentAdditionalFunction: parentOptimizedFunction || undefined,
    effects,
    transforms,
    generator,
    additionalRoots: new Set()
  };
  return retValue;
}

function handleReportedSideEffect(exceptionHandler, sideEffectType, binding, expressionLocation) {
  // This causes an infinite recursion because creating a callstack causes internal-only side effects
  if (binding && binding.object && binding.object.intrinsicName === "__checkedBindings") return;
  let location = (0, _babelhelpers.optionalStringOfLocation)(expressionLocation);

  if (sideEffectType === "MODIFIED_BINDING") {
    let name = binding ? `"${binding.name}"` : "unknown";
    exceptionHandler(`side-effects from mutating the binding ${name}${location}`, expressionLocation);
  } else if (sideEffectType === "MODIFIED_PROPERTY" || sideEffectType === "MODIFIED_GLOBAL") {
    let name = "";
    let pb = binding;
    let key = pb.key;

    if (typeof key === "string") {
      name = `"${key}"`;
    }

    if (sideEffectType === "MODIFIED_PROPERTY") {
      if (!_index.ObjectValue.refuseSerializationOnPropertyBinding(pb)) exceptionHandler(`side-effects from mutating a property ${name}${location}`, expressionLocation);
    } else {
      exceptionHandler(`side-effects from mutating the global object property ${name}${location}`, expressionLocation);
    }
  } else if (sideEffectType === "EXCEPTION_THROWN") {
    exceptionHandler(`side-effects from throwing exception${location}`, expressionLocation);
  }
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optimizeReactComponentTreeRoot = optimizeReactComponentTreeRoot;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _utils = __webpack_require__(413);

var _utils2 = __webpack_require__(291);

var _types = __webpack_require__(408);

var _reconcilation = __webpack_require__(415);

var _errors = __webpack_require__(417);

var _singletons = __webpack_require__(236);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _logger = __webpack_require__(412);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function writeEffectsKeyOfComponentValue(realm, componentType, componentTreeState, transforms) {
  if ((0, _utils2.valueIsClassComponent)(realm, componentType)) {
    if (componentTreeState.status === "SIMPLE") {
      // if the root component was a class and is now simple, we can convert it from a class
      // component to a functional component
      if (componentType instanceof _index.BoundFunctionValue) {
        let targetFunction = componentType.$BoundTargetFunction;
        (0, _invariant.default)(targetFunction instanceof _index.ECMAScriptSourceFunctionValue);
        (0, _utils2.convertSimpleClassComponentToFunctionalComponent)(realm, targetFunction, transforms);
        (0, _utils2.normalizeFunctionalComponentParamaters)(targetFunction);
        return targetFunction;
      } else {
        (0, _utils2.convertSimpleClassComponentToFunctionalComponent)(realm, componentType, transforms);
        (0, _utils2.normalizeFunctionalComponentParamaters)(componentType);
        return componentType;
      }
    } else {
      let prototype = (0, _index2.Get)(realm, componentType, "prototype");
      (0, _invariant.default)(prototype instanceof _index.ObjectValue);
      let renderMethod = (0, _index2.Get)(realm, prototype, "render");
      (0, _invariant.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
      return renderMethod;
    }
  } else {
    if (componentTreeState.status === "COMPLEX") {
      (0, _utils2.convertFunctionalComponentToComplexClassComponent)(realm, componentType, componentTreeState.componentType, transforms);
      let prototype = (0, _index2.Get)(realm, componentType, "prototype");
      (0, _invariant.default)(prototype instanceof _index.ObjectValue);
      let renderMethod = (0, _index2.Get)(realm, prototype, "render");
      (0, _invariant.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
      return renderMethod;
    } else {
      if (componentType instanceof _index.BoundFunctionValue) {
        let targetFunction = componentType.$BoundTargetFunction;
        (0, _invariant.default)(targetFunction instanceof _index.ECMAScriptSourceFunctionValue);
        (0, _utils2.normalizeFunctionalComponentParamaters)(targetFunction);
        return targetFunction;
      } else {
        (0, _utils2.normalizeFunctionalComponentParamaters)(componentType);
        return componentType;
      }
    }
  }
}

function applyWriteEffectsForOptimizedComponent(realm, componentType, _effects, componentTreeState, evaluatedNode, writeEffects, preEvaluationComponentToWriteEffectFunction, parentOptimizedFunction) {
  let effects = _effects;
  let transforms = [];
  let writeEffectsKey = writeEffectsKeyOfComponentValue(realm, componentType, componentTreeState, transforms); // NB: Must be done here because its required by cAE

  preEvaluationComponentToWriteEffectFunction.set(componentType, writeEffectsKey);
  let additionalFunctionEffects = (0, _utils.createAdditionalEffects)(realm, effects, false, "ReactAdditionalFunctionEffects", writeEffects, preEvaluationComponentToWriteEffectFunction, writeEffectsKey, parentOptimizedFunction, transforms);

  if (additionalFunctionEffects === null) {
    throw new _errors.ReconcilerFatalError(`Failed to optimize React component tree for "${evaluatedNode.name}" due to an unsupported completion`, evaluatedNode);
  }

  effects = additionalFunctionEffects.effects;
  let value = effects.result;

  if (value === realm.intrinsics.undefined) {
    // if we get undefined, then this component tree failed and a message was already logged
    // in the reconciler
    return;
  }

  writeEffects.set(writeEffectsKey, additionalFunctionEffects); // apply contextTypes for legacy context

  if (componentTreeState.contextTypes.size > 0) {
    let contextTypes = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
    let noOpFunc = (0, _utils2.createNoopFunction)(realm);

    for (let key of componentTreeState.contextTypes) {
      _singletons.Properties.Set(realm, contextTypes, key, noOpFunc, true);
    }

    _singletons.Properties.Set(realm, componentType, "contextTypes", contextTypes, true);
  }
}

function optimizeReactComponentTreeBranches(realm, reconciler, writeEffects, logger, alreadyEvaluated, preEvaluationComponentToWriteEffectFunction) {
  if (realm.react.verbose && reconciler.branchedComponentTrees.length > 0) {
    logger.logInformation(`  Evaluating React component tree branches...`);
  } // for now we just use abstract props/context, in the future we'll create a new branch with a new component
  // that used the props/context. It will extend the original component and only have a render method


  for (let _ref of reconciler.branchedComponentTrees) {
    let {
      rootValue: branchRootValue,
      evaluatedNode
    } = _ref;
    let branchComponentType = (0, _utils2.getComponentTypeFromRootValue)(realm, branchRootValue);

    if (branchComponentType === null) {
      evaluatedNode.status = "UNKNOWN_TYPE";
      continue;
    }

    if (alreadyEvaluated.has(branchComponentType)) {
      return;
    }

    alreadyEvaluated.set(branchComponentType, evaluatedNode);
    reconciler.clearComponentTreeState();

    if (realm.react.verbose) {
      logger.logInformation(`    Evaluating ${evaluatedNode.name} (branch)`);
    }

    let parentOptimizedFunction = realm.currentOptimizedFunction;
    let branchEffects = realm.withNewOptimizedFunction(() => reconciler.resolveReactComponentTree(branchComponentType, null, null, evaluatedNode), branchComponentType);

    if (realm.react.verbose) {
      logger.logInformation(`     ${evaluatedNode.name} (branch)`);
    }

    let branchComponentTreeState = reconciler.componentTreeState;
    applyWriteEffectsForOptimizedComponent(realm, branchComponentType, branchEffects, branchComponentTreeState, evaluatedNode, writeEffects, preEvaluationComponentToWriteEffectFunction, parentOptimizedFunction);
  }
}

function optimizeReactComponentTreeRoot(realm, componentRoot, config, writeEffects, logger, statistics, alreadyEvaluated, preEvaluationComponentToWriteEffectFunction) {
  let reconciler = new _reconcilation.Reconciler(realm, config, alreadyEvaluated, statistics, logger);
  let componentType = (0, _utils2.getComponentTypeFromRootValue)(realm, componentRoot);

  if (componentType === null) {
    return;
  }

  if (alreadyEvaluated.has(componentType)) {
    return;
  }

  let evaluatedRootNode = (0, _utils2.createReactEvaluatedNode)("ROOT", (0, _utils2.getComponentName)(realm, componentType));
  statistics.evaluatedRootNodes.push(evaluatedRootNode);
  alreadyEvaluated.set(componentType, evaluatedRootNode);

  if (realm.react.verbose) {
    logger.logInformation(`  Evaluating ${evaluatedRootNode.name} (root)`);
  }

  let parentOptimizedFunction = realm.currentOptimizedFunction;
  let componentTreeEffects = realm.withNewOptimizedFunction(() => reconciler.resolveReactComponentTree(componentType, null, null, evaluatedRootNode), componentType);

  if (realm.react.verbose) {
    logger.logInformation(`   ${evaluatedRootNode.name} (root)`);
  }

  applyWriteEffectsForOptimizedComponent(realm, componentType, componentTreeEffects, reconciler.componentTreeState, evaluatedRootNode, writeEffects, preEvaluationComponentToWriteEffectFunction, parentOptimizedFunction);
  let startingComponentTreeBranches = 0;

  do {
    startingComponentTreeBranches = reconciler.branchedComponentTrees.length;
    optimizeReactComponentTreeBranches(realm, reconciler, writeEffects, logger, alreadyEvaluated, preEvaluationComponentToWriteEffectFunction);
  } while (startingComponentTreeBranches !== reconciler.branchedComponentTrees.length);
}
//# sourceMappingURL=optimizing.js.map

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Reconciler = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _types = __webpack_require__(408);

var _utils = __webpack_require__(291);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _singletons = __webpack_require__(236);

var _errors = __webpack_require__(3);

var _branching = __webpack_require__(416);

var _completions = __webpack_require__(18);

var _components = __webpack_require__(418);

var _errors2 = __webpack_require__(417);

var _elements = __webpack_require__(420);

var _logger = __webpack_require__(412);

var _utils2 = __webpack_require__(413);

var _generator = __webpack_require__(237);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function setContextCurrentValue(contextObject, value) {
  if (contextObject instanceof _index.AbstractObjectValue && !contextObject.values.isTop()) {
    let elements = contextObject.values.getElements();

    if (elements && elements.size === 1) {
      for (let element of elements) {
        (0, _invariant.default)(element instanceof _index.ObjectValue);
        contextObject = element;
      }
    } else {
      (0, _invariant.default)(false, "TODO: deal with multiple possible context objects");
    }
  }

  if (!(contextObject instanceof _index.ObjectValue)) {
    throw new _errors2.ExpectedBailOut("cannot set currentValue on an abstract context consumer");
  }

  let binding = contextObject.properties.get("currentValue");

  if (binding && binding.descriptor) {
    (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);
    binding.descriptor.value = value;
  } else {
    (0, _invariant.default)(false, "setContextCurrentValue failed to set the currentValue");
  }
}

function throwUnsupportedSideEffectError(msg) {
  throw new _errors2.UnsupportedSideEffect(msg);
}

class Reconciler {
  constructor(realm, componentTreeConfig, alreadyEvaluated, statistics, logger) {
    this.realm = realm;
    this.statistics = statistics;
    this.logger = logger;
    this.componentTreeConfig = componentTreeConfig;
    this.componentTreeState = this._createComponentTreeState();
    this.alreadyEvaluated = alreadyEvaluated;
    this.branchedComponentTrees = [];
  }

  resolveReactComponentTree(componentType, props, context, evaluatedRootNode) {
    const resolveComponentTree = () => {
      try {
        let initialProps = props || (0, _components.getInitialProps)(this.realm, componentType, this.componentTreeConfig);
        let initialContext = context || (0, _components.getInitialContext)(this.realm, componentType);

        let {
          result
        } = this._resolveComponent(componentType, initialProps, initialContext, "ROOT", evaluatedRootNode);

        this.statistics.optimizedTrees++;
        return result;
      } catch (error) {
        if (error instanceof _completions.AbruptCompletion) throw error;

        this._handleComponentTreeRootFailure(error, evaluatedRootNode); // flow belives we can get here, when it should never be possible


        (0, _invariant.default)(false, "resolveReactComponentTree error not handled correctly");
      }
    };

    try {
      this.realm.react.activeReconciler = this;
      return this.realm.wrapInGlobalEnv(() => this.realm.evaluatePure(() => this.realm.evaluateForEffects(resolveComponentTree,
      /*state*/
      null, `react component: ${(0, _utils.getComponentName)(this.realm, componentType)}`),
      /*bubbles*/
      true, (sideEffectType, binding, expressionLocation) => {
        if (this.realm.react.failOnUnsupportedSideEffects) {
          (0, _utils2.handleReportedSideEffect)(throwUnsupportedSideEffectError, sideEffectType, binding, expressionLocation);
        }
      }));
    } finally {
      this.realm.react.activeReconciler = undefined;
    }
  }

  clearComponentTreeState() {
    this.componentTreeState = this._createComponentTreeState();
  }

  _queueNewComponentTree(rootValue, evaluatedNode, props = null, context = null) {
    if (rootValue instanceof _index.SymbolValue) {
      return;
    }

    (0, _invariant.default)(rootValue instanceof _index.ECMAScriptSourceFunctionValue || rootValue instanceof _index.AbstractValue);
    this.componentTreeState.deadEnds++;
    let componentType = (0, _utils.getComponentTypeFromRootValue)(this.realm, rootValue);

    if (componentType !== null && !this.alreadyEvaluated.has(componentType)) {
      this.branchedComponentTrees.push({
        context,
        evaluatedNode,
        props,
        rootValue
      });
    }
  }

  _resolveComplexClassComponent(componentType, props, context, classMetadata, branchStatus, evaluatedNode) {
    if (branchStatus !== "ROOT") {
      // if the tree is simple and we're not in a branch, we can make this tree complex
      // and make this complex component the root
      let evaluatedComplexNode = this.alreadyEvaluated.get(componentType);

      if (branchStatus === "NO_BRANCH" && this.componentTreeState.status === "SIMPLE" && evaluatedComplexNode && evaluatedComplexNode.status !== "RENDER_PROPS") {
        this.componentTreeState.componentType = componentType;
      } else {
        this._queueNewComponentTree(componentType, evaluatedNode);

        evaluatedNode.status = "NEW_TREE";
        throw new _errors2.NewComponentTreeBranch(evaluatedNode);
      }
    }

    this.componentTreeState.status = "COMPLEX"; // create a new instance of this React class component

    let instance = (0, _components.createClassInstance)(this.realm, componentType, props, context, classMetadata); // get the "render" method off the instance

    let renderMethod = (0, _index2.Get)(this.realm, instance, "render");
    (0, _invariant.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue); // the render method doesn't have any arguments, so we just assign the context of "this" to be the instance

    return (0, _utils.getValueFromFunctionCall)(this.realm, renderMethod, instance, []);
  }

  _resolveSimpleClassComponent(componentType, props, context, branchStatus, evaluatedNode) {
    // create a new simple instance of this React class component
    let instance = (0, _components.createSimpleClassInstance)(this.realm, componentType, props, context); // get the "render" method off the instance

    let renderMethod = (0, _index2.Get)(this.realm, instance, "render");
    (0, _invariant.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue); // the render method doesn't have any arguments, so we just assign the context of "this" to be the instance

    return (0, _utils.getValueFromFunctionCall)(this.realm, renderMethod, instance, []);
  }

  _resolveFunctionalComponent(componentType, props, context, evaluatedNode) {
    return (0, _utils.getValueFromFunctionCall)(this.realm, componentType, this.realm.intrinsics.undefined, [props, context]);
  }

  _getClassComponentMetadata(componentType, props, context) {
    if (this.realm.react.classComponentMetadata.has(componentType)) {
      let classMetadata = this.realm.react.classComponentMetadata.get(componentType);
      (0, _invariant.default)(classMetadata);
      return classMetadata;
    } // get all this assignments in the constructor


    let classMetadata = (0, _components.evaluateClassConstructor)(this.realm, componentType, props, context);
    this.realm.react.classComponentMetadata.set(componentType, classMetadata);
    return classMetadata;
  }

  _resolveContextProviderComponent(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("NORMAL", "Context.Provider");
    evaluatedNode.children.push(evaluatedChildNode);
    this.statistics.componentsEvaluated++;
    (0, _invariant.default)(typeValue instanceof _index.ObjectValue || typeValue instanceof _index.AbstractObjectValue);
    const contextConsumer = (0, _utils.getProperty)(this.realm, typeValue, "context");
    (0, _invariant.default)(contextConsumer instanceof _index.ObjectValue || contextConsumer instanceof _index.AbstractObjectValue);
    let lastValueProp = (0, _utils.getProperty)(this.realm, contextConsumer, "currentValue");

    this._incremementReferenceForContextNode(contextConsumer);

    let valueProp; // if we have a value prop, set it

    if (propsValue instanceof _index.ObjectValue || propsValue instanceof _index.AbstractObjectValue) {
      valueProp = (0, _index2.Get)(this.realm, propsValue, "value");
      setContextCurrentValue(contextConsumer, valueProp);
    }

    if (propsValue instanceof _index.ObjectValue) {
      // if the value is abstract, we need to keep the render prop as unless
      // we are in firstRenderOnly mode, where we can just inline the abstract value
      if (!(valueProp instanceof _index.AbstractValue) || this.componentTreeConfig.firstRenderOnly) {
        let resolvedReactElement = this._resolveReactElementHostChildren(componentType, reactElement, context, branchStatus, evaluatedChildNode);

        let resolvedPropsValue = (0, _utils.getProperty)(this.realm, resolvedReactElement, "props");
        (0, _invariant.default)(resolvedPropsValue instanceof _index.ObjectValue || resolvedPropsValue instanceof _index.AbstractObjectValue);
        (0, _invariant.default)(lastValueProp instanceof _index.Value);
        setContextCurrentValue(contextConsumer, lastValueProp);

        this._decremementReferenceForContextNode(contextConsumer); // if we no dead ends, we know the rest of the tree and can safely remove the provider


        if (this.componentTreeState.deadEnds === 0) {
          let childrenValue = (0, _index2.Get)(this.realm, resolvedPropsValue, "children");
          evaluatedChildNode.status = "INLINED";
          this.statistics.inlinedComponents++;
          return childrenValue;
        }

        return resolvedReactElement;
      }
    }

    let children = this._resolveReactElementHostChildren(componentType, reactElement, context, branchStatus, evaluatedChildNode);

    setContextCurrentValue(contextConsumer, lastValueProp);

    this._decremementReferenceForContextNode(contextConsumer);

    return children;
  }

  _decremementReferenceForContextNode(contextNode) {
    let references = this.componentTreeState.contextNodeReferences.get(contextNode);

    if (!references) {
      references = 0;
    } else {
      references--;
    }

    this.componentTreeState.contextNodeReferences.set(contextNode, references);
  }

  _incremementReferenceForContextNode(contextNode) {
    let references = this.componentTreeState.contextNodeReferences.get(contextNode);

    if (!references) {
      references = 1;
    } else {
      references++;
    }

    this.componentTreeState.contextNodeReferences.set(contextNode, references);
  }

  _isContextValueKnown(contextNode) {
    if (this.componentTreeConfig.isRoot) {
      return true;
    }

    if (this.componentTreeState.contextNodeReferences.has(contextNode)) {
      let references = this.componentTreeState.contextNodeReferences.get(contextNode);

      if (!references) {
        return false;
      }

      return references > 0;
    }

    return false;
  }

  _resolveContextConsumerComponent(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("RENDER_PROPS", "Context.Consumer");
    evaluatedNode.children.push(evaluatedChildNode);

    if (propsValue instanceof _index.ObjectValue || propsValue instanceof _index.AbstractObjectValue) {
      // get the "render" prop child off the instance
      if (propsValue instanceof _index.ObjectValue && propsValue.properties.has("children")) {
        let renderProp = (0, _utils.getProperty)(this.realm, propsValue, "children");

        this._findReactComponentTrees(propsValue, evaluatedChildNode, "NORMAL_FUNCTIONS", componentType, context, branchStatus);

        if (renderProp instanceof _index.ECMAScriptSourceFunctionValue) {
          if (typeValue instanceof _index.ObjectValue || typeValue instanceof _index.AbstractObjectValue) {
            // make sure this context is in our tree
            if (this._isContextValueKnown(typeValue)) {
              let valueProp = (0, _index2.Get)(this.realm, typeValue, "currentValue"); // if the value is abstract, we need to keep the render prop as unless
              // we are in firstRenderOnly mode, where we can just inline the abstract value

              if (!(valueProp instanceof _index.AbstractValue) || this.componentTreeConfig.firstRenderOnly) {
                let result = (0, _utils.getValueFromFunctionCall)(this.realm, renderProp, this.realm.intrinsics.undefined, [valueProp]);
                this.statistics.inlinedComponents++;
                this.statistics.componentsEvaluated++;
                evaluatedChildNode.status = "INLINED";
                return this._resolveDeeply(componentType, result, context, branchStatus, evaluatedNode);
              }
            }
          }

          this._evaluateNestedOptimizedFunctionAndStoreEffects(componentType, context, branchStatus, evaluatedChildNode, renderProp);

          return;
        } else {
          this._findReactComponentTrees(renderProp, evaluatedChildNode, "NESTED_CLOSURES", componentType, context, branchStatus);
        }
      }
    }

    this.componentTreeState.deadEnds++;
    return;
  }

  _resolveForwardRefComponent(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    let refValue = (0, _utils.getProperty)(this.realm, reactElement, "ref");
    (0, _invariant.default)(typeValue instanceof _index.AbstractObjectValue || typeValue instanceof _index.ObjectValue);
    let forwardedComponent = (0, _utils.getProperty)(this.realm, typeValue, "render");
    let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("FORWARD_REF", (0, _utils.getComponentName)(this.realm, forwardedComponent));
    evaluatedNode.children.push(evaluatedChildNode);
    (0, _invariant.default)(forwardedComponent instanceof _index.ECMAScriptSourceFunctionValue || forwardedComponent instanceof _index.BoundFunctionValue, "expect React.forwardRef() to be passed function value");
    let value = (0, _utils.getValueFromFunctionCall)(this.realm, forwardedComponent, this.realm.intrinsics.undefined, [propsValue, refValue]);
    return this._resolveDeeply(componentType, value, context, branchStatus, evaluatedChildNode);
  }

  _resolveRelayQueryRendererComponent(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("RENDER_PROPS", (0, _utils.getComponentName)(this.realm, typeValue));
    evaluatedNode.children.push(evaluatedChildNode);

    if (propsValue instanceof _index.ObjectValue || propsValue instanceof _index.AbstractObjectValue) {
      // get the "render" prop
      if (propsValue instanceof _index.ObjectValue && propsValue.properties.has("render")) {
        let renderProp = (0, _utils.getProperty)(this.realm, propsValue, "render");

        if (renderProp instanceof _index.ECMAScriptSourceFunctionValue) {
          this._evaluateNestedOptimizedFunctionAndStoreEffects(componentType, context, branchStatus, evaluatedChildNode, renderProp);
        } else if (renderProp instanceof _index.AbstractValue) {
          this._findReactComponentTrees(renderProp, evaluatedChildNode, "NESTED_CLOSURES", componentType, context, branchStatus);
        }
      }

      this._findReactComponentTrees(propsValue, evaluatedChildNode, "NORMAL_FUNCTIONS", componentType, context, branchStatus);

      return;
    } // this is the worst case, we were unable to find the render prop function
    // and won't be able to find any further components to evaluate as trees
    // because of that


    this.componentTreeState.deadEnds++;
  }

  _resolveClassComponent(componentType, props, context, branchStatus, evaluatedNode) {
    let value;

    let classMetadata = this._getClassComponentMetadata(componentType, props, context);

    let {
      instanceProperties,
      instanceSymbols
    } = classMetadata; // if there were no this assignments we can try and render it as a simple class component

    if (instanceProperties.size === 0 && instanceSymbols.size === 0) {
      // We first need to know what type of class component we're dealing with.
      // A "simple" class component is defined as:
      //
      // - having only a "render" method
      // - having no lifecycle events
      // - having no state
      // - having no instance variables
      //
      // the only things a class component should be able to access on "this" are:
      // - this.props
      // - this.context
      // - this._someRenderMethodX() etc
      //
      // Otherwise, the class component is a "complex" one.
      // To begin with, we don't know what type of component it is, so we try and render it as if it were
      // a simple component using the above heuristics. If an error occurs during this process, we assume
      // that the class wasn't simple, then try again with the "complex" heuristics.
      try {
        value = this._resolveSimpleClassComponent(componentType, props, context, branchStatus, evaluatedNode);
      } catch (error) {
        // if we get back a SimpleClassBailOut error, we know that this class component
        // wasn't a simple one and is likely to be a complex class component instead
        if (error instanceof _errors2.SimpleClassBailOut) {// the component was not simple, so we continue with complex case
        } else {
          // else we rethrow the error
          throw error;
        }
      }
    } // handle the complex class component if there is not value


    if (value === undefined) {
      value = this._resolveComplexClassComponent(componentType, props, context, classMetadata, branchStatus, evaluatedNode);
    }

    return value;
  }

  _resolveClassComponentForFirstRenderOnly(componentType, props, context, branchStatus, evaluatedNode) {
    // create a new simple instance of this React class component
    let instance = (0, _components.createClassInstanceForFirstRenderOnly)(this.realm, componentType, props, context, evaluatedNode);
    let getDerivedStateFromProps = (0, _index2.Get)(this.realm, componentType, "getDerivedStateFromProps");
    let getSnapshotBeforeUpdate = (0, _index2.Get)(this.realm, instance, "getSnapshotBeforeUpdate"); // if either getDerivedStateFromProps or getSnapshotBeforeUpdate exist, then
    // we don't try and execute componentWillMount and UNSAFE_componentWillMount

    if (getDerivedStateFromProps !== this.realm.intrinsics.undefined || getSnapshotBeforeUpdate !== this.realm.intrinsics.undefined) {
      if (getDerivedStateFromProps instanceof _index.ECMAScriptSourceFunctionValue && getDerivedStateFromProps.$Call) {
        (0, _components.applyGetDerivedStateFromProps)(this.realm, getDerivedStateFromProps, instance, props);
      }
    } else {
      // get the "componentWillMount" and "render" methods off the instance
      let componentWillMount = (0, _index2.Get)(this.realm, instance, "componentWillMount");

      if (componentWillMount instanceof _index.ECMAScriptSourceFunctionValue && componentWillMount.$Call) {
        componentWillMount.$Call(instance, []);
      }

      let unsafeComponentWillMount = (0, _index2.Get)(this.realm, instance, "UNSAFE_componentWillMount");

      if (unsafeComponentWillMount instanceof _index.ECMAScriptSourceFunctionValue && unsafeComponentWillMount.$Call) {
        unsafeComponentWillMount.$Call(instance, []);
      }
    }

    let renderMethod = (0, _index2.Get)(this.realm, instance, "render");
    (0, _invariant.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
    return (0, _utils.getValueFromFunctionCall)(this.realm, renderMethod, instance, []);
  }

  _resolveRelayContainer(reactHint, props, context, branchStatus, evaluatedNode) {
    evaluatedNode.status = "INLINED";
    evaluatedNode.message = "RelayContainer";
    (0, _invariant.default)(reactHint.firstRenderValue instanceof _index.Value); // for better serialization, ensure context has the right abstract properties defined

    if ((0, _utils.getProperty)(this.realm, context, "relay") === this.realm.intrinsics.undefined) {
      let abstractRelayContext = _index.AbstractValue.createAbstractObject(this.realm, "context.relay");

      let abstractRelayEnvironment = _index.AbstractValue.createAbstractObject(this.realm, "context.relay.environment");

      let abstractRelayInternal = _index.AbstractValue.createAbstractObject(this.realm, "context.relay.environment.unstable_internal");

      _singletons.Properties.Set(this.realm, context, "relay", abstractRelayContext, true);

      _singletons.Properties.Set(this.realm, abstractRelayContext, "environment", abstractRelayEnvironment, true);

      _singletons.Properties.Set(this.realm, abstractRelayEnvironment, "unstable_internal", abstractRelayInternal, true);
    } // add contextType to this component


    this.componentTreeState.contextTypes.add("relay");
    return this._resolveComponent(reactHint.firstRenderValue, props, context, branchStatus, evaluatedNode);
  }

  _resolveComponent(componentType, props, context, branchStatus, evaluatedNode) {
    if ((0, _utils.doNotOptimizeComponent)(this.realm, componentType)) {
      throw new _errors2.DoNotOptimize("__reactCompilerDoNotOptimize flag detected");
    }

    this.statistics.componentsEvaluated++;

    if ((0, _utils.valueIsKnownReactAbstraction)(this.realm, componentType)) {
      (0, _invariant.default)(componentType instanceof _index.AbstractValue);
      let reactHint = this.realm.react.abstractHints.get(componentType);
      (0, _invariant.default)(reactHint);

      if (typeof reactHint !== "string" && reactHint.object === this.realm.fbLibraries.reactRelay && this.componentTreeConfig.firstRenderOnly) {
        return this._resolveRelayContainer(reactHint, props, context, branchStatus, evaluatedNode);
      }

      this._queueNewComponentTree(componentType, evaluatedNode);

      evaluatedNode.status = "NEW_TREE";
      evaluatedNode.message = "RelayContainer";
      throw new _errors2.NewComponentTreeBranch(evaluatedNode);
    }

    (0, _invariant.default)(componentType instanceof _index.ECMAScriptSourceFunctionValue || componentType instanceof _index.BoundFunctionValue);
    let value;
    let childContext = context; // first we check if it's a legacy class component

    if ((0, _utils.valueIsLegacyCreateClassComponent)(this.realm, componentType)) {
      throw new _errors2.ExpectedBailOut("components created with create-react-class are not supported");
    } else if ((0, _utils.valueIsClassComponent)(this.realm, componentType)) {
      if (this.componentTreeConfig.firstRenderOnly) {
        value = this._resolveClassComponentForFirstRenderOnly(componentType, props, context, branchStatus, evaluatedNode);
      } else {
        value = this._resolveClassComponent(componentType, props, context, branchStatus, evaluatedNode);
      }
    } else {
      value = this._resolveFunctionalComponent(componentType, props, context, evaluatedNode);

      if ((0, _utils.valueIsFactoryClassComponent)(this.realm, value)) {
        (0, _invariant.default)(value instanceof _index.ObjectValue);

        if (branchStatus !== "ROOT") {
          throw new _errors2.ExpectedBailOut("non-root factory class components are not suppoted");
        } else {
          // TODO support factory components
          return {
            result: value,
            childContext
          };
        }
      }
    }

    (0, _invariant.default)(value !== undefined);
    return {
      result: this._resolveDeeply(componentType, value, context, branchStatus === "ROOT" ? "NO_BRANCH" : branchStatus, evaluatedNode),
      childContext
    };
  }

  _createComponentTreeState() {
    return {
      componentType: undefined,
      contextTypes: new Set(),
      deadEnds: 0,
      status: "SIMPLE",
      contextNodeReferences: new Map()
    };
  }

  _getComponentResolutionStrategy(value) {
    // check if it's a ReactRelay.QueryRenderer
    if (this.realm.fbLibraries.reactRelay !== undefined) {
      let QueryRenderer = (0, _utils.getProperty)(this.realm, this.realm.fbLibraries.reactRelay, "QueryRenderer");

      if (value === QueryRenderer) {
        return "RELAY_QUERY_RENDERER";
      }
    }

    if (value === (0, _utils.getReactSymbol)("react.fragment", this.realm)) {
      return "FRAGMENT";
    }

    if ((value instanceof _index.ObjectValue || value instanceof _index.AbstractObjectValue) && value.kind !== "conditional") {
      let $$typeof = (0, _utils.getProperty)(this.realm, value, "$$typeof");

      if ($$typeof === (0, _utils.getReactSymbol)("react.context", this.realm)) {
        return "CONTEXT_CONSUMER";
      }

      if ($$typeof === (0, _utils.getReactSymbol)("react.provider", this.realm)) {
        return "CONTEXT_PROVIDER";
      }

      if ($$typeof === (0, _utils.getReactSymbol)("react.forward_ref", this.realm)) {
        return "FORWARD_REF";
      }
    }

    return "NORMAL";
  }

  _resolveReactDomPortal(createPortalNode, args, componentType, context, branchStatus, evaluatedNode) {
    let [reactPortalValue, domNodeValue] = args;
    let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("INLINED", "ReactDOM.createPortal");

    let resolvedReactPortalValue = this._resolveDeeply(componentType, reactPortalValue, context, branchStatus, evaluatedChildNode);

    evaluatedNode.children.push(evaluatedChildNode);

    if (resolvedReactPortalValue !== reactPortalValue) {
      this.statistics.inlinedComponents++;
      let reactDomValue = this.realm.fbLibraries.reactDom;
      (0, _invariant.default)(reactDomValue instanceof _index.ObjectValue);
      let reactDomPortalFunc = (0, _utils.getProperty)(this.realm, reactDomValue, "createPortal");
      return _index.AbstractValue.createTemporalFromBuildFunction(this.realm, _index.ObjectValue, [reactDomPortalFunc, resolvedReactPortalValue, domNodeValue], (0, _generator.createOperationDescriptor)("REACT_TEMPORAL_FUNC"), {
        skipInvariant: true,
        isPure: true
      });
    }

    return createPortalNode;
  }

  _resolveAbstractConditionalValue(componentType, condValue, consequentVal, alternateVal, context, evaluatedNode) {
    let value = this.realm.evaluateWithAbstractConditional(condValue, () => {
      return this.realm.evaluateForEffects(() => (0, _branching.wrapReactElementInBranchOrReturnValue)(this.realm, this._resolveDeeply(componentType, consequentVal, context, "NEW_BRANCH", evaluatedNode)), null, "_resolveAbstractConditionalValue consequent");
    }, () => {
      return this.realm.evaluateForEffects(() => (0, _branching.wrapReactElementInBranchOrReturnValue)(this.realm, this._resolveDeeply(componentType, alternateVal, context, "NEW_BRANCH", evaluatedNode)), null, "_resolveAbstractConditionalValue alternate");
    });

    if (value instanceof _index.AbstractValue && value.kind === "conditional") {
      return (0, _branching.getValueWithBranchingLogicApplied)(this.realm, consequentVal, alternateVal, value);
    }

    return value;
  }

  _resolveAbstractLogicalValue(componentType, value, context, evaluatedNode) {
    let [leftValue, rightValue] = value.args;
    let operator = value.kind;
    (0, _invariant.default)(leftValue instanceof _index.AbstractValue);

    if (operator === "||") {
      return this._resolveAbstractConditionalValue(componentType, leftValue, leftValue, rightValue, context, evaluatedNode);
    } else {
      return this._resolveAbstractConditionalValue(componentType, leftValue, rightValue, leftValue, context, evaluatedNode);
    }
  }

  _resolveAbstractValue(componentType, value, context, branchStatus, evaluatedNode) {
    (0, _invariant.default)(this.realm.generator); // TODO investigate what other kinds than "conditional" might be safe to deeply resolve

    if (value.kind === "conditional") {
      let [condValue, consequentVal, alternateVal] = value.args;
      (0, _invariant.default)(condValue instanceof _index.AbstractValue);
      return this._resolveAbstractConditionalValue(componentType, condValue, consequentVal, alternateVal, context, evaluatedNode);
    } else if (value.kind === "||" || value.kind === "&&") {
      return this._resolveAbstractLogicalValue(componentType, value, context, evaluatedNode);
    } else {
      if (value instanceof _index.AbstractValue && this.realm.react.abstractHints.has(value)) {
        let reactHint = this.realm.react.abstractHints.get(value);
        (0, _invariant.default)(reactHint !== undefined);

        if (reactHint.object === this.realm.fbLibraries.reactDom && reactHint.propertyName === "createPortal") {
          return this._resolveReactDomPortal(value, reactHint.args, componentType, context, branchStatus, evaluatedNode);
        }
      }

      this.componentTreeState.deadEnds++;
    }

    return value;
  }

  _resolveUnknownComponentType(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");

    this._findReactComponentTrees(propsValue, evaluatedNode, "NORMAL_FUNCTIONS", componentType, context, branchStatus);

    if (typeValue instanceof _index.AbstractValue) {
      this._findReactComponentTrees(typeValue, evaluatedNode, "FUNCTIONAL_COMPONENTS", componentType, context, branchStatus);

      return reactElement;
    } else {
      let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("BAIL-OUT", (0, _utils.getComponentName)(this.realm, typeValue));
      evaluatedNode.children.push(evaluatedChildNode);
      let bailOutMessage = `type on <Component /> was not a ECMAScriptSourceFunctionValue`;
      evaluatedChildNode.message = bailOutMessage;

      this._assignBailOutMessage(reactElement, bailOutMessage);

      this.componentTreeState.deadEnds++;
      return reactElement;
    }
  }

  _resolveReactElementBadRef(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("BAIL-OUT", (0, _utils.getComponentName)(this.realm, typeValue));
    evaluatedNode.children.push(evaluatedChildNode);
    let bailOutMessage = `refs are not supported on <Components />`;
    evaluatedChildNode.message = bailOutMessage;

    this._queueNewComponentTree(typeValue, evaluatedChildNode);

    this._findReactComponentTrees(propsValue, evaluatedNode, "NORMAL_FUNCTIONS", componentType, context, branchStatus);

    this._assignBailOutMessage(reactElement, bailOutMessage);

    return reactElement;
  }

  _resolveReactElementUndefinedRender(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("BAIL-OUT", (0, _utils.getComponentName)(this.realm, typeValue));
    evaluatedNode.children.push(evaluatedChildNode);
    let bailOutMessage = `undefined was returned from render`;
    evaluatedChildNode.message = bailOutMessage;

    this._assignBailOutMessage(reactElement, bailOutMessage);

    this._findReactComponentTrees(propsValue, evaluatedNode, "NORMAL_FUNCTIONS", componentType, context, branchStatus);

    return reactElement;
  }

  _resolveReactElementHostChildren(componentType, reactElement, context, branchStatus, evaluatedNode) {
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props"); // terminal host component. Start evaluating its children.

    if (propsValue instanceof _index.ObjectValue && propsValue.properties.has("children")) {
      let childrenValue = (0, _index2.Get)(this.realm, propsValue, "children");

      if (childrenValue instanceof _index.Value) {
        let resolvedChildren = this._resolveDeeply(componentType, childrenValue, context, branchStatus, evaluatedNode, false); // we can optimize further and flatten arrays on non-composite components


        if (resolvedChildren instanceof _index.ArrayValue && !resolvedChildren.intrinsicName) {
          resolvedChildren = (0, _utils.flattenChildren)(this.realm, resolvedChildren, true);
        }

        if (resolvedChildren !== childrenValue) {
          let newProps = (0, _utils.cloneProps)(this.realm, propsValue, resolvedChildren); // This is safe to do as we clone a new ReactElement as part of reconcilation
          // so we will never be mutating an object used by something else. Furthermore,
          // the ReactElement is "immutable" so it can never change and only React controls
          // this object.

          (0, _utils.hardModifyReactObjectPropertyBinding)(this.realm, reactElement, "props", newProps);
        }
      }
    }

    return reactElement;
  }

  _resolveFragmentComponent(componentType, reactElement, context, branchStatus, evaluatedNode) {
    this.statistics.componentsEvaluated++;

    if (this.componentTreeConfig.firstRenderOnly) {
      let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("INLINED", "React.Fragment");
      evaluatedNode.children.push(evaluatedChildNode);
      this.statistics.inlinedComponents++;

      let children = this._resolveReactElementHostChildren(componentType, reactElement, context, branchStatus, evaluatedChildNode);

      return children;
    } else {
      let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("NORMAL", "React.Fragment");
      evaluatedNode.children.push(evaluatedChildNode);
      return this._resolveReactElementHostChildren(componentType, reactElement, context, branchStatus, evaluatedChildNode);
    }
  }

  _resolveReactElement(componentType, reactElement, context, branchStatus, evaluatedNode, needsKey) {
    // We create a clone of the ReactElement to be safe. This is because the same
    // ReactElement might be a temporal referenced in other effects and also it allows us to
    // easily mutate and swap the props of the ReactElement with the optimized version with
    // resolved/inlined children.
    // Note: We used to sanitize out props for firstRender here, we now do this during serialization.
    reactElement = (0, _utils.cloneReactElement)(this.realm, reactElement, false);
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    let refValue = (0, _utils.getProperty)(this.realm, reactElement, "ref");
    let keyValue = (0, _utils.getProperty)(this.realm, reactElement, "key");
    (0, _invariant.default)(!(typeValue instanceof _index.AbstractValue && typeValue.kind === "conditional"), `the reconciler should never encounter a ReactElement "type" that is conditional abstract value`);
    (0, _invariant.default)(!(propsValue instanceof _index.AbstractValue && propsValue.kind === "conditional"), `the reconciler should never encounter a ReactElement "props" that is conditional abstract value`);

    if (typeValue instanceof _index.StringValue) {
      return this._resolveReactElementHostChildren(componentType, reactElement, context, branchStatus, evaluatedNode);
    }

    if (!(propsValue instanceof _index.ObjectValue || propsValue instanceof _index.AbstractObjectValue)) {
      this._assignBailOutMessage(reactElement, `props on <Component /> was not not an ObjectValue or an AbstractObjectValue`);

      return reactElement;
    }

    let componentResolutionStrategy = this._getComponentResolutionStrategy(typeValue); // We do not support "ref" on <Component /> ReactElements, unless it's a forwarded ref
    // or we are firstRenderOnly mode (in which case, we ignore the ref)


    if (!this.componentTreeConfig.firstRenderOnly && !(refValue instanceof _index.NullValue) && componentResolutionStrategy !== "FORWARD_REF" && // If we have an abstract value, it might mean a bad ref, but we will have
    // already thrown a FatalError in the createElement implementation by this
    // point, so if we're here, then the FatalError has been recovered explicitly
    !(refValue instanceof _index.AbstractValue)) {
      this._resolveReactElementBadRef(componentType, reactElement, context, branchStatus, evaluatedNode);
    }

    try {
      let result;

      switch (componentResolutionStrategy) {
        case "NORMAL":
          {
            if (!(typeValue instanceof _index.ECMAScriptSourceFunctionValue || typeValue instanceof _index.BoundFunctionValue || (0, _utils.valueIsKnownReactAbstraction)(this.realm, typeValue))) {
              return this._resolveUnknownComponentType(componentType, reactElement, context, branchStatus, evaluatedNode);
            }

            let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("INLINED", (0, _utils.getComponentName)(this.realm, typeValue));

            let render = this._resolveComponent(typeValue, propsValue, context, branchStatus === "NEW_BRANCH" ? "BRANCH" : branchStatus, evaluatedChildNode);

            if (this.logger !== undefined && this.realm.react.verbose && evaluatedChildNode.status === "INLINED") {
              this.logger.logInformation(`     ${evaluatedChildNode.name} (inlined)`);
            }

            evaluatedNode.children.push(evaluatedChildNode);
            result = render.result;
            this.statistics.inlinedComponents++;
            break;
          }

        case "FRAGMENT":
          {
            result = this._resolveFragmentComponent(componentType, reactElement, context, branchStatus, evaluatedNode);
            break;
          }

        case "RELAY_QUERY_RENDERER":
          {
            (0, _invariant.default)(typeValue instanceof _index.AbstractObjectValue);
            result = this._resolveRelayQueryRendererComponent(componentType, reactElement, context, branchStatus, evaluatedNode);
            break;
          }

        case "CONTEXT_PROVIDER":
          {
            result = this._resolveContextProviderComponent(componentType, reactElement, context, branchStatus, evaluatedNode);
            break;
          }

        case "CONTEXT_CONSUMER":
          {
            result = this._resolveContextConsumerComponent(componentType, reactElement, context, branchStatus, evaluatedNode);
            break;
          }

        case "FORWARD_REF":
          {
            result = this._resolveForwardRefComponent(componentType, reactElement, context, branchStatus, evaluatedNode);
            break;
          }

        default:
          (0, _invariant.default)(false, "unsupported component resolution strategy");
      }

      if (result === undefined) {
        result = reactElement;
      }

      if (result instanceof _index.UndefinedValue) {
        return this._resolveReactElementUndefinedRender(componentType, reactElement, context, branchStatus, evaluatedNode);
      } // If we have a new result and we might have a key value then wrap our inlined result in a
      // `<React.Fragment key={keyValue}>` so that we may maintain the key.


      if (!this.componentTreeConfig.firstRenderOnly && needsKey && keyValue.mightNotBeNull()) {
        result = (0, _elements.wrapReactElementWithKeyedFragment)(this.realm, keyValue, result);
      }

      return result;
    } catch (error) {
      if (error instanceof _completions.AbruptCompletion) throw error;
      return this._resolveComponentResolutionFailure(componentType, error, reactElement, context, evaluatedNode, branchStatus);
    }
  }

  _handleComponentTreeRootFailure(error, evaluatedRootNode) {
    if (error.name === "Invariant Violation") {
      throw error;
    } else if (error instanceof _errors2.ReconcilerFatalError) {
      throw new _errors2.ReconcilerFatalError(error.message, evaluatedRootNode);
    } else if (error instanceof _errors2.UnsupportedSideEffect || error instanceof _errors2.DoNotOptimize) {
      throw new _errors2.ReconcilerFatalError(`Failed to render React component root "${evaluatedRootNode.name}" due to ${error.message}`, evaluatedRootNode);
    }

    let message;

    if (error instanceof _errors2.ExpectedBailOut) {
      message = `Failed to optimize React component tree for "${evaluatedRootNode.name}" due to an expected bail-out: ${error.message}`;
    } else if (error instanceof _errors.FatalError) {
      message = `Failed to optimize React component tree for "${evaluatedRootNode.name}" due to a fatal error during evaluation: ${error.message}`;
    } else {
      // if we don't know what the error is, then best to rethrow
      throw error;
    }

    throw new _errors2.ReconcilerFatalError(message, evaluatedRootNode);
  }

  _resolveComponentResolutionFailure(componentType, error, reactElement, context, evaluatedNode, branchStatus) {
    if (error.name === "Invariant Violation") {
      throw error;
    } else if (error instanceof _errors2.ReconcilerFatalError) {
      throw error;
    } else if (error instanceof _errors2.UnsupportedSideEffect) {
      throw new _errors2.ReconcilerFatalError(`Failed to render React component "${evaluatedNode.name}" due to ${error.message}`, evaluatedNode);
    } else if (error instanceof _errors2.DoNotOptimize) {
      return reactElement;
    }

    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props"); // assign a bail out message

    if (error instanceof _errors2.NewComponentTreeBranch) {
      this._findReactComponentTrees(propsValue, evaluatedNode, "NORMAL_FUNCTIONS", componentType, context, branchStatus);

      evaluatedNode.children.push(error.evaluatedNode); // NO-OP (we don't queue a newComponentTree as this was already done)
    } else {
      let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("BAIL-OUT", (0, _utils.getComponentName)(this.realm, typeValue));

      if (this.logger !== undefined && this.realm.react.verbose) {
        this.logger.logInformation(`     ${evaluatedChildNode.name} (bail-out)`);
      }

      evaluatedNode.children.push(evaluatedChildNode);

      this._queueNewComponentTree(typeValue, evaluatedChildNode);

      this._findReactComponentTrees(propsValue, evaluatedNode, "NORMAL_FUNCTIONS", componentType, context, branchStatus);

      if (error instanceof _errors2.ExpectedBailOut) {
        evaluatedChildNode.message = error.message;

        this._assignBailOutMessage(reactElement, error.message);
      } else if (error instanceof _errors.FatalError) {
        let message = "evaluation failed";
        evaluatedChildNode.message = message;

        this._assignBailOutMessage(reactElement, message);
      } else {
        evaluatedChildNode.message = `unknown error`;
        throw error;
      }
    } // a child component bailed out during component folding, so return the function value and continue


    return reactElement;
  }

  _resolveDeeply(componentType, value, context, branchStatus, evaluatedNode, needsKey) {
    if (value instanceof _index.StringValue || value instanceof _index.NumberValue || value instanceof _index.BooleanValue || value instanceof _index.NullValue || value instanceof _index.UndefinedValue) {
      // terminal values
      return value;
    }

    (0, _invariant.default)(!(value instanceof _index.ObjectValue) || value._isFinal !== undefined, `An object value was detected during React reconcilation without its bindings properly applied`);

    if (value instanceof _index.AbstractValue) {
      return this._resolveAbstractValue(componentType, value, context, branchStatus, evaluatedNode);
    } else if (value instanceof _index.ArrayValue) {
      // TODO investigate what about other iterables type objects
      return this._resolveArray(componentType, value, context, branchStatus, evaluatedNode, needsKey);
    } else if (value instanceof _index.ObjectValue && (0, _utils.isReactElement)(value)) {
      return this._resolveReactElement(componentType, value, context, branchStatus, evaluatedNode, needsKey);
    } // This value is not a valid return value of a render, but given we might be
    // in a "&&"" condition, it may never result in a runtime error. Still, if it does
    // result in a runtime error, it would have been the same error before compilation.
    // See issue #2497 for more context.


    return value;
  }

  _assignBailOutMessage(reactElement, message) {
    // $BailOutReason is a field on ObjectValue that allows us to specify a message
    // that gets serialized as a comment node during the ReactElement serialization stage
    message = `Bail-out: ${message}`;

    if (reactElement.$BailOutReason !== undefined) {
      // merge bail out messages if one already exists
      reactElement.$BailOutReason += `, ${message}`;
    } else {
      reactElement.$BailOutReason = message;
    }
  }

  _resolveArray(componentType, arrayValue, context, branchStatus, evaluatedNode, needsKey) {
    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(arrayValue)) {
      let nestedOptimizedFunctionEffects = arrayValue.nestedOptimizedFunctionEffects;

      if (nestedOptimizedFunctionEffects !== undefined) {
        for (let [func, effects] of nestedOptimizedFunctionEffects) {
          let funcCall = () => {
            let result = effects.result;
            this.realm.applyEffects(effects);

            if (result instanceof _completions.SimpleNormalCompletion) {
              result = result.value;
            } else {
              (0, _invariant.default)(false, "TODO support other types of completion");
            }

            (0, _invariant.default)(result instanceof _index.Value);
            return this._resolveDeeply(componentType, result, context, branchStatus, evaluatedNode, needsKey);
          };

          let pureFuncCall = () => this.realm.evaluatePure(funcCall,
          /*bubbles*/
          true, (sideEffectType, binding, expressionLocation) => (0, _utils2.handleReportedSideEffect)(throwUnsupportedSideEffectError, sideEffectType, binding, expressionLocation));

          let resolvedEffects;
          resolvedEffects = this.realm.evaluateForEffects(pureFuncCall,
          /*state*/
          null, `react resolve nested optimized closure`);
          this.statistics.optimizedNestedClosures++;
          nestedOptimizedFunctionEffects.set(func, resolvedEffects);
          this.realm.collectedNestedOptimizedFunctionEffects.set(func, resolvedEffects);
        }
      }

      return arrayValue;
    }

    if (needsKey !== false) needsKey = true;
    let children = (0, _utils.mapArrayValue)(this.realm, arrayValue, elementValue => this._resolveDeeply(componentType, elementValue, context, "NEW_BRANCH", evaluatedNode, needsKey));
    children.makeFinal();
    return children;
  }

  _findReactComponentTrees(value, evaluatedNode, treatFunctionsAs, componentType, context, branchStatus) {
    if (value instanceof _index.AbstractValue) {
      if (value.args.length > 0) {
        for (let arg of value.args) {
          this._findReactComponentTrees(arg, evaluatedNode, treatFunctionsAs, componentType, context, branchStatus);
        }
      } else {
        this.componentTreeState.deadEnds++;
      }
    } else if ((0, _utils.valueIsKnownReactAbstraction)(this.realm, value)) {
      let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("NEW_TREE", (0, _utils.getComponentName)(this.realm, value));
      evaluatedNode.children.push(evaluatedChildNode);

      this._queueNewComponentTree(value, evaluatedChildNode);
    } else if (value instanceof _index.ECMAScriptSourceFunctionValue || value instanceof _index.BoundFunctionValue) {
      if ((0, _utils.valueIsClassComponent)(this.realm, value) || treatFunctionsAs === "FUNCTIONAL_COMPONENTS") {
        let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("NEW_TREE", (0, _utils.getComponentName)(this.realm, value));
        evaluatedNode.children.push(evaluatedChildNode);

        this._queueNewComponentTree(value, evaluatedChildNode);
      } else if (treatFunctionsAs === "NESTED_CLOSURES") {
        (0, _invariant.default)(componentType && context);
        let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("RENDER_PROPS", (0, _utils.getComponentName)(this.realm, value));

        this._evaluateNestedOptimizedFunctionAndStoreEffects(componentType, context, branchStatus, evaluatedChildNode, value);
      }
    } else if (value instanceof _index.ObjectValue) {
      if ((0, _utils.isReactElement)(value)) {
        let typeValue = (0, _utils.getProperty)(this.realm, value, "type");
        let ref = (0, _utils.getProperty)(this.realm, value, "ref");
        let props = (0, _utils.getProperty)(this.realm, value, "props");

        if ((0, _utils.valueIsKnownReactAbstraction)(this.realm, typeValue) || typeValue instanceof _index.ECMAScriptSourceFunctionValue) {
          let evaluatedChildNode = (0, _utils.createReactEvaluatedNode)("NEW_TREE", (0, _utils.getComponentName)(this.realm, typeValue));
          evaluatedNode.children.push(evaluatedChildNode);

          this._queueNewComponentTree(typeValue, evaluatedChildNode);
        }

        this._findReactComponentTrees(ref, evaluatedNode, treatFunctionsAs, componentType, context, branchStatus);

        this._findReactComponentTrees(props, evaluatedNode, treatFunctionsAs, componentType, context, branchStatus);
      } else {
        for (let [propName, binding] of value.properties) {
          if (binding && binding.descriptor) {
            (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

            if (binding.descriptor.enumerable) {
              this._findReactComponentTrees((0, _utils.getProperty)(this.realm, value, propName), evaluatedNode, treatFunctionsAs, componentType, context, branchStatus);
            }
          }
        }
      }
    }
  }

  _evaluateNestedOptimizedFunctionAndStoreEffects(componentType, context, branchStatus, evaluatedNode, func, thisValue = this.realm.intrinsics.undefined) {
    if (!this.realm.react.optimizeNestedFunctions) {
      return;
    }

    let funcToModel = func;

    if (func instanceof _index.BoundFunctionValue) {
      funcToModel = func.$BoundTargetFunction;
      thisValue = func.$BoundThis;
    }

    (0, _invariant.default)(funcToModel instanceof _index.ECMAScriptSourceFunctionValue);

    let funcCall = _singletons.Utils.createModelledFunctionCall(this.realm, funcToModel, undefined, thisValue); // We take the modelled function and wrap it in a pure evaluation so we can check for
    // side-effects that occur when evaluating the function. If there are side-effects, then
    // we don't try and optimize the nested function.


    let pureFuncCall = () => this.realm.evaluatePure(funcCall,
    /*bubbles*/
    false, () => {
      throw new _errors.NestedOptimizedFunctionSideEffect();
    });

    let effects;

    try {
      effects = this.realm.evaluateForEffects(() => {
        let result = pureFuncCall();
        return this._resolveDeeply(componentType, result, context, branchStatus, evaluatedNode, false);
      }, null, "React nestedOptimizedFunction");
    } catch (e) {
      // If the nested optimized function had side-effects, we need to fallback to
      // the default behaviour and leak the nested functions so any bindings
      // within the function properly leak and materialize.
      if (e instanceof _errors.NestedOptimizedFunctionSideEffect) {
        _singletons.Leak.value(this.realm, func);

        return;
      }

      throw e;
    }

    this.statistics.optimizedNestedClosures++;
    this.realm.collectedNestedOptimizedFunctionEffects.set(funcToModel, effects);
  }

}

exports.Reconciler = Reconciler;
//# sourceMappingURL=reconcilation.js.map

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValueWithBranchingLogicApplied = getValueWithBranchingLogicApplied;
exports.wrapReactElementInBranchOrReturnValue = wrapReactElementInBranchOrReturnValue;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index2 = __webpack_require__(15);

var _utils = __webpack_require__(291);

var _errors = __webpack_require__(417);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// This function aims to determine if we need to add keys to the ReactElements
// of the returned conditional abstract value branches. It does this by first
// checking the parent branch nodes (these were use to render both respective branches)
// for any cases where ReactElement types on host components mismatch.
// Note: this implementation is not fully sound and is likely missing support
// for all React reconcilation cases for handling of keys, see issue #1131
function getValueWithBranchingLogicApplied(realm, parentX, parentY, value) {
  let needsKeys = false; // we check the inlined value and see if the component types match

  const searchAndFlagMatchingComponentTypes = (x, y, xTypeParent, yTypeParent) => {
    // The returned value is the result of getting the "render" from a component.
    // We need to search the value returned to see if the nodes need keys adding to them.
    // 1. If we have <X? /> and <Y? />, then check if their
    // types are the same, if they are the same and the parent types
    // are not the same as then we need to add keys
    if (x instanceof _index.ObjectValue && (0, _utils.isReactElement)(x) && y instanceof _index.ObjectValue && (0, _utils.isReactElement)(y)) {
      let xType = (0, _utils.getProperty)(realm, x, "type");
      let yType = (0, _utils.getProperty)(realm, y, "type");

      if (xType.equals(yType) && !xTypeParent.equals(xType) && !yTypeParent.equals(yType)) {
        needsKeys = true;
      }
    } else if (x instanceof _index.ArrayValue) {
      // If we have x: []
      // Go  through the elements of array x
      (0, _utils.forEachArrayValue)(realm, x, (xElem, index) => {
        let yElem = y; // And if we also have y: [], with a given element from x
        // search element of y at the same index from x.
        // If y is not an array, then continue but use x: [] against y

        if (y instanceof _index.ArrayValue) {
          yElem = (0, _utils.getProperty)(realm, y, index + "");
        }

        searchAndFlagMatchingComponentTypes(xElem, yElem, xTypeParent, yTypeParent);
      });
    } else if (y instanceof _index.ArrayValue) {
      // If we have y: []
      // Go  through the elements of array y
      (0, _utils.forEachArrayValue)(realm, y, (yElem, index) => {
        let xElem = x; // And if we also have x: [], with a given element from y
        // search element of x at the same index from y.
        // If x is not an array, then continue but use y: [] against x

        if (x instanceof _index.ArrayValue) {
          xElem = (0, _utils.getProperty)(realm, x, index + "");
        }

        searchAndFlagMatchingComponentTypes(xElem, yElem, xTypeParent, yTypeParent);
      });
    } else if (x instanceof _index.AbstractValue && x.kind === "conditional") {
      // if x is a conditional value like "a ? b : c",
      let [, consequentVal, alternateVal] = x.args;
      searchAndFlagMatchingComponentTypes(consequentVal, y, xTypeParent, yTypeParent);
      searchAndFlagMatchingComponentTypes(alternateVal, y, xTypeParent, yTypeParent);
    } else if (y instanceof _index.AbstractValue && y.kind === "conditional") {
      // if y is a conditional value like "a ? b : c",
      let [, consequentVal, alternateVal] = y.args;
      searchAndFlagMatchingComponentTypes(x, consequentVal, xTypeParent, yTypeParent);
      searchAndFlagMatchingComponentTypes(x, alternateVal, xTypeParent, yTypeParent);
    }
  }; // we first check our "parent" value, that was used to get the inlined value


  const searchAndFlagMismatchingNonHostTypes = (x, y, arrayDepth) => {
    if (x instanceof _index.ObjectValue && (0, _utils.isReactElement)(x) && y instanceof _index.ObjectValue && (0, _utils.isReactElement)(y)) {
      let xType = (0, _utils.getProperty)(realm, x, "type");
      let yType = (0, _utils.getProperty)(realm, y, "type");

      if (xType instanceof _index.StringValue && yType instanceof _index.StringValue) {
        let xProps = (0, _utils.getProperty)(realm, x, "props");
        let yProps = (0, _utils.getProperty)(realm, y, "props");

        if (xProps instanceof _index.ObjectValue && yProps instanceof _index.ObjectValue) {
          let xChildren = (0, _utils.getProperty)(realm, xProps, "children");
          let yChildren = (0, _utils.getProperty)(realm, yProps, "children");

          if (xChildren instanceof _index.Value && yChildren instanceof _index.Value) {
            searchAndFlagMismatchingNonHostTypes(xChildren, yChildren, arrayDepth);
          }
        }
      } else if (!xType.equals(yType)) {
        let [, xVal, yVal] = value.args;
        searchAndFlagMatchingComponentTypes(xVal, yVal, xType, yType);
      }
    } else if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(x) || _index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(y)) {// If either case is an array with wideneded properties, we do not know
      // the contents of the array, so we cannot add keys
    } else if (x instanceof _index.ArrayValue && arrayDepth === 0) {
      (0, _utils.forEachArrayValue)(realm, x, (xElem, index) => {
        let yElem;

        if (y instanceof _index.ArrayValue) {
          // handle the case of [x].equals([y])
          yElem = (0, _utils.getProperty)(realm, y, index + "");
        } else if (index === 0) {
          // handle the case of [x].equals(y)
          yElem = y;
        }

        if (xElem instanceof _index.Value && yElem instanceof _index.Value) {
          searchAndFlagMismatchingNonHostTypes(xElem, yElem, arrayDepth + 1);
        }
      });
    } else if (y instanceof _index.ArrayValue && arrayDepth === 0) {
      (0, _utils.forEachArrayValue)(realm, y, (yElem, index) => {
        let xElem;

        if (x instanceof _index.ArrayValue) {
          // handle the case of [y].equals([x]
          xElem = (0, _utils.getProperty)(realm, x, index + "");
        } else if (index === 0) {
          // handle the case of [y].equals(x)
          xElem = x;
        }

        if (xElem instanceof _index.Value && yElem instanceof _index.Value) {
          searchAndFlagMismatchingNonHostTypes(xElem, yElem, arrayDepth + 1);
        }
      });
    }
  };

  searchAndFlagMismatchingNonHostTypes(parentX, parentY, 0);

  if (needsKeys) {
    return applyBranchedLogicValue(realm, value);
  }

  return value;
} // When we apply branching logic, it means to add keys to all ReactElement nodes
// we encounter, thus returning new ReactElements with the keys on them


function applyBranchedLogicValue(realm, value) {
  if (value instanceof _index.StringValue || value instanceof _index.NumberValue || value instanceof _index.BooleanValue || value instanceof _index.NullValue || value instanceof _index.UndefinedValue) {// terminal values
  } else if (value instanceof _index.ObjectValue && (0, _utils.isReactElement)(value)) {
    return (0, _utils.addKeyToReactElement)(realm, value);
  } else if (value instanceof _index.ArrayValue) {
    let newArray = (0, _utils.mapArrayValue)(realm, value, elementValue => applyBranchedLogicValue(realm, elementValue));
    newArray.makeFinal();
    return newArray;
  } else if (value instanceof _index.AbstractValue && value.kind === "conditional") {
    let [condValue, consequentVal, alternateVal] = value.args;
    (0, _invariant.default)(condValue instanceof _index.AbstractValue);
    return realm.evaluateWithAbstractConditional(condValue, () => {
      return realm.evaluateForEffects(() => wrapReactElementInBranchOrReturnValue(realm, applyBranchedLogicValue(realm, consequentVal)), null, "applyBranchedLogicValue consequent");
    }, () => {
      return realm.evaluateForEffects(() => wrapReactElementInBranchOrReturnValue(realm, applyBranchedLogicValue(realm, alternateVal)), null, "applyBranchedLogicValue alternate");
    });
  } else if (value instanceof _index.AbstractValue && (value.kind === "||" || value.kind === "&&")) {
    (0, _invariant.default)(false, "applyBranchedLogicValue encounterted a logical expression (|| or &&), this should never occur");
  } else {
    throw new _errors.ExpectedBailOut("Unsupported value encountered when applying branched logic to values");
  }

  return value;
} // when a ReactElement is resolved in a conditional branch we
// can improve runtime performance by ensuring that the ReactElement
// is only created lazily in that specific branch and referenced
// from then on. To do this we create a temporal abstract value
// and set its kind to "branched ReactElement" so we properly track
// the original ReactElement. If we don't have a ReactElement,
// return the original value


function wrapReactElementInBranchOrReturnValue(realm, value) {
  if (value instanceof _index.ObjectValue && (0, _utils.isReactElement)(value)) {
    let temporal = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.ObjectValue, [(0, _utils.cloneReactElement)(realm, value, false)], (0, _generator.createOperationDescriptor)("SINGLE_ARG"), {
      isPure: true,
      skipInvariant: true
    });

    (0, _invariant.default)(temporal instanceof _index.AbstractObjectValue);
    temporal.values = new _index2.ValuesDomain(value);
    value.temporalAlias = temporal;
  }

  return value;
}
//# sourceMappingURL=branching.js.map

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReconcilerFatalError = exports.DoNotOptimize = exports.NewComponentTreeBranch = exports.UnsupportedSideEffect = exports.SimpleClassBailOut = exports.ExpectedBailOut = void 0;

var _errors = __webpack_require__(3);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ExpectedBailOut is like an error, that gets thrown during the reconcilation phase
// allowing the reconcilation to continue on other branches of the tree, the message
// given to ExpectedBailOut will be assigned to the value.$BailOutReason property and serialized
// as a comment in the output source to give the user hints as to what they need to do
// to fix the bail-out case
class ExpectedBailOut extends Error {} // SimpleClassBailOuts only occur when a simple class instance is created and used
// bailing out here will result in a complex class instance being created after
// and an alternative complex class component route being used


exports.ExpectedBailOut = ExpectedBailOut;

class SimpleClassBailOut extends Error {} // When the reconciler detectes a side-effect in pure evaluation, it throws one
// of these errors. This will fall straight through the the wrapping React
// component render try/catch, which will then throw an appropiate
// ReconcilerFatalError along with information on the React component stack


exports.SimpleClassBailOut = SimpleClassBailOut;

class UnsupportedSideEffect extends Error {} // NewComponentTreeBranch only occur when a complex class is found in a
// component tree and the reconciler can no longer fold the component of that branch


exports.UnsupportedSideEffect = UnsupportedSideEffect;

class NewComponentTreeBranch extends Error {
  constructor(evaluatedNode) {
    super();
    this.evaluatedNode = evaluatedNode;
  }

}

exports.NewComponentTreeBranch = NewComponentTreeBranch;

class DoNotOptimize extends Error {} // Used when an entire React component tree has failed to optimize
// this means there is a programming bug in the application that is
// being Prepacked


exports.DoNotOptimize = DoNotOptimize;

class ReconcilerFatalError extends _errors.FatalError {
  constructor(message, evaluatedNode) {
    super(message);
    evaluatedNode.status = "FATAL";
    evaluatedNode.message = message;
    this.evaluatedNode = evaluatedNode; // used for assertions in tests

    this.__isReconcilerFatalError = true;
  }

}

exports.ReconcilerFatalError = ReconcilerFatalError;
//# sourceMappingURL=errors.js.map

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInitialProps = getInitialProps;
exports.getInitialContext = getInitialContext;
exports.createSimpleClassInstance = createSimpleClassInstance;
exports.createClassInstanceForFirstRenderOnly = createClassInstanceForFirstRenderOnly;
exports.createClassInstance = createClassInstance;
exports.evaluateClassConstructor = evaluateClassConstructor;
exports.applyGetDerivedStateFromProps = applyGetDerivedStateFromProps;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _utils = __webpack_require__(291);

var _errors = __webpack_require__(417);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _traverse = _interopRequireDefault(__webpack_require__(293));

var _errors2 = __webpack_require__(3);

var _ShapeInformation = __webpack_require__(419);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const lifecycleMethods = new Set(["componentWillUnmount", "componentDidMount", "componentWillMount", "componentDidUpdate", "componentWillUpdate", "componentDidCatch", "componentWillReceiveProps"]);
const whitelistedProperties = new Set(["props", "context", "refs", "setState"]);

function getInitialProps(realm, componentType, {
  modelString
}) {
  let componentModel = modelString !== undefined ? JSON.parse(modelString) : undefined;

  let shape = _ShapeInformation.ShapeInformation.createForReactComponentProps(componentModel);

  let propsName = null;

  if (componentType !== null) {
    if ((0, _utils.valueIsClassComponent)(realm, componentType)) {
      propsName = "this.props";
    } else {
      let formalParameters;

      if (componentType instanceof _index.BoundFunctionValue) {
        (0, _invariant.default)(componentType.$BoundTargetFunction instanceof _index.ECMAScriptSourceFunctionValue);
        formalParameters = componentType.$BoundTargetFunction.$FormalParameters;
      } else {
        formalParameters = componentType.$FormalParameters;
      } // otherwise it's a functional component, where the first paramater of the function is "props" (if it exists)


      if (formalParameters.length > 0) {
        let firstParam = formalParameters[0];

        if (t.isIdentifier(firstParam)) {
          propsName = firstParam.name;
        }
      }
    }
  }

  let abstractPropsObject = _index.AbstractValue.createAbstractObject(realm, propsName || "props", shape);

  (0, _invariant.default)(abstractPropsObject instanceof _index.AbstractObjectValue);
  (0, _utils.flagPropsWithNoPartialKeyOrRef)(realm, abstractPropsObject);
  abstractPropsObject.makeFinal();
  return abstractPropsObject;
}

function getInitialContext(realm, componentType) {
  let contextName = null;

  if ((0, _utils.valueIsClassComponent)(realm, componentType)) {
    // it's a class component, so we need to check the type on for context of the component prototype
    let superTypeParameters = componentType.$SuperTypeParameters;
    contextName = "this.context";

    if (superTypeParameters !== undefined) {
      throw new _errors.ExpectedBailOut("context on class components not yet supported");
    }
  } else {
    let formalParameters;

    if (componentType instanceof _index.BoundFunctionValue) {
      (0, _invariant.default)(componentType.$BoundTargetFunction instanceof _index.ECMAScriptSourceFunctionValue);
      formalParameters = componentType.$BoundTargetFunction.$FormalParameters;
    } else {
      formalParameters = componentType.$FormalParameters;
    } // otherwise it's a functional component, where the second paramater of the function is "context" (if it exists)


    if (formalParameters.length > 1) {
      let secondParam = formalParameters[1];

      if (t.isIdentifier(secondParam)) {
        contextName = secondParam.name;
      }
    }
  }

  let value = _index.AbstractValue.createAbstractObject(realm, contextName || "context");

  return value;
}

function visitClassMethodAstForThisUsage(realm, method) {
  let formalParameters = method.$FormalParameters;
  let code = method.$ECMAScriptCode;
  (0, _traverse.default)(t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])), {
    ThisExpression(path) {
      let parentNode = path.parentPath.node;

      if (!t.isMemberExpression(parentNode)) {
        throw new _errors.SimpleClassBailOut(`possible leakage of independent "this" reference found`);
      }
    }

  }, null, {});
}

function createSimpleClassInstance(realm, componentType, props, context) {
  let componentPrototype = (0, _index2.Get)(realm, componentType, "prototype");
  (0, _invariant.default)(componentPrototype instanceof _index.ObjectValue); // create an instance object and disable serialization as we don't want to output the internals we set below

  let instance = new _index.ObjectValue(realm, componentPrototype, "this", true);
  let allowedPropertyAccess = new Set(["props", "context"]);

  for (let [name] of componentPrototype.properties) {
    if (lifecycleMethods.has(name)) {
      // this error will result in the simple class falling back to a complex class
      throw new _errors.SimpleClassBailOut("lifecycle methods are not supported on simple classes");
    } else if (name !== "constructor") {
      allowedPropertyAccess.add(name);
      let method = (0, _index2.Get)(realm, componentPrototype, name);

      if (method instanceof _index.ECMAScriptSourceFunctionValue) {
        visitClassMethodAstForThisUsage(realm, method);
      }

      _singletons.Properties.Set(realm, instance, name, method, true);
    }
  } // assign props


  _singletons.Properties.Set(realm, instance, "props", props, true); // assign context


  _singletons.Properties.Set(realm, instance, "context", context, true); // as this object is simple, we want to check if any access to anything other than
  // "this.props" or "this.context" or methods on the class occur


  let $GetOwnProperty = instance.$GetOwnProperty;

  instance.$GetOwnProperty = P => {
    if (!allowedPropertyAccess.has(P)) {
      // this error will result in the simple class falling back to a complex class
      throw new _errors.SimpleClassBailOut("access to basic class instance properties is not supported on simple classes");
    }

    return $GetOwnProperty.call(instance, P);
  }; // enable serialization to support simple instance variables properties


  instance.refuseSerialization = false; // return the instance

  return instance;
}

function deeplyApplyInstancePrototypeProperties(realm, instance, componentPrototype, classMetadata) {
  let {
    instanceProperties,
    instanceSymbols
  } = classMetadata;
  let proto = componentPrototype.$Prototype;

  if (proto instanceof _index.ObjectValue && proto !== realm.intrinsics.ObjectPrototype) {
    deeplyApplyInstancePrototypeProperties(realm, instance, proto, classMetadata);
  }

  for (let [name] of componentPrototype.properties) {
    // ensure we don't set properties that were defined on the instance
    if (name !== "constructor" && !instanceProperties.has(name)) {
      _singletons.Properties.Set(realm, instance, name, (0, _index2.Get)(realm, componentPrototype, name), true);
    }
  }

  for (let [symbol] of componentPrototype.symbols) {
    // ensure we don't set symbols that were defined on the instance
    if (!instanceSymbols.has(symbol)) {
      _singletons.Properties.Set(realm, instance, symbol, (0, _index2.Get)(realm, componentPrototype, symbol), true);
    }
  }
}

function createClassInstanceForFirstRenderOnly(realm, componentType, props, context, evaluatedNode) {
  let instance = (0, _utils.getValueFromFunctionCall)(realm, componentType, realm.intrinsics.undefined, [props, context], true);
  let objectAssign = (0, _index2.Get)(realm, realm.intrinsics.Object, "assign");
  (0, _invariant.default)(objectAssign instanceof _index.ECMAScriptFunctionValue);
  let objectAssignCall = objectAssign.$Call;
  (0, _invariant.default)(objectAssignCall !== undefined);
  (0, _invariant.default)(instance instanceof _index.ObjectValue);
  instance.refuseSerialization = true; // assign props

  _singletons.Properties.Set(realm, instance, "props", props, true); // assign context


  _singletons.Properties.Set(realm, instance, "context", context, true);

  let state = (0, _index2.Get)(realm, instance, "state");

  if (state instanceof _index.AbstractObjectValue || state instanceof _index.ObjectValue) {
    state.makeFinal();
  } // assign a mocked setState


  let setState = new _index.NativeFunctionValue(realm, undefined, `setState`, 1, (_context, [stateToUpdate, callback]) => {
    (0, _invariant.default)(instance instanceof _index.ObjectValue);
    let prevState = (0, _index2.Get)(realm, instance, "state");
    (0, _invariant.default)(prevState instanceof _index.ObjectValue);

    if (stateToUpdate instanceof _index.ECMAScriptSourceFunctionValue && stateToUpdate.$Call) {
      stateToUpdate = stateToUpdate.$Call(instance, [prevState]);
    }

    if (stateToUpdate instanceof _index.ObjectValue) {
      let newState = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
      objectAssignCall(realm.intrinsics.undefined, [newState, prevState]);
      newState.makeFinal();

      for (let [key, binding] of stateToUpdate.properties) {
        if (binding && binding.descriptor) {
          (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

          if (binding.descriptor.enumerable) {
            let value = (0, _utils.getProperty)(realm, stateToUpdate, key);
            (0, _utils.hardModifyReactObjectPropertyBinding)(realm, newState, key, value);
          }
        }
      }

      _singletons.Properties.Set(realm, instance, "state", newState, true);
    }

    if (callback instanceof _index.ECMAScriptSourceFunctionValue && callback.$Call) {
      callback.$Call(instance, []);
    }

    return realm.intrinsics.undefined;
  });
  setState.intrinsicName = "(function() {})";

  _singletons.Properties.Set(realm, instance, "setState", setState, true);

  instance.refuseSerialization = false;
  return instance;
}

function createClassInstance(realm, componentType, props, context, classMetadata) {
  let componentPrototype = (0, _index2.Get)(realm, componentType, "prototype");
  (0, _invariant.default)(componentPrototype instanceof _index.ObjectValue); // create an instance object and disable serialization as we don't want to output the internals we set below

  let instance = new _index.ObjectValue(realm, componentPrototype, "this", true);
  deeplyApplyInstancePrototypeProperties(realm, instance, componentPrototype, classMetadata); // assign refs

  _singletons.Properties.Set(realm, instance, "refs", _index.AbstractValue.createAbstractObject(realm, "this.refs"), true); // assign props


  _singletons.Properties.Set(realm, instance, "props", props, true); // assign context


  _singletons.Properties.Set(realm, instance, "context", context, true); // enable serialization to support simple instance variables properties


  instance.refuseSerialization = false; // return the instance in an abstract object

  let value = _index.AbstractValue.createAbstractObject(realm, "this", instance);

  (0, _invariant.default)(value instanceof _index.AbstractObjectValue);
  return value;
}

function evaluateClassConstructor(realm, constructorFunc, props, context) {
  let instanceProperties = new Set();
  let instanceSymbols = new Set();
  realm.evaluatePure(() => realm.evaluateForEffects(() => {
    let instance = (0, _index2.Construct)(realm, constructorFunc, [props, context]);
    (0, _invariant.default)(instance instanceof _index.ObjectValue);

    for (let [propertyName] of instance.properties) {
      if (!whitelistedProperties.has(propertyName)) {
        instanceProperties.add(propertyName);
      }
    }

    for (let [symbol] of instance.symbols) {
      instanceSymbols.add(symbol);
    }

    return instance;
  },
  /*state*/
  null, `react component constructor: ${constructorFunc.getName()}`),
  /*bubbles*/
  true,
  /*reportSideEffectFunc*/
  null);
  return {
    instanceProperties,
    instanceSymbols
  };
}

function applyGetDerivedStateFromProps(realm, getDerivedStateFromProps, instance, props) {
  let prevState = (0, _index2.Get)(realm, instance, "state");
  let getDerivedStateFromPropsCall = getDerivedStateFromProps.$Call;
  (0, _invariant.default)(getDerivedStateFromPropsCall !== undefined);
  let partialState = getDerivedStateFromPropsCall(realm.intrinsics.null, [props, prevState]);

  const deriveState = state => {
    let objectAssign = (0, _index2.Get)(realm, realm.intrinsics.Object, "assign");
    (0, _invariant.default)(objectAssign instanceof _index.ECMAScriptFunctionValue);
    let objectAssignCall = objectAssign.$Call;
    (0, _invariant.default)(objectAssignCall !== undefined);

    if (state instanceof _index.AbstractValue && !(state instanceof _index.AbstractObjectValue)) {
      const kind = state.kind;

      if (kind === "conditional") {
        let condition = state.args[0];
        let a = deriveState(state.args[1]);
        let b = deriveState(state.args[2]);
        (0, _invariant.default)(condition instanceof _index.AbstractValue);

        if (a === null && b === null) {
          return null;
        } else if (a === null) {
          (0, _invariant.default)(b instanceof _index.Value);
          return _index.AbstractValue.createFromConditionalOp(realm, condition, realm.intrinsics.false, b);
        } else if (b === null) {
          (0, _invariant.default)(a instanceof _index.Value);
          return _index.AbstractValue.createFromConditionalOp(realm, condition, a, realm.intrinsics.false);
        } else {
          (0, _invariant.default)(a instanceof _index.Value);
          (0, _invariant.default)(b instanceof _index.Value);
          return _index.AbstractValue.createFromConditionalOp(realm, condition, a, b);
        }
      } else if (kind === "||" || kind === "&&") {
        let a = deriveState(state.args[0]);
        let b = deriveState(state.args[1]);

        if (b === null) {
          (0, _invariant.default)(a instanceof _index.Value);
          return _index.AbstractValue.createFromLogicalOp(realm, kind, a, realm.intrinsics.false);
        } else {
          (0, _invariant.default)(a instanceof _index.Value);
          (0, _invariant.default)(b instanceof _index.Value);
          return _index.AbstractValue.createFromLogicalOp(realm, kind, a, b);
        }
      } else {
        (0, _invariant.default)(state.args !== undefined, "TODO: unknown abstract value passed to deriveState"); // as the value is completely abstract, we need to add a bunch of
        // operations to be emitted to ensure we do the right thing at runtime

        let a = _index.AbstractValue.createFromBinaryOp(realm, "!==", state, realm.intrinsics.null);

        let b = _index.AbstractValue.createFromBinaryOp(realm, "!==", state, realm.intrinsics.undefined);

        let c = _index.AbstractValue.createFromLogicalOp(realm, "&&", a, b);

        (0, _invariant.default)(c instanceof _index.AbstractValue);
        let newState = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
        let preludeGenerator = realm.preludeGenerator;
        (0, _invariant.default)(preludeGenerator !== undefined); // we cannot use the standard Object.assign as partial state
        // is not simple. however, given getDerivedStateFromProps is
        // meant to be pure, we can assume that there are no getters on
        // the partial abstract state

        _index.AbstractValue.createTemporalObjectAssign(realm, newState, [prevState, state]);

        newState.makeSimple();
        newState.makePartial();
        newState.makeFinal();

        let conditional = _index.AbstractValue.createFromLogicalOp(realm, "&&", c, newState);

        return conditional;
      }
    } else if (state !== realm.intrinsics.null && state !== realm.intrinsics.undefined) {
      let newState = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);

      try {
        objectAssignCall(realm.intrinsics.undefined, [newState, prevState, state]);
      } catch (e) {
        if (realm.isInPureScope() && e instanceof _errors2.FatalError) {
          let preludeGenerator = realm.preludeGenerator;
          (0, _invariant.default)(preludeGenerator !== undefined);

          _index.AbstractValue.createTemporalObjectAssign(realm, newState, [prevState, state]);

          newState.makeSimple();
          newState.makePartial();
          return newState;
        }

        throw e;
      }

      newState.makeFinal();
      return newState;
    } else {
      return null;
    }
  };

  let newState = deriveState(partialState);

  if (newState !== null) {
    if (newState instanceof _index.AbstractValue) {
      newState = _index.AbstractValue.createFromLogicalOp(realm, "||", newState, prevState);
    }

    (0, _invariant.default)(newState instanceof _index.Value);

    _singletons.Properties.Set(realm, instance, "state", newState, true);
  }
}
//# sourceMappingURL=components.js.map

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAndValidateArgModel = createAndValidateArgModel;
exports.ShapeInformation = void 0;

var _singletons = __webpack_require__(236);

var _index = __webpack_require__(10);

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ShapeInformation {
  constructor(descriptor, parentDescriptor, parentKey, universe) {
    this._descriptor = descriptor;
    this._parentDescriptor = parentDescriptor;
    this._parentKey = parentKey;
    this._universe = universe;
  }

  getGetter() {
    // we want getter only for existing GraphQL objects
    return this._parentDescriptor !== undefined && this._parentDescriptor.graphQLType !== undefined && this._parentDescriptor.kind === "object" ? this._getAssociatedGetter() : undefined;
  }

  getAbstractType() {
    // we assume that value is not optional if it root
    if (this._isOptional() || this._descriptor.jsType === "void" || this._descriptor.jsType === "null") {
      return _index.Value;
    }

    return _singletons.Utils.getTypeFromName(this._descriptor.jsType) || _index.Value;
  }

  getPropertyShape(key) {
    let property = this._getInformationForProperty(key);

    return property !== undefined ? ShapeInformation._resolveLinksAndWrap(property.shape, this._descriptor, key, this._universe) : undefined;
  }

  static createForArgument(model, argname) {
    return model !== undefined ? ShapeInformation._resolveLinksAndWrap(model.universe[model.arguments[argname]], undefined, undefined, model.universe) : undefined;
  }

  static createForReactComponentProps(model) {
    return model !== undefined ? ShapeInformation._resolveLinksAndWrap(model.universe[model.component.props], undefined, undefined, model.universe) : undefined;
  }

  _isOptional() {
    if (this._parentDescriptor === undefined) {
      return undefined;
    }

    switch (this._parentDescriptor.kind) {
      case "object":
        return this._parentKey !== undefined && this._parentDescriptor.properties[this._parentKey] !== undefined ? this._parentDescriptor.properties[this._parentKey].optional : undefined;

      case "array":
        return this._parentDescriptor.elementShape !== undefined ? this._parentDescriptor.elementShape.optional : undefined;

      default:
        return undefined;
    }
  }

  _getInformationForProperty(key) {
    switch (this._descriptor.kind) {
      case "object":
        return this._descriptor.properties[key];

      case "array":
        switch (key) {
          case "length":
            return ShapeInformation._arrayLengthProperty;

          case "prototype":
            return undefined;

          default:
            return this._descriptor.elementShape;
        }

      default:
        // it is still legal to do member access on primitive value
        // such as string
        return undefined;
    }
  }

  _getAssociatedGetter() {
    switch (this._descriptor.kind) {
      case "object":
        return "tree";

      case "array":
        let elementShape = this._descriptor.elementShape !== undefined ? this._descriptor.elementShape.shape : undefined;

        let innerShape = ShapeInformation._resolveLinksAndWrap(elementShape, this._descriptor, undefined, this._universe);

        if (innerShape === undefined) {
          return undefined;
        }

        switch (innerShape._getAssociatedGetter()) {
          case "bool":
            return "bool_list";

          case "double":
            return "double_list";

          case "int":
            return "int_list";

          case "time":
            return "time_list";

          case "string":
            return "string_list";

          case "tree":
            return "tree_list";
          // no support for nested arrays yet

          default:
            return undefined;
        }

      case "scalar":
        switch (this._descriptor.graphQLType) {
          case "Color":
          case "File":
          case "ID":
          case "String":
          case "Url":
            return "string";

          case "Int":
          case "Time":
            return "int";

          case "Float":
            return "double";

          case "Boolean":
            return "bool";

          default:
            return undefined;
        }

      case "enum":
        return "string";

      default:
        return undefined;
    }
  }

  static _resolveLinksAndWrap(descriptor, parentDescription, parentKey, universe) {
    while (descriptor && descriptor.kind === "link") {
      descriptor = universe[descriptor.shapeName];
    }

    return descriptor !== undefined ? new ShapeInformation(descriptor, parentDescription, parentKey, universe) : undefined;
  }

} // TODO: do more full validation walking the whole shape


exports.ShapeInformation = ShapeInformation;

_defineProperty(ShapeInformation, "_arrayLengthProperty", {
  shape: {
    kind: "scalar",
    jsType: "integral"
  },
  optional: false
});

function createAndValidateArgModel(realm, argModelString) {
  let argModelError;

  if (argModelString instanceof _index.StringValue) {
    try {
      let argModel = JSON.parse(argModelString.value);
      if (!argModel.universe) argModelError = new _errors.CompilerDiagnostic("ArgModel must contain a universe property containing a ShapeUniverse", realm.currentLocation, "PP1008", "FatalError");
      if (!argModel.arguments) argModelError = new _errors.CompilerDiagnostic("ArgModel must contain an arguments property.", realm.currentLocation, "PP1008", "FatalError");
      return argModel;
    } catch (e) {
      argModelError = new _errors.CompilerDiagnostic("Failed to parse model for arguments", realm.currentLocation, "PP1008", "FatalError");
    }
  } else {
    argModelError = new _errors.CompilerDiagnostic("String expected as a model", realm.currentLocation, "PP1008", "FatalError");
  }

  if (argModelError !== undefined && realm.handleError(argModelError) !== "Recover") {
    throw new _errors.FatalError();
  }

  return undefined;
}
//# sourceMappingURL=ShapeInformation.js.map

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneReactElement = cloneReactElement;
exports.createReactElement = createReactElement;
exports.wrapReactElementWithKeyedFragment = wrapReactElementWithKeyedFragment;
exports.traverseReactElement = traverseReactElement;

var _index = __webpack_require__(15);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index3 = __webpack_require__(232);

var _utils = __webpack_require__(291);

var _BinaryExpression = __webpack_require__(292);

var _errors = __webpack_require__(3);

var _generator = __webpack_require__(237);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function createPropsObject(realm, type, config, children) {
  // If we're in "rendering" a React component tree, we should have an active reconciler
  let activeReconciler = realm.react.activeReconciler;
  let firstRenderOnly = activeReconciler !== undefined ? activeReconciler.componentTreeConfig.firstRenderOnly : false;
  let defaultProps = type instanceof _index2.ObjectValue || type instanceof _index2.AbstractObjectValue ? (0, _index3.Get)(realm, type, "defaultProps") : realm.intrinsics.undefined;

  let props = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);

  props.makeFinal();
  realm.react.reactProps.add(props);
  let key = realm.intrinsics.null;
  let ref = realm.intrinsics.null;

  if (!(0, _utils.hasNoPartialKeyOrRef)(realm, config)) {
    // if either are abstract, this will impact the reconcilation process
    // and ultimately prevent us from folding ReactElements properly
    let diagnostic = new _errors.CompilerDiagnostic(`unable to evaluate "key" and "ref" on a ReactElement due to an abstract config passed to createElement`, realm.currentLocation, "PP0025", "FatalError");
    realm.handleError(diagnostic);
    if (realm.handleError(diagnostic) === "Fail") throw new _errors.FatalError();
  }

  let possibleKey = (0, _index3.Get)(realm, config, "key");

  if (possibleKey !== realm.intrinsics.null && possibleKey !== realm.intrinsics.undefined) {
    // if the config has been marked as having no partial key or ref and the possible key
    // is abstract, yet the config doesn't have a key property, then the key can remain null
    let keyNotNeeded = (0, _utils.hasNoPartialKeyOrRef)(realm, config) && possibleKey instanceof _index2.AbstractValue && config instanceof _index2.ObjectValue && !config.properties.has("key");

    if (!keyNotNeeded) {
      key = (0, _BinaryExpression.computeBinary)(realm, "+", realm.intrinsics.emptyString, possibleKey);
    }
  }

  let possibleRef = (0, _index3.Get)(realm, config, "ref");

  if (possibleRef !== realm.intrinsics.null && possibleRef !== realm.intrinsics.undefined && !firstRenderOnly) {
    // if the config has been marked as having no partial key or ref and the possible ref
    // is abstract, yet the config doesn't have a ref property, then the ref can remain null
    let refNotNeeded = (0, _utils.hasNoPartialKeyOrRef)(realm, config) && possibleRef instanceof _index2.AbstractValue && config instanceof _index2.ObjectValue && !config.properties.has("ref");

    if (!refNotNeeded) {
      ref = possibleRef;
    }
  }

  const setProp = (name, value) => {
    if (name !== "__self" && name !== "__source" && name !== "key" && name !== "ref") {
      (0, _invariant.default)(props instanceof _index2.ObjectValue);
      (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, name, value);
    }
  };

  const applyProperties = () => {
    if (config instanceof _index2.ObjectValue) {
      for (let [propKey, binding] of config.properties) {
        if (binding && binding.descriptor) {
          (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

          if (binding.descriptor.enumerable) {
            setProp(propKey, (0, _index3.Get)(realm, config, propKey));
          }
        }
      }
    }
  };

  if (config instanceof _index2.AbstractObjectValue && config.isPartialObject() || config instanceof _index2.ObjectValue && config.isPartialObject() && config.isSimpleObject()) {
    // create a new props object that will be the target of the Object.assign
    props = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);
    realm.react.reactProps.add(props);
    (0, _utils.applyObjectAssignConfigsForReactElement)(realm, props, [config]);
    props.makeFinal();

    if (children !== undefined) {
      (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, "children", children);
    } // handle default props on a partial/abstract config


    if (defaultProps !== realm.intrinsics.undefined) {
      let defaultPropsEvaluated = 0; // first see if we can apply all the defaultProps without needing the helper

      if (defaultProps instanceof _index2.ObjectValue && !defaultProps.isPartialObject()) {
        for (let [propName, binding] of defaultProps.properties) {
          if (binding.descriptor !== undefined) {
            (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

            if (binding.descriptor.value !== realm.intrinsics.undefined) {
              // see if we have this on our props object
              let propBinding = props.properties.get(propName); // if the binding exists and value is abstract, it might be undefined
              // so in that case we need the helper, otherwise we can continue

              if (propBinding !== undefined && !(propBinding.descriptor instanceof _descriptors.PropertyDescriptor && propBinding.descriptor.value instanceof _index2.AbstractValue)) {
                defaultPropsEvaluated++; // if the value we have is undefined, we can apply the defaultProp

                if (propBinding.descriptor) {
                  (0, _invariant.default)(propBinding.descriptor instanceof _descriptors.PropertyDescriptor);
                  if (propBinding.descriptor.value === realm.intrinsics.undefined) (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, propName, (0, _index3.Get)(realm, defaultProps, propName));
                }
              }
            }
          }
        }
      } // if defaultPropsEvaluated === the amount of properties defaultProps has, then we've successfully
      // ensured all the defaultProps have already been dealt with, so we don't need the helper


      if (!(defaultProps instanceof _index2.ObjectValue) || defaultProps.isPartialObject() || defaultPropsEvaluated !== defaultProps.properties.size) {
        props.makePartial();
        props.makeSimple(); // if the props has any properties that are "undefined", we need to make them abstract
        // as the helper function applies defaultProps on values that are undefined or do not
        // exist

        for (let [propName, binding] of props.properties) {
          if (binding.descriptor !== undefined) {
            (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

            if (binding.descriptor.value === realm.intrinsics.undefined) {
              (0, _invariant.default)(defaultProps instanceof _index2.AbstractObjectValue || defaultProps instanceof _index2.ObjectValue);
              (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, propName, (0, _index3.Get)(realm, defaultProps, propName));
            }
          }
        } // if we have children and they are abstract, they might be undefined at runtime


        if (children !== undefined && children instanceof _index2.AbstractValue) {
          // children === undefined ? defaultProps.children : children;
          let condition = _index2.AbstractValue.createFromBinaryOp(realm, "===", children, realm.intrinsics.undefined);

          (0, _invariant.default)(defaultProps instanceof _index2.AbstractObjectValue || defaultProps instanceof _index2.ObjectValue);

          let conditionalChildren = _index2.AbstractValue.createFromConditionalOp(realm, condition, (0, _index3.Get)(realm, defaultProps, "children"), children);

          (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, "children", conditionalChildren);
        }

        let defaultPropsHelper = realm.react.defaultPropsHelper;
        (0, _invariant.default)(defaultPropsHelper !== undefined);
        let snapshot = props.getSnapshot();
        props.temporalAlias = snapshot;
        let temporalArgs = [defaultPropsHelper, snapshot, defaultProps];

        let temporalTo = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.ObjectValue, temporalArgs, (0, _generator.createOperationDescriptor)("REACT_DEFAULT_PROPS_HELPER"), {
          skipInvariant: true,
          mutatesOnly: [snapshot]
        });

        (0, _invariant.default)(temporalTo instanceof _index2.AbstractObjectValue);

        if (props instanceof _index2.AbstractObjectValue) {
          temporalTo.values = props.values;
        } else {
          (0, _invariant.default)(props instanceof _index2.ObjectValue);
          temporalTo.values = new _index.ValuesDomain(props);
        }

        props.temporalAlias = temporalTo;
      }
    }
  } else {
    applyProperties();

    if (children !== undefined) {
      setProp("children", children);
    }

    if (defaultProps instanceof _index2.AbstractObjectValue || defaultProps.isPartialObject()) {
      (0, _invariant.default)(false, "TODO: we need to eventually support this");
    } else if (defaultProps instanceof _index2.ObjectValue) {
      for (let [propKey, binding] of defaultProps.properties) {
        if (binding && binding.descriptor) {
          (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

          if (binding.descriptor.enumerable && (0, _index3.Get)(realm, props, propKey) === realm.intrinsics.undefined) {
            setProp(propKey, (0, _index3.Get)(realm, defaultProps, propKey));
          }
        }
      }
    }
  }

  (0, _invariant.default)(props instanceof _index2.ObjectValue); // We know the props has no keys because if it did it would have thrown above
  // so we can remove them the props we create.

  (0, _utils.flagPropsWithNoPartialKeyOrRef)(realm, props);
  return {
    key,
    props,
    ref
  };
}

function splitReactElementsByConditionalType(realm, condValue, consequentVal, alternateVal, config, children) {
  return realm.evaluateWithAbstractConditional(condValue, () => {
    return realm.evaluateForEffects(() => createReactElement(realm, consequentVal, config, children), null, "splitReactElementsByConditionalType consequent");
  }, () => {
    return realm.evaluateForEffects(() => createReactElement(realm, alternateVal, config, children), null, "splitReactElementsByConditionalType alternate");
  });
}

function splitReactElementsByConditionalConfig(realm, condValue, consequentVal, alternateVal, type, children) {
  return realm.evaluateWithAbstractConditional(condValue, () => {
    return realm.evaluateForEffects(() => createReactElement(realm, type, consequentVal, children), null, "splitReactElementsByConditionalConfig consequent");
  }, () => {
    return realm.evaluateForEffects(() => createReactElement(realm, type, alternateVal, children), null, "splitReactElementsByConditionalConfig alternate");
  });
}

function cloneReactElement(realm, reactElement, config, children) {
  let props = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);

  realm.react.reactProps.add(props);

  const setProp = (name, value) => {
    if (name !== "__self" && name !== "__source" && name !== "key" && name !== "ref") {
      (0, _invariant.default)(props instanceof _index2.ObjectValue);
      (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, name, value);
    }
  };

  let elementProps = (0, _utils.getProperty)(realm, reactElement, "props");
  (0, _utils.applyObjectAssignConfigsForReactElement)(realm, props, [elementProps, config]);
  props.makeFinal();
  let key = (0, _utils.getProperty)(realm, reactElement, "key");
  let ref = (0, _utils.getProperty)(realm, reactElement, "ref");
  let type = (0, _utils.getProperty)(realm, reactElement, "type");

  if (!(config instanceof _index2.NullValue)) {
    let possibleKey = (0, _index3.Get)(realm, config, "key");

    if (possibleKey !== realm.intrinsics.null && possibleKey !== realm.intrinsics.undefined) {
      // if the config has been marked as having no partial key or ref and the possible key
      // is abstract, yet the config doesn't have a key property, then the key can remain null
      let keyNotNeeded = (0, _utils.hasNoPartialKeyOrRef)(realm, config) && possibleKey instanceof _index2.AbstractValue && config instanceof _index2.ObjectValue && !config.properties.has("key");

      if (!keyNotNeeded) {
        key = (0, _BinaryExpression.computeBinary)(realm, "+", realm.intrinsics.emptyString, possibleKey);
      }
    }

    let possibleRef = (0, _index3.Get)(realm, config, "ref");

    if (possibleRef !== realm.intrinsics.null && possibleRef !== realm.intrinsics.undefined) {
      // if the config has been marked as having no partial key or ref and the possible ref
      // is abstract, yet the config doesn't have a ref property, then the ref can remain null
      let refNotNeeded = (0, _utils.hasNoPartialKeyOrRef)(realm, config) && possibleRef instanceof _index2.AbstractValue && config instanceof _index2.ObjectValue && !config.properties.has("ref");

      if (!refNotNeeded) {
        ref = possibleRef;
      }
    }

    let defaultProps = type instanceof _index2.ObjectValue || type instanceof _index2.AbstractObjectValue ? (0, _index3.Get)(realm, type, "defaultProps") : realm.intrinsics.undefined;

    if (defaultProps instanceof _index2.ObjectValue) {
      for (let [propKey, binding] of defaultProps.properties) {
        if (binding && binding.descriptor) {
          (0, _invariant.default)(binding.descriptor instanceof _descriptors.PropertyDescriptor);

          if (binding.descriptor.enumerable && (0, _index3.Get)(realm, props, propKey) === realm.intrinsics.undefined) {
            setProp(propKey, (0, _index3.Get)(realm, defaultProps, propKey));
          }
        }
      }
    } else if (defaultProps instanceof _index2.AbstractObjectValue) {
      (0, _invariant.default)(false, "TODO: we need to eventually support this");
    }
  }

  if (children !== undefined) {
    (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, "children", children);
  } else {
    (0, _invariant.default)(elementProps instanceof _index2.ObjectValue);
    let elementChildren = (0, _utils.getProperty)(realm, elementProps, "children");
    (0, _utils.hardModifyReactObjectPropertyBinding)(realm, props, "children", elementChildren);
  }

  return (0, _utils.createInternalReactElement)(realm, type, key, ref, props);
}

function createReactElement(realm, type, config, children) {
  if (type instanceof _index2.AbstractValue && type.kind === "conditional") {
    let [condValue, consequentVal, alternateVal] = type.args;
    (0, _invariant.default)(condValue instanceof _index2.AbstractValue);
    return splitReactElementsByConditionalType(realm, condValue, consequentVal, alternateVal, config, children);
  } else if (config instanceof _index2.AbstractObjectValue && config.kind === "conditional") {
    let [condValue, consequentVal, alternateVal] = config.args;
    (0, _invariant.default)(condValue instanceof _index2.AbstractValue);
    (0, _invariant.default)(consequentVal instanceof _index2.ObjectValue || consequentVal instanceof _index2.AbstractObjectValue);
    (0, _invariant.default)(alternateVal instanceof _index2.ObjectValue || alternateVal instanceof _index2.AbstractObjectValue);
    return splitReactElementsByConditionalConfig(realm, condValue, consequentVal, alternateVal, type, children);
  }

  let {
    key,
    props,
    ref
  } = createPropsObject(realm, type, config, children);
  return (0, _utils.createInternalReactElement)(realm, type, key, ref, props);
} // Wraps a React element in a `<React.Fragment key={keyValue}>` so that we can
// add a key without mutating or cloning the element.


function wrapReactElementWithKeyedFragment(realm, keyValue, reactElement) {
  const react = realm.fbLibraries.react;
  (0, _invariant.default)(react instanceof _index2.ObjectValue);
  const reactFragment = (0, _utils.getProperty)(realm, react, "Fragment");

  const fragmentConfigValue = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);

  _singletons.Create.CreateDataPropertyOrThrow(realm, fragmentConfigValue, "key", keyValue);

  let fragmentChildrenValue = _singletons.Create.ArrayCreate(realm, 1);

  _singletons.Create.CreateDataPropertyOrThrow(realm, fragmentChildrenValue, "0", reactElement);

  fragmentChildrenValue = (0, _utils.flattenChildren)(realm, fragmentChildrenValue, true);
  return createReactElement(realm, reactFragment, fragmentConfigValue, fragmentChildrenValue);
}

function traverseReactElement(realm, reactElement, traversalVisitor) {
  let typeValue = (0, _utils.getProperty)(realm, reactElement, "type");
  traversalVisitor.visitType(typeValue);
  let keyValue = (0, _utils.getProperty)(realm, reactElement, "key");

  if (keyValue !== realm.intrinsics.null && keyValue !== realm.intrinsics.undefined) {
    traversalVisitor.visitKey(keyValue);
  }

  let refValue = (0, _utils.getProperty)(realm, reactElement, "ref");

  if (refValue !== realm.intrinsics.null && refValue !== realm.intrinsics.undefined) {
    traversalVisitor.visitRef(refValue);
  }

  const loopArrayElements = (childrenValue, length) => {
    for (let i = 0; i < length; i++) {
      let child = (0, _utils.getProperty)(realm, childrenValue, "" + i);
      traversalVisitor.visitChildNode(child);
    }
  };

  const handleChildren = () => {
    // handle children
    (0, _invariant.default)(propsValue instanceof _index2.ObjectValue);

    if (propsValue.properties.has("children")) {
      let childrenValue = (0, _utils.getProperty)(realm, propsValue, "children");

      if (childrenValue !== realm.intrinsics.undefined && childrenValue !== realm.intrinsics.null) {
        if (childrenValue instanceof _index2.ArrayValue && !childrenValue.intrinsicName) {
          let childrenLength = (0, _utils.getProperty)(realm, childrenValue, "length");

          if (childrenLength instanceof _index2.NumberValue) {
            loopArrayElements(childrenValue, childrenLength.value);
          } else if (childrenLength instanceof _index2.AbstractValue && childrenLength.kind === "conditional") {
            loopArrayElements(childrenValue, (0, _utils.getMaxLength)(childrenLength, 0));
          } else {
            (0, _invariant.default)(false, "TODO: support other types of array length value");
          }
        } else {
          traversalVisitor.visitChildNode(childrenValue);
        }
      }
    }
  };

  let propsValue = (0, _utils.getProperty)(realm, reactElement, "props");

  if (propsValue instanceof _index2.AbstractValue) {
    // visit object, as it's going to be spread
    traversalVisitor.visitAbstractOrPartialProps(propsValue);
  } else if (propsValue instanceof _index2.ObjectValue) {
    if (propsValue.isPartialObject()) {
      traversalVisitor.visitAbstractOrPartialProps(propsValue);
      handleChildren();
    } else {
      traversalVisitor.visitConcreteProps(propsValue);
      handleChildren();
    }
  }
}
//# sourceMappingURL=elements.js.map

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stripFlowTypeAnnotations = stripFlowTypeAnnotations;

var _traverse = _interopRequireDefault(__webpack_require__(293));

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
// Taken directly from Babel:
// https://github.com/babel/babel/blob/cde005422701a69ff21044c138c29a5ad23b6d0a/packages/babel-plugin-transform-flow-strip-types/src/index.js#L32-L107
// Copyright 2015-present Sebastian McKenzie / Babel project (https://github.com/babel)
// only the lines reflected in the above were used
function stripFlowTypeAnnotations(ast) {
  (0, _traverse.default)(ast, {
    ImportDeclaration(path) {
      if (!path.node.specifiers.length) return;
      let typeCount = 0;
      path.node.specifiers.forEach(({
        importKind
      }) => {
        if (importKind === "type" || importKind === "typeof") {
          typeCount++;
        }
      });

      if (typeCount === path.node.specifiers.length) {
        path.remove();
      }
    },

    Flow(path) {
      path.remove();
    },

    ClassProperty(path) {
      path.node.variance = null;
      path.node.typeAnnotation = null;
      if (!path.node.value) path.remove();
    },

    Class(path) {
      path.node.implements = null;
      path.get("body.body").forEach(child => {
        if (child.isClassProperty()) {
          child.node.typeAnnotation = null;
          if (!child.node.value) child.remove();
        }
      });
    },

    AssignmentPattern({
      node
    }) {
      node.left.optional = false;
    },

    Function({
      node
    }) {
      for (let i = 0; i < node.params.length; i++) {
        const param = node.params[i];
        param.optional = false;

        if (param.type === "AssignmentPattern") {
          param.left.optional = false;
        }
      }

      node.predicate = null;
    },

    TypeCastExpression(path) {
      let {
        node
      } = path;

      do {
        node = node.expression;
      } while (t.isTypeCastExpression(node));

      path.replaceWith(node);
    }

  }, undefined, {}, undefined);

  _traverse.default.cache.clear();
}
//# sourceMappingURL=flow.js.map

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoggingTracer = void 0;

var _environment = __webpack_require__(20);

var _realm = __webpack_require__(7);

var _index = __webpack_require__(232);

var _completions = __webpack_require__(18);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _babelhelpers = __webpack_require__(239);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function describeValue(realm, v) {
  if (v instanceof _index2.NumberValue || v instanceof _index2.BooleanValue) return v.value.toString();
  if (v instanceof _index2.UndefinedValue) return "undefined";
  if (v instanceof _index2.NullValue) return "null";
  if (v instanceof _index2.StringValue) return JSON.stringify(v.value);
  if (v instanceof _index2.FunctionValue) return _singletons.To.ToStringPartial(realm, (0, _index.Get)(realm, v, "name")) || "(anonymous function)";
  if (v instanceof _index2.ObjectValue) return "(some object)";
  if (v instanceof _index2.AbstractValue) return "(some abstract value)";
  (0, _invariant.default)(false);
}

class LoggingTracer extends _realm.Tracer {
  constructor(realm) {
    super();
    this.realm = realm;
    this.nesting = [];
  }

  log(message) {
    console.log(`[calls] ${this.nesting.map(_ => "  ").join("")}${message}`);
  }

  beginEvaluateForEffects(state) {
    this.log(`>evaluate for effects`);
    this.nesting.push("(evaluate for effects)");
  }

  endEvaluateForEffects(state, effects) {
    let name = this.nesting.pop();
    (0, _invariant.default)(name === "(evaluate for effects)");
    this.log(`<evaluate for effects`);
  }

  beforeCall(F, thisArgument, argumentsList, newTarget) {
    let realm = this.realm;
    let name = describeValue(realm, F);
    this.log(`>${name}(${argumentsList.map(v => describeValue(realm, v)).join(", ")})`);
    this.nesting.push(name);
  }

  afterCall(F, thisArgument, argumentsList, newTarget, result) {
    let name = this.nesting.pop();
    this.log(`<${name}${result instanceof _completions.ThrowCompletion ? ": error" : ""}`);
  }

  beginOptimizingFunction(optimizedFunctionId, functionValue) {
    this.log(`>Starting Optimized Function ${optimizedFunctionId} ${functionValue.intrinsicName ? functionValue.intrinsicName : "[unknown name]"} ${functionValue.expressionLocation ? (0, _babelhelpers.stringOfLocation)(functionValue.expressionLocation) : ""}`);
  }

  endOptimizingFunction(optimizedFunctionId) {
    this.log(`<Ending Optimized Function ${optimizedFunctionId}`);
  }

}

exports.LoggingTracer = LoggingTracer;
//# sourceMappingURL=LoggingTracer.js.map

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapVisitor = void 0;

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _singletons = __webpack_require__(236);

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var _Error = __webpack_require__(424);

var t = _interopRequireWildcard(__webpack_require__(21));

var _generator = __webpack_require__(237);

var _traverse = _interopRequireDefault(__webpack_require__(293));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _visitors = __webpack_require__(425);

var _logger = __webpack_require__(412);

var _modules = __webpack_require__(411);

var _HeapInspector = __webpack_require__(426);

var _utils = __webpack_require__(413);

var _utils2 = __webpack_require__(291);

var _ResidualReactElementVisitor = __webpack_require__(427);

var _GeneratorTree = __webpack_require__(432);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/* This class visits all values that are reachable in the residual heap.
   In particular, this "filters out" values that are:
   - captured by a DeclarativeEnvironmentRecord, but not actually used by any closure.
   - Unmodified prototype objects
   TODO #680: Figure out minimal set of values that need to be kept alive for WeakSet and WeakMap instances.
*/
class ResidualHeapVisitor {
  constructor(realm, logger, modules, additionalFunctionValuesAndEffects) {
    (0, _invariant.default)(realm.useAbstractInterpretation);
    this.realm = realm;
    this.logger = logger;
    this.modules = modules;
    this.declarativeEnvironmentRecordsBindings = new Map();
    this.globalBindings = new Map();
    this.functionInfos = new Map();
    this.classMethodInstances = new Map();
    this.functionInstances = new Map();
    this.values = new Map();
    this.conditionalFeasibility = new Map();
    let generator = this.realm.generator;
    (0, _invariant.default)(generator);
    this.scope = this.globalGenerator = generator;
    this.inspector = new _HeapInspector.HeapInspector(realm, logger);
    this.referencedDeclaredValues = new Map();
    this.delayedActions = [];
    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;
    this.equivalenceSet = new _index.HashSet();
    this.additionalFunctionValueInfos = new Map();
    this.functionToCapturedScopes = new Map();
    let environment = realm.$GlobalEnv.environmentRecord;
    (0, _invariant.default)(environment instanceof _environment.GlobalEnvironmentRecord);
    this.globalEnvironmentRecord = environment;
    this.additionalGeneratorRoots = new Map();
    this.residualReactElementVisitor = new _ResidualReactElementVisitor.ResidualReactElementVisitor(this.realm, this);
    this.generatorTree = new _GeneratorTree.GeneratorTree();
  }

  // Going backwards from the current scope, find either the containing
  // additional function, or if there isn't one, return the global generator.
  _getCommonScope() {
    let s = this.scope;

    while (true) {
      if (s instanceof _generator.Generator) s = this.generatorTree.getParent(s);else if (s instanceof _index2.FunctionValue) {
        // Did we find an additional function?
        if (this.additionalFunctionValuesAndEffects.has(s)) return s; // Did the function itself get created by a generator we can chase?

        s = this.generatorTree.getCreator(s) || "GLOBAL";
      } else {
        (0, _invariant.default)(s === "GLOBAL");
        let generator = this.globalGenerator;
        (0, _invariant.default)(generator);
        return generator;
      }
    }

    (0, _invariant.default)(false);
  } // If the current scope has a containing additional function, retrieve it.


  _getAdditionalFunctionOfScope() {
    let s = this._getCommonScope();

    return s instanceof _index2.FunctionValue ? s : undefined;
  } // When a value has been created by some generator that is unrelated
  // to the current common scope, visit the value in the scope it was
  // created --- this causes the value later to be serialized in its
  // creation scope, ensuring that the value has the right creation / life time.


  _registerAdditionalRoot(value) {
    let creationGenerator = this.generatorTree.getCreator(value) || this.globalGenerator;
    let additionalFunction = this._getAdditionalFunctionOfScope() || "GLOBAL";
    let targetAdditionalFunction;

    if (creationGenerator === this.globalGenerator) {
      targetAdditionalFunction = "GLOBAL";
    } else {
      let s = creationGenerator;

      while (s instanceof _generator.Generator) {
        s = this.generatorTree.getParent(s);
        (0, _invariant.default)(s !== undefined);
      }

      (0, _invariant.default)(s === "GLOBAL" || s instanceof _index2.FunctionValue);
      targetAdditionalFunction = s;
    }

    let usageScope;

    if (additionalFunction === targetAdditionalFunction) {
      usageScope = this.scope;
    } else {
      // Object was created outside of current additional function scope
      (0, _invariant.default)(additionalFunction instanceof _index2.FunctionValue);
      let additionalFVEffects = this.additionalFunctionValuesAndEffects.get(additionalFunction);
      (0, _invariant.default)(additionalFVEffects !== undefined);
      additionalFVEffects.additionalRoots.add(value);

      this._visitInUnrelatedScope(creationGenerator, value);

      usageScope = this.generatorTree.getCreator(value) || this.globalGenerator;
    }

    usageScope = this.scope;

    if (usageScope instanceof _generator.Generator) {
      // Also check if object is used in some nested generator scope that involved
      // applying effects; if so, store additional information that the serializer
      // can use to proactive serialize such objects from within the right generator
      let anyRelevantEffects = false;

      for (let g = usageScope; g instanceof _generator.Generator; g = this.generatorTree.getParent(g)) {
        if (g === creationGenerator) {
          if (anyRelevantEffects) {
            let s = this.additionalGeneratorRoots.get(g);
            if (s === undefined) this.additionalGeneratorRoots.set(g, s = new Set());

            if (!s.has(value)) {
              s.add(value);

              this._visitInUnrelatedScope(g, value);
            }
          }

          break;
        }

        let effectsToApply = g.effectsToApply;
        if (effectsToApply) for (let pb of effectsToApply.modifiedProperties.keys()) if (pb.object === value) {
          anyRelevantEffects = true;
          break;
        }
      }
    }
  } // Careful!
  // Only use _withScope when you know that the currently applied effects makes sense for the given (nested) scope!


  _withScope(scope, f) {
    let oldScope = this.scope;
    this.scope = scope;

    try {
      f();
    } finally {
      this.scope = oldScope;
    }
  } // Queues up an action to be later processed in some arbitrary scope.


  _enqueueWithUnrelatedScope(scope, action) {
    // If we are in a zone with a non-default equivalence set (we are wrapped in a `withCleanEquivalenceSet` call) then
    // we need to save our equivalence set so that we may load it before running our action.
    if (this.residualReactElementVisitor.defaultEquivalenceSet === false) {
      const save = this.residualReactElementVisitor.saveEquivalenceSet();
      const originalAction = action;

      action = () => this.residualReactElementVisitor.loadEquivalenceSet(save, originalAction);
    }

    this.delayedActions.push({
      scope,
      action
    });
  } // Queues up visiting a value in some arbitrary scope.


  _visitInUnrelatedScope(scope, val) {
    let scopes = this.values.get(val);
    if (scopes !== undefined && scopes.has(scope)) return;

    this._enqueueWithUnrelatedScope(scope, () => this.visitValue(val));
  }

  visitObjectProperty(binding) {
    let desc = binding.descriptor;
    let obj = binding.object;
    (0, _invariant.default)(binding.key !== undefined, "Undefined keys should never make it here.");

    if (obj instanceof _index2.AbstractObjectValue || !(typeof binding.key === "string" && this.inspector.canIgnoreProperty(obj, binding.key))) {
      if (desc !== undefined) this.visitDescriptor(desc);
    }

    if (binding.key instanceof _index2.Value) this.visitValue(binding.key);
  }

  visitObjectProperties(obj, kind) {
    // In non-instant render mode, properties of leaked objects are generated via assignments
    let {
      skipPrototype,
      constructor
    } = (0, _utils.getObjectPrototypeMetadata)(this.realm, obj);
    if (obj.temporalAlias !== undefined) return; // visit properties

    for (let [symbol, propertyBinding] of obj.symbols) {
      (0, _invariant.default)(propertyBinding);
      let desc = propertyBinding.descriptor;
      if (desc === undefined) continue; //deleted

      this.visitDescriptor(desc);
      this.visitValue(symbol);
    } // visit properties


    for (let [propertyBindingKey, propertyBindingValue] of obj.properties) {
      // we don't want to visit these as we handle the serialization ourselves
      // via a different logic route for classes
      let descriptor = propertyBindingValue.descriptor;

      if (obj instanceof _index2.ECMAScriptFunctionValue && obj.$FunctionKind === "classConstructor" && (_utils.ClassPropertiesToIgnore.has(propertyBindingKey) || propertyBindingKey === "length" && (0, _utils.canIgnoreClassLengthProperty)(obj, descriptor, this.logger))) {
        continue;
      }

      if (propertyBindingValue.pathNode !== undefined) continue; // property is written to inside a loop
      // Leaked object. Properties are set via assignments
      // TODO #2259: Make deduplication in the face of leaking work for custom accessors

      if (!(obj instanceof _index2.ArrayValue) && !obj.mightNotBeLeakedObject() && descriptor instanceof _descriptors.PropertyDescriptor && descriptor.get === undefined && descriptor.set === undefined) {
        continue;
      }

      this.visitObjectProperty(propertyBindingValue);
    } // inject properties with computed names


    if (obj.unknownProperty !== undefined) {
      this.visitObjectPropertiesWithComputedNamesDescriptor(obj.unknownProperty.descriptor);
    } // prototype


    if (!skipPrototype) {
      this.visitObjectPrototype(obj);
    }

    if (obj instanceof _index2.FunctionValue) {
      this.visitConstructorPrototype(constructor ? constructor : obj);
    } else if (obj instanceof _index2.ObjectValue && skipPrototype && constructor) {
      this.visitValue(constructor);
    }
  }

  visitObjectPrototype(obj) {
    let proto = obj.$Prototype;
    let kind = obj.getKind();
    if (proto === this.realm.intrinsics[kind + "Prototype"]) return;

    if (!obj.$IsClassPrototype || proto !== this.realm.intrinsics.null) {
      this.visitValue(proto);
    }
  }

  visitConstructorPrototype(func) {
    // If the original prototype object was mutated,
    // request its serialization here as this might be observable by
    // residual code.
    (0, _invariant.default)(func instanceof _index2.FunctionValue);

    let prototype = _HeapInspector.HeapInspector.getPropertyValue(func, "prototype");

    if (prototype instanceof _index2.ObjectValue && prototype.originalConstructor === func && !this.inspector.isDefaultPrototype(prototype)) {
      this.visitValue(prototype);
    }
  }

  visitObjectPropertiesWithComputedNamesDescriptor(desc) {
    if (desc !== undefined) {
      if (desc instanceof _descriptors.PropertyDescriptor) {
        let val = desc.value;
        (0, _invariant.default)(val instanceof _index2.AbstractValue);
        this.visitObjectPropertiesWithComputedNames(val);
      } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
        this.visitValue(desc.joinCondition);
        this.visitObjectPropertiesWithComputedNamesDescriptor(desc.descriptor1);
        this.visitObjectPropertiesWithComputedNamesDescriptor(desc.descriptor2);
      } else {
        (0, _invariant.default)(false, "unknown descriptor");
      }
    }
  }

  visitObjectPropertiesWithComputedNames(absVal) {
    if (absVal.kind === "widened property") return;
    if (absVal.kind === "template for prototype member expression") return;

    if (absVal.kind === "conditional") {
      let cond = absVal.args[0];
      (0, _invariant.default)(cond instanceof _index2.AbstractValue);

      if (cond.kind === "template for property name condition") {
        let P = cond.args[0];
        (0, _invariant.default)(P instanceof _index2.AbstractValue);
        let V = absVal.args[1];
        let earlier_props = absVal.args[2];
        if (earlier_props instanceof _index2.AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);
        this.visitValue(P);
        this.visitValue(V);
      } else {
        // conditional assignment
        absVal.args[0] = this.visitEquivalentValue(cond);
        let consequent = absVal.args[1];

        if (consequent instanceof _index2.AbstractValue) {
          this.visitObjectPropertiesWithComputedNames(consequent);
        }

        let alternate = absVal.args[2];

        if (alternate instanceof _index2.AbstractValue) {
          this.visitObjectPropertiesWithComputedNames(alternate);
        }
      }
    } else {
      this.visitValue(absVal);
    }
  }

  visitDescriptor(desc) {
    if (desc === undefined) {} else if (desc instanceof _descriptors.PropertyDescriptor) {
      if (desc.value !== undefined) desc.value = this.visitEquivalentValue(desc.value);
      if (desc.get !== undefined) this.visitValue(desc.get);
      if (desc.set !== undefined) this.visitValue(desc.set);
    } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
      desc.joinCondition = this.visitEquivalentValue(desc.joinCondition);
      if (desc.descriptor1 !== undefined) this.visitDescriptor(desc.descriptor1);
      if (desc.descriptor2 !== undefined) this.visitDescriptor(desc.descriptor2);
    } else {
      (0, _invariant.default)(false, "unknown descriptor");
    }
  }

  visitValueArray(val) {
    this._registerAdditionalRoot(val);

    this.visitObjectProperties(val);
    const realm = this.realm;
    let lenProperty;

    if (val.mightBeLeakedObject()) {
      lenProperty = this.realm.evaluateWithoutLeakLogic(() => (0, _index.Get)(realm, val, "length"));
    } else {
      lenProperty = (0, _index.Get)(realm, val, "length");
    }

    let [initialLength, lengthAssignmentNotNeeded] = (0, _utils.getSuggestedArrayLiteralLength)(realm, val);
    if (lengthAssignmentNotNeeded) return;

    if (lenProperty instanceof _index2.AbstractValue ? lenProperty.kind !== "widened property" : _singletons.To.ToLength(realm, lenProperty) !== initialLength) {
      this.visitValue(lenProperty);
    }
  }

  visitValueMap(val) {
    (0, _invariant.default)(val.getKind() === "Map");
    let entries = val.$MapData;
    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;

    for (let i = 0; i < len; i++) {
      let entry = entries[i];
      let key = entry.$Key;
      let value = entry.$Value;
      if (key === undefined || value === undefined) continue;
      this.visitValue(key);
      this.visitValue(value);
    }
  }

  visitValueWeakMap(val) {
    (0, _invariant.default)(val.getKind() === "WeakMap");
    let entries = val.$WeakMapData;
    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;

    for (let i = 0; i < len; i++) {
      let entry = entries[i];
      let key = entry.$Key;
      let value = entry.$Value;

      if (key !== undefined && value !== undefined) {
        let fixpoint_rerun = () => {
          let progress;

          if (this.values.has(key)) {
            progress = true;
            this.visitValue(key);
            this.visitValue(value);
          } else {
            progress = false;

            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);
          }

          return progress;
        };

        fixpoint_rerun();
      }
    }
  }

  visitValueSet(val) {
    (0, _invariant.default)(val.getKind() === "Set");
    let entries = val.$SetData;
    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;

    for (let i = 0; i < len; i++) {
      let entry = entries[i];
      if (entry === undefined) continue;
      this.visitValue(entry);
    }
  }

  visitValueWeakSet(val) {
    (0, _invariant.default)(val.getKind() === "WeakSet");
    let entries = val.$WeakSetData;
    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;

    for (let i = 0; i < len; i++) {
      let entry = entries[i];

      if (entry !== undefined) {
        let fixpoint_rerun = () => {
          let progress;

          if (this.values.has(entry)) {
            progress = true;
            this.visitValue(entry);
          } else {
            progress = false;

            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);
          }

          return progress;
        };

        fixpoint_rerun();
      }
    }
  }

  visitValueFunction(val) {
    let isClass = false;

    this._registerAdditionalRoot(val);

    if (val instanceof _index2.ECMAScriptFunctionValue && val.$FunctionKind === "classConstructor") {
      (0, _invariant.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
      let homeObject = val.$HomeObject;

      if (homeObject instanceof _index2.ObjectValue && homeObject.$IsClassPrototype) {
        isClass = true;
      }
    }

    this.visitObjectProperties(val);

    if (val instanceof _index2.BoundFunctionValue) {
      this.visitValue(val.$BoundTargetFunction);
      this.visitValue(val.$BoundThis);

      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);

      return;
    }

    (0, _invariant.default)(!(val instanceof _index2.NativeFunctionValue), "all native function values should be intrinsics");
    (0, _invariant.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
    (0, _invariant.default)(val.constructor === _index2.ECMAScriptSourceFunctionValue);
    let formalParameters = val.$FormalParameters;
    let code = val.$ECMAScriptCode;
    let functionInfo = this.functionInfos.get(code);
    let residualFunctionBindings = new Map();
    this.functionInstances.set(val, {
      residualFunctionBindings,
      initializationStatements: [],
      functionValue: val,
      scopeInstances: new Map()
    });

    if (!functionInfo) {
      functionInfo = {
        depth: 0,
        lexicalDepth: 0,
        unbound: new Map(),
        requireCalls: new Map(),
        modified: new Set(),
        usesArguments: false,
        usesThis: false
      };
      let state = {
        functionInfo,
        realm: this.realm,
        getModuleIdIfNodeIsRequireFunction: this.modules.getGetModuleIdIfNodeIsRequireFunction(formalParameters, [val])
      };
      (0, _traverse.default)(t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])), _visitors.ClosureRefVisitor, null, state);

      _traverse.default.cache.clear();

      this.functionInfos.set(code, functionInfo);

      if (val.isResidual && functionInfo.unbound.size) {
        if (!val.isUnsafeResidual) {
          this.logger.logError(val, `residual function ${(0, _Error.describeLocation)(this.realm, val, undefined, code.loc) || "(unknown)"} refers to the following identifiers defined outside of the local scope: ${Object.keys(functionInfo.unbound).join(", ")}`);
        }
      }
    }

    let additionalFunctionEffects = this.additionalFunctionValuesAndEffects.get(val);

    if (additionalFunctionEffects) {
      this._visitAdditionalFunction(val, additionalFunctionEffects);
    } else {
      this._enqueueWithUnrelatedScope(val, () => {
        (0, _invariant.default)(this.scope === val);
        (0, _invariant.default)(functionInfo);

        for (let innerName of functionInfo.unbound.keys()) {
          let environment = this.resolveBinding(val, innerName);
          let residualBinding = this.getBinding(environment, innerName);
          this.visitBinding(val, residualBinding);
          residualFunctionBindings.set(innerName, residualBinding);
          if (functionInfo.modified.has(innerName)) residualBinding.modified = true;
        }
      });
    }

    if (isClass && val.$HomeObject instanceof _index2.ObjectValue) {
      this._visitClass(val, val.$HomeObject);
    }
  }

  _visitBindingHelper(residualFunctionBinding) {
    if (residualFunctionBinding.hasLeaked) return;
    let environment = residualFunctionBinding.declarativeEnvironmentRecord;
    (0, _invariant.default)(environment !== null);

    if (residualFunctionBinding.value === undefined) {
      // The first time we visit, we need to initialize the value to its equivalent value
      (0, _invariant.default)(environment instanceof _environment.DeclarativeEnvironmentRecord);
      let binding = environment.bindings[residualFunctionBinding.name];
      (0, _invariant.default)(binding !== undefined);
      (0, _invariant.default)(!binding.deletable);
      let value = binding.initialized && binding.value || this.realm.intrinsics.undefined;
      residualFunctionBinding.value = this.visitEquivalentValue(value);
    } else {
      // Subsequently, we just need to visit the value.
      this.visitValue(residualFunctionBinding.value);
    }
  } // Addresses the case:
  // let x = [];
  // let y = [];
  // function a() { x.push("hi"); }
  // function b() { y.push("bye"); }
  // function c() { return x.length + y.length; }
  // Here we need to make sure that a and b both initialize x and y because x and y will be in the same
  // captured scope because c captures both x and y.


  visitBinding(scope, residualFunctionBinding) {
    let environment = residualFunctionBinding.declarativeEnvironmentRecord;
    if (environment === null) return;
    (0, _invariant.default)(this.scope === scope);
    let refScope = this._getAdditionalFunctionOfScope() || "GLOBAL";
    residualFunctionBinding.potentialReferentializationScopes.add(refScope);
    (0, _invariant.default)(!(refScope instanceof _generator.Generator));
    let funcToScopes = (0, _utils.getOrDefault)(this.functionToCapturedScopes, refScope, () => new Map());
    let envRec = residualFunctionBinding.declarativeEnvironmentRecord;
    (0, _invariant.default)(envRec !== null);
    let bindingState = (0, _utils.getOrDefault)(funcToScopes, envRec, () => ({
      capturedBindings: new Set(),
      capturingScopes: new Set()
    })); // If the binding is new for this bindingState, have all functions capturing bindings from that scope visit it

    if (!bindingState.capturedBindings.has(residualFunctionBinding)) {
      for (let capturingScope of bindingState.capturingScopes) {
        this._enqueueWithUnrelatedScope(capturingScope, () => this._visitBindingHelper(residualFunctionBinding));
      }

      bindingState.capturedBindings.add(residualFunctionBinding);
    } // If the function is new for this bindingState, visit all existent bindings in this scope


    if (!bindingState.capturingScopes.has(scope)) {
      (0, _invariant.default)(this.scope === scope);

      for (let residualBinding of bindingState.capturedBindings) this._visitBindingHelper(residualBinding);

      bindingState.capturingScopes.add(scope);
    }
  }

  resolveBinding(val, name) {
    let doesNotMatter = true;
    let reference = this.logger.tryQuery(() => _singletons.Environment.ResolveBinding(this.realm, name, doesNotMatter, val.$Environment), undefined);

    if (reference === undefined || _singletons.Environment.IsUnresolvableReference(this.realm, reference) || reference.base === this.globalEnvironmentRecord || reference.base === this.globalEnvironmentRecord.$DeclarativeRecord) {
      return this.globalEnvironmentRecord;
    } else {
      (0, _invariant.default)(!_singletons.Environment.IsUnresolvableReference(this.realm, reference));
      let referencedBase = reference.base;
      let referencedName = reference.referencedName;
      (0, _invariant.default)(referencedName === name);
      (0, _invariant.default)(referencedBase instanceof _environment.DeclarativeEnvironmentRecord);
      return referencedBase;
    }
  }

  hasBinding(environment, name) {
    if (environment === this.globalEnvironmentRecord.$DeclarativeRecord) environment = this.globalEnvironmentRecord;

    if (environment === this.globalEnvironmentRecord) {
      // Global Binding
      return this.globalBindings.get(name) !== undefined;
    } else {
      (0, _invariant.default)(environment instanceof _environment.DeclarativeEnvironmentRecord); // DeclarativeEnvironmentRecord binding

      let residualFunctionBindings = this.declarativeEnvironmentRecordsBindings.get(environment);
      if (residualFunctionBindings === undefined) return false;
      return residualFunctionBindings.get(name) !== undefined;
    }
  } // Visits a binding, returns a ResidualFunctionBinding


  getBinding(environment, name) {
    if (environment === this.globalEnvironmentRecord.$DeclarativeRecord) environment = this.globalEnvironmentRecord;

    if (environment === this.globalEnvironmentRecord) {
      // Global Binding
      return (0, _utils.getOrDefault)(this.globalBindings, name, () => {
        let residualFunctionBinding = {
          name,
          value: undefined,
          modified: true,
          hasLeaked: false,
          declarativeEnvironmentRecord: null,
          potentialReferentializationScopes: new Set()
        }; // Queue up visiting of global binding exactly once in the globalGenerator scope.

        this._enqueueWithUnrelatedScope(this.globalGenerator, () => {
          let value = this.realm.getGlobalLetBinding(name);
          if (value !== undefined) residualFunctionBinding.value = this.visitEquivalentValue(value);
        });

        return residualFunctionBinding;
      });
    } else {
      (0, _invariant.default)(environment instanceof _environment.DeclarativeEnvironmentRecord); // DeclarativeEnvironmentRecord binding

      let residualFunctionBindings = (0, _utils.getOrDefault)(this.declarativeEnvironmentRecordsBindings, environment, () => new Map());
      return (0, _utils.getOrDefault)(residualFunctionBindings, name, () => {
        (0, _invariant.default)(environment instanceof _environment.DeclarativeEnvironmentRecord);
        return {
          name,
          value: undefined,
          modified: false,
          hasLeaked: false,
          declarativeEnvironmentRecord: environment,
          potentialReferentializationScopes: new Set()
        };
      }); // Note that we don't yet visit the binding (and its value) here,
      // as that should be done by a call to visitBinding, in the right scope,
      // if the binding's incoming value is relevant.
    }
  }

  _visitClass(classFunc, classPrototype) {
    let visitClassMethod = (propertyNameOrSymbol, methodFunc, methodType, isStatic) => {
      if (methodFunc instanceof _index2.ECMAScriptSourceFunctionValue) {
        // if the method does not have a $HomeObject, it's not a class method
        if (methodFunc.$HomeObject !== undefined) {
          if (methodFunc !== classFunc) {
            this._visitClassMethod(methodFunc, methodType, classPrototype, !!isStatic);
          }
        }
      }
    };

    for (let [propertyName, method] of classPrototype.properties) {
      (0, _utils.withDescriptorValue)(propertyName, method.descriptor, visitClassMethod);
    }

    for (let [symbol, method] of classPrototype.symbols) {
      (0, _utils.withDescriptorValue)(symbol, method.descriptor, visitClassMethod);
    } // handle class inheritance


    if (!(classFunc.$Prototype instanceof _index2.NativeFunctionValue)) {
      this.visitValue(classFunc.$Prototype);
    }

    if (classPrototype.properties.has("constructor")) {
      let constructor = classPrototype.properties.get("constructor");
      (0, _invariant.default)(constructor !== undefined); // check if the constructor was deleted, as it can't really be deleted
      // it just gets set to empty (the default again)

      if (constructor.descriptor === undefined) {
        classFunc.$HasEmptyConstructor = true;
      } else {
        let visitClassProperty = (propertyNameOrSymbol, methodFunc, methodType) => {
          visitClassMethod(propertyNameOrSymbol, methodFunc, methodType, true);
        }; // check if we have any static methods we need to include


        let constructorFunc = (0, _index.Get)(this.realm, classPrototype, "constructor");
        (0, _invariant.default)(constructorFunc instanceof _index2.ObjectValue);

        for (let [propertyName, method] of constructorFunc.properties) {
          if (!_utils.ClassPropertiesToIgnore.has(propertyName) && method.descriptor !== undefined && !(propertyName === "length" && (0, _utils.canIgnoreClassLengthProperty)(constructorFunc, method.descriptor, this.logger))) {
            (0, _utils.withDescriptorValue)(propertyName, method.descriptor, visitClassProperty);
          }
        }
      }
    }

    this.classMethodInstances.set(classFunc, {
      classPrototype,
      methodType: "constructor",
      classSuperNode: undefined,
      classMethodIsStatic: false,
      classMethodKeyNode: undefined,
      classMethodComputed: false
    });
  }

  _visitClassMethod(methodFunc, methodType, classPrototype, isStatic) {
    this.classMethodInstances.set(methodFunc, {
      classPrototype,
      methodType: methodType === "value" ? "method" : methodType,
      classSuperNode: undefined,
      classMethodIsStatic: isStatic,
      classMethodKeyNode: undefined,
      classMethodComputed: !!methodFunc.$HasComputedName
    });
  }

  visitValueObject(val) {
    (0, _invariant.default)(val.isValid());

    this._registerAdditionalRoot(val);

    if ((0, _utils2.isReactElement)(val)) {
      this.residualReactElementVisitor.visitReactElement(val);
      return;
    }

    let kind = val.getKind();
    this.visitObjectProperties(val, kind); // If this object is a prototype object that was implicitly created by the runtime
    // for a constructor, then we can obtain a reference to this object
    // in a special way that's handled alongside function serialization.

    let constructor = val.originalConstructor;

    if (constructor !== undefined) {
      this.visitValue(constructor);
      return;
    }

    switch (kind) {
      case "RegExp":
      case "Number":
      case "String":
      case "Boolean":
      case "ArrayBuffer":
        return;

      case "Date":
        let dateValue = val.$DateValue;
        (0, _invariant.default)(dateValue !== undefined);
        this.visitValue(dateValue);
        return;

      case "Float32Array":
      case "Float64Array":
      case "Int8Array":
      case "Int16Array":
      case "Int32Array":
      case "Uint8Array":
      case "Uint16Array":
      case "Uint32Array":
      case "Uint8ClampedArray":
      case "DataView":
        let buf = val.$ViewedArrayBuffer;
        (0, _invariant.default)(buf !== undefined);
        this.visitValue(buf);
        return;

      case "Map":
        this.visitValueMap(val);
        return;

      case "WeakMap":
        this.visitValueWeakMap(val);
        return;

      case "Set":
        this.visitValueSet(val);
        return;

      case "WeakSet":
        this.visitValueWeakSet(val);
        return;

      default:
        if (kind !== "Object") this.logger.logError(val, `Object of kind ${kind} is not supported in residual heap.`);

        if (this.realm.react.enabled && (0, _utils2.valueIsReactLibraryObject)(this.realm, val, this.logger)) {
          this.realm.fbLibraries.react = val;
        }

        return;
    }
  }

  visitValueSymbol(val) {
    if (val.$Description) this.visitValue(val.$Description);
  }

  visitValueProxy(val) {
    this._registerAdditionalRoot(val);

    this.visitValue(val.$ProxyTarget);
    this.visitValue(val.$ProxyHandler);
  }

  _visitAbstractValueConditional(val) {
    let condition = val.args[0];
    (0, _invariant.default)(condition instanceof _index2.AbstractValue);
    let cf = this.conditionalFeasibility.get(val);
    if (cf === undefined) this.conditionalFeasibility.set(val, cf = {
      t: false,
      f: false
    });
    let feasibleT, feasibleF;
    let savedPath = this.realm.pathConditions;

    try {
      this.realm.pathConditions = this.scope instanceof _generator.Generator ? this.scope.pathConditions : (0, _singletons.createPathConditions)();

      let impliesT = _singletons.Path.implies(condition);

      let impliesF = _singletons.Path.impliesNot(condition);

      (0, _invariant.default)(!(impliesT && impliesF));

      if (!impliesT && !impliesF) {
        feasibleT = feasibleF = true;
      } else {
        feasibleT = impliesT;
        feasibleF = impliesF;
      }
    } finally {
      this.realm.pathConditions = savedPath;
    }

    let visitedT = false,
        visitedF = false;

    if (!cf.t && feasibleT) {
      val.args[1] = this.visitEquivalentValue(val.args[1]);
      cf.t = true;
      if (cf.f) val.args[0] = this.visitEquivalentValue(val.args[0]);
      visitedT = true;
    }

    if (!cf.f && feasibleF) {
      val.args[2] = this.visitEquivalentValue(val.args[2]);
      cf.f = true;
      if (cf.t) val.args[0] = this.visitEquivalentValue(val.args[0]);
      visitedF = true;
    }

    if (!visitedT || !visitedF) {
      let fixpoint_rerun = () => {
        let progress = false;
        (0, _invariant.default)(cf !== undefined);

        if (cf.f && cf.t) {
          (0, _invariant.default)(!visitedT || !visitedF);
          this.visitValue(val.args[0]);
        }

        if (cf.t && !visitedT) {
          this.visitValue(val.args[1]);
          progress = visitedT = true;
        }

        (0, _invariant.default)(cf.t === visitedT);

        if (cf.f && !visitedF) {
          this.visitValue(val.args[2]);
          progress = visitedF = true;
        }

        (0, _invariant.default)(cf.f === visitedF); // When not all possible outcomes are assumed to be feasible yet after visiting some scopes,
        // it might be that they do become assumed to be feasible when later visiting some other scopes.
        // In that case, we should also re-visit the corresponding cases in this scope.
        // To this end, calling _enqueueWithUnrelatedScope enqueues this function for later re-execution if
        // any other visiting progress was made.

        if (!visitedT || !visitedF) this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);
        return progress;
      };

      fixpoint_rerun();
    }
  }

  visitAbstractValue(val) {
    if (val.kind === "sentinel member expression") {
      this.logger.logError(val, "expressions of type o[p] are not yet supported for partially known o and unknown p");
    } else if (val.kind === "environment initialization expression") {
      this.logger.logError(val, "reads during environment initialization should never leak to serialization");
    } else if (val.kind === "conditional") {
      this._visitAbstractValueConditional(val);

      return;
    }

    for (let i = 0, n = val.args.length; i < n; i++) {
      val.args[i] = this.visitEquivalentValue(val.args[i]);
    }
  } // Overridable hook for pre-visiting the value.
  // Return false will tell visitor to skip visiting children of this node.


  preProcessValue(val) {
    return this._mark(val);
  } // Overridable hook for post-visiting the value.


  postProcessValue(val) {}

  _mark(val) {
    let scopes = this.values.get(val);
    if (scopes === undefined) this.values.set(val, scopes = new Set());

    if (this.scope instanceof _generator.Generator && this.scope.effectsToApply === undefined) {
      // If we've already marked this value for any simple parent (non-effect carrying) generator,
      // then we don't need to re-mark it, as such a set of generators is reduced to the
      // parent generator in all uses of the scopes set.
      for (let g = this.scope; g instanceof _generator.Generator && g.effectsToApply === undefined; g = this.generatorTree.getParent(g)) {
        if (scopes.has(g)) return false;
      }
    } else if (scopes.has(this.scope)) return false;

    scopes.add(this.scope);
    return true;
  }

  visitEquivalentValue(val) {
    if (val instanceof _index2.AbstractValue) {
      let equivalentValue = this.equivalenceSet.add(val);
      if (this.preProcessValue(equivalentValue)) this.visitAbstractValue(equivalentValue);
      this.postProcessValue(equivalentValue);
      return equivalentValue;
    }

    if (val instanceof _index2.ObjectValue) {
      (0, _invariant.default)(val.isValid());

      if ((0, _utils2.isReactElement)(val)) {
        if (val.temporalAlias !== undefined) {
          return this.visitEquivalentValue(val.temporalAlias);
        }

        let equivalentReactElementValue = this.residualReactElementVisitor.reactElementEquivalenceSet.add(val);
        if (this._mark(equivalentReactElementValue)) this.visitValueObject(equivalentReactElementValue);
        return equivalentReactElementValue;
      } else if ((0, _utils2.isReactPropsObject)(val)) {
        let equivalentReactPropsValue = this.residualReactElementVisitor.reactPropsEquivalenceSet.add(val);
        if (this._mark(equivalentReactPropsValue)) this.visitValueObject(equivalentReactPropsValue);
        return equivalentReactPropsValue;
      }
    }

    this.visitValue(val);
    return val;
  }

  visitValue(val) {
    (0, _invariant.default)(val !== undefined);
    (0, _invariant.default)(!(val instanceof _index2.ObjectValue && val.refuseSerialization));

    if (val instanceof _index2.AbstractValue) {
      if (this.preProcessValue(val)) this.visitAbstractValue(val);
      this.postProcessValue(val);
    } else if (val.isIntrinsic()) {
      // All intrinsic values exist from the beginning of time...
      // ...except for a few that come into existence as templates for abstract objects via executable code.
      if (val instanceof _index2.ObjectValue && val.isScopedTemplate) {
        this.preProcessValue(val);
        this.postProcessValue(val);
      } else this._enqueueWithUnrelatedScope(this._getCommonScope(), () => {
        this.preProcessValue(val);
        this.postProcessValue(val);
      });
    } else if (val instanceof _index2.EmptyValue) {
      this.preProcessValue(val);
      this.postProcessValue(val);
    } else if (_HeapInspector.HeapInspector.isLeaf(val)) {
      this.preProcessValue(val);
      this.postProcessValue(val);
    } else if ((0, _index.IsArray)(this.realm, val)) {
      (0, _invariant.default)(val instanceof _index2.ObjectValue);
      if (this.preProcessValue(val)) this.visitValueArray(val);
      this.postProcessValue(val);
    } else if (val instanceof _index2.ProxyValue) {
      if (this.preProcessValue(val)) this.visitValueProxy(val);
      this.postProcessValue(val);
    } else if (val instanceof _index2.FunctionValue) {
      let creationGenerator = this.generatorTree.getCreator(val) || this.globalGenerator; // 1. Visit function in its creation scope

      this._enqueueWithUnrelatedScope(creationGenerator, () => {
        (0, _invariant.default)(val instanceof _index2.FunctionValue);
        if (this.preProcessValue(val)) this.visitValueFunction(val);
        this.postProcessValue(val);
      }); // 2. If current scope is not related to creation scope,
      //    and if this is not a recursive visit, mark the usage of this function
      //    in the common scope as well.


      let commonScope = this._getCommonScope();

      if (commonScope !== creationGenerator && commonScope !== val) {
        this._enqueueWithUnrelatedScope(commonScope, () => {
          this.preProcessValue(val);
          this.postProcessValue(val);
        });
      }
    } else if (val instanceof _index2.SymbolValue) {
      if (this.preProcessValue(val)) this.visitValueSymbol(val);
      this.postProcessValue(val);
    } else {
      (0, _invariant.default)(val instanceof _index2.ObjectValue);
      if (this.preProcessValue(val)) this.visitValueObject(val);
      this.postProcessValue(val);
    }
  }

  createGeneratorVisitCallbacks(additionalFunctionInfo) {
    let callbacks = {
      visitEquivalentValue: this.visitEquivalentValue.bind(this),
      visitGenerator: (generator, parent) => {
        (0, _invariant.default)(this.generatorTree.getParent(generator) === parent);
        this.visitGenerator(generator, additionalFunctionInfo);
      },
      canOmit: value => {
        let canOmit = !this.referencedDeclaredValues.has(value) && !this.values.has(value);

        if (!canOmit) {
          return false;
        }

        if (value instanceof _index2.ObjectValue && value.temporalAlias !== undefined) {
          let temporalAlias = value.temporalAlias;
          return !this.referencedDeclaredValues.has(temporalAlias) && !this.values.has(temporalAlias);
        }

        return canOmit;
      },
      recordDeclaration: value => {
        this.referencedDeclaredValues.set(value, this._getAdditionalFunctionOfScope());
      },
      recordDelayedEntry: (generator, entry) => {
        this._enqueueWithUnrelatedScope(generator, () => entry.visit(callbacks, generator));
      },
      visitModifiedProperty: binding => {
        let fixpoint_rerun = () => {
          if (this.values.has(binding.object)) {
            if (binding.internalSlot) {
              (0, _invariant.default)(typeof binding.key === "string");
              let error = new _errors.CompilerDiagnostic(`Internal slot ${binding.key} modified in a nested context. This is not yet supported.`, binding.object.expressionLocation, "PP1006", "FatalError");
              this.realm.handleError(error) === "Fail";
              throw new _errors.FatalError();
            }

            this.visitValue(binding.object);
            if (binding.key instanceof _index2.Value) this.visitValue(binding.key);
            this.visitObjectProperty(binding);
            return true;
          } else {
            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);

            return false;
          }
        };

        fixpoint_rerun();
      },
      visitModifiedBinding: modifiedBinding => {
        let fixpoint_rerun = () => {
          if (this.hasBinding(modifiedBinding.environment, modifiedBinding.name)) {
            (0, _invariant.default)(additionalFunctionInfo);
            let {
              functionValue
            } = additionalFunctionInfo;
            (0, _invariant.default)(functionValue instanceof _index2.ECMAScriptSourceFunctionValue);
            let residualBinding = this.getBinding(modifiedBinding.environment, modifiedBinding.name);
            let funcInstance = additionalFunctionInfo.instance;
            (0, _invariant.default)(funcInstance !== undefined);
            funcInstance.residualFunctionBindings.set(modifiedBinding.name, residualBinding);
            let newValue = modifiedBinding.value;
            (0, _invariant.default)(newValue);
            this.visitValue(newValue);
            residualBinding.modified = true;
            let otherFunc = residualBinding.additionalFunctionOverridesValue;

            if (otherFunc !== undefined && otherFunc !== functionValue) {
              let otherNameVal = otherFunc._SafeGetDataPropertyValue("name");

              let otherNameStr = otherNameVal instanceof _index2.StringValue ? otherNameVal.value : "unknown function";

              let funcNameVal = functionValue._SafeGetDataPropertyValue("name");

              let funNameStr = funcNameVal instanceof _index2.StringValue ? funcNameVal.value : "unknown function";
              let error = new _errors.CompilerDiagnostic(`Variable ${modifiedBinding.name} written to in optimized function ${funNameStr} conflicts with write in another optimized function ${otherNameStr}`, funcNameVal.expressionLocation, "PP1001", "RecoverableError");
              if (functionValue.$Realm.handleError(error) === "Fail") throw new _errors.FatalError();
            }

            residualBinding.additionalFunctionOverridesValue = functionValue;
            additionalFunctionInfo.modifiedBindings.set(modifiedBinding, residualBinding); // TODO #2430 nested optimized functions: revisit adding GLOBAL as outer optimized function

            residualBinding.potentialReferentializationScopes.add("GLOBAL");
            return true;
          } else {
            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);

            return false;
          }
        };

        fixpoint_rerun();
      },
      visitBindingAssignment: (binding, value) => {
        let residualBinding = this.getBinding(binding.environment, binding.name);
        residualBinding.modified = true;
        residualBinding.hasLeaked = true; // This may not have been referentialized if the binding is a local of an optimized function.
        // in that case, we need to figure out which optimized function it is, and referentialize it in that scope.

        let commonScope = this._getCommonScope();

        if (residualBinding.potentialReferentializationScopes.size === 0) {
          this._enqueueWithUnrelatedScope(commonScope, () => {
            if (additionalFunctionInfo !== undefined) {
              let funcInstance = additionalFunctionInfo.instance;
              (0, _invariant.default)(funcInstance !== undefined);
              funcInstance.residualFunctionBindings.set(residualBinding.name, residualBinding);
            }

            this.visitBinding(commonScope, residualBinding);
          });
        }

        return this.visitEquivalentValue(value);
      }
    };
    return callbacks;
  }

  visitGenerator(generator, additionalFunctionInfo) {
    this._withScope(generator, () => {
      generator.visit(this.createGeneratorVisitCallbacks(additionalFunctionInfo));
    }); // We don't bother purging created objects

  } // result -- serialized as a return statement
  // Generator -- visit all entries
  // Bindings -- (modifications to named variables) only need to serialize bindings if they're
  //             captured by a residual function
  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure
  //             we don't overwrite anything they capture
  // PropertyBindings -- (property modifications) visit any property bindings to pre-existing objects
  // CreatedObjects -- should take care of itself


  _visitAdditionalFunction(functionValue, additionalEffects) {
    // Get Instance + Info
    (0, _invariant.default)(functionValue instanceof _index2.ECMAScriptSourceFunctionValue);
    let code = functionValue.$ECMAScriptCode;
    let functionInfo = this.functionInfos.get(code);
    (0, _invariant.default)(functionInfo !== undefined);
    let funcInstance = this.functionInstances.get(functionValue);
    (0, _invariant.default)(funcInstance !== undefined); // Set Visitor state
    // Allows us to emit function declarations etc. inside of this additional
    // function instead of adding them at global scope

    let visitor = () => {
      (0, _invariant.default)(funcInstance !== undefined);
      (0, _invariant.default)(functionInfo !== undefined);
      let additionalFunctionInfo = {
        modifiedBindings: new Map(),
        functionValue,
        instance: funcInstance,
        prelude: []
      };
      this.additionalFunctionValueInfos.set(functionValue, additionalFunctionInfo);
      let effectsGenerator = additionalEffects.generator;
      this.generatorTree.add(functionValue, effectsGenerator);
      this.visitGenerator(effectsGenerator, additionalFunctionInfo);
    };

    if (this.realm.react.enabled) {
      this.residualReactElementVisitor.withCleanEquivalenceSet(visitor);
    } else {
      visitor();
    }
  }

  visitRoots() {
    this.generatorTree.add("GLOBAL", this.globalGenerator);
    this.visitGenerator(this.globalGenerator);

    for (let moduleValue of this.modules.initializedModules.values()) this.visitValue(moduleValue);

    this._visitUntilFixpoint();
  }

  _visitUntilFixpoint() {
    if (this.realm.react.verbose) {
      this.logger.logInformation(`Computing fixed point...`);
    } // Do a fixpoint over all pure generator entries to make sure that we visit
    // arguments of only BodyEntries that are required by some other residual value


    let progress = true;

    while (progress) {
      // Let's partition the actions by their generators,
      // as applying effects is expensive, and so we don't want to do it
      // more often than necessary.
      let actionsByGenerator = new Map();
      let expected = 0;

      for (let _ref of this.delayedActions) {
        let {
          scope,
          action
        } = _ref;
        let generator;
        if (scope instanceof _index2.FunctionValue) generator = this.generatorTree.getCreator(scope) || this.globalGenerator;else if (scope === "GLOBAL") generator = this.globalGenerator;else {
          (0, _invariant.default)(scope instanceof _generator.Generator);
          generator = scope;
        }
        let a = actionsByGenerator.get(generator);
        if (a === undefined) actionsByGenerator.set(generator, a = []);
        a.push({
          action,
          scope
        });
        expected++;
      }

      this.delayedActions = [];
      progress = false; // We build up a tree of effects runner that mirror the nesting of Generator effects.
      // This way, we only have to apply any given effects once, regardless of how many actions we have associated with whatever generators.

      let effectsInfos = new Map();
      let topEffectsRunners = [];
      let actual = 0;

      for (let [generator, scopedActions] of actionsByGenerator) {
        let runGeneratorAction = () => {
          for (let _ref2 of scopedActions) {
            let {
              action,
              scope
            } = _ref2;
            actual++;

            this._withScope(scope, () => {
              if (action() !== false) progress = true;
            });
          }
        };

        let s = generator;
        let visited = new Set();
        let newNestedRunner;

        while (s !== "GLOBAL") {
          (0, _invariant.default)(!visited.has(s));
          visited.add(s);

          if (s instanceof _generator.Generator) {
            let effectsToApply = s.effectsToApply;

            if (effectsToApply) {
              let info = effectsInfos.get(effectsToApply);
              let runner;

              if (info === undefined) {
                runner = () => {
                  this.realm.withEffectsAppliedInGlobalEnv(() => {
                    (0, _invariant.default)(info !== undefined);

                    for (let nestedEffectsRunner of info.nestedEffectsRunners) nestedEffectsRunner();

                    return null;
                  }, effectsToApply);
                };

                effectsInfos.set(effectsToApply, info = {
                  runner,
                  nestedEffectsRunners: []
                });
              }

              if (newNestedRunner !== undefined) info.nestedEffectsRunners.push(newNestedRunner);
              newNestedRunner = runner;
              if (runGeneratorAction === undefined) break;
              info.nestedEffectsRunners.push(runGeneratorAction);
              runGeneratorAction = undefined;
            }

            s = this.generatorTree.getParent(s);
          } else if (s instanceof _index2.FunctionValue) {
            (0, _invariant.default)(this.additionalFunctionValuesAndEffects.has(s));
            s = this.generatorTree.getCreator(s) || "GLOBAL";
          }

          (0, _invariant.default)(s instanceof _generator.Generator || s instanceof _index2.FunctionValue || s === "GLOBAL");
        }

        if (runGeneratorAction !== undefined) {
          (0, _invariant.default)(newNestedRunner === undefined);
          runGeneratorAction();
        } else if (newNestedRunner !== undefined) topEffectsRunners.push(newNestedRunner);
      }

      for (let topEffectsRunner of topEffectsRunners) topEffectsRunner();

      (0, _invariant.default)(expected === actual);

      if (this.realm.react.verbose) {
        this.logger.logInformation(`  (${actual} items processed)`);
      }
    }
  }

  toInfo() {
    return {
      values: this.values,
      functionInstances: this.functionInstances,
      classMethodInstances: this.classMethodInstances,
      functionInfos: this.functionInfos,
      referencedDeclaredValues: this.referencedDeclaredValues,
      additionalFunctionValueInfos: this.additionalFunctionValueInfos,
      declarativeEnvironmentRecordsBindings: this.declarativeEnvironmentRecordsBindings,
      globalBindings: this.globalBindings,
      conditionalFeasibility: this.conditionalFeasibility,
      additionalGeneratorRoots: this.additionalGeneratorRoots
    };
  }

}

exports.ResidualHeapVisitor = ResidualHeapVisitor;
//# sourceMappingURL=ResidualHeapVisitor.js.map

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.describeLocation = describeLocation;
exports.build = build;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return build("Error", realm, false);
}

function describeLocation(realm, callerFn, env, loc) {
  let locString = "";
  let displayName = "";
  let key = loc || callerFn; // check if we've already encountered the callFn and if so
  // re-use that described location. plus we may get stuck trying
  // to get the location by recursively checking the same fun
  // so this also prevents a stack overflow

  if (key) {
    if (realm.alreadyDescribedLocations.has(key)) {
      return realm.alreadyDescribedLocations.get(key);
    }

    realm.alreadyDescribedLocations.set(key, undefined);
  }

  if (callerFn) {
    if (callerFn instanceof _index.NativeFunctionValue) {
      locString = "native";
    }

    let name = callerFn._SafeGetDataPropertyValue("name");

    if (!name.mightBeUndefined()) displayName = _singletons.To.ToStringPartial(realm, name);else name.throwIfNotConcrete();
    if (env && env.environmentRecord.$NewTarget) displayName = `new ${displayName}`;
  }

  if (!locString) {
    if (loc) {
      locString = `${loc.start.line}:${loc.start.column + 1}`;
      if (loc.source !== null) locString = `${loc.source}:${locString}`;
    } else {
      locString = (loc ? loc.source : undefined) || "unknown";
      if (!displayName) return undefined;
    }
  }

  let location;

  if (displayName) {
    location = `at ${displayName} (${locString})`;
  } else {
    location = `at ${locString}`;
  }

  if (key) {
    realm.alreadyDescribedLocations.set(key, location);
  }

  return location;
}

const buildStackTemplateSrc = 'A + (B ? ": " + B : "") + C';

function buildStack(realm, context) {
  (0, _invariant.default)(context.$ErrorData);
  let stack = context.$ErrorData.contextStack;
  if (!stack) return realm.intrinsics.undefined;
  let lines = [];

  let header = _singletons.To.ToStringPartial(realm, (0, _index2.Get)(realm, context, "name"));

  let message = (0, _index2.Get)(realm, context, "message");

  if (!message.mightBeUndefined()) {
    message = _singletons.To.ToStringValue(realm, message);
  } else {
    message.throwIfNotConcrete();
  }

  for (let executionContext of stack.reverse()) {
    let caller = executionContext.caller;
    if (!executionContext.loc) continue; // compiler generated helper for destructuring arguments

    let locString = describeLocation(realm, caller ? caller.function : undefined, caller ? caller.lexicalEnvironment : undefined, executionContext.loc);
    if (locString !== undefined) lines.push(locString);
  }

  let footer = `\n    ${lines.join("\n    ")}`;
  return message instanceof _index.StringValue ? new _index.StringValue(realm, `${header}${message.value ? `: ${message.value}` : ""}${footer}`) : _index.AbstractValue.createFromTemplate(realm, buildStackTemplateSrc, _index.StringValue, [new _index.StringValue(realm, header), message, new _index.StringValue(realm, footer)]);
}

function build(name, realm, inheritError = true) {
  let func = new _index.NativeFunctionValue(realm, name, name, 1, (context, [message], argLength, NewTarget) => {
    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
    let newTarget = NewTarget || func; // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%ErrorPrototype%",  [[ErrorData]] ).

    let O = _singletons.Create.OrdinaryCreateFromConstructor(realm, newTarget, `${name}Prototype`, {
      $ErrorData: undefined
    });

    O.$ErrorData = {
      contextStack: realm.contextStack.slice(1),
      locationData: undefined
    }; // 3. If message is not undefined, then

    if (!message.mightBeUndefined()) {
      // a. Let msg be ? ToString(message).
      let msg = message.getType() === _index.StringValue ? message : _singletons.To.ToStringValue(realm, message); // b. Let msgDesc be the PropertyDescriptor{[[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.

      let msgDesc = new _descriptors.PropertyDescriptor({
        value: msg,
        writable: true,
        enumerable: false,
        configurable: true
      }); // c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).

      _singletons.Properties.DefinePropertyOrThrow(realm, O, "message", msgDesc);
    } else {
      message.throwIfNotConcrete();
    } // Build a text description of the stack.


    let stackDesc = new _descriptors.PropertyDescriptor({
      value: buildStack(realm, O),
      enumerable: false,
      configurable: true,
      writable: true
    });

    _singletons.Properties.DefinePropertyOrThrow(realm, O, "stack", stackDesc); // 4. Return O.


    return O;
  });

  if (inheritError) {
    func.$Prototype = realm.intrinsics.Error;
  }

  return func;
}
//# sourceMappingURL=Error.js.map

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClosureRefVisitor = void 0;

var _realm = __webpack_require__(7);

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function visitName(path, state, node, modified) {
  // Is the name bound to some local identifier? If so, we don't need to do anything
  if (path.scope.hasBinding(node.name,
  /*noGlobals*/
  true)) return; // Otherwise, let's record that there's an unbound identifier

  let nodes = state.functionInfo.unbound.get(node.name);
  if (nodes === undefined) state.functionInfo.unbound.set(node.name, nodes = []);
  nodes.push(node);
  if (modified) state.functionInfo.modified.add(node.name);
}

function ignorePath(path) {
  let parent = path.parent;
  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);
}

let ClosureRefVisitor = {
  "FunctionDeclaration|ArrowFunctionExpression|FunctionExpression": {
    enter(path, state) {
      state.functionInfo.depth++;
    },

    exit(path, state) {
      state.functionInfo.depth--;
    }

  },
  ArrowFunctionExpression: {
    enter(path, state) {
      state.functionInfo.depth++;
      state.functionInfo.lexicalDepth++;
    },

    exit(path, state) {
      state.functionInfo.depth--;
      state.functionInfo.lexicalDepth--;
    }

  },

  CallExpression(path, state) {
    // Here we apply the require optimization by replacing require calls with their
    // corresponding initialized modules.
    if (state.getModuleIdIfNodeIsRequireFunction === undefined) return;
    let moduleId = state.getModuleIdIfNodeIsRequireFunction(path.scope, path.node);
    if (moduleId === undefined) return;
    state.functionInfo.requireCalls.set(path.node, moduleId);
  },

  ReferencedIdentifier(path, state) {
    if (ignorePath(path)) return;
    let innerName = path.node.name;

    if (innerName === "arguments") {
      if (state.functionInfo.depth === 1) {
        state.functionInfo.usesArguments = true;
      } // "arguments" bound to local scope. therefore, there's no need to visit this identifier.


      return;
    }

    visitName(path, state, path.node, false);
  },

  ThisExpression(path, state) {
    if (state.functionInfo.depth - state.functionInfo.lexicalDepth === 1) {
      state.functionInfo.usesThis = true;
    }
  },

  "AssignmentExpression|UpdateExpression"(path, state) {
    let ids = path.getBindingIdentifiers();

    for (let name in ids) {
      visitName(path, state, ids[name], true);
    }
  },

  "ForInStatement|ForOfStatement"(path, state) {
    if (path.node.left !== "VariableDeclaration") {
      // `LeftHandSideExpression`s in a for-in/for-of statement perform `DestructuringAssignment` on the current loop
      // value so we need to make sure we visit these bindings and mark them as modified.
      const ids = path.get("left").getBindingIdentifiers();

      for (const name in ids) {
        visitName(path, state, ids[name], true);
      }
    }
  }

};
exports.ClosureRefVisitor = ClosureRefVisitor;
//# sourceMappingURL=visitors.js.map

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HeapInspector = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _logger = __webpack_require__(412);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function hasAnyConfigurable(desc) {
  if (!desc) {
    return false;
  }

  if (desc instanceof _descriptors.PropertyDescriptor) {
    return !!desc.configurable;
  }

  if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
    return hasAnyConfigurable(desc.descriptor1) || hasAnyConfigurable(desc.descriptor2);
  }

  (0, _invariant.default)(false, "internal slots aren't covered here");
}

function hasAnyWritable(desc) {
  if (!desc) {
    return false;
  }

  if (desc instanceof _descriptors.PropertyDescriptor) {
    return desc.value !== undefined && !!desc.writable;
  }

  if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
    return hasAnyWritable(desc.descriptor1) || hasAnyWritable(desc.descriptor2);
  }

  (0, _invariant.default)(false, "internal slots aren't covered here");
}

class HeapInspector {
  constructor(realm, logger) {
    this.realm = realm;
    this.logger = logger;
    this.ignoredProperties = new Map();
    this._targetIntegrityCommands = new Map();
  }

  getTargetIntegrityCommand(val) {
    let command = this._targetIntegrityCommands.get(val);

    if (command === undefined) {
      command = "";

      if (val instanceof _index2.ProxyValue) {// proxies don't participate in regular object freezing/sealing,
        // only their underlying proxied objects do
      } else {
        let extensible = val.$Extensible;

        if (!(extensible instanceof _index2.BooleanValue)) {
          this.logger.logError(val, "Object that might or might not be sealed or frozen are not supported in residual heap.");
        } else if (!extensible.value) {
          let anyWritable = false,
              anyConfigurable = false;

          for (let propertyBinding of val.properties.values()) {
            let desc = propertyBinding.descriptor;
            if (desc === undefined) continue; //deleted

            if (hasAnyConfigurable(desc)) anyConfigurable = true;else if (hasAnyWritable(desc)) anyWritable = true;
          }

          command = anyConfigurable ? "preventExtensions" : anyWritable ? "seal" : "freeze";
        }
      }

      this._targetIntegrityCommands.set(val, command);
    }

    return command;
  }

  getTargetIntegrityDescriptor(val) {
    return HeapInspector._integrityDescriptors[this.getTargetIntegrityCommand(val)];
  }

  static isLeaf(val) {
    if (val instanceof _index2.SymbolValue) {
      return false;
    }

    if (val instanceof _index2.AbstractValue) {
      if (val.hasIdentifier()) {
        return true;
      }

      if (val.$Realm.instantRender.enabled && val.intrinsicName !== undefined && val.intrinsicName.startsWith("__native")) {
        // Never factor out multiple occurrences of InstantRender's __native... abstract functions.
        return true;
      }
    }

    if (val.isIntrinsic()) {
      return false;
    }

    return val instanceof _index2.PrimitiveValue;
  } // Object properties which have the default value can be ignored by the serializer.


  canIgnoreProperty(val, key) {
    let set = this.ignoredProperties.get(val);

    if (!set) {
      this.ignoredProperties.set(val, set = this._getIgnoredProperties(val));
    }

    return set.has(key);
  }

  _getIgnoredProperties(val) {
    let set = new Set();

    for (let [key, propertyBinding] of val.properties) {
      (0, _invariant.default)(propertyBinding);
      let desc = propertyBinding.descriptor;
      if (desc === undefined) continue; //deleted

      if (this._canIgnoreProperty(val, key, desc)) set.add(key);
    }

    return set;
  }

  _canIgnoreProperty(val, key, desc) {
    if (!(desc instanceof _descriptors.PropertyDescriptor)) {
      // If we have a joined descriptor, there is at least one variant that isn't the same as
      // the target descriptor. Since the two descriptors won't be equal.
      return false;
    }

    let targetDescriptor = this.getTargetIntegrityDescriptor(val);

    if ((0, _index.IsArray)(this.realm, val)) {
      if (key === "length" && desc.writable === targetDescriptor.writable && desc.enumerable !== true && desc.configurable !== true) {
        // length property has the correct descriptor values
        return true;
      }
    } else if (val instanceof _index2.FunctionValue) {
      if (key === "length") {
        if (desc.value === undefined) {
          this.logger.logError(val, "Functions with length accessor properties are not supported in residual heap."); // Rationale: .bind() would call the accessor, which might throw, mutate state, or do whatever...
        } // length property will be inferred already by the amount of parameters


        return desc.writable !== true && desc.enumerable !== true && desc.configurable === targetDescriptor.configurable && val.hasDefaultLength();
      }

      if (key === "name") {
        // TODO #474: Make sure that we retain original function names. Or set name property.
        // Or ensure that nothing references the name property.
        // NOTE: with some old runtimes notably JSC, function names are not configurable
        // For now don't ignore the property if it is different from the function name.
        // I.e. if it was set explicitly in the code, retain it.
        if (desc.value !== undefined && !this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) && !this.realm.isCompatibleWith("mobile") && (desc.value instanceof _index2.AbstractValue || desc.value instanceof _index2.ConcreteValue && val.__originalName !== undefined && val.__originalName !== "" && _singletons.To.ToString(this.realm, desc.value) !== val.__originalName)) return false;
        return true;
      } // Properties `caller` and `arguments` are added to normal functions in non-strict mode to prevent TypeErrors.
      // Because they are autogenerated, they should be ignored.


      if (key === "arguments" || key === "caller") {
        (0, _invariant.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
        if (!val.$Strict && desc.writable === (!val.$Strict && targetDescriptor.writable) && desc.enumerable !== true && desc.configurable === targetDescriptor.configurable && desc.value instanceof _index2.UndefinedValue && val.$FunctionKind === "normal") return true;
      } // ignore the `prototype` property when it's the right one


      if (key === "prototype") {
        if (desc.configurable !== true && desc.enumerable !== true && desc.writable === targetDescriptor.writable && desc.value instanceof _index2.ObjectValue && desc.value.originalConstructor === val) {
          return true;
        }
      }
    } else {
      let kind = val.getKind();

      switch (kind) {
        case "RegExp":
          if (key === "lastIndex" && desc.writable === targetDescriptor.writable && desc.enumerable !== true && desc.configurable !== true) {
            // length property has the correct descriptor values
            let v = desc.value;
            return v instanceof _index2.NumberValue && v.value === 0;
          }

          break;

        default:
          break;
      }
    }

    if (key === "constructor") {
      if (desc.configurable === targetDescriptor.configurable && desc.enumerable !== true && desc.writable === targetDescriptor.writable && desc.value === val.originalConstructor) return true;
    }

    return false;
  }

  static getPropertyValue(val, name) {
    let prototypeBinding = val.properties.get(name);
    if (prototypeBinding === undefined) return undefined;
    let prototypeDesc = prototypeBinding.descriptor;
    if (prototypeDesc === undefined) return undefined;
    (0, _invariant.default)(prototypeDesc instanceof _descriptors.PropertyDescriptor);
    (0, _invariant.default)(prototypeDesc.value === undefined || prototypeDesc.value instanceof _index2.Value);
    return prototypeDesc.value;
  }

  isDefaultPrototype(prototype) {
    if (prototype.symbols.size !== 0 || prototype.$Prototype !== this.realm.intrinsics.ObjectPrototype || prototype.$Extensible.mightNotBeTrue()) {
      return false;
    }

    let foundConstructor = false;

    for (let name of prototype.properties.keys()) if (name === "constructor" && HeapInspector.getPropertyValue(prototype, name) === prototype.originalConstructor) foundConstructor = true;else return false;

    return foundConstructor;
  }

}

exports.HeapInspector = HeapInspector;

_defineProperty(HeapInspector, "_integrityDescriptors", {
  "": {
    writable: true,
    configurable: true
  },
  preventExtensions: {
    writable: true,
    configurable: true
  },
  seal: {
    writable: true,
    configurable: false
  },
  freeze: {
    writable: false,
    configurable: false
  }
});
//# sourceMappingURL=HeapInspector.js.map

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualReactElementVisitor = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _ResidualHeapVisitor = __webpack_require__(423);

var _hoisting = __webpack_require__(428);

var _elements = __webpack_require__(420);

var _utils = __webpack_require__(291);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _generator = __webpack_require__(237);

var _ReactEquivalenceSet = __webpack_require__(429);

var _ReactElementSet = __webpack_require__(430);

var _ReactPropsSet = __webpack_require__(431);

var _index2 = __webpack_require__(232);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class ResidualReactElementVisitor {
  constructor(realm, residualHeapVisitor) {
    this.realm = realm;
    this.residualHeapVisitor = residualHeapVisitor;
    this.reactOutput = realm.react.output || "create-element";
    this.defaultEquivalenceSet = true;
    this.reactEquivalenceSet = new _ReactEquivalenceSet.ReactEquivalenceSet(realm, this);
    this.reactElementEquivalenceSet = new _ReactElementSet.ReactElementSet(realm, this.reactEquivalenceSet);
    this.reactPropsEquivalenceSet = new _ReactPropsSet.ReactPropsSet(realm, this.reactEquivalenceSet);
  }

  visitReactElement(reactElement) {
    let reactElementData = this.realm.react.reactElements.get(reactElement);
    (0, _invariant.default)(reactElementData !== undefined);
    let {
      firstRenderOnly
    } = reactElementData;
    let isReactFragment = false;
    (0, _elements.traverseReactElement)(this.realm, reactElement, {
      visitType: typeValue => {
        let reactElementStringTypeReferences = this.realm.react.reactElementStringTypeReferences; // If the type is a text value, and we have a derived reference for it
        // then use that derived reference instead of the string value. This is
        // primarily designed around RCTView and RCTText, which are string values
        // for RN apps, but are treated as special host components.

        if (typeValue instanceof _index.StringValue && reactElementStringTypeReferences.has(typeValue.value)) {
          let reference = reactElementStringTypeReferences.get(typeValue.value);
          (0, _invariant.default)(reference instanceof _index.AbstractValue);
          (0, _utils.hardModifyReactObjectPropertyBinding)(this.realm, reactElement, "type", reference);
          this.residualHeapVisitor.visitValue(reference);
          return;
        }

        isReactFragment = typeValue instanceof _index.SymbolValue && typeValue === (0, _utils.getReactSymbol)("react.fragment", this.realm); // we don't want to visit fragments as they are internal values

        if (!isReactFragment) {
          this.residualHeapVisitor.visitValue(typeValue);
        }
      },
      visitKey: keyValue => {
        this.residualHeapVisitor.visitValue(keyValue);
      },
      visitRef: refValue => {
        if (!firstRenderOnly) {
          this.residualHeapVisitor.visitValue(refValue);
        }
      },
      visitAbstractOrPartialProps: propsValue => {
        this.residualHeapVisitor.visitValue(propsValue);
      },
      visitConcreteProps: propsValue => {
        for (let [propName, binding] of propsValue.properties) {
          (0, _invariant.default)(propName !== "key" && propName !== "ref", `"${propName}" is a reserved prop name`);

          if (binding.descriptor === undefined || propName === "children") {
            continue;
          }

          let propValue = (0, _utils.getProperty)(this.realm, propsValue, propName);

          if ((0, _utils.canExcludeReactElementObjectProperty)(this.realm, reactElement, propName, propValue)) {
            continue;
          }

          this.residualHeapVisitor.visitValue(propValue);
        }
      },
      visitChildNode: childValue => {
        this.residualHeapVisitor.visitValue(childValue);
      }
    }); // Our serializer requires that every value we serialize must first be visited in every scope where it appears. In
    // our React element serializer we serialize some values (namely `React.createElement` and `React.Fragment`) that do
    // not necessarily appear in our source code. We must manually visit these values in our visitor pass for the values
    // to be serializable.

    if (this.realm.react.output === "create-element") {
      const reactLibraryObject = this._getReactLibraryValue();

      (0, _invariant.default)(reactLibraryObject instanceof _index.ObjectValue);
      const createElement = reactLibraryObject.properties.get("createElement");
      (0, _invariant.default)(createElement !== undefined);
      const reactCreateElement = (0, _index2.Get)(this.realm, reactLibraryObject, "createElement"); // Our `createElement` value will be used in the prelude of the optimized function we serialize to initialize
      // our hoisted React elements. So we need to ensure that we visit our value in a scope above our own to allow
      // the function to be used in our optimized function prelude. We use our global scope to accomplish this. We are
      // a "friend" class of `ResidualHeapVisitor` so we call one of its private methods.

      this.residualHeapVisitor._visitInUnrelatedScope(this.residualHeapVisitor.globalGenerator, reactCreateElement);
    }

    if (isReactFragment) {
      const reactLibraryObject = this._getReactLibraryValue(); // Our `React.Fragment` value will be used in the function to lazily initialize hoisted JSX elements. So we need
      // to visit the library in our global generator so that it is available when creating the hoisted elements.


      this.residualHeapVisitor._visitInUnrelatedScope(this.residualHeapVisitor.globalGenerator, reactLibraryObject);
    } // determine if this ReactElement node tree is going to be hoistable


    (0, _hoisting.determineIfReactElementCanBeHoisted)(this.realm, reactElement, this.residualHeapVisitor);
  }

  withCleanEquivalenceSet(func) {
    let defaultEquivalenceSet = this.defaultEquivalenceSet;
    let reactEquivalenceSet = this.reactEquivalenceSet;
    let reactElementEquivalenceSet = this.reactElementEquivalenceSet;
    let reactPropsEquivalenceSet = this.reactPropsEquivalenceSet;
    this.defaultEquivalenceSet = false;
    this.reactEquivalenceSet = new _ReactEquivalenceSet.ReactEquivalenceSet(this.realm, this);
    this.reactElementEquivalenceSet = new _ReactElementSet.ReactElementSet(this.realm, this.reactEquivalenceSet);
    this.reactPropsEquivalenceSet = new _ReactPropsSet.ReactPropsSet(this.realm, this.reactEquivalenceSet);
    func(); // Cleanup

    this.defaultEquivalenceSet = defaultEquivalenceSet;
    this.reactEquivalenceSet = reactEquivalenceSet;
    this.reactElementEquivalenceSet = reactElementEquivalenceSet;
    this.reactPropsEquivalenceSet = reactPropsEquivalenceSet;
  }

  saveEquivalenceSet() {
    const {
      reactEquivalenceSet,
      reactElementEquivalenceSet,
      reactPropsEquivalenceSet
    } = this;
    return {
      reactEquivalenceSet,
      reactElementEquivalenceSet,
      reactPropsEquivalenceSet
    };
  }

  loadEquivalenceSet(save, func) {
    const defaultEquivalenceSet = this.defaultEquivalenceSet;
    const reactEquivalenceSet = this.reactEquivalenceSet;
    const reactElementEquivalenceSet = this.reactElementEquivalenceSet;
    const reactPropsEquivalenceSet = this.reactPropsEquivalenceSet;
    this.defaultEquivalenceSet = false;
    this.reactEquivalenceSet = save.reactEquivalenceSet;
    this.reactElementEquivalenceSet = save.reactElementEquivalenceSet;
    this.reactPropsEquivalenceSet = save.reactPropsEquivalenceSet;
    const result = func(); // Cleanup

    this.defaultEquivalenceSet = defaultEquivalenceSet;
    this.reactEquivalenceSet = reactEquivalenceSet;
    this.reactElementEquivalenceSet = reactElementEquivalenceSet;
    this.reactPropsEquivalenceSet = reactPropsEquivalenceSet;
    return result;
  }

  wasTemporalAliasDeclaredInCurrentScope(temporalAlias) {
    let scope = this.residualHeapVisitor.scope;

    if (scope instanceof _index.FunctionValue) {
      return false;
    } // If the temporal has already been visited, then we know the temporal
    // value was used and thus declared in another scope


    if (this.residualHeapVisitor.values.has(temporalAlias)) {
      return false;
    } // Otherwise, we check the current scope and see if the
    // temporal value was declared in one of the entries


    for (let i = 0; i < scope._entries.length; i++) {
      let entry = scope._entries[i];

      if (entry instanceof _generator.TemporalOperationEntry) {
        if (entry.declared === temporalAlias) {
          return true;
        }
      }
    }

    return false;
  }

  _getReactLibraryValue() {
    const reactLibraryObject = this.realm.fbLibraries.react;
    (0, _invariant.default)(reactLibraryObject, "Unable to find React library reference in scope.");
    return reactLibraryObject;
  }

}

exports.ResidualReactElementVisitor = ResidualReactElementVisitor;
//# sourceMappingURL=ResidualReactElementVisitor.js.map

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canHoistFunction = canHoistFunction;
exports.canHoistReactElement = canHoistReactElement;
exports.determineIfReactElementCanBeHoisted = determineIfReactElementCanBeHoisted;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils = __webpack_require__(291);

var _ResidualHeapVisitor = __webpack_require__(423);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// a nested object of a React Element should be hoisted where all its properties are known
// at evaluation time to be safe to hoist (because of the heuristics of a React render)
function canHoistObject(realm, object, residualHeapVisitor, visitedValues) {
  if ((0, _utils.isReactElement)(object)) {
    return canHoistReactElement(realm, object, residualHeapVisitor, visitedValues);
  }

  for (let [propName] of object.properties) {
    let prop = (0, _index2.Get)(realm, object, propName);

    if (!canHoistValue(realm, prop, residualHeapVisitor, visitedValues)) {
      return false;
    }
  }

  for (let [symbol] of object.symbols) {
    let prop = (0, _index2.Get)(realm, object, symbol);

    if (!canHoistValue(realm, prop, residualHeapVisitor, visitedValues)) {
      return false;
    }
  }

  return true;
}

function canHoistArray(realm, array, residualHeapVisitor, visitedValues) {
  if (array.intrinsicName) return false;
  let lengthValue = (0, _index2.Get)(realm, array, "length");

  if (!canHoistValue(realm, lengthValue, residualHeapVisitor, visitedValues)) {
    return false;
  }

  if (lengthValue instanceof _index.NumberValue) {
    let length = lengthValue.value;

    for (let i = 0; i < length; i++) {
      let element = (0, _index2.Get)(realm, array, "" + i);

      if (!canHoistValue(realm, element, residualHeapVisitor, visitedValues)) {
        return false;
      }
    }
  }

  return true;
}

function canHoistFunction(realm, func, residualHeapVisitor, visitedValues) {
  if (realm.react.hoistableFunctions.has(func)) {
    // cast because Flow thinks that we may have set a value to be something other than a boolean?
    return realm.react.hoistableFunctions.get(func);
  }

  if (residualHeapVisitor === undefined) {
    return false;
  } // get the function instance


  let functionInstance = residualHeapVisitor.functionInstances.get(func); // we can safely hoist the function if the residual bindings hoistable too

  if (functionInstance !== undefined) {
    (0, _invariant.default)(functionInstance.residualFunctionBindings instanceof Map);
    let residualBindings = functionInstance.residualFunctionBindings;

    for (let [, {
      declarativeEnvironmentRecord,
      value
    }] of residualBindings) {
      // if declarativeEnvironmentRecord is null, it's likely a global binding
      // so we can assume that we can still hoist this function
      if (declarativeEnvironmentRecord !== null) {
        if (value === undefined) {
          return false;
        }

        (0, _invariant.default)(value instanceof _index.Value);

        if (!canHoistValue(realm, value, residualHeapVisitor, visitedValues)) {
          return false;
        }
      }
    }

    if (func instanceof _index.ECMAScriptSourceFunctionValue) {
      let code = func.$ECMAScriptCode;
      let functionInfos = residualHeapVisitor.functionInfos.get(code);

      if (functionInfos && functionInfos.unbound.size > 0) {
        return false;
      }
    }

    realm.react.hoistableFunctions.set(func, true);
    return true;
  }

  realm.react.hoistableFunctions.set(func, false);
  return false;
}

function canHoistAbstract(realm, abstract, residualHeapVisitor) {
  // TODO #1687: add abstract value hoisting
  return false;
}

function isPrimitive(realm, value) {
  return value instanceof _index.StringValue || value instanceof _index.NumberValue || value instanceof _index.SymbolValue || value instanceof _index.BooleanValue || value === realm.intrinsics.null || value === realm.intrinsics.undefined;
}

function canHoistValue(realm, value, residualHeapVisitor, visitedValues) {
  if (visitedValues.has(value)) {
    // If there is a cycle, bail out.
    // TODO: is there some way to *not* bail out in this case?
    // Currently if we don't, the output is broken.
    return false;
  }

  visitedValues.add(value);
  let canHoist = false;

  if (value instanceof _index.ArrayValue) {
    canHoist = canHoistArray(realm, value, residualHeapVisitor, visitedValues);
  } else if (value instanceof _index.FunctionValue) {
    canHoist = canHoistFunction(realm, value, residualHeapVisitor, visitedValues);
  } else if (value instanceof _index.ObjectValue) {
    canHoist = canHoistObject(realm, value, residualHeapVisitor, visitedValues);
  } else if (value instanceof _index.AbstractValue) {
    canHoist = canHoistAbstract(realm, value, residualHeapVisitor);
  } else if (isPrimitive) {
    canHoist = true;
  }

  visitedValues.delete(value);
  return canHoist;
}

function canHoistReactElement(realm, reactElement, residualHeapVisitor, visitedValues) {
  if (realm.react.hoistableReactElements.has(reactElement)) {
    // cast because Flow thinks that we may have set a value to be something other than a boolean?
    return realm.react.hoistableReactElements.get(reactElement);
  }

  if (residualHeapVisitor === undefined) {
    return false;
  }

  let type = (0, _utils.getProperty)(realm, reactElement, "type");
  let ref = (0, _utils.getProperty)(realm, reactElement, "ref");
  let key = (0, _utils.getProperty)(realm, reactElement, "key");
  let props = (0, _utils.getProperty)(realm, reactElement, "props");

  if (visitedValues === undefined) {
    visitedValues = new Set();
    visitedValues.add(reactElement);
  }

  if (canHoistValue(realm, type, residualHeapVisitor, visitedValues) && // we can't hoist string "refs" or if they're abstract, as they might be abstract strings
  !(ref instanceof String || ref instanceof _index.AbstractValue) && canHoistValue(realm, ref, residualHeapVisitor, visitedValues) && canHoistValue(realm, key, residualHeapVisitor, visitedValues) && !props.isPartialObject() && canHoistValue(realm, props, residualHeapVisitor, visitedValues)) {
    realm.react.hoistableReactElements.set(reactElement, true);
    return true;
  }

  realm.react.hoistableReactElements.set(reactElement, false);
  return false;
}

function determineIfReactElementCanBeHoisted(realm, reactElement, residualHeapVisitor) {
  canHoistReactElement(realm, reactElement, residualHeapVisitor);
}
//# sourceMappingURL=hoisting.js.map

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactEquivalenceSet = exports.temporalAliasSymbol = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils = __webpack_require__(291);

var _ResidualReactElementVisitor = __webpack_require__(427);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const temporalAliasSymbol = Symbol("temporalAlias"); // ReactEquivalenceSet keeps records around of the values
// of ReactElement/JSX nodes so we can return the same immutable values
// where possible, i.e. <div /> === <div />
//
// Rather than uses hashes, this class uses linked Maps to track equality of objects.
// It does this by recursively iterating through objects, by their properties/symbols and using
// each property key as a map, and then from that map, each value as a map. The value
// then links to the subsequent property/symbol in the object. This approach ensures insertion
// is maintained through all objects.

exports.temporalAliasSymbol = temporalAliasSymbol;

class ReactEquivalenceSet {
  constructor(realm, residualReactElementVisitor) {
    this.realm = realm;
    this.residualReactElementVisitor = residualReactElementVisitor;
    this.objectRoot = new Map();
    this.arrayRoot = new Map();
    this.reactElementRoot = new Map();
    this.reactPropsRoot = new Map();
    this.temporalAliasRoot = new Map();
  }

  _createNode() {
    return {
      map: new Map(),
      value: null
    };
  }

  getKey(key, map, visitedValues) {
    if (!map.has(key)) {
      map.set(key, new Map());
    }

    return map.get(key);
  }

  _getValue(val, map, visitedValues) {
    if (val instanceof _index.StringValue || val instanceof _index.NumberValue) {
      val = val.value;
    } else if (val instanceof _index.AbstractValue) {
      val = this.residualReactElementVisitor.residualHeapVisitor.equivalenceSet.add(val);
    } else if (val instanceof _index.ArrayValue) {
      val = this._getArrayValue(val, visitedValues);
    } else if (val instanceof _index.ObjectValue && !(val instanceof _index.FunctionValue)) {
      val = this._getObjectValue(val, visitedValues);
    }

    if (!map.has(val)) {
      map.set(val, this._createNode());
    }

    return map.get(val);
  } // for objects: [key/symbol] -> [key/symbol]... as nodes


  _getObjectValue(object, visitedValues) {
    if (visitedValues.has(object)) return object;
    visitedValues.add(object);

    if ((0, _utils.isReactElement)(object)) {
      return this.residualReactElementVisitor.reactElementEquivalenceSet.add(object);
    }

    let currentMap = this.objectRoot;
    let result;

    for (let [propName] of object.properties) {
      currentMap = this.getKey(propName, currentMap, visitedValues);
      result = this.getEquivalentPropertyValue(object, propName, currentMap, visitedValues);
      currentMap = result.map;
    }

    for (let [symbol] of object.symbols) {
      currentMap = this.getKey(symbol, currentMap, visitedValues);
      let prop = (0, _utils.getProperty)(this.realm, object, symbol);
      result = this._getValue(prop, currentMap, visitedValues);
      currentMap = result.map;
    }

    let temporalAlias = object.temporalAlias;

    if (temporalAlias !== undefined) {
      currentMap = this.getKey(temporalAliasSymbol, currentMap, visitedValues);
      result = this.getTemporalAliasValue(temporalAlias, currentMap, visitedValues);
    }

    if (result === undefined) {
      // If we have a temporalAlias, we can never return an empty object
      if (temporalAlias === undefined && this.realm.react.emptyObject !== undefined) {
        return this.realm.react.emptyObject;
      }

      return object;
    }

    if (result.value === null) {
      result.value = object;
    }

    return result.value;
  }

  _getTemporalValue(temporalAlias, visitedValues) {
    // Check to ensure the temporal alias is definitely declared in the current scope
    if (!this.residualReactElementVisitor.wasTemporalAliasDeclaredInCurrentScope(temporalAlias)) {
      return temporalAlias;
    }

    let temporalOperationEntry = this.realm.getTemporalOperationEntryFromDerivedValue(temporalAlias);

    if (temporalOperationEntry === undefined) {
      return temporalAlias;
    }

    let temporalArgs = temporalOperationEntry.args;

    if (temporalArgs.length === 0) {
      return temporalAlias;
    }

    let currentMap = this.temporalAliasRoot;
    let result;

    for (let i = 0; i < temporalArgs.length; i++) {
      let arg = temporalArgs[i];
      let equivalenceArg;

      if (arg instanceof _index.ObjectValue && arg.temporalAlias === temporalAlias) {
        continue;
      }

      if (arg instanceof _index.ObjectValue && (0, _utils.isReactElement)(arg)) {
        equivalenceArg = this.residualReactElementVisitor.reactElementEquivalenceSet.add(arg);

        if (arg !== equivalenceArg) {
          temporalArgs[i] = equivalenceArg;
        }
      } else if (arg instanceof _index.AbstractObjectValue && !arg.values.isTop() && arg.kind !== "conditional") {
        // Might be a temporal, so let's check
        let childTemporalOperationEntry = this.realm.getTemporalOperationEntryFromDerivedValue(arg);

        if (childTemporalOperationEntry !== undefined) {
          equivalenceArg = this._getTemporalValue(arg, visitedValues);
          (0, _invariant.default)(equivalenceArg instanceof _index.AbstractObjectValue);

          if (equivalenceArg !== arg) {
            temporalArgs[i] = equivalenceArg;
          }
        }
      } else if (arg instanceof _index.AbstractValue) {
        equivalenceArg = this.residualReactElementVisitor.residualHeapVisitor.equivalenceSet.add(arg);

        if (arg !== equivalenceArg) {
          temporalArgs[i] = equivalenceArg;
        }
      }

      currentMap = this.getKey(i, currentMap, visitedValues);
      (0, _invariant.default)(arg instanceof _index.Value && (equivalenceArg instanceof _index.Value || equivalenceArg === undefined));
      result = this._getValue(equivalenceArg || arg, currentMap, visitedValues);
      currentMap = result.map;
    }

    (0, _invariant.default)(result !== undefined);

    if (result.value === null) {
      result.value = temporalAlias;
    } // Check to ensure the equivalent temporal alias is definitely declared in the current scope


    if (!this.residualReactElementVisitor.wasTemporalAliasDeclaredInCurrentScope(result.value)) {
      result.value = temporalAlias;
      return temporalAlias;
    }

    return result.value;
  }

  getTemporalAliasValue(temporalAlias, map, visitedValues) {
    let result = this._getTemporalValue(temporalAlias, visitedValues);

    (0, _invariant.default)(result instanceof _index.AbstractObjectValue);

    if (!map.has(result)) {
      map.set(result, this._createNode());
    }

    return map.get(result);
  } // for arrays: [length] -> ([length] is numeric) -> [0] -> [1] -> [2]... as nodes


  _getArrayValue(array, visitedValues) {
    if (visitedValues.has(array)) return array;
    if (array.intrinsicName) return array;
    visitedValues.add(array);
    let currentMap = this.arrayRoot;
    currentMap = this.getKey("length", currentMap, visitedValues);
    let result = this.getEquivalentPropertyValue(array, "length", currentMap, visitedValues);
    currentMap = result.map;
    let lengthValue = (0, _utils.getProperty)(this.realm, array, "length"); // If we have a numeric lenth that is not abstract, then also check all the array elements

    if (lengthValue instanceof _index.NumberValue) {
      (0, _invariant.default)(lengthValue instanceof _index.NumberValue);
      let length = lengthValue.value;

      for (let i = 0; i < length; i++) {
        currentMap = this.getKey(i, currentMap, visitedValues);
        result = this.getEquivalentPropertyValue(array, "" + i, currentMap, visitedValues);
        currentMap = result.map;
      }
    }

    if (result === undefined) {
      if (this.realm.react.emptyArray !== undefined) {
        return this.realm.react.emptyArray;
      }

      return array;
    }

    if (result.value === null) {
      result.value = array;
    }

    (0, _invariant.default)(result.value instanceof _index.ArrayValue);
    return result.value;
  }

  getEquivalentPropertyValue(object, propName, map, visitedValues) {
    let prop = (0, _utils.getProperty)(this.realm, object, propName);
    let isFinal = object.mightBeFinalObject();
    let equivalentProp;

    if (prop instanceof _index.ObjectValue && (0, _utils.isReactElement)(prop)) {
      equivalentProp = this.residualReactElementVisitor.reactElementEquivalenceSet.add(prop);
    } else if (prop instanceof _index.ObjectValue && (0, _utils.isReactPropsObject)(prop)) {
      equivalentProp = this.residualReactElementVisitor.reactPropsEquivalenceSet.add(prop);
    } else if (prop instanceof _index.AbstractValue) {
      equivalentProp = this.residualReactElementVisitor.residualHeapVisitor.equivalenceSet.add(prop);
    }

    if (equivalentProp !== undefined) {
      if (prop !== equivalentProp && isFinal) {
        (0, _utils.hardModifyReactObjectPropertyBinding)(this.realm, object, propName, equivalentProp);
      }

      if (!map.has(equivalentProp)) {
        map.set(equivalentProp, this._createNode());
      }

      return map.get(equivalentProp);
    } else {
      return this._getValue(prop, map, visitedValues);
    }
  }

}

exports.ReactEquivalenceSet = ReactEquivalenceSet;
//# sourceMappingURL=ReactEquivalenceSet.js.map

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactElementSet = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _ReactEquivalenceSet = __webpack_require__(429);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class ReactElementSet {
  constructor(realm, reactEquivalenceSet) {
    this.realm = realm;
    this.reactEquivalenceSet = reactEquivalenceSet;
  }

  add(reactElement, visitedValues) {
    if (!visitedValues) visitedValues = new Set();
    let reactEquivalenceSet = this.reactEquivalenceSet;
    let currentMap = reactEquivalenceSet.reactElementRoot; // type

    currentMap = reactEquivalenceSet.getKey("type", currentMap, visitedValues);
    let result = reactEquivalenceSet.getEquivalentPropertyValue(reactElement, "type", currentMap, visitedValues);
    currentMap = result.map; // key

    currentMap = reactEquivalenceSet.getKey("key", currentMap, visitedValues);
    result = reactEquivalenceSet.getEquivalentPropertyValue(reactElement, "key", currentMap, visitedValues);
    currentMap = result.map; // ref

    currentMap = reactEquivalenceSet.getKey("ref", currentMap, visitedValues);
    result = reactEquivalenceSet.getEquivalentPropertyValue(reactElement, "ref", currentMap, visitedValues);
    currentMap = result.map; // props

    currentMap = reactEquivalenceSet.getKey("props", currentMap, visitedValues);
    result = reactEquivalenceSet.getEquivalentPropertyValue(reactElement, "props", currentMap, visitedValues);

    if (result.value === null) {
      result.value = reactElement;
    }

    (0, _invariant.default)(result.value instanceof _index.ObjectValue);
    return result.value;
  }

}

exports.ReactElementSet = ReactElementSet;
//# sourceMappingURL=ReactElementSet.js.map

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactPropsSet = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _ReactEquivalenceSet = __webpack_require__(429);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class ReactPropsSet {
  constructor(realm, reactEquivalenceSet) {
    this.realm = realm;
    this.reactEquivalenceSet = reactEquivalenceSet;
  }

  add(props, visitedValues) {
    if (!visitedValues) visitedValues = new Set();
    let reactEquivalenceSet = this.reactEquivalenceSet;
    let currentMap = reactEquivalenceSet.reactPropsRoot;
    let result;

    for (let [propName] of props.properties) {
      currentMap = reactEquivalenceSet.getKey(propName, currentMap, visitedValues);
      result = reactEquivalenceSet.getEquivalentPropertyValue(props, propName, currentMap, visitedValues);
      currentMap = result.map;
    }

    let temporalAlias = props.temporalAlias;

    if (temporalAlias !== undefined) {
      currentMap = reactEquivalenceSet.getKey(_ReactEquivalenceSet.temporalAliasSymbol, currentMap, visitedValues);
      result = reactEquivalenceSet.getTemporalAliasValue(temporalAlias, currentMap, visitedValues);
      currentMap = result.map;
    }

    if (result === undefined) {
      // If we have a temporalAlias, we can never return an empty object
      if (temporalAlias === undefined && this.realm.react.emptyObject !== undefined) {
        return this.realm.react.emptyObject;
      }

      return props;
    }

    if (result.value === null) {
      result.value = props;
    }

    (0, _invariant.default)(result.value instanceof _index.ObjectValue);
    return result.value;
  }

}

exports.ReactPropsSet = ReactPropsSet;
//# sourceMappingURL=ReactPropsSet.js.map

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeneratorTree = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(10);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// This class maintains a tree containing all generators known so far,
// and information about the most specific generator that created any
// particular object.
// New sub-trees are added in chunks, at the beginning for the global generator,
// and every time the visitor handles another additional function.
class GeneratorTree {
  constructor() {
    this.parents = new Map();
    this.createdObjects = new Map();
  }

  getParent(generator) {
    let parent = this.parents.get(generator);
    (0, _invariant.default)(parent !== undefined);
    return parent;
  }

  getCreator(value) {
    return this.createdObjects.get(value);
  }

  add(parent, generator) {
    this._add(parent, generator);
  }

  _add(parent, generator) {
    (0, _invariant.default)(!this.parents.has(generator));
    this.parents.set(generator, parent);
    let effects = generator.effectsToApply;

    if (effects !== undefined) {
      (0, _invariant.default)(parent instanceof _index.FunctionValue);

      for (let createdObject of effects.createdObjects) {
        let isValidPreviousCreator = previousCreator => {
          // It's okay if we don't know about any previous creator.
          if (previousCreator === undefined) return true; // If we already recorded a newly-created object, then we must have done so for our parent

          if (previousCreator === parent) return true; // Since we are dealing with a DAG, and not a tree, we might have already the current generator as the creator

          if (previousCreator === generator) return true; // TODO: There's something else going on that is not yet understood.
          // Fix the return value once #1901 is understood and landed.

          return true; // false
        };

        (0, _invariant.default)(isValidPreviousCreator(this.createdObjects.get(createdObject))); // Update the created objects mapping to the most specific generator

        this.createdObjects.set(createdObject, generator);
      }
    }

    for (let dependency of generator.getDependencies()) this._add(generator, dependency);
  }

}

exports.GeneratorTree = GeneratorTree;
//# sourceMappingURL=GeneratorTree.js.map

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapSerializer = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _generator = __webpack_require__(237);

var _PreludeGenerator = __webpack_require__(238);

var _NameGenerator = __webpack_require__(240);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _types2 = __webpack_require__(408);

var _statistics = __webpack_require__(407);

var _logger = __webpack_require__(412);

var _modules = __webpack_require__(411);

var _HeapInspector = __webpack_require__(426);

var _ResidualFunctions = __webpack_require__(434);

var _factorify = __webpack_require__(438);

var _babelhelpers = __webpack_require__(239);

var _Emitter = __webpack_require__(440);

var _ResidualHeapValueIdentifiers = __webpack_require__(441);

var _utils = __webpack_require__(413);

var _errors = __webpack_require__(3);

var _hoisting = __webpack_require__(428);

var _singletons = __webpack_require__(236);

var _ResidualReactElementSerializer = __webpack_require__(442);

var _environment = __webpack_require__(20);

var _GeneratorTree = __webpack_require__(432);

var _ResidualFunctionInstantiator = __webpack_require__(435);

var _utils2 = __webpack_require__(443);

var _ResidualOperationSerializer = __webpack_require__(444);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function commentStatement(text) {
  let s = t.emptyStatement();
  s.leadingComments = [{
    type: "BlockComment",
    value: text
  }];
  return s;
}

class CountingSemaphore {
  constructor(action, initialCount = 1) {
    (0, _invariant.default)(initialCount >= 1);
    this.count = initialCount;
    this.action = action;
  }

  acquireOne() {
    this.count++;
  }

  releaseOne() {
    (0, _invariant.default)(this.count > 0);
    if (--this.count === 0) this.action();
  }

}

class ResidualHeapSerializer {
  constructor(realm, logger, modules, residualHeapValueIdentifiers, residualHeapInspector, residualHeapInfo, options, additionalFunctionValuesAndEffects, referentializer, generatorTree, residualOptimizedFunctions) {
    this.realm = realm;
    this.logger = logger;
    this.modules = modules;
    this.residualHeapValueIdentifiers = residualHeapValueIdentifiers;
    this.referentializer = referentializer;
    this._residualOptimizedFunctions = residualOptimizedFunctions;
    let realmGenerator = this.realm.generator;
    (0, _invariant.default)(realmGenerator);
    this.generator = realmGenerator;
    let realmPreludeGenerator = this.realm.preludeGenerator;
    (0, _invariant.default)(realmPreludeGenerator);
    this.preludeGenerator = realmPreludeGenerator;
    this.residualOperationSerializer = new _ResidualOperationSerializer.ResidualOperationSerializer(realm, realmPreludeGenerator);
    this.prelude = [];
    this._descriptors = new Map();
    this.needsEmptyVar = false;
    this.needsAuxiliaryConstructor = false;
    this.descriptorNameGenerator = this.preludeGenerator.createNameGenerator("$$");
    this.factoryNameGenerator = this.preludeGenerator.createNameGenerator("$_");
    this.intrinsicNameGenerator = this.preludeGenerator.createNameGenerator("$i_");
    this.functionNameGenerator = this.preludeGenerator.createNameGenerator("$f_");
    this.initializeConditionNameGenerator = this.preludeGenerator.createNameGenerator("_initialized");
    this.initializerNameGenerator = this.preludeGenerator.createNameGenerator("__init_");
    this.requireReturns = new Map();
    this.serializedValues = new Set();
    this._serializedValueWithIdentifiers = new Set();
    this.additionalFunctionValueNestedFunctions = new Set();
    this.residualReactElementSerializer = new _ResidualReactElementSerializer.ResidualReactElementSerializer(this.realm, this, residualOptimizedFunctions);
    this.residualFunctions = new _ResidualFunctions.ResidualFunctions(this.realm, options, this.modules, this.requireReturns, {
      getContainingAdditionalFunction: functionValue => {
        let instance = this.residualFunctionInstances.get(functionValue);
        (0, _invariant.default)(instance !== undefined);
        return instance.containingAdditionalFunction;
      },
      getLocation: value => this.getSerializeObjectIdentifier(value),
      createLocation: containingAdditionalFunction => {
        let location = t.identifier(this.initializeConditionNameGenerator.generate());
        let declar = t.variableDeclaration("var", [t.variableDeclarator(location)]);
        this.getPrelude(containingAdditionalFunction).push(declar);
        return location;
      },
      createFunction: (containingAdditionalFunction, statements) => {
        let id = t.identifier(this.initializerNameGenerator.generate());
        this.getPrelude(containingAdditionalFunction).push(t.functionDeclaration(id, [], t.blockStatement(statements)));
        return id;
      }
    }, this.prelude, this.factoryNameGenerator, residualHeapInfo.functionInfos, residualHeapInfo.functionInstances, residualHeapInfo.classMethodInstances, residualHeapInfo.additionalFunctionValueInfos, this.additionalFunctionValueNestedFunctions, referentializer);
    this.emitter = new _Emitter.Emitter(this.residualFunctions, residualHeapInfo.referencedDeclaredValues, residualHeapInfo.conditionalFeasibility, this.realm.derivedIds);
    this.mainBody = this.emitter.getBody();
    this.residualHeapInspector = residualHeapInspector;
    this.residualValues = residualHeapInfo.values;
    this.residualFunctionInstances = residualHeapInfo.functionInstances;
    this.residualClassMethodInstances = residualHeapInfo.classMethodInstances;
    this.residualFunctionInfos = residualHeapInfo.functionInfos;
    this._options = options;
    this.referencedDeclaredValues = residualHeapInfo.referencedDeclaredValues;
    this.activeGeneratorBodies = new Map();
    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;
    this.additionalFunctionValueInfos = residualHeapInfo.additionalFunctionValueInfos;
    this.rewrittenAdditionalFunctions = new Map();
    this.declarativeEnvironmentRecordsBindings = residualHeapInfo.declarativeEnvironmentRecordsBindings;
    this.globalBindings = residualHeapInfo.globalBindings;
    this.generatorTree = generatorTree;
    this.conditionalFeasibility = residualHeapInfo.conditionalFeasibility;
    this.additionalFunctionGenerators = new Map();
    this.declaredGlobalLets = new Map();
    this._objectSemaphores = new Map();
    this.additionalGeneratorRoots = residualHeapInfo.additionalGeneratorRoots;
    let environment = realm.$GlobalEnv.environmentRecord;
    (0, _invariant.default)(environment instanceof _environment.GlobalEnvironmentRecord);
    this.globalEnvironmentRecord = environment;
  }

  getStatistics() {
    (0, _invariant.default)(this.realm.statistics instanceof _statistics.SerializerStatistics, "serialization requires SerializerStatistics");
    return this.realm.statistics;
  }

  _acquireOneObjectSemaphore(object) {
    let semaphore = this._objectSemaphores.get(object);

    if (semaphore !== undefined) semaphore.acquireOne();
    return semaphore;
  } // Configures all mutable aspects of an object, in particular:
  // symbols, properties, prototype.
  // For every created object that corresponds to a value,
  // this function should be invoked once.
  // Thus, as a side effect, we gather statistics here on all emitted objects.


  _emitObjectProperties(obj, properties = obj.properties, objectPrototypeAlreadyEstablished = false, cleanupDummyProperties, skipPrototype = false) {
    //inject symbols
    for (let [symbol, propertyBinding] of obj.symbols) {
      (0, _invariant.default)(propertyBinding);
      let desc = propertyBinding.descriptor;
      if (desc === undefined) continue; //deleted

      let semaphore = this._acquireOneObjectSemaphore(obj);

      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat([symbol, obj]), () => {
        (0, _invariant.default)(desc !== undefined);

        this._emitProperty(obj, symbol, desc);

        if (semaphore !== undefined) semaphore.releaseOne();
      }, this.emitter.getBody());
    } // TODO #2259: Make deduplication in the face of leaking work for custom accessors


    let isCertainlyLeaked = !obj.mightNotBeLeakedObject();

    let shouldDropAsAssignedProp = descriptor => isCertainlyLeaked && descriptor instanceof _descriptors.PropertyDescriptor && descriptor.get === undefined && descriptor.set === undefined; // inject properties


    for (let [key, propertyBinding] of properties) {
      (0, _invariant.default)(propertyBinding);
      if (propertyBinding.pathNode !== undefined) continue; // Property is assigned to inside loop

      let desc = propertyBinding.descriptor;
      if (shouldDropAsAssignedProp(desc)) continue;
      if (desc === undefined) continue; //deleted

      if (this.residualHeapInspector.canIgnoreProperty(obj, key)) continue;
      (0, _invariant.default)(desc !== undefined);

      let semaphore = this._acquireOneObjectSemaphore(obj);

      let body = this.emitter.getBody();
      this.emitter.emitNowOrAfterWaitingForDependencies(this._getDescriptorValues(desc).concat(obj), () => {
        (0, _invariant.default)(desc !== undefined);

        this._emitProperty(obj, key, desc, cleanupDummyProperties != null && cleanupDummyProperties.has(key));

        if (semaphore !== undefined) semaphore.releaseOne();
      }, body);
    } // inject properties with computed names


    if (obj.unknownProperty !== undefined) {
      let desc = obj.unknownProperty.descriptor;

      if (desc !== undefined) {
        let semaphore = this._acquireOneObjectSemaphore(obj);

        this.emitter.emitNowOrAfterWaitingForDependencies(this._getNestedValuesFromAbstractDescriptor(desc, [obj]), () => {
          this._emitPropertiesWithComputedNamesDescriptor(obj, desc);

          if (semaphore !== undefined) semaphore.releaseOne();
        }, this.emitter.getBody());
      }
    } // prototype


    if (!skipPrototype) {
      this._emitObjectPrototype(obj, objectPrototypeAlreadyEstablished);

      if (obj instanceof _index2.FunctionValue) this._emitConstructorPrototype(obj);
    }

    this.getStatistics().objects++;
    this.getStatistics().objectProperties += obj.properties.size;
  }

  _emitObjectPrototype(obj, objectPrototypeAlreadyEstablished) {
    let kind = obj.getKind();
    let proto = obj.$Prototype;

    if (objectPrototypeAlreadyEstablished) {
      if (this.realm.invariantLevel >= 3) {
        this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {
          (0, _invariant.default)(proto);
          let serializedProto = this.serializeValue(proto);
          let uid = this.getSerializeObjectIdentifier(obj);
          const fetchedPrototype = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) || this.realm.isCompatibleWith("mobile") ? t.memberExpression(uid, _babelhelpers.protoExpression) : t.callExpression(this.preludeGenerator.memoizeReference("Object.getPrototypeOf"), [uid]);
          let condition = t.binaryExpression("!==", fetchedPrototype, serializedProto);
          let consequent = this.residualOperationSerializer.getErrorStatement(t.stringLiteral("unexpected prototype"));
          this.emitter.emit(t.ifStatement(condition, consequent));
        }, this.emitter.getBody());
      }

      return;
    }

    if (proto === this.realm.intrinsics[kind + "Prototype"]) return;

    let semaphore = this._acquireOneObjectSemaphore(obj);

    this.emitter.emitNowOrAfterWaitingForDependencies([proto, obj], () => {
      (0, _invariant.default)(proto);
      let serializedProto = this.serializeValue(proto);
      let uid = this.getSerializeObjectIdentifier(obj);
      if (!this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) && !this.realm.isCompatibleWith("mobile")) this.emitter.emit(t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference("Object.setPrototypeOf"), [uid, serializedProto])));else {
        this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(uid, _babelhelpers.protoExpression), serializedProto)));
      }
      if (semaphore !== undefined) semaphore.releaseOne();
    }, this.emitter.getBody());
  }

  _emitConstructorPrototype(func) {
    // If the original prototype object was mutated,
    // request its serialization here as this might be observable by
    // residual code.
    let prototype = _HeapInspector.HeapInspector.getPropertyValue(func, "prototype");

    if (prototype instanceof _index2.ObjectValue && this.residualValues.has(prototype)) {
      this.emitter.emitNowOrAfterWaitingForDependencies([prototype], () => {
        (0, _invariant.default)(prototype instanceof _index2.Value);
        this.serializeValue(prototype);
      }, this.emitter.getBody());
    }
  }

  _getNestedValuesFromAbstractDescriptor(desc, values) {
    if (desc === undefined) return values;

    if (desc instanceof _descriptors.PropertyDescriptor) {
      let val = desc.value;
      (0, _invariant.default)(val instanceof _index2.AbstractValue);
      return this._getNestedValuesFromAbstract(val, values);
    } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
      values.push(desc.joinCondition);

      this._getNestedValuesFromAbstractDescriptor(desc.descriptor1, values);

      this._getNestedValuesFromAbstractDescriptor(desc.descriptor2, values);

      return values;
    } else {
      (0, _invariant.default)(false, "unknown descriptor");
    }
  }

  _getNestedValuesFromAbstract(absVal, values) {
    if (absVal.kind === "widened property") return values;
    if (absVal.kind === "template for prototype member expression") return values;
    (0, _invariant.default)(absVal.args.length === 3);
    let cond = absVal.args[0];
    (0, _invariant.default)(cond instanceof _index2.AbstractValue);

    if (cond.kind === "template for property name condition") {
      let P = cond.args[0];
      values.push(P);
      let V = absVal.args[1];
      values.push(V);
      let W = absVal.args[2];
      if (W instanceof _index2.AbstractValue) this._getNestedValuesFromAbstract(W, values);else values.push(W);
    } else {
      // conditional assignment
      values.push(cond);
      let consequent = absVal.args[1];

      if (consequent instanceof _index2.AbstractValue) {
        this._getNestedValuesFromAbstract(consequent, values);
      } else {
        values.push(consequent);
      }

      let alternate = absVal.args[2];

      if (alternate instanceof _index2.AbstractValue) {
        this._getNestedValuesFromAbstract(alternate, values);
      } else {
        values.push(alternate);
      }
    }

    return values;
  }

  _emitPropertiesWithComputedNamesDescriptor(obj, desc) {
    if (desc === undefined) return;

    if (desc instanceof _descriptors.PropertyDescriptor) {
      let val = desc.value;
      (0, _invariant.default)(val instanceof _index2.AbstractValue);

      this._emitPropertiesWithComputedNames(obj, val);
    } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
      let serializedCond = this.serializeValue(desc.joinCondition);
      let valuesToProcess = new Set();
      let consequentStatement;
      let alternateStatement;

      if (desc.descriptor1) {
        let oldBody = this.emitter.beginEmitting("consequent", {
          type: "ConditionalAssignmentBranch",
          parentBody: undefined,
          entries: [],
          done: false
        },
        /*isChild*/
        true);

        this._emitPropertiesWithComputedNamesDescriptor(obj, desc.descriptor1);

        let consequentBody = this.emitter.endEmitting("consequent", oldBody, valuesToProcess,
        /*isChild*/
        true);
        consequentStatement = t.blockStatement(consequentBody.entries);
      }

      if (desc.descriptor2) {
        let oldBody = this.emitter.beginEmitting("alternate", {
          type: "ConditionalAssignmentBranch",
          parentBody: undefined,
          entries: [],
          done: false
        },
        /*isChild*/
        true);

        this._emitPropertiesWithComputedNamesDescriptor(obj, desc.descriptor2);

        let alternateBody = this.emitter.endEmitting("alternate", oldBody, valuesToProcess,
        /*isChild*/
        true);
        alternateStatement = t.blockStatement(alternateBody.entries);
      }

      if (consequentStatement) {
        this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));
      } else if (alternateStatement) {
        this.emitter.emit(t.ifStatement(t.unaryExpression("!", serializedCond), alternateStatement));
      }

      this.emitter.processValues(valuesToProcess);
    } else {
      (0, _invariant.default)(false, "unknown descriptor");
    }
  }

  _emitPropertiesWithComputedNames(obj, absVal) {
    if (absVal.kind === "widened property") return;
    if (absVal.kind === "template for prototype member expression") return;
    (0, _invariant.default)(absVal.args.length === 3);
    let cond = absVal.args[0];
    (0, _invariant.default)(cond instanceof _index2.AbstractValue);

    if (cond.kind === "template for property name condition") {
      let P = cond.args[0];
      (0, _invariant.default)(P instanceof _index2.AbstractValue);
      let V = absVal.args[1];
      let earlier_props = absVal.args[2];
      if (earlier_props instanceof _index2.AbstractValue) this._emitPropertiesWithComputedNames(obj, earlier_props);
      let uid = this.getSerializeObjectIdentifier(obj);
      let serializedP = this.serializeValue(P);
      let serializedV = this.serializeValue(V);
      this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(uid, serializedP, true), serializedV)));
    } else {
      // conditional assignment
      let serializedCond = this.serializeValue(cond);
      let consequent = absVal.args[1];
      let valuesToProcess = new Set();
      let consequentStatement;
      let alternateStatement;

      if (consequent instanceof _index2.AbstractValue) {
        let oldBody = this.emitter.beginEmitting("consequent", {
          type: "ConditionalAssignmentBranch",
          parentBody: undefined,
          entries: [],
          done: false
        },
        /*isChild*/
        true);

        this._emitPropertiesWithComputedNames(obj, consequent);

        let consequentBody = this.emitter.endEmitting("consequent", oldBody, valuesToProcess,
        /*isChild*/
        true);
        consequentStatement = t.blockStatement(consequentBody.entries);
      }

      let alternate = absVal.args[2];

      if (alternate instanceof _index2.AbstractValue) {
        let oldBody = this.emitter.beginEmitting("alternate", {
          type: "ConditionalAssignmentBranch",
          parentBody: undefined,
          entries: [],
          done: false
        },
        /*isChild*/
        true);

        this._emitPropertiesWithComputedNames(obj, alternate);

        let alternateBody = this.emitter.endEmitting("alternate", oldBody, valuesToProcess,
        /*isChild*/
        true);
        alternateStatement = t.blockStatement(alternateBody.entries);
      }

      if (consequentStatement) {
        this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));
      } else if (alternateStatement) {
        this.emitter.emit(t.ifStatement(t.unaryExpression("!", serializedCond), alternateStatement));
      }

      this.emitter.processValues(valuesToProcess);
    }
  } // Overridable.


  getSerializeObjectIdentifier(val) {
    return this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val);
  }

  _emitProperty(val, key, desc, deleteIfMightHaveBeenDeleted = false) {
    // Location for the property to be assigned to
    let locationFunction = () => {
      let serializedKey = key instanceof _index2.SymbolValue || key instanceof _index2.AbstractValue ? this.serializeValue(key) : (0, _babelhelpers.getAsPropertyNameExpression)(key);
      let computed = key instanceof _index2.SymbolValue || key instanceof _index2.AbstractValue || !t.isIdentifier(serializedKey);
      return t.memberExpression(this.getSerializeObjectIdentifier(val), serializedKey, computed);
    };

    if (desc === undefined) {
      this._deleteProperty(locationFunction());
    } else {
      this.emitter.emit(this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc));
    }
  }

  emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc) {
    if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
      let cond = this.serializeValue(desc.joinCondition);
      (0, _invariant.default)(cond !== undefined);
      let trueBody;
      let falseBody;
      if (desc.descriptor1) trueBody = this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc.descriptor1);
      if (desc.descriptor2) falseBody = this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc.descriptor2);
      if (trueBody && falseBody) return t.ifStatement(cond, trueBody, falseBody);
      if (trueBody) return t.ifStatement(cond, trueBody);
      if (falseBody) return t.ifStatement(t.unaryExpression("!", cond), falseBody);
      (0, _invariant.default)(false);
    }

    (0, _invariant.default)(desc instanceof _descriptors.PropertyDescriptor);

    if (locationFunction !== undefined && this._canEmbedProperty(val, key, desc)) {
      let descValue = desc.value;
      (0, _invariant.default)(descValue instanceof _index2.Value);
      (0, _invariant.default)(!this.emitter.getReasonToWaitForDependencies([descValue, val]), "precondition of _emitProperty");
      let mightHaveBeenDeleted = descValue.mightHaveBeenDeleted(); // The only case we do not need to remove the dummy property is array index property.

      return this._getPropertyAssignmentStatement(locationFunction(), descValue, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted);
    }

    let body = [];
    let descProps = [];
    let boolKeys = ["enumerable", "configurable"];
    let valKeys = [];

    if (!desc.get && !desc.set) {
      boolKeys.push("writable");
      valKeys.push("value");
    } else {
      valKeys.push("set", "get");
    }

    let descriptorsKey = [];

    for (let boolKey of boolKeys) {
      if (desc[boolKey] !== undefined) {
        let b = desc[boolKey];
        (0, _invariant.default)(b !== undefined);
        descProps.push(t.objectProperty(t.identifier(boolKey), t.booleanLiteral(b)));
        descriptorsKey.push(`${boolKey}:${b.toString()}`);
      }
    }

    descriptorsKey = descriptorsKey.join(",");

    let descriptorId = this._descriptors.get(descriptorsKey);

    if (descriptorId === undefined) {
      descriptorId = t.identifier(this.descriptorNameGenerator.generate(descriptorsKey));
      let declar = t.variableDeclaration("var", [t.variableDeclarator(descriptorId, t.objectExpression(descProps))]); // The descriptors are used across all scopes, and thus must be declared in the prelude.

      this.prelude.push(declar);

      this._descriptors.set(descriptorsKey, descriptorId);
    }

    (0, _invariant.default)(descriptorId !== undefined);

    for (let descKey of valKeys) {
      if (desc[descKey] !== undefined) {
        let descValue = desc[descKey];
        (0, _invariant.default)(descValue instanceof _index2.Value);

        if (descValue instanceof _index2.UndefinedValue) {
          this.serializeValue(descValue);
          continue;
        }

        (0, _invariant.default)(!this.emitter.getReasonToWaitForDependencies([descValue]), "precondition of _emitProperty");
        body.push(t.assignmentExpression("=", t.memberExpression(descriptorId, t.identifier(descKey)), this.serializeValue(descValue)));
      }
    }

    let serializedKey = key instanceof _index2.SymbolValue || key instanceof _index2.AbstractValue ? this.serializeValue(key) : (0, _babelhelpers.getAsPropertyNameExpression)(key,
    /*canBeIdentifier*/
    false);
    (0, _invariant.default)(!this.emitter.getReasonToWaitForDependencies([val]), "precondition of _emitProperty");
    body.push(t.callExpression(this.preludeGenerator.memoizeReference("Object.defineProperty"), [this.getSerializeObjectIdentifier(val), serializedKey, descriptorId]));
    return t.expressionStatement(t.sequenceExpression(body));
  }

  _serializeDeclarativeEnvironmentRecordBinding(residualFunctionBinding) {
    if (!residualFunctionBinding.serializedValue) {
      let value = residualFunctionBinding.value;
      (0, _invariant.default)(residualFunctionBinding.declarativeEnvironmentRecord);

      if (residualFunctionBinding.hasLeaked) {
        this.referentializer.referentializeLeakedBinding(residualFunctionBinding);
      } else {
        residualFunctionBinding.serializedValue = value !== undefined ? this.serializeValue(value) : _babelhelpers.voidExpression;

        if (residualFunctionBinding.modified) {
          this.referentializer.referentializeModifiedBinding(residualFunctionBinding);
        }
      }

      if (value !== undefined && value.mightBeObject()) {
        // Increment ref count one more time to ensure that this object will be assigned a unique id.
        // This ensures that only once instance is created across all possible residual function invocations.
        this.residualHeapValueIdentifiers.incrementReferenceCount(value);
      }
    }
  } // Augments an initial set of generators with all generators from
  // which any of a given set of function values is referenced.


  _getReferencingGenerators(initialGenerators, functionValues, referencingOnlyOptimizedFunction) {
    let result = new Set(initialGenerators);
    let activeFunctions = functionValues.slice();
    let visitedFunctions = new Set();

    while (activeFunctions.length > 0) {
      let f = activeFunctions.pop();
      if (visitedFunctions.has(f)) continue;
      visitedFunctions.add(f);

      if (f === referencingOnlyOptimizedFunction) {
        let g = this.additionalFunctionGenerators.get(f);
        (0, _invariant.default)(g !== undefined);
        result.add(g);
      } else {
        let scopes = this.residualValues.get(f);
        (0, _invariant.default)(scopes);

        for (let scope of scopes) if (scope instanceof _index2.FunctionValue) {
          activeFunctions.push(scope);
        } else {
          (0, _invariant.default)(scope instanceof _generator.Generator);
          result.add(scope);
        }
      }
    }

    return Array.from(result);
  }

  _getActiveBodyOfGenerator(generator) {
    return generator === this.generator ? this.mainBody : this.activeGeneratorBodies.get(generator);
  } // Determine whether initialization code for a value should go into the main body, or a more specific initialization body.


  _getTarget(val, trace) {
    let scopes = this.residualValues.get(val);
    (0, _invariant.default)(scopes !== undefined, "value must have been visited"); // All relevant values were visited in at least one scope.

    (0, _invariant.default)(scopes.size >= 1);
    if (trace) this._logScopes(scopes); // If a value is used in more than one scope, prevent inlining as it might be an additional root with a particular creation scope

    if (scopes.size > 1) this.residualHeapValueIdentifiers.incrementReferenceCount(val); // First, let's figure out from which function and generator scopes this value is referenced.

    let functionValues = [];
    let generators = [];

    for (let scope of scopes) {
      if (scope instanceof _index2.FunctionValue) {
        functionValues.push(scope);
      } else {
        (0, _invariant.default)(scope instanceof _generator.Generator, "scope must be either function value or generator");
        generators.push(scope);
      }
    }

    let optimizedFunctionRoot = this._residualOptimizedFunctions.tryGetOptimizedFunctionRoot(val);

    if (generators.length === 0) {
      // This value is only referenced from residual functions.
      if (this._options.delayInitializations && (optimizedFunctionRoot === undefined || !functionValues.includes(optimizedFunctionRoot))) {
        // We can delay the initialization, and move it into a conditional code block in the residual functions!
        let body = this.residualFunctions.residualFunctionInitializers.registerValueOnlyReferencedByResidualFunctions(functionValues, val);
        return {
          body,
          usedOnlyByResidualFunctions: true,
          optimizedFunctionRoot,
          description: "delay_initializer"
        };
      }
    }

    if (trace) console.log(`  has optimized function root? ${optimizedFunctionRoot !== undefined ? "yes" : "no"}`); // flatten all function values into the scopes that use them

    generators = this._getReferencingGenerators(generators, functionValues, optimizedFunctionRoot);

    if (optimizedFunctionRoot === undefined) {
      // Remove all generators rooted in optimized functions,
      // since we know that there's at least one root that's not in an optimized function
      // which requires the value to be emitted outside of the optimized function.
      generators = generators.filter(generator => {
        let s = generator;

        while (s instanceof _generator.Generator) {
          s = this.generatorTree.getParent(s);
        }

        return s === "GLOBAL";
      });

      if (generators.length === 0) {
        // This means that the value was referenced by multiple optimized functions (but not by global code itself),
        // and thus it must have existed at the end of global code execution.
        // TODO: Emit to the end, not somewhere in the middle of the mainBody.
        if (trace) console.log(`  no filtered generators`); // TODO #2426: Revisit for nested optimized functions

        return {
          body: this.mainBody
        };
      }
    }

    const getGeneratorParent = g => {
      let s = this.generatorTree.getParent(g);
      return s instanceof _generator.Generator ? s : undefined;
    }; // This value is referenced from more than one generator.
    // Let's find the body associated with their common ancestor.


    let commonAncestor = Array.from(generators).reduce((x, y) => (0, _utils.commonAncestorOf)(x, y, getGeneratorParent), generators[0]); // In the case where we have no common ancestor but we have an optimized function reference,
    // we can attempt to use the generator of the single optimized function

    if (commonAncestor === undefined && optimizedFunctionRoot !== undefined) {
      commonAncestor = this.additionalFunctionGenerators.get(optimizedFunctionRoot);
    }

    (0, _invariant.default)(commonAncestor !== undefined, "there must always be a common generator ancestor");
    if (trace) console.log(`  common ancestor: ${commonAncestor.getName()}`);
    let body;

    while (true) {
      body = this._getActiveBodyOfGenerator(commonAncestor);
      if (body !== undefined) break;
      commonAncestor = getGeneratorParent(commonAncestor);
      (0, _invariant.default)(commonAncestor !== undefined, "there must always be an active body for the common generator ancestor");
    } // So we have a (common ancestor) body now.


    (0, _invariant.default)(body !== undefined, "there must always be an active body"); // However, there's a potential problem: That body might belong to a generator
    // which has nested generators that are currently being processed (they are not "done" yet).
    // This becomes a problem when the value for which we are trying to determine the target body
    // depends on other values which are only declared in such not-yet-done nested generator!
    // So we find all such not-yet-done bodies here, and pick a most nested one
    // which is related to one of the scopes this value is used by.

    let notYetDoneBodies = new Set();
    this.emitter.dependenciesVisitor(val, {
      onIntrinsicDerivedObject: dependency => {
        if (trace) {
          console.log(`  depending on intrinsic derived object and an identifier ${dependency.intrinsicName || "?"}`);
        }

        (0, _invariant.default)(optimizedFunctionRoot === undefined || !!this.emitter.getActiveOptimizedFunction(), "optimized function inconsistency");
        let declarationBody = this.emitter.getDeclarationBody(dependency);

        if (declarationBody !== undefined) {
          if (trace) console.log(`    has declaration body`);

          for (let b = declarationBody; b !== undefined; b = b.parentBody) {
            if (notYetDoneBodies.has(b)) break;
            notYetDoneBodies.add(b);
          }
        }
      },
      onAbstractValueWithIdentifier: dependency => {
        if (trace) console.log(`  depending on abstract value with identifier ${dependency.intrinsicName || "?"}`);
        (0, _invariant.default)(optimizedFunctionRoot === undefined || !!this.emitter.getActiveOptimizedFunction(), "optimized function inconsistency");
        let declarationBody = this.emitter.getDeclarationBody(dependency);

        if (declarationBody !== undefined) {
          if (trace) console.log(`    has declaration body`);

          for (let b = declarationBody; b !== undefined; b = b.parentBody) {
            if (notYetDoneBodies.has(b)) break;
            notYetDoneBodies.add(b);
          }
        }
      }
    });
    if (trace) console.log(`  got ${notYetDoneBodies.size} not yet done bodies`);

    for (let s of generators) for (let g = s; g !== undefined; g = getGeneratorParent(g)) {
      let scopeBody = this._getActiveBodyOfGenerator(g);

      if (scopeBody !== undefined && (scopeBody.nestingLevel || 0) > (body.nestingLevel || 0) && notYetDoneBodies.has(scopeBody)) {
        // TODO: If there are multiple such scopeBody's, why is it okay to pick an arbitrary one?
        body = scopeBody;
        break;
      }
    }

    return {
      body,
      commonAncestor
    };
  }

  _getValueDebugName(val) {
    let name;

    if (val instanceof _index2.FunctionValue) {
      name = val.getName();
    } else {
      const id = this.residualHeapValueIdentifiers.getIdentifier(val);
      (0, _invariant.default)(id);
      name = id.name;
    }

    return name;
  }

  _getResidualFunctionBinding(binding) {
    let environment = binding.environment;
    if (environment === this.globalEnvironmentRecord.$DeclarativeRecord) environment = this.globalEnvironmentRecord;

    if (environment === this.globalEnvironmentRecord) {
      return this.globalBindings.get(binding.name);
    }

    (0, _invariant.default)(environment instanceof _environment.DeclarativeEnvironmentRecord, "only declarative environments have bindings");
    let residualFunctionBindings = this.declarativeEnvironmentRecordsBindings.get(environment);
    if (residualFunctionBindings === undefined) return undefined;
    return residualFunctionBindings.get(binding.name);
  }

  serializeBinding(binding) {
    let residualBinding = this._getResidualFunctionBinding(binding);

    (0, _invariant.default)(residualBinding !== undefined, "any referenced residual binding should have been visited");

    this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);

    let location = residualBinding.serializedUnscopedLocation;
    (0, _invariant.default)(location !== undefined);
    return location;
  }

  getPrelude(optimizedFunction) {
    if (optimizedFunction !== undefined) {
      let body = this.residualFunctions.additionalFunctionPreludes.get(optimizedFunction);
      (0, _invariant.default)(body !== undefined);
      return body;
    } else {
      return this.prelude;
    }
  }

  _declare(emittingToResidualFunction, optimizedFunctionRoot, bindingType, id, init) {
    if (emittingToResidualFunction) {
      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id)]);
      this.getPrelude(optimizedFunctionRoot).push(declar);
      let assignment = t.expressionStatement(t.assignmentExpression("=", id, init));
      this.emitter.emit(assignment);
    } else {
      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id, init)]);
      this.emitter.emit(declar);
    }
  }

  serializeValue(val, referenceOnly, bindingType) {
    (0, _invariant.default)(!(val instanceof _index2.ObjectValue && val.refuseSerialization));

    if (val instanceof _index2.AbstractValue) {
      if (val.kind === "widened") {
        this.serializedValues.add(val);
        let name = val.intrinsicName;
        (0, _invariant.default)(name !== undefined);
        return t.identifier(name);
      } else if (val.kind === "widened property") {
        this.serializedValues.add(val);
        return this._serializeAbstractValueHelper(val);
      }
    } // make sure we're not serializing a class method here


    if (val instanceof _index2.ECMAScriptSourceFunctionValue && this.residualClassMethodInstances.has(val)) {
      let classMethodInstance = this.residualClassMethodInstances.get(val);
      (0, _invariant.default)(classMethodInstance); // anything other than a class constructor should never go through serializeValue()
      // so we need to log a nice error message to the user

      if (classMethodInstance.methodType !== "constructor") {
        let error = new _errors.CompilerDiagnostic("a class method incorrectly went through the serializeValue() code path", val.$ECMAScriptCode.loc, "PP0022", "FatalError");
        this.realm.handleError(error);
        throw new _errors.FatalError();
      }
    }

    if (this._serializedValueWithIdentifiers.has(val)) {
      return this.getSerializeObjectIdentifier(val);
    }

    this.serializedValues.add(val);

    if (!referenceOnly && _HeapInspector.HeapInspector.isLeaf(val)) {
      let res = this._serializeValue(val);

      (0, _invariant.default)(res !== undefined);
      return res;
    }

    this._serializedValueWithIdentifiers.add(val);

    let target = this._getTarget(val);

    let oldBody = this.emitter.beginEmitting(val, target.body);

    let init = this._serializeValue(val);

    let id = this.residualHeapValueIdentifiers.getIdentifier(val);

    if (this._options.debugIdentifiers !== undefined && this._options.debugIdentifiers.includes(id.name)) {
      console.log(`Tracing value with identifier ${id.name} (${val.constructor.name}) targetting ${target.body.type}`);

      this._getTarget(val, true);
    }

    let result = id;
    this.residualHeapValueIdentifiers.incrementReferenceCount(val);

    if (this.residualHeapValueIdentifiers.needsIdentifier(val)) {
      if (init) {
        if (this._options.debugScopes) {
          let scopes = this.residualValues.get(val);
          (0, _invariant.default)(scopes !== undefined);
          const scopeList = Array.from(scopes).map(s => `"${s.getName()}"`).join(",");
          let comment = `${this._getValueDebugName(val)} referenced from scopes [${scopeList}]`;
          if (target.commonAncestor !== undefined) comment = `${comment} with common ancestor: ${target.commonAncestor.getName()}`;
          if (target.description !== undefined) comment = `${comment} => ${target.description} `;
          this.emitter.emit(commentStatement(comment));
        }

        if (init !== id) {
          this._declare(!!target.usedOnlyByResidualFunctions, target.optimizedFunctionRoot, bindingType || "var", id, init);
        }

        this.getStatistics().valueIds++;
        if (target.usedOnlyByResidualFunctions) this.getStatistics().delayedValues++;
      }
    } else {
      if (init) {
        this.residualHeapValueIdentifiers.deleteIdentifier(val);
        result = init;
        this.getStatistics().valuesInlined++;
      }
    }

    this.emitter.endEmitting(val, oldBody);
    return result;
  }

  _serializeValueIntrinsic(val) {
    let intrinsicName = val.intrinsicName;
    (0, _invariant.default)(intrinsicName);

    if (val instanceof _index2.ObjectValue && val.intrinsicNameGenerated) {
      // The intrinsic was generated at a particular point in time.
      return this.preludeGenerator.convertStringToMember(intrinsicName);
    } else {
      // The intrinsic conceptually exists ahead of time.
      (0, _invariant.default)(this.emitter.getBody().type === "MainGenerator" || this.emitter.getBody().type === "OptimizedFunction" || this.emitter.getBody().type === "DelayInitializations");
      return this.preludeGenerator.memoizeReference(intrinsicName);
    }
  }

  _getDescriptorValues(desc) {
    if (desc === undefined) {
      return [];
    } else if (desc instanceof _descriptors.PropertyDescriptor) {
      (0, _invariant.default)(desc.value === undefined || desc.value instanceof _index2.Value);
      if (desc.value !== undefined) return [desc.value];
      (0, _invariant.default)(desc.get !== undefined);
      (0, _invariant.default)(desc.set !== undefined);
      return [desc.get, desc.set];
    } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
      return [desc.joinCondition, ...this._getDescriptorValues(desc.descriptor1), ...this._getDescriptorValues(desc.descriptor2)];
    } else {
      (0, _invariant.default)(false, "unknown descriptor");
    }
  }

  _deleteProperty(location) {
    (0, _invariant.default)(location.type === "MemberExpression");
    this.emitter.emit(t.expressionStatement(t.unaryExpression("delete", location, true)));
  }

  _assignProperty(location, value, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted = false) {
    this.emitter.emit(this._getPropertyAssignmentStatement(location, value, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted));
  }

  _getPropertyAssignmentStatement(location, value, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted = false) {
    if (mightHaveBeenDeleted) {
      // We always need to serialize this value in order to keep the invariants happy.
      let serializedValue = this.serializeValue(value);
      let condition;

      if (value instanceof _index2.AbstractValue && value.kind === "conditional") {
        let [c, x, y] = value.args;

        if (x instanceof _index2.EmptyValue) {
          if (c instanceof _index2.AbstractValue && c.kind === "!") condition = this.serializeValue(c.args[0]);else condition = t.unaryExpression("!", this.serializeValue(c));
          serializedValue = this.serializeValue(y);
        } else if (y instanceof _index2.EmptyValue) {
          condition = this.serializeValue(c);
          serializedValue = this.serializeValue(x);
        }
      }

      if (condition === undefined) {
        condition = t.binaryExpression("!==", this.serializeValue(value), this._serializeEmptyValue());
      }

      let assignment = t.expressionStatement(t.assignmentExpression("=", location, serializedValue));
      let deletion = null;

      if (deleteIfMightHaveBeenDeleted) {
        (0, _invariant.default)(location.type === "MemberExpression");
        deletion = t.expressionStatement(t.unaryExpression("delete", location, true));
      }

      return t.ifStatement(condition, assignment, deletion);
    } else {
      return t.expressionStatement(t.assignmentExpression("=", location, this.serializeValue(value)));
    }
  }

  _serializeArrayIndexProperties(array, indexPropertyLength, remainingProperties) {
    let elems = [];

    for (let i = 0; i < indexPropertyLength; i++) {
      let key = i + "";
      let propertyBinding = remainingProperties.get(key);
      let elem = null; // "propertyBinding === undefined" means array has a hole in the middle.

      if (propertyBinding !== undefined) {
        let descriptor = propertyBinding.descriptor; // "descriptor === undefined" means this array item has been deleted.

        (0, _invariant.default)(descriptor === undefined || descriptor instanceof _descriptors.PropertyDescriptor);

        if (descriptor !== undefined && descriptor.value !== undefined && this._canEmbedProperty(array, key, descriptor)) {
          let elemVal = descriptor.value;
          (0, _invariant.default)(elemVal instanceof _index2.Value);
          let mightHaveBeenDeleted = elemVal.mightHaveBeenDeleted();
          let instantRenderMode = this.realm.instantRender.enabled;
          let delayReason;
          /* In Instant Render mode, deleted indices are initialized
          to the __empty built-in */

          if (instantRenderMode) {
            if (this.emitter.getReasonToWaitForDependencies(elemVal)) {
              this.realm.instantRenderBailout("InstantRender does not yet support cyclical arrays or objects", array.expressionLocation);
            }

            delayReason = undefined;
          } else {
            delayReason = this.emitter.getReasonToWaitForDependencies(elemVal) || this.emitter.getReasonToWaitForActiveValue(array, mightHaveBeenDeleted);
          }

          if (!delayReason) {
            elem = this.serializeValue(elemVal);
            remainingProperties.delete(key);
          }
        }
      }

      elems.push(elem);
    }

    return elems;
  }

  _serializeArrayLengthIfNeeded(val, numberOfIndexProperties, remainingProperties) {
    const realm = this.realm;
    let lenProperty;

    if (val.mightBeLeakedObject()) {
      lenProperty = this.realm.evaluateWithoutLeakLogic(() => (0, _index.Get)(realm, val, "length"));
    } else {
      lenProperty = (0, _index.Get)(realm, val, "length");
    } // Need to serialize length property if:
    // 1. array length is abstract.
    // 2. array length is concrete, but different from number of index properties
    //  we put into initialization list.


    if (lenProperty instanceof _index2.AbstractValue || _singletons.To.ToLength(realm, lenProperty) !== numberOfIndexProperties) {
      if (!(lenProperty instanceof _index2.AbstractValue) || lenProperty.kind !== "widened property") {
        let semaphore = this._acquireOneObjectSemaphore(val);

        this.emitter.emitNowOrAfterWaitingForDependencies([val, lenProperty], () => {
          this._assignProperty(t.memberExpression(this.getSerializeObjectIdentifier(val), t.identifier("length")), lenProperty, false
          /*mightHaveBeenDeleted*/
          );

          if (semaphore !== undefined) semaphore.releaseOne();
        }, this.emitter.getBody());
      }

      remainingProperties.delete("length");
    }
  }

  _serializeValueArray(val) {
    let remainingProperties = new Map(val.properties);
    let [unconditionalLength, assignmentNotNeeded] = (0, _utils.getSuggestedArrayLiteralLength)(this.realm, val); // Use the unconditional serialized index properties as array initialization list.

    const initProperties = this._serializeArrayIndexProperties(val, unconditionalLength, remainingProperties);

    if (!assignmentNotNeeded) this._serializeArrayLengthIfNeeded(val, unconditionalLength, remainingProperties);

    this._emitObjectProperties(val, remainingProperties);

    return t.arrayExpression(initProperties);
  }

  _serializeValueMap(val) {
    let kind = val.getKind();
    let elems = [];
    let entries;
    let omitDeadEntries;

    if (kind === "Map") {
      entries = val.$MapData;
      omitDeadEntries = false;
    } else {
      (0, _invariant.default)(kind === "WeakMap");
      entries = val.$WeakMapData;
      omitDeadEntries = true;
    }

    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;
    let mapConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);

    for (let i = 0; i < len; i++) {
      let entry = entries[i];
      let key = entry.$Key;
      let value = entry.$Value;
      if (key === undefined || value === undefined || omitDeadEntries && !this.residualValues.has(key)) continue;
      let mightHaveBeenDeleted = key.mightHaveBeenDeleted();
      let delayReason = this.emitter.getReasonToWaitForDependencies(key) || this.emitter.getReasonToWaitForDependencies(value) || this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || mapConstructorDoesntTakeArguments);

      if (delayReason) {
        this.emitter.emitAfterWaiting(delayReason, [key, value, val], () => {
          (0, _invariant.default)(key !== undefined);
          (0, _invariant.default)(value !== undefined);
          this.emitter.emit(t.expressionStatement(t.callExpression(t.memberExpression(this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val), t.identifier("set")), [this.serializeValue(key), this.serializeValue(value)])));
        }, this.emitter.getBody());
      } else {
        let serializedKey = this.serializeValue(key);
        let serializedValue = this.serializeValue(value);
        let elem = t.arrayExpression([serializedKey, serializedValue]);
        elems.push(elem);
      }
    }

    this._emitObjectProperties(val);

    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];
    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);
  }

  _serializeValueSet(val) {
    let kind = val.getKind();
    let elems = [];
    let entries;
    let omitDeadEntries;

    if (kind === "Set") {
      entries = val.$SetData;
      omitDeadEntries = false;
    } else {
      (0, _invariant.default)(kind === "WeakSet");
      entries = val.$WeakSetData;
      omitDeadEntries = true;
    }

    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;
    let setConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);

    for (let i = 0; i < len; i++) {
      let entry = entries[i];
      if (entry === undefined || omitDeadEntries && !this.residualValues.has(entry)) continue;
      let mightHaveBeenDeleted = entry.mightHaveBeenDeleted();
      let delayReason = this.emitter.getReasonToWaitForDependencies(entry) || this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || setConstructorDoesntTakeArguments);

      if (delayReason) {
        this.emitter.emitAfterWaiting(delayReason, [entry, val], () => {
          (0, _invariant.default)(entry !== undefined);
          this.emitter.emit(t.expressionStatement(t.callExpression(t.memberExpression(this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val), t.identifier("add")), [this.serializeValue(entry)])));
        }, this.emitter.getBody());
      } else {
        let elem = this.serializeValue(entry);
        elems.push(elem);
      }
    }

    this._emitObjectProperties(val);

    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];
    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);
  }

  _serializeValueTypedArrayOrDataView(val) {
    let buf = val.$ViewedArrayBuffer;
    (0, _invariant.default)(buf !== undefined);
    let outlinedArrayBuffer = this.serializeValue(buf, true);

    this._emitObjectProperties(val);

    return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [outlinedArrayBuffer]);
  }

  _serializeValueArrayBuffer(val) {
    let elems = [];
    let len = val.$ArrayBufferByteLength;
    let db = val.$ArrayBufferData;
    (0, _invariant.default)(len !== undefined);
    (0, _invariant.default)(db);
    let allzero = true;

    for (let i = 0; i < len; i++) {
      if (db[i] !== 0) {
        allzero = false;
      }

      let elem = t.numericLiteral(db[i]);
      elems.push(elem);
    }

    this._emitObjectProperties(val);

    if (allzero) {
      // if they're all zero, just emit the array buffer constructor
      return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [t.numericLiteral(len)]);
    } else {
      // initialize from a byte array otherwise
      let arrayValue = t.arrayExpression(elems);
      let consExpr = t.newExpression(this.preludeGenerator.memoizeReference("Uint8Array"), [arrayValue]); // access the Uint8Array.buffer property to extract the created buffer

      return t.memberExpression(consExpr, t.identifier("buffer"));
    }
  }

  _serializeValueFunction(val) {
    if (val instanceof _index2.BoundFunctionValue) {
      this._emitObjectProperties(val);

      return t.callExpression(t.memberExpression(this.serializeValue(val.$BoundTargetFunction), t.identifier("bind")), [].concat(this.serializeValue(val.$BoundThis), val.$BoundArguments.map((boundArg, i) => this.serializeValue(boundArg))));
    }

    (0, _invariant.default)(!(val instanceof _index2.NativeFunctionValue), "all native function values should be intrinsics");
    (0, _invariant.default)(val instanceof _index2.ECMAScriptSourceFunctionValue);
    let instance = this.residualFunctionInstances.get(val);
    (0, _invariant.default)(instance !== undefined);
    let residualBindings = instance.residualFunctionBindings;

    let inOptimizedFunction = this._residualOptimizedFunctions.tryGetOptimizedFunctionRoot(val);

    if (inOptimizedFunction !== undefined) instance.containingAdditionalFunction = inOptimizedFunction;
    let bindingsEmittedSemaphore = new CountingSemaphore(() => {
      (0, _invariant.default)(instance); // hoist if we are in an additionalFunction

      if (inOptimizedFunction !== undefined && (0, _hoisting.canHoistFunction)(this.realm, val, undefined, new Set())) {
        instance.insertionPoint = new _types2.BodyReference(this.mainBody, this.mainBody.entries.length);
        instance.containingAdditionalFunction = undefined;
      } else {
        instance.insertionPoint = this.emitter.getBodyReference();
      }
    });

    for (let [boundName, residualBinding] of residualBindings) {
      let referencedValues = [];
      let serializeBindingFunc;

      if (!residualBinding.declarativeEnvironmentRecord) {
        serializeBindingFunc = () => this._serializeGlobalBinding(boundName, residualBinding);
      } else {
        serializeBindingFunc = () => this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);

        if (residualBinding.value !== undefined) referencedValues.push(residualBinding.value);
      }

      bindingsEmittedSemaphore.acquireOne();
      this.emitter.emitNowOrAfterWaitingForDependencies(referencedValues, () => {
        serializeBindingFunc();
        bindingsEmittedSemaphore.releaseOne();
      }, this.emitter.getBody());
    }

    if (val.$FunctionKind === "classConstructor") {
      let homeObject = val.$HomeObject;

      if (homeObject instanceof _index2.ObjectValue && homeObject.$IsClassPrototype) {
        this._serializeClass(val, homeObject, bindingsEmittedSemaphore);

        return;
      }
    }

    bindingsEmittedSemaphore.releaseOne();

    this._emitObjectProperties(val);

    let additionalEffects = this.additionalFunctionValuesAndEffects.get(val);
    if (additionalEffects) this._serializeAdditionalFunction(val, additionalEffects);
  }

  _serializeClass(classFunc, classPrototype, bindingsEmittedSemaphore) {
    let classMethodInstance = this.residualClassMethodInstances.get(classFunc);
    (0, _invariant.default)(classMethodInstance !== undefined);
    let classProtoId;
    let hasSerializedClassProtoId = false;
    let propertiesToSerialize = new Map(); // handle class inheritance

    if (!(classFunc.$Prototype instanceof _index2.NativeFunctionValue)) {
      classMethodInstance.classSuperNode = this.serializeValue(classFunc.$Prototype);
    }

    let serializeClassPrototypeId = () => {
      if (!hasSerializedClassProtoId) {
        let classId = this.getSerializeObjectIdentifier(classFunc);
        classProtoId = t.identifier(this.intrinsicNameGenerator.generate());
        hasSerializedClassProtoId = true;
        this.emitter.emit(t.variableDeclaration("var", [t.variableDeclarator(classProtoId, t.memberExpression(classId, t.identifier("prototype")))]));
      }
    };

    let serializeClassMethodOrProperty = (propertyNameOrSymbol, methodFuncOrProperty) => {
      const serializeNameAndId = () => {
        let methodFuncOrPropertyId = this.serializeValue(methodFuncOrProperty);
        let name;

        if (typeof propertyNameOrSymbol === "string") {
          name = t.identifier(propertyNameOrSymbol);
        } else {
          name = this.serializeValue(propertyNameOrSymbol);
        }

        return {
          name,
          methodFuncOrPropertyId
        };
      };

      if (methodFuncOrProperty instanceof _index2.ECMAScriptSourceFunctionValue) {
        if (methodFuncOrProperty !== classFunc) {
          // if the method does not have a $HomeObject, it's not a class method
          if (methodFuncOrProperty.$HomeObject !== undefined) {
            this.serializedValues.add(methodFuncOrProperty);

            this._serializeClassMethod(propertyNameOrSymbol, methodFuncOrProperty);
          } else {
            // if the method is not part of the class, we have to assign it to the prototype
            // we can't serialize via emitting the properties as that will emit all
            // the prototype and we only want to mutate the prototype here
            serializeClassPrototypeId();
            (0, _invariant.default)(classProtoId !== undefined);
            let {
              name,
              methodFuncOrPropertyId
            } = serializeNameAndId();
            this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(classProtoId, name), methodFuncOrPropertyId)));
          }
        }
      } else {
        let prototypeId = t.memberExpression(this.getSerializeObjectIdentifier(classFunc), t.identifier("prototype"));
        let {
          name,
          methodFuncOrPropertyId
        } = serializeNameAndId();
        this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.memberExpression(prototypeId, name), methodFuncOrPropertyId)));
      }
    };

    let serializeClassProperty = (propertyNameOrSymbol, propertyValue) => {
      // we handle the prototype via class syntax
      if (propertyNameOrSymbol === "prototype") {
        this.serializedValues.add(propertyValue);
      } else if (propertyValue instanceof _index2.ECMAScriptSourceFunctionValue && propertyValue.$HomeObject === classFunc) {
        serializeClassMethodOrProperty(propertyNameOrSymbol, propertyValue);
      } else {
        let prop = classFunc.properties.get(propertyNameOrSymbol);
        (0, _invariant.default)(prop);
        propertiesToSerialize.set(propertyNameOrSymbol, prop);
      }
    }; // find the all the properties on the class that we need to serialize


    for (let [propertyName, method] of classFunc.properties) {
      if (!this.residualHeapInspector.canIgnoreProperty(classFunc, propertyName) && !_utils.ClassPropertiesToIgnore.has(propertyName) && method.descriptor !== undefined && !(propertyName === "length" && (0, _utils.canIgnoreClassLengthProperty)(classFunc, method.descriptor, this.logger))) {
        (0, _utils.withDescriptorValue)(propertyName, method.descriptor, serializeClassProperty);
      }
    } // pass in the properties and set it so we don't serialize the prototype


    bindingsEmittedSemaphore.releaseOne();

    this._emitObjectProperties(classFunc, propertiesToSerialize, undefined, undefined, true); // handle non-symbol properties


    for (let [propertyName, method] of classPrototype.properties) {
      (0, _utils.withDescriptorValue)(propertyName, method.descriptor, serializeClassMethodOrProperty);
    } // handle symbol properties


    for (let [symbol, method] of classPrototype.symbols) {
      (0, _utils.withDescriptorValue)(symbol, method.descriptor, serializeClassMethodOrProperty);
    } // assign the AST method key node for the "constructor"


    classMethodInstance.classMethodKeyNode = t.identifier("constructor");
  }

  _serializeClassMethod(key, methodFunc) {
    let classMethodInstance = this.residualClassMethodInstances.get(methodFunc);
    (0, _invariant.default)(classMethodInstance !== undefined);

    if (typeof key === "string") {
      classMethodInstance.classMethodKeyNode = t.identifier(key); // as we know the method name is a string again, we can remove the computed status

      classMethodInstance.classMethodComputed = false;
    } else if (key instanceof _index2.SymbolValue) {
      classMethodInstance.classMethodKeyNode = this.serializeValue(key);
    } else {
      (0, _invariant.default)(false, "Unknown method key type");
    }

    this._serializeValueFunction(methodFunc);
  } // Checks whether a property can be defined via simple assignment, or using object literal syntax.


  _canEmbedProperty(obj, key, prop) {
    if (!(prop instanceof _descriptors.PropertyDescriptor)) return false;
    let targetDescriptor = this.residualHeapInspector.getTargetIntegrityDescriptor(obj);
    if (obj instanceof _index2.FunctionValue && key === "prototype" || obj.getKind() === "RegExp" && key === "lastIndex") return prop.writable === targetDescriptor.writable && !prop.configurable && !prop.enumerable && !prop.set && !prop.get;else if (prop.writable === targetDescriptor.writable && prop.configurable === targetDescriptor.configurable && !!prop.enumerable && !prop.set && !prop.get) {
      return !(prop.value instanceof _index2.AbstractValue && prop.value.kind === "widened property");
    } else {
      return false;
    }
  }

  _findLastObjectPrototype(obj) {
    while (obj.$Prototype instanceof _index2.ObjectValue) obj = obj.$Prototype;

    return obj;
  }

  _serializeValueRegExpObject(val) {
    let source = val.$OriginalSource;
    let flags = val.$OriginalFlags;
    (0, _invariant.default)(typeof source === "string");
    (0, _invariant.default)(typeof flags === "string");

    this._emitObjectProperties(val);

    source = new RegExp(source).source; // add escapes as per 21.2.3.2.4

    return t.regExpLiteral(source, flags);
  } // Overridable.


  serializeValueRawObject(val, skipPrototype, emitIntegrityCommand) {
    let remainingProperties = new Map(val.properties);
    const dummyProperties = new Set();
    let props = [];
    let isCertainlyLeaked = !val.mightNotBeLeakedObject(); // TODO #2259: Make deduplication in the face of leaking work for custom accessors

    let shouldDropAsAssignedProp = descriptor => isCertainlyLeaked && descriptor instanceof _descriptors.PropertyDescriptor && descriptor.get === undefined && descriptor.set === undefined;

    if (val.temporalAlias !== undefined) {
      return t.objectExpression(props);
    } else {
      for (let [key, propertyBinding] of val.properties) {
        if (propertyBinding.descriptor !== undefined && shouldDropAsAssignedProp(propertyBinding.descriptor)) {
          remainingProperties.delete(key);
          continue;
        }

        if (propertyBinding.pathNode !== undefined) continue; // written to inside loop

        let descriptor = propertyBinding.descriptor;
        if (descriptor === undefined || !(descriptor instanceof _descriptors.PropertyDescriptor) || descriptor.value === undefined) continue; // deleted

        let serializedKey = (0, _babelhelpers.getAsPropertyNameExpression)(key);

        if (this._canEmbedProperty(val, key, descriptor)) {
          let propValue = descriptor.value;
          (0, _invariant.default)(propValue instanceof _index2.Value);
          if (this.residualHeapInspector.canIgnoreProperty(val, key)) continue;
          let mightHaveBeenDeleted = propValue.mightHaveBeenDeleted();
          let instantRenderMode = this.realm.instantRender.enabled;
          let delayReason;

          if (instantRenderMode) {
            if (this.emitter.getReasonToWaitForDependencies(propValue)) {
              this.realm.instantRenderBailout("InstantRender does not yet support cyclical arrays or objects", val.expressionLocation);
            }

            delayReason = undefined;
          } else {
            delayReason = this.emitter.getReasonToWaitForDependencies(propValue) || this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted);
          } // Although the property needs to be delayed, we still want to emit dummy "undefined"
          // value as part of the object literal to ensure a consistent property ordering.


          let serializedValue = !instantRenderMode ? _babelhelpers.voidExpression : _babelhelpers.emptyExpression;

          if (delayReason) {
            // May need to be cleaned up later.
            dummyProperties.add(key);
          } else {
            remainingProperties.delete(key);
            serializedValue = this.serializeValue(propValue);
          }

          props.push(t.objectProperty(serializedKey, serializedValue));
        } else if (descriptor.value instanceof _index2.Value && descriptor.value.mightHaveBeenDeleted()) {
          dummyProperties.add(key);
          props.push(t.objectProperty(serializedKey, _babelhelpers.voidExpression));
        }
      }
    }

    this._emitObjectProperties(val, remainingProperties,
    /*objectPrototypeAlreadyEstablished*/
    false, dummyProperties, skipPrototype);

    return t.objectExpression(props);
  }

  _serializeValueObjectViaConstructor(val, skipPrototype, classConstructor) {
    let proto = val.$Prototype;

    this._emitObjectProperties(val, val.properties,
    /*objectPrototypeAlreadyEstablished*/
    true, undefined, skipPrototype);

    let serializedProto = this.serializeValue(classConstructor ? classConstructor : proto);

    if (val.temporalAlias === undefined) {
      this.needsAuxiliaryConstructor = true;
      return t.sequenceExpression([t.assignmentExpression("=", t.memberExpression(_babelhelpers.constructorExpression, t.identifier("prototype")), classConstructor ? t.memberExpression(serializedProto, t.identifier("prototype")) : serializedProto), t.newExpression(_babelhelpers.constructorExpression, [])]);
    } else {
      this.emitter.emitAfterWaiting(val.temporalAlias, [], () => {
        (0, _invariant.default)(val.temporalAlias !== undefined);
        let uid = this.serializeValue(val.temporalAlias);
        this.emitter.emit(t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference("Object.setPrototypeOf"), [uid, serializedProto])));
      }, this.emitter.getBody());
      return t.objectExpression([]);
    }
  }

  serializeValueObject(val, emitIntegrityCommand) {
    // If this object is a prototype object that was implicitly created by the runtime
    // for a constructor, then we can obtain a reference to this object
    // in a special way that's handled alongside function serialization.
    let constructor = val.originalConstructor;

    if (constructor !== undefined) {
      let prototypeId = this.residualHeapValueIdentifiers.getIdentifier(val);
      this.emitter.emitNowOrAfterWaitingForDependencies([constructor], () => {
        (0, _invariant.default)(constructor !== undefined);
        (0, _invariant.default)(prototypeId !== undefined);
        this.serializeValue(constructor);

        this._emitObjectProperties(val);

        (0, _invariant.default)(prototypeId.type === "Identifier");
        this.residualFunctions.setFunctionPrototype(constructor, prototypeId);
      }, this.emitter.getBody());
      return prototypeId;
    }

    let kind = val.getKind();

    switch (kind) {
      case "RegExp":
        return this._serializeValueRegExpObject(val);

      case "Number":
        let numberData = val.$NumberData;
        (0, _invariant.default)(numberData !== undefined);
        numberData.throwIfNotConcreteNumber();
        (0, _invariant.default)(numberData instanceof _index2.NumberValue, "expected number data internal slot to be a number value");

        this._emitObjectProperties(val);

        return t.newExpression(this.preludeGenerator.memoizeReference("Number"), [t.numericLiteral(numberData.value)]);

      case "String":
        let stringData = val.$StringData;
        (0, _invariant.default)(stringData !== undefined);
        stringData.throwIfNotConcreteString();
        (0, _invariant.default)(stringData instanceof _index2.StringValue, "expected string data internal slot to be a string value");

        this._emitObjectProperties(val);

        return t.newExpression(this.preludeGenerator.memoizeReference("String"), [t.stringLiteral(stringData.value)]);

      case "Boolean":
        let booleanData = val.$BooleanData;
        (0, _invariant.default)(booleanData !== undefined);
        booleanData.throwIfNotConcreteBoolean();
        (0, _invariant.default)(booleanData instanceof _index2.BooleanValue, "expected boolean data internal slot to be a boolean value");

        this._emitObjectProperties(val);

        return t.newExpression(this.preludeGenerator.memoizeReference("Boolean"), [t.booleanLiteral(booleanData.value)]);

      case "Date":
        let dateValue = val.$DateValue;
        (0, _invariant.default)(dateValue !== undefined);
        let serializedDateValue = this.serializeValue(dateValue);

        this._emitObjectProperties(val);

        return t.newExpression(this.preludeGenerator.memoizeReference("Date"), [serializedDateValue]);

      case "Float32Array":
      case "Float64Array":
      case "Int8Array":
      case "Int16Array":
      case "Int32Array":
      case "Uint8Array":
      case "Uint16Array":
      case "Uint32Array":
      case "Uint8ClampedArray":
      case "DataView":
        return this._serializeValueTypedArrayOrDataView(val);

      case "ArrayBuffer":
        return this._serializeValueArrayBuffer(val);

      case "ReactElement":
        this.residualReactElementSerializer.serializeReactElement(val);
        return;

      case "Map":
      case "WeakMap":
        return this._serializeValueMap(val);

      case "Set":
      case "WeakSet":
        return this._serializeValueSet(val);

      default:
        (0, _invariant.default)(kind === "Object", "invariant established by visitor");
        let proto = val.$Prototype;
        let {
          skipPrototype,
          constructor: _constructor
        } = (0, _utils.getObjectPrototypeMetadata)(this.realm, val);
        let createViaAuxiliaryConstructor = val.temporalAlias === undefined && proto !== this.realm.intrinsics.ObjectPrototype && this._findLastObjectPrototype(val) === this.realm.intrinsics.ObjectPrototype && proto instanceof _index2.ObjectValue && !skipPrototype;
        return createViaAuxiliaryConstructor || _constructor ? this._serializeValueObjectViaConstructor(val, skipPrototype, _constructor) : this.serializeValueRawObject(val, skipPrototype, emitIntegrityCommand);
    }
  }

  _serializeValueSymbol(val) {
    let args = [];

    if (val.$Description instanceof _index2.Value) {
      let serializedArg = this.serializeValue(val.$Description);
      (0, _invariant.default)(serializedArg);
      args.push(serializedArg);
    } // check if symbol value exists in the global symbol map, in that case we emit an invocation of System.for
    // to look it up


    let globalReg = this.realm.globalSymbolRegistry.find(e => e.$Symbol === val) !== undefined;

    if (globalReg) {
      return t.callExpression(this.preludeGenerator.memoizeReference("Symbol.for"), args);
    } else {
      return t.callExpression(this.preludeGenerator.memoizeReference("Symbol"), args);
    }
  }

  _serializeValueProxy(val) {
    return t.newExpression(this.preludeGenerator.memoizeReference("Proxy"), [this.serializeValue(val.$ProxyTarget), this.serializeValue(val.$ProxyHandler)]);
  }

  _serializeAbstractValueHelper(val) {
    let serializedArgs = val.args.map((abstractArg, i) => this.serializeValue(abstractArg));

    if (val.kind === "abstractConcreteUnion") {
      (0, _invariant.default)(val.args.length >= 2);
      (0, _invariant.default)(val.args[0] instanceof _index2.AbstractValue);
      return serializedArgs[0];
    }

    if (val.kind === "explicit conversion to object") {
      let ob = serializedArgs[0];
      (0, _invariant.default)(ob !== undefined);
      return t.callExpression(this.preludeGenerator.memoizeReference("Object.assign"), [ob]);
    } else if (val.kind === "template for prototype member expression") {
      let obj = this.serializeValue(val.args[0]);
      let prop = this.serializeValue(val.args[1]);
      return t.memberExpression(obj, prop, true);
    }

    (0, _invariant.default)(val.operationDescriptor !== undefined);
    let serializedValue = this.residualOperationSerializer.serializeExpression(val.operationDescriptor, serializedArgs);

    if (serializedValue.type === "Identifier") {
      let id = serializedValue;
      (0, _invariant.default)(!this.realm.derivedIds.has(id.name) || this.emitter.cannotDeclare() || this.emitter.hasBeenDeclared(val) || !!this.emitter.getActiveOptimizedFunction(), `an abstract value with an identifier "${id.name}" was referenced before being declared`);
    }

    return serializedValue;
  }

  _serializeAbstractValue(val) {
    (0, _invariant.default)(val.kind !== "sentinel member expression", "invariant established by visitor");

    if (val.kind === "conditional") {
      let cf = this.conditionalFeasibility.get(val);
      (0, _invariant.default)(cf !== undefined);
      if (cf.t && !cf.f) return this.serializeValue(val.args[1]);else if (!cf.t && cf.f) return this.serializeValue(val.args[2]);else (0, _invariant.default)(cf.t && cf.f);
    }

    if (val.hasIdentifier()) {
      return this._serializeAbstractValueHelper(val);
    } else {
      // This abstract value's dependencies should all be declared
      // but still need to check them again in case their serialized bodies are in different generator scope.
      let reason = this.emitter.getReasonToWaitForDependencies(val.args);

      if (reason === undefined) {
        return this._serializeAbstractValueHelper(val);
      } else {
        this.emitter.emitAfterWaiting(reason, val.args, () => {
          const serializedValue = this._serializeAbstractValueHelper(val);

          let uid = this.getSerializeObjectIdentifier(val);

          this._declare(this.emitter.cannotDeclare(), undefined, "var", uid, serializedValue);
        }, this.emitter.getBody());
      }
    }
  }

  _serializeEmptyValue() {
    this.needsEmptyVar = !this.realm.instantRender.enabled;
    return _babelhelpers.emptyExpression;
  }

  _serializeValue(val) {
    if (val instanceof _index2.AbstractValue) {
      return this._serializeAbstractValue(val);
    } else if (val.isIntrinsic()) {
      return this._serializeValueIntrinsic(val);
    } else if (val instanceof _index2.EmptyValue) {
      return this._serializeEmptyValue();
    } else if (val instanceof _index2.UndefinedValue) {
      return _babelhelpers.voidExpression;
    } else if (_HeapInspector.HeapInspector.isLeaf(val)) {
      return t.valueToNode(val.serialize());
    } else if (val instanceof _index2.ObjectValue) {
      return this._serializeValueObjectBase(val);
    } else {
      (0, _invariant.default)(val instanceof _index2.SymbolValue);
      return this._serializeValueSymbol(val);
    }
  }

  _serializeValueObjectBase(obj) {
    if (obj instanceof _index2.ProxyValue) {
      return this._serializeValueProxy(obj);
    }

    let objectSemaphore;
    let targetCommand = this.residualHeapInspector.getTargetIntegrityCommand(obj);
    let emitIntegrityCommand;

    if (targetCommand) {
      let body = this.emitter.getBody();
      objectSemaphore = new CountingSemaphore(() => {
        this.emitter.emitNowOrAfterWaitingForDependencies([obj], () => {
          let uid = this.getSerializeObjectIdentifier(obj);
          this.emitter.emit(t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference("Object." + targetCommand), [uid])));
        }, body);
      });

      this._objectSemaphores.set(obj, objectSemaphore);

      emitIntegrityCommand = alternateBody => {
        if (objectSemaphore !== undefined) {
          if (alternateBody !== undefined) body = alternateBody;
          objectSemaphore.releaseOne();

          this._objectSemaphores.delete(obj);
        }

        objectSemaphore = undefined;
      };
    }

    let res;

    if ((0, _index.IsArray)(this.realm, obj)) {
      res = this._serializeValueArray(obj);
    } else if (obj instanceof _index2.FunctionValue) {
      res = this._serializeValueFunction(obj);
    } else {
      res = this.serializeValueObject(obj, emitIntegrityCommand);
    }

    if (emitIntegrityCommand !== undefined) emitIntegrityCommand();
    return res;
  }

  _serializeGlobalBinding(boundName, binding) {
    (0, _invariant.default)(!binding.declarativeEnvironmentRecord);

    if (!binding.serializedValue) {
      binding.referentialized = true;

      if (boundName === "undefined") {
        binding.serializedValue = _babelhelpers.voidExpression;
      } else if (binding.value !== undefined) {
        binding.serializedValue = t.identifier(boundName);
        (0, _invariant.default)(binding.value !== undefined);
        this.declaredGlobalLets.set(boundName, binding.value);
      }
    }
  }

  _annotateGeneratorStatements(generator, statements) {
    let comment = `generator "${generator.getName()}"`;
    let parent = this.generatorTree.getParent(generator);

    if (parent instanceof _generator.Generator) {
      comment = `${comment} with parent "${parent.getName()}"`;
    } else if (parent instanceof _index2.FunctionValue) {
      comment = `${comment} with function parent`;
    } else {
      (0, _invariant.default)(parent === "GLOBAL");
      comment = `${comment} with global parent`;
    }

    let beginComments = [commentStatement("begin " + comment)];
    let effects = generator.effectsToApply;

    if (effects) {
      let valueToString = value => this.residualHeapValueIdentifiers.hasIdentifier(value) ? this.residualHeapValueIdentifiers.getIdentifier(value).name : "?";

      let keyToString = key => typeof key === "string" ? key : key instanceof _index2.Value ? valueToString(key) : "?";

      beginComments.push(commentStatement(`  has effects: ${effects.createdObjects.size} created objects, ${effects.modifiedBindings.size} modified bindings, ${effects.modifiedProperties.size} modified properties`));
      if (effects.createdObjects.size > 0) beginComments.push(commentStatement(`    created objects: ${Array.from(effects.createdObjects).map(valueToString).join(", ")}`));
      if (effects.modifiedBindings.size > 0) beginComments.push(commentStatement(`    modified bindings: ${Array.from(effects.modifiedBindings.keys()).map(b => b.name).join(", ")}`));
      if (effects.modifiedProperties.size > 0) beginComments.push(commentStatement(`    modified properties: ${Array.from(effects.modifiedProperties.keys()).map(b => `${valueToString(b.object)}.${keyToString(b.key)}`).join(", ")}`));
    }

    statements.unshift(...beginComments);
    statements.push(commentStatement("end " + comment));
  }

  _withGeneratorScope(type, generator, valuesToProcess, callback, optimizedFunction) {
    let newBody = {
      type,
      parentBody: undefined,
      entries: [],
      done: false,
      optimizedFunction
    };
    let optimizedFunctionRoot = optimizedFunction === undefined ? undefined : this._residualOptimizedFunctions.tryGetOptimizedFunctionRoot(optimizedFunction);
    let isChild = !!optimizedFunctionRoot || type === "Generator";
    let oldBody = this.emitter.beginEmitting(generator, newBody,
    /*isChild*/
    isChild);
    (0, _invariant.default)(!this.activeGeneratorBodies.has(generator));
    this.activeGeneratorBodies.set(generator, newBody);
    callback(newBody);
    (0, _invariant.default)(this.activeGeneratorBodies.has(generator));
    this.activeGeneratorBodies.delete(generator);
    const statements = this.emitter.endEmitting(generator, oldBody, valuesToProcess,
    /*isChild*/
    isChild).entries;
    if (this._options.debugScopes) this._annotateGeneratorStatements(generator, statements);
    this.getStatistics().generators++;
    return statements;
  }

  _getContext() {
    let context = {
      serializeOperationDescriptor: this.residualOperationSerializer.serializeStatement.bind(this.residualOperationSerializer),
      serializeBinding: this.serializeBinding.bind(this),
      serializeBindingAssignment: (binding, bindingValue) => {
        let serializeBinding = this.serializeBinding(binding);
        let serializedValue = context.serializeValue(bindingValue);
        return t.expressionStatement(t.assignmentExpression("=", serializeBinding, serializedValue));
      },
      serializeCondition: (condition, consequentGenerator, alternateGenerator, valuesToProcess) => {
        let serializedCondition = this.serializeValue(condition);
        let consequentBody = context.serializeGenerator(consequentGenerator, valuesToProcess);
        let alternateBody = context.serializeGenerator(alternateGenerator, valuesToProcess);
        return t.ifStatement(serializedCondition, t.blockStatement(consequentBody), t.blockStatement(alternateBody));
      },

      serializeDebugScopeComment(declared) {
        let s = t.emptyStatement();
        s.leadingComments = [{
          type: "BlockComment",
          value: `declaring ${declared.intrinsicName || "?"}`
        }];
        return s;
      },

      serializeReturnValue: val => {
        return t.returnStatement(this.serializeValue(val));
      },
      serializeGenerator: (generator, valuesToProcess) => this._withGeneratorScope("Generator", generator, valuesToProcess, () => generator.serialize(context)),
      serializeValue: this.serializeValue.bind(this),
      initGenerator: generator => {
        let activeGeneratorBody = this._getActiveBodyOfGenerator(generator);

        (0, _invariant.default)(activeGeneratorBody === this.emitter.getBody(), "generator to init must be current emitter body");
        let s = this.additionalGeneratorRoots.get(generator);
        if (s !== undefined) for (let value of s) this.serializeValue(value);
      },
      finalizeGenerator: generator => {
        let activeGeneratorBody = this._getActiveBodyOfGenerator(generator);

        (0, _invariant.default)(activeGeneratorBody === this.emitter.getBody(), "generator to finalize must be current emitter body");
        this.emitter.finalizeCurrentBody();
      },
      emit: statement => {
        this.emitter.emit(statement);
      },
      processValues: valuesToProcess => {
        this.emitter.processValues(valuesToProcess);
      },
      getPropertyAssignmentStatement: this._getPropertyAssignmentStatement.bind(this),
      emitDefinePropertyBody: this.emitDefinePropertyBody.bind(this, false, undefined),
      canOmit: value => {
        let canOmit = !this.referencedDeclaredValues.has(value) && !this.residualValues.has(value);

        if (!canOmit) {
          return false;
        }

        if (value instanceof _index2.ObjectValue && value.temporalAlias !== undefined) {
          let temporalAlias = value.temporalAlias;
          return !this.referencedDeclaredValues.has(temporalAlias) && !this.residualValues.has(temporalAlias);
        }

        return canOmit;
      },
      declare: value => {
        this.emitter.declare(value);
      },
      emitBindingModification: binding => {
        let residualFunctionBinding = this._getResidualFunctionBinding(binding);

        if (residualFunctionBinding !== undefined) {
          (0, _invariant.default)(residualFunctionBinding.referentialized);
          (0, _invariant.default)(residualFunctionBinding.serializedValue, "ResidualFunctionBinding must be referentialized before serializing a mutation to it.");
          let newValue = binding.value;
          (0, _invariant.default)(newValue);
          let bindingReference = residualFunctionBinding.serializedValue;
          (0, _invariant.default)(t.isLVal(bindingReference), "Referentialized values must be LVals even though serializedValues may be any Expression");
          let serializedNewValue = this.serializeValue(newValue);
          this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", bindingReference, serializedNewValue)));
        }
      },
      emitPropertyModification: propertyBinding => {
        let desc = propertyBinding.descriptor;
        let object = propertyBinding.object;
        (0, _invariant.default)(object instanceof _index2.ObjectValue);

        if (this.residualValues.has(object)) {
          let key = propertyBinding.key;
          (0, _invariant.default)(key !== undefined, "established by visitor");
          let dependencies = [];
          if (desc !== undefined) dependencies.push(...this._getDescriptorValues(desc));
          dependencies.push(object);
          if (key instanceof _index2.Value) dependencies.push(key);
          this.emitter.emitNowOrAfterWaitingForDependencies(dependencies, () => {
            // separate serialize object, as _emitProperty assumes that this already happened
            this.serializeValue(object);

            this._emitProperty(object, key, desc, true);
          }, this.emitter.getBody());
        }
      },
      options: this._options
    };
    return context;
  }

  _shouldBeWrapped(body) {
    for (let i = 0; i < body.length; i++) {
      let item = body[i];

      if (item.type === "ExpressionStatement") {
        continue;
      } else if (item.type === "VariableDeclaration" || item.type === "FunctionDeclaration") {
        return true;
      } else if (item.type === "BlockStatement") {
        if (this._shouldBeWrapped(item.body)) {
          return true;
        }
      } else if (item.type === "IfStatement") {
        if (item.alternate) {
          if (this._shouldBeWrapped(item.alternate.body)) {
            return true;
          }
        }

        if (item.consequent) {
          if (this._shouldBeWrapped(item.consequent.body)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  _serializeAdditionalFunctionGeneratorAndEffects(generator, functionValue, additionalEffects) {
    return this._withGeneratorScope("OptimizedFunction", generator,
    /*valuesToProcess*/
    undefined, newBody => {
      let effectsGenerator = additionalEffects.generator;
      (0, _invariant.default)(effectsGenerator === generator);
      effectsGenerator.serialize(this._getContext());
      this.realm.withEffectsAppliedInGlobalEnv(() => {
        const lazyHoistedReactNodes = this.residualReactElementSerializer.serializeLazyHoistedNodes(functionValue);
        this.mainBody.entries.push(...lazyHoistedReactNodes);
        return null;
      }, additionalEffects.effects);
    }, functionValue);
  } // result -- serialize it, a return statement will be generated later, must be a Value
  // Generator -- visit all entries
  // Bindings -- only need to serialize bindings if they're captured by some nested function?
  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure
  //          -- we don't overwrite anything they capture
  // PropertyBindings -- visit any property bindings that aren't to createdobjects
  // CreatedObjects -- should take care of itself


  _serializeAdditionalFunction(additionalFunctionValue, additionalEffects) {
    let {
      effects,
      transforms,
      generator,
      additionalRoots
    } = additionalEffects; // No function info means the function is dead code, also break recursive cycles where we've already started
    // serializing this value

    if (!this.additionalFunctionValueInfos.has(additionalFunctionValue) || this.rewrittenAdditionalFunctions.has(additionalFunctionValue)) {
      return;
    }

    this.rewrittenAdditionalFunctions.set(additionalFunctionValue, []); // visit all additional roots before going into the additional functions;
    // this ensures that those potentially stateful additional roots will get
    // initially serialized with the right initial effects applied.

    for (let additionalRoot of additionalRoots) this.serializeValue(additionalRoot);

    let createdObjects = effects.createdObjects;
    let nestedFunctions = new Set([...createdObjects].filter(object => object instanceof _index2.FunctionValue)); // Allows us to emit function declarations etc. inside of this additional
    // function instead of adding them at global scope
    // TODO: make sure this generator isn't getting mutated oddly

    nestedFunctions.forEach(val => this.additionalFunctionValueNestedFunctions.add(val));

    let body = this._serializeAdditionalFunctionGeneratorAndEffects(generator, additionalFunctionValue, additionalEffects);

    (0, _invariant.default)(additionalFunctionValue instanceof _index2.ECMAScriptSourceFunctionValue);

    for (let transform of transforms) {
      transform(body);
    }

    this.rewrittenAdditionalFunctions.set(additionalFunctionValue, body);
  }

  prepareAdditionalFunctionValues() {
    for (let [additionalFunctionValue, {
      generator
    }] of this.additionalFunctionValuesAndEffects.entries()) {
      (0, _invariant.default)(!this.additionalFunctionGenerators.has(additionalFunctionValue));
      this.additionalFunctionGenerators.set(additionalFunctionValue, generator);
    }
  } // Hook point for any serialization needs to be done after generator serialization is complete.


  postGeneratorSerialization() {// For overriding only.
  }

  serialize() {
    this.prepareAdditionalFunctionValues();
    this.generator.serialize(this._getContext());
    this.getStatistics().generators++;
    (0, _invariant.default)(this.emitter.declaredCount() <= this.realm.derivedIds.size); // TODO #20: add timers
    // TODO #21: add event listeners

    for (let [moduleId, moduleValue] of this.modules.initializedModules) this.requireReturns.set(moduleId, (0, _ResidualFunctionInstantiator.getReplacement)(this.serializeValue(moduleValue), moduleValue));

    for (let [name, value] of this.declaredGlobalLets) {
      this.emitter.emit(t.expressionStatement(t.assignmentExpression("=", t.identifier(name), this.serializeValue(value))));
    }

    this.postGeneratorSerialization();
    Array.prototype.push.apply(this.prelude, this.preludeGenerator.prelude);
    this.emitter.finalize();
    this.residualFunctions.residualFunctionInitializers.factorifyInitializers(this.factoryNameGenerator);
    let {
      unstrictFunctionBodies,
      strictFunctionBodies
    } = this.residualFunctions.spliceFunctions(this.rewrittenAdditionalFunctions); // add strict modes

    let strictDirective = t.directive(t.directiveLiteral("use strict"));
    let globalDirectives = [];

    if (!this.realm.isStrict && !unstrictFunctionBodies.length && strictFunctionBodies.length) {
      // no unstrict functions, only strict ones
      globalDirectives.push(strictDirective);
    } else if (unstrictFunctionBodies.length && strictFunctionBodies.length) {
      // strict and unstrict functions
      funcLoop: for (let node of strictFunctionBodies) {
        if (t.isFunctionExpression(node)) {
          let func = node;

          if (func.body.directives) {
            for (let directive of func.body.directives) {
              if (directive.value.value === "use strict") {
                // already have a use strict directive
                continue funcLoop;
              }
            }
          } else func.body.directives = [];

          func.body.directives.unshift(strictDirective);
        }
      }
    } // build ast


    if (this.needsEmptyVar) {
      this.prelude.push(t.variableDeclaration("var", [t.variableDeclarator(_babelhelpers.emptyExpression, t.objectExpression([]))]));
    }

    if (this.needsAuxiliaryConstructor) {
      this.prelude.push(t.variableDeclaration("var", [t.variableDeclarator(_babelhelpers.constructorExpression, t.functionExpression(null, [], t.blockStatement([])))]));
    }

    let body = this.prelude.concat(this.emitter.getBody().entries);
    (0, _factorify.factorifyObjects)(body, this.factoryNameGenerator);
    let ast_body = [];
    if (this.preludeGenerator.declaredGlobals.size > 0) ast_body.push(t.variableDeclaration("var", Array.from(this.preludeGenerator.declaredGlobals).map(key => t.variableDeclarator(t.identifier(key)))));
    if (this.declaredGlobalLets.size > 0) ast_body.push(t.variableDeclaration("let", Array.from(this.declaredGlobalLets.keys()).map(key => t.variableDeclarator(t.identifier(key)))));

    if (body.length) {
      if (this.realm.isCompatibleWith("node-source-maps")) {
        ast_body.push(t.expressionStatement(t.callExpression(t.memberExpression(t.callExpression(t.identifier("require"), [t.stringLiteral("source-map-support")]), t.identifier("install")), [])));
      }

      if (this._shouldBeWrapped(body)) {
        let globalExpression = t.thisExpression();
        let functionExpression = t.functionExpression(null, [], t.blockStatement(body, globalDirectives));
        let callExpression = this.preludeGenerator.usesThis ? t.callExpression(t.memberExpression(functionExpression, t.identifier("call")), [globalExpression]) : t.callExpression(functionExpression, []);
        ast_body.push(t.expressionStatement(callExpression));
      } else {
        Array.prototype.push.apply(ast_body, body);
      }
    } // Make sure that the visitor visited exactly the same values as the serializer


    if (this.serializedValues.size !== this.residualValues.size || !Array.from(this.serializedValues).every(val => this.residualValues.has(val))) {
      this._logSerializedResidualMismatches();

      (0, _invariant.default)(false, "serialized " + this.serializedValues.size + " of " + this.residualValues.size);
    } // TODO: find better way to do this?
    // revert changes to functionInstances in case we do multiple serialization passes


    for (let instance of this.residualFunctionInstances.values()) {
      this.referentializer.cleanInstance(instance);
    }

    let program_directives = [];
    if (this.realm.isStrict) program_directives.push(strictDirective);
    return t.file(t.program(ast_body, program_directives));
  }

  _logScopes(scopes) {
    console.log(`  referenced by ${scopes.size} scopes`);

    for (let s of scopes) if (s instanceof _generator.Generator) {
      let text = "";

      for (; s instanceof _generator.Generator; s = this.generatorTree.getParent(s)) text += "=>" + s.getName();

      console.log(`      ${text}`);
    } else {
      (0, _invariant.default)(s instanceof _index2.FunctionValue);
      console.log(`      ${s.__originalName || JSON.stringify(s.expressionLocation) || s.constructor.name}`);
    }
  }

  _logSerializedResidualMismatches() {
    let logValue = value => {
      console.log((0, _utils2.describeValue)(value));
      let scopes = this.residualValues.get(value);
      if (scopes !== undefined) this._logScopes(scopes);
    };

    console.log("=== serialized but not visited values");

    for (let value of this.serializedValues) if (!this.residualValues.has(value)) logValue(value);

    console.log("=== visited but not serialized values");

    for (let value of this.residualValues.keys()) if (!this.serializedValues.has(value)) logValue(value);
  }

}

exports.ResidualHeapSerializer = ResidualHeapSerializer;
//# sourceMappingURL=ResidualHeapSerializer.js.map

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualFunctions = void 0;

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _types2 = __webpack_require__(408);

var _statistics = __webpack_require__(407);

var _ResidualFunctionInstantiator = __webpack_require__(435);

var _modules = __webpack_require__(411);

var _ResidualFunctionInitializers = __webpack_require__(437);

var _babelhelpers = __webpack_require__(239);

var _Referentializer = __webpack_require__(439);

var _utils = __webpack_require__(413);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class ResidualFunctions {
  constructor(realm, options, modules, requireReturns, locationService, prelude, factoryNameGenerator, residualFunctionInfos, residualFunctionInstances, residualClassMethodInstances, additionalFunctionValueInfos, additionalFunctionValueNestedFunctions, referentializer) {
    this.realm = realm;
    this.modules = modules;
    this.requireReturns = requireReturns;
    this.locationService = locationService;
    this.prelude = prelude;
    this.factoryNameGenerator = factoryNameGenerator;
    this.functionPrototypes = new Map();
    this.firstFunctionUsages = new Map();
    this.functions = new Map();
    this.classes = new Map();
    this.functionInstances = [];
    this.residualFunctionInitializers = new _ResidualFunctionInitializers.ResidualFunctionInitializers(locationService);
    this.residualFunctionInfos = residualFunctionInfos;
    this.residualFunctionInstances = residualFunctionInstances;
    this.residualClassMethodInstances = residualClassMethodInstances;
    this.additionalFunctionValueInfos = additionalFunctionValueInfos;
    this.referentializer = referentializer;

    for (let instance of residualFunctionInstances.values()) {
      (0, _invariant.default)(instance !== undefined);
      if (!additionalFunctionValueInfos.has(instance.functionValue)) this.addFunctionInstance(instance);
    }

    this.additionalFunctionValueNestedFunctions = additionalFunctionValueNestedFunctions;
    this.additionalFunctionPreludes = new Map();

    for (let functionValue of additionalFunctionValueInfos.keys()) {
      this.additionalFunctionPreludes.set(functionValue, []);
    }
  }

  getStatistics() {
    (0, _invariant.default)(this.realm.statistics instanceof _statistics.SerializerStatistics, "serialization requires SerializerStatistics");
    return this.realm.statistics;
  }

  addFunctionInstance(instance) {
    this.functionInstances.push(instance);
    let code = instance.functionValue.$ECMAScriptCode;
    (0, _invariant.default)(code != null);
    (0, _utils.getOrDefault)(this.functions, code, () => []).push(instance);
  }

  setFunctionPrototype(constructor, prototypeId) {
    this.functionPrototypes.set(constructor, prototypeId);
  }

  addFunctionUsage(val, bodyReference) {
    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);
  }

  _shouldUseFactoryFunction(funcBody, instances) {
    (0, _invariant.default)(instances.length > 0);

    function shouldInlineFunction() {
      if (instances[0].scopeInstances.size > 0) return false;
      let shouldInline = true;

      if (funcBody.start && funcBody.end) {
        let bodySize = funcBody.end - funcBody.start;
        shouldInline = bodySize <= 30;
      }

      return shouldInline;
    }

    let functionInfo = this.residualFunctionInfos.get(funcBody);
    (0, _invariant.default)(functionInfo);
    let {
      usesArguments
    } = functionInfo;
    let hasAnyLeakedIds = false;

    for (const instance of instances) for (const scope of instance.scopeInstances.values()) if (scope.leakedIds.length > 0) hasAnyLeakedIds = true;

    return !shouldInlineFunction() && instances.length > 1 && !usesArguments && !hasAnyLeakedIds;
  }

  _getIdentifierReplacements(funcBody, residualFunctionBindings) {
    let functionInfo = this.residualFunctionInfos.get(funcBody);
    (0, _invariant.default)(functionInfo);
    let {
      unbound
    } = functionInfo;
    let res = new Map();

    for (let [name, nodes] of unbound) {
      let residualFunctionBinding = residualFunctionBindings.get(name);
      if (residualFunctionBinding === undefined) continue; // Let's skip bindings that are referring to
      // 1) something global (without an environment record), and
      // 2) have not been assigned a value (which would mean that they have a var/let binding and Prepack will take the liberty to rename them).

      if (residualFunctionBinding.declarativeEnvironmentRecord === null && residualFunctionBinding.value === undefined) {
        continue;
      }

      let serializedValue = residualFunctionBinding.serializedValue;
      (0, _invariant.default)(serializedValue !== undefined);
      let replacement = (0, _ResidualFunctionInstantiator.getReplacement)(serializedValue, residualFunctionBinding.referentialized ? undefined : residualFunctionBinding.value);

      for (let node of nodes) res.set(node, replacement);
    }

    return res;
  }

  _getCallReplacements(funcBody) {
    let functionInfo = this.residualFunctionInfos.get(funcBody);
    (0, _invariant.default)(functionInfo);
    let {
      requireCalls,
      modified
    } = functionInfo;
    let res = new Map();

    for (let [callNode, moduleId] of requireCalls) {
      this.getStatistics().requireCalls++;
      if (modified.has(callNode.callee.name)) continue;
      let replacement = this.requireReturns.get("" + moduleId);

      if (replacement !== undefined) {
        this.getStatistics().requireCallsReplaced++;
        res.set(callNode, replacement);
      }
    }

    return res;
  } // Note: this function takes linear time. Please do not call it inside loop.


  _hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances) {
    return instances.find(instance => rewrittenAdditionalFunctions.has(instance.functionValue)) !== undefined;
  }

  _generateFactoryFunctionInfos(rewrittenAdditionalFunctions) {
    const factoryFunctionInfos = new Map();

    for (const [functionBody, instances] of this.functions) {
      (0, _invariant.default)(instances.length > 0);
      let factoryId;
      const suffix = instances[0].functionValue.__originalName || this.realm.debugNames ? "factoryFunction" : "";

      if (this._shouldUseFactoryFunction(functionBody, instances)) {
        // Rewritten function should never use factory function.
        (0, _invariant.default)(!this._hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances));
        factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));
      } else {
        // For inline function body case, use the first function as the factory function.
        factoryId = this.locationService.getLocation(instances[0].functionValue);
      }

      const functionUniqueTag = functionBody.uniqueOrderedTag;
      (0, _invariant.default)(functionUniqueTag);
      const functionInfo = this.residualFunctionInfos.get(functionBody);
      (0, _invariant.default)(functionInfo);
      let anyContainingAdditionalFunction = !instances.every(instance => instance.containingAdditionalFunction === undefined);
      factoryFunctionInfos.set(functionUniqueTag, {
        factoryId,
        functionInfo,
        anyContainingAdditionalFunction
      });
    }

    return factoryFunctionInfos;
  } // Preserve residual functions' ordering based on its ast dfs traversal order.
  // This is necessary to prevent unexpected code locality issues.


  _sortFunctionByOriginalOrdering(functionEntries) {
    functionEntries.sort((funcA, funcB) => {
      const funcAUniqueTag = funcA[0].uniqueOrderedTag;
      (0, _invariant.default)(funcAUniqueTag);
      const funcBUniqueTag = funcB[0].uniqueOrderedTag;
      (0, _invariant.default)(funcBUniqueTag);
      return funcAUniqueTag - funcBUniqueTag;
    });
  }

  _createFunctionExpression(params, body, isLexical) {
    // Additional statements might be inserted at the beginning of the body, so we clone it.
    body = Object.assign({}, body);
    return isLexical ? t.arrowFunctionExpression(params, body) : t.functionExpression(null, params, body);
  }

  spliceFunctions(rewrittenAdditionalFunctions) {
    this.residualFunctionInitializers.scrubFunctionInitializers();
    let functionBodies = new Map(); // these need to get spliced in at the end

    let additionalFunctionModifiedBindingsSegment = new Map();

    let getModifiedBindingsSegment = additionalFunction => (0, _utils.getOrDefault)(additionalFunctionModifiedBindingsSegment, additionalFunction, () => []);

    let getFunctionBody = instance => (0, _utils.getOrDefault)(functionBodies, instance, () => []);

    let getPrelude = instance => {
      let additionalFunction = instance.containingAdditionalFunction;
      let b;

      if (additionalFunction !== undefined) {
        b = this.additionalFunctionPreludes.get(additionalFunction);
        (0, _invariant.default)(b !== undefined);
      } else {
        b = this.prelude;
      }

      return b;
    };

    let functionEntries = Array.from(this.functions.entries());

    this._sortFunctionByOriginalOrdering(functionEntries);

    this.getStatistics().functions = functionEntries.length;
    let unstrictFunctionBodies = [];
    let strictFunctionBodies = [];

    let registerFunctionStrictness = (node, strict) => {
      if (t.isFunctionExpression(node) || t.isArrowFunctionExpression(node)) {
        (strict ? strictFunctionBodies : unstrictFunctionBodies).push(node);
      }
    };

    let funcNodes = new Map();

    let defineFunction = (instance, funcId, funcOrClassNode) => {
      let {
        functionValue
      } = instance;

      if (instance.initializationStatements.length > 0) {
        // always add initialization statements to insertion point
        let initializationBody = getFunctionBody(instance);
        Array.prototype.push.apply(initializationBody, instance.initializationStatements);
      }

      let body;

      if (t.isFunctionExpression(funcOrClassNode)) {
        funcNodes.set(functionValue, funcOrClassNode);
        body = getPrelude(instance);
      } else {
        (0, _invariant.default)(t.isCallExpression(funcOrClassNode) || t.isClassExpression(funcOrClassNode) || t.isArrowFunctionExpression(funcOrClassNode)); // .bind call

        body = getFunctionBody(instance);
      }

      body.push(t.variableDeclaration("var", [t.variableDeclarator(funcId, funcOrClassNode)]));
      let prototypeId = this.functionPrototypes.get(functionValue);

      if (prototypeId !== undefined) {
        let id = this.locationService.getLocation(functionValue);
        (0, _invariant.default)(id !== undefined);
        body.push(t.variableDeclaration("var", [t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier("prototype")))]));
      }
    }; // Emit code for ModifiedBindings for additional functions


    for (let [funcValue, funcInfo] of this.additionalFunctionValueInfos) {
      let scopes = new Set();

      for (let [, residualBinding] of funcInfo.modifiedBindings) {
        let scope = residualBinding.scope;
        if (scope === undefined || scopes.has(scope)) continue;
        scopes.add(scope);
        (0, _invariant.default)(residualBinding.referentialized); // Find the proper prelude to emit to (global vs additional function's prelude)

        let bodySegment = getModifiedBindingsSegment(funcValue); // binding has been referentialized, so setup the scope to be able to
        // access bindings from other __captured_scopes initializers

        if (scope.referentializationScope !== funcValue) {
          let init = this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id)); // flow forces me to do this

          Array.prototype.push.apply(bodySegment, init);
        }
      }
    } // Process Additional Functions


    for (let [funcValue, additionalFunctionInfo] of this.additionalFunctionValueInfos.entries()) {
      let {
        instance
      } = additionalFunctionInfo;
      let functionValue = funcValue;
      let params = functionValue.$FormalParameters;
      let isLexical = functionValue.$ThisMode === "lexical";
      (0, _invariant.default)(params !== undefined);
      let rewrittenBody = rewrittenAdditionalFunctions.get(funcValue);
      (0, _invariant.default)(rewrittenBody); // rewritten functions shouldn't have references fixed up because the body,
      // consists of serialized code. For simplicity we emit their instances in a naive way

      let functionBody = t.blockStatement(rewrittenBody);
      let funcOrClassNode;

      if (this.residualClassMethodInstances.has(funcValue)) {
        let classMethodInstance = this.residualClassMethodInstances.get(funcValue);
        (0, _invariant.default)(classMethodInstance);
        let {
          methodType,
          classMethodKeyNode,
          classSuperNode,
          classMethodComputed,
          classPrototype,
          classMethodIsStatic
        } = classMethodInstance;
        let isConstructor = methodType === "constructor";
        (0, _invariant.default)(classPrototype instanceof _index.ObjectValue);
        (0, _invariant.default)(classMethodKeyNode && (t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode))); // we use the classPrototype as the key to get the class expression ast node

        funcOrClassNode = this._getOrCreateClassNode(classPrototype);
        let classMethod = t.classMethod(methodType, classMethodKeyNode, params, functionBody, classMethodComputed, classMethodIsStatic); // add the class method to the class expression node body

        if (isConstructor) {
          funcOrClassNode.body.body.unshift(classMethod);
        } else {
          funcOrClassNode.body.body.push(classMethod);
        } // we only return the funcOrClassNode if this is the constructor


        if (!isConstructor) {
          continue;
        } // handle the class super


        if (classSuperNode !== undefined) {
          funcOrClassNode.superClass = classSuperNode;
        }
      } else {
        funcOrClassNode = isLexical ? t.arrowFunctionExpression(params, functionBody) : t.functionExpression(null, params, functionBody);
      }

      let id = this.locationService.getLocation(funcValue);
      (0, _invariant.default)(id !== undefined);
      registerFunctionStrictness(funcOrClassNode, funcValue instanceof _index.ECMAScriptSourceFunctionValue && funcValue.$Strict);
      defineFunction(instance, id, funcOrClassNode);
    } // Process normal functions


    const factoryFunctionInfos = this._generateFactoryFunctionInfos(rewrittenAdditionalFunctions);

    for (let [funcBody, instances] of functionEntries) {
      let functionInfo = this.residualFunctionInfos.get(funcBody);
      (0, _invariant.default)(functionInfo);
      let {
        unbound,
        usesThis
      } = functionInfo;
      let params = instances[0].functionValue.$FormalParameters;
      (0, _invariant.default)(params !== undefined); // Split instances into normal or nested in an additional function

      let normalInstances = [];
      let additionalFunctionNestedInstances = [];

      for (let instance of instances) {
        if (this.additionalFunctionValueNestedFunctions.has(instance.functionValue)) additionalFunctionNestedInstances.push(instance);else normalInstances.push(instance);
      }

      let naiveProcessInstances = instancesToSplice => {
        this.getStatistics().functionClones += instancesToSplice.length;

        for (let instance of instancesToSplice) {
          let {
            functionValue,
            residualFunctionBindings,
            scopeInstances
          } = instance;
          let funcOrClassNode;

          if (this.residualClassMethodInstances.has(functionValue)) {
            let classMethodInstance = this.residualClassMethodInstances.get(functionValue);
            (0, _invariant.default)(classMethodInstance);
            let {
              classSuperNode,
              classMethodKeyNode,
              methodType,
              classMethodComputed,
              classPrototype,
              classMethodIsStatic
            } = classMethodInstance;
            let isConstructor = methodType === "constructor";
            (0, _invariant.default)(classPrototype instanceof _index.ObjectValue);
            (0, _invariant.default)(classMethodKeyNode);
            (0, _invariant.default)(t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode)); // we use the classPrototype as the key to get the class expression ast node

            funcOrClassNode = this._getOrCreateClassNode(classPrototype); // if we are dealing with a constructor, don't serialize it if the original
            // had an empty user-land constructor (because we create a constructor behind the scenes for them)

            let hasEmptyConstructor = !!functionValue.$HasEmptyConstructor;

            if (!isConstructor || isConstructor && !hasEmptyConstructor) {
              let methodParams = params.slice();
              let classMethod = new _ResidualFunctionInstantiator.ResidualFunctionInstantiator(factoryFunctionInfos, this._getIdentifierReplacements(funcBody, residualFunctionBindings), this._getCallReplacements(funcBody), t.classMethod(methodType, classMethodKeyNode, methodParams, funcBody, classMethodComputed, classMethodIsStatic)).instantiate(); // add the class method to the class expression node body

              if (isConstructor) {
                funcOrClassNode.body.body.unshift(classMethod);
              } else {
                funcOrClassNode.body.body.push(classMethod);
              }
            } // we only return the funcOrClassNode if this is the constructor


            if (!isConstructor) {
              continue;
            } // handle the class super


            if (classSuperNode !== undefined) {
              funcOrClassNode.superClass = classSuperNode;
            }
          } else {
            let isLexical = instance.functionValue.$ThisMode === "lexical";
            funcOrClassNode = new _ResidualFunctionInstantiator.ResidualFunctionInstantiator(factoryFunctionInfos, this._getIdentifierReplacements(funcBody, residualFunctionBindings), this._getCallReplacements(funcBody), this._createFunctionExpression(params, funcBody, isLexical)).instantiate();
            let scopeInitialization = [];

            for (let scope of scopeInstances.values()) {
              scopeInitialization = scopeInitialization.concat(this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id)));
            }

            if (scopeInitialization.length > 0) {
              let funcOrClassNodeBody = funcOrClassNode.body;
              (0, _invariant.default)(t.isBlockStatement(funcOrClassNodeBody));
              funcOrClassNodeBody.body = scopeInitialization.concat(funcOrClassNodeBody.body);
            }
          }

          let id = this.locationService.getLocation(functionValue);
          (0, _invariant.default)(id !== undefined);
          registerFunctionStrictness(funcOrClassNode, functionValue.$Strict);
          (0, _invariant.default)(id !== undefined);
          (0, _invariant.default)(funcOrClassNode !== undefined);
          defineFunction(instance, id, funcOrClassNode);
        }
      };

      if (additionalFunctionNestedInstances.length > 0) naiveProcessInstances(additionalFunctionNestedInstances);

      if (normalInstances.length > 0 && !this._shouldUseFactoryFunction(funcBody, normalInstances)) {
        naiveProcessInstances(normalInstances);
        this.getStatistics().functionClones--;
      } else if (normalInstances.length > 0) {
        const functionUniqueTag = funcBody.uniqueOrderedTag;
        (0, _invariant.default)(functionUniqueTag);
        const factoryInfo = factoryFunctionInfos.get(functionUniqueTag);
        (0, _invariant.default)(factoryInfo);
        const {
          factoryId
        } = factoryInfo; // filter included variables to only include those that are different

        let factoryNames = [];
        let sameResidualBindings = new Map();

        for (let name of unbound.keys()) {
          let isDifferent = false;
          let lastBinding;
          let firstBinding = normalInstances[0].residualFunctionBindings.get(name);
          (0, _invariant.default)(firstBinding);

          if (firstBinding.modified) {
            // Must modify for traversal
            sameResidualBindings.set(name, firstBinding);
            continue;
          }

          for (let _ref of normalInstances) {
            let {
              residualFunctionBindings
            } = _ref;
            let residualBinding = residualFunctionBindings.get(name);
            (0, _invariant.default)(residualBinding);
            (0, _invariant.default)(!residualBinding.modified);

            if (!lastBinding) {
              lastBinding = residualBinding;
            } else if (!(0, _types2.AreSameResidualBinding)(this.realm, residualBinding, lastBinding)) {
              isDifferent = true;
              break;
            }
          }

          if (isDifferent) {
            factoryNames.push(name);
          } else {
            (0, _invariant.default)(lastBinding);
            sameResidualBindings.set(name, lastBinding);
          }
        }

        let factoryParams = [];

        for (let key of factoryNames) {
          factoryParams.push(t.identifier(key));
        }

        let scopeInitialization = [];

        for (let [scopeName, scope] of normalInstances[0].scopeInstances) {
          let scopeNameId = t.identifier(scopeName);
          factoryParams.push(scopeNameId);
          scopeInitialization = scopeInitialization.concat(this.referentializer.getReferentializedScopeInitialization(scope, scopeNameId));
        }

        factoryParams = factoryParams.concat(params).slice();
        let factoryNode = new _ResidualFunctionInstantiator.ResidualFunctionInstantiator(factoryFunctionInfos, this._getIdentifierReplacements(funcBody, sameResidualBindings), this._getCallReplacements(funcBody), this._createFunctionExpression(factoryParams, funcBody, false)).instantiate();

        if (scopeInitialization.length > 0) {
          let factoryNodeBody = factoryNode.body;
          (0, _invariant.default)(t.isBlockStatement(factoryNodeBody));
          factoryNodeBody.body = scopeInitialization.concat(factoryNodeBody.body);
        } // factory functions do not depend on any nested generator scope, so they go to the prelude


        let factoryDeclaration = t.variableDeclaration("var", [t.variableDeclarator(factoryId, factoryNode)]);
        this.prelude.push(factoryDeclaration);
        registerFunctionStrictness(factoryNode, normalInstances[0].functionValue.$Strict);

        for (let instance of normalInstances) {
          let {
            functionValue,
            residualFunctionBindings,
            insertionPoint
          } = instance;
          let functionId = this.locationService.getLocation(functionValue);
          (0, _invariant.default)(functionId !== undefined);
          let hasFunctionArg = false;
          let flatArgs = factoryNames.map(name => {
            let residualBinding = residualFunctionBindings.get(name);
            (0, _invariant.default)(residualBinding);
            let serializedValue = residualBinding.serializedValue;
            hasFunctionArg = hasFunctionArg || residualBinding.value && residualBinding.value instanceof _index.FunctionValue;
            (0, _invariant.default)(serializedValue);
            return serializedValue;
          });
          let hasAnyLeakedIds = false;

          for (const scope of instance.scopeInstances.values()) {
            flatArgs.push(t.numericLiteral(scope.id));
            if (scope.leakedIds.length > 0) hasAnyLeakedIds = true;
          }

          let funcNode;
          let firstUsage = this.firstFunctionUsages.get(functionValue); // todo: why can this be undefined?

          (0, _invariant.default)(insertionPoint !== undefined);

          if ( // The same free variables in shared instances may refer to objects with different initialization values
          // so a stub forward function is needed during delay initializations.
          this.residualFunctionInitializers.hasInitializerStatement(functionValue) || usesThis || hasFunctionArg || firstUsage === undefined || !firstUsage.isNotEarlierThan(insertionPoint) || this.functionPrototypes.get(functionValue) !== undefined || hasAnyLeakedIds) {
            let callArgs = [t.thisExpression()];

            for (let flatArg of flatArgs) callArgs.push(flatArg);

            for (let param of params) {
              if (param.type !== "Identifier") {
                throw new _errors.FatalError("TODO: do not know how to deal with non-Identifier parameters");
              }

              callArgs.push(param);
            }

            let callee = t.memberExpression(factoryId, t.identifier("call"));
            let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);
            funcNode = t.functionExpression(null, params, childBody);
            registerFunctionStrictness(funcNode, functionValue.$Strict);
          } else {
            funcNode = t.callExpression(t.memberExpression(factoryId, t.identifier("bind")), [_babelhelpers.nullExpression].concat(flatArgs));
          }

          defineFunction(instance, functionId, funcNode);
        }
      }
    }

    for (let referentializationScope of this.referentializer.referentializationState.keys()) {
      let prelude; // Get the prelude for this additional function value

      if (referentializationScope !== "GLOBAL") {
        let additionalFunction = referentializationScope;
        prelude = this.additionalFunctionPreludes.get(additionalFunction);
        (0, _invariant.default)(prelude !== undefined);
      } else {
        prelude = this.prelude;
      }

      prelude.unshift(...this.referentializer.createCapturedScopesPrelude(referentializationScope), ...this.referentializer.createLeakedIds(referentializationScope));
    }

    for (let instance of this.functionInstances.reverse()) {
      let functionBody = functionBodies.get(instance);

      if (functionBody !== undefined) {
        let insertionPoint = instance.insertionPoint;
        (0, _invariant.default)(insertionPoint instanceof _types2.BodyReference); // v8 seems to do something clever with array splicing, so this potentially
        // expensive operations seems to be actually cheap.

        insertionPoint.body.entries.splice(insertionPoint.index, 0, ...functionBody);
      }
    } // Inject initializer code for indexed vars into functions (for delay initializations)


    for (let [functionValue, funcNode] of funcNodes) {
      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);

      if (initializerStatement !== undefined) {
        (0, _invariant.default)(t.isFunctionExpression(funcNode));
        let blockStatement = funcNode.body;
        blockStatement.body.unshift(initializerStatement);
      }
    }

    for (let [additionalFunction, body] of Array.from(rewrittenAdditionalFunctions.entries()).reverse()) {
      let additionalFunctionInfo = this.additionalFunctionValueInfos.get(additionalFunction);
      (0, _invariant.default)(additionalFunctionInfo); // Modified bindings initializers of optimized function

      let bodySegment = additionalFunctionModifiedBindingsSegment.get(additionalFunction); // initializers from Referentialization

      let initializationStatements = getFunctionBody(additionalFunctionInfo.instance);
      let prelude = this.additionalFunctionPreludes.get(additionalFunction);
      (0, _invariant.default)(prelude !== undefined);
      let insertionPoint = additionalFunctionInfo.instance.insertionPoint;
      (0, _invariant.default)(insertionPoint); // TODO: I think this inserts things in the wrong place

      insertionPoint.body.entries.splice(insertionPoint.index, 0, ...initializationStatements);
      if (bodySegment) body.unshift(...bodySegment);
      body.unshift(...prelude);
    }

    return {
      unstrictFunctionBodies,
      strictFunctionBodies
    };
  }

  _getOrCreateClassNode(classPrototype) {
    if (!this.classes.has(classPrototype)) {
      let funcOrClassNode = t.classExpression(null, null, t.classBody([]), []);
      this.classes.set(classPrototype, funcOrClassNode);
      return funcOrClassNode;
    } else {
      let funcOrClassNode = this.classes.get(classPrototype);
      (0, _invariant.default)(funcOrClassNode && t.isClassExpression(funcOrClassNode));
      return funcOrClassNode;
    }
  }

}

exports.ResidualFunctions = ResidualFunctions;
//# sourceMappingURL=ResidualFunctions.js.map

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getReplacement = getReplacement;
exports.isPure = isPure;
exports.ResidualFunctionInstantiator = void 0;

var t = _interopRequireWildcard(__webpack_require__(21));

var _jsx = __webpack_require__(436);

var _babelhelpers = __webpack_require__(239);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function canShareFunctionBody(duplicateFunctionInfo) {
  if (duplicateFunctionInfo.anyContainingAdditionalFunction) {
    // If the function is referenced by an optimized function,
    // it may get emitted within that optimized function,
    // and then the function name is not generally available in arbitrary other code
    // where we'd like to replace the body with a reference to the extracted function body.
    // TODO: Revisit interplay of factory function concept, scope concept, and optimized functions.
    return false;
  } // Only share function when:
  // 1. it does not access any free variables.
  // 2. it does not use "this".


  const {
    unbound,
    modified,
    usesThis
  } = duplicateFunctionInfo.functionInfo;
  return unbound.size === 0 && modified.size === 0 && !usesThis;
}

function getReplacement(node, value) {
  let truthiness;
  if (value !== undefined) if (!value.mightNotBeFalse()) truthiness = false;else if (!value.mightNotBeTrue()) truthiness = true;
  return {
    node,
    truthiness
  };
}

function isPure(node) {
  switch (node.type) {
    case "NullLiteral":
    case "BooleanLiteral":
    case "StringLiteral":
    case "NumericLiteral":
      return true;

    case "UnaryExpression":
    case "SpreadElement":
      let unaryExpression = node;
      return isPure(unaryExpression.argument);

    case "BinaryExpression":
    case "LogicalExpression":
      let binaryExpression = node;
      return isPure(binaryExpression.left) && isPure(binaryExpression.right);

    default:
      return false;
  }
} // This class instantiates residual functions by replacing certain nodes,
// i.e. bindings to captured scopes that need to get renamed to variable ids.
// The original nodes are never mutated; instead, nodes are cloned as needed.
// Along the way, some trivial code optimizations are performed as well.


class ResidualFunctionInstantiator {
  constructor(factoryFunctionInfos, identifierReplacements, callReplacements, root) {
    this.factoryFunctionInfos = factoryFunctionInfos;
    this.identifierReplacements = identifierReplacements;
    this.callReplacements = callReplacements;
    this.root = root;
  }

  instantiate() {
    return this._replace(this.root);
  }

  _getLiteralTruthiness(node) {
    switch (node.type) {
      case "BooleanLiteral":
      case "NumericLiteral":
      case "StringLiteral":
        return !!node.value;

      case "Identifier":
        {
          let replacement = this.identifierReplacements.get(node);
          if (replacement !== undefined) return replacement.truthiness;
          return undefined;
        }

      case "CallExpression":
        {
          let replacement = this.callReplacements.get(node);
          if (replacement !== undefined) return replacement.truthiness;
          return undefined;
        }

      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "RegExpLiteral":
        return true;

      case "ClassExpression":
        let classExpression = node;
        return classExpression.superClass === null && classExpression.body.body.length === 0 ? true : undefined;

      case "ObjectExpression":
        let objectExpression = node;
        return objectExpression.properties.every(property => isPure(property.key) && isPure(property.value)) ? true : undefined;

      case "ArrayExpression":
        let arrayExpression = node;
        return arrayExpression.elements.every(element => element === undefined || isPure(element)) ? true : undefined;

      case "NullLiteral":
        return false;

      case "UnaryExpression":
        let unaryExpression = node;
        return unaryExpression.operator === "void" && isPure(unaryExpression.argument) ? false : undefined;

      default:
        return undefined;
    }
  }

  _replaceIdentifier(node) {
    let replacement = this.identifierReplacements.get(node);
    if (replacement !== undefined) return replacement.node;
    return node; // nothing else to replace in an identifier
  }

  _replaceJSXIdentifier(node) {
    let replacement = this.identifierReplacements.get(node);
    if (replacement !== undefined) return (0, _jsx.convertExpressionToJSXIdentifier)(replacement.node, true);
    return node; // nothing else to replace in an identifier
  }

  _replaceLabeledStatement(node) {
    // intentionally ignore embedded identifier
    let newBody = this._replace(node.body);

    if (newBody !== node.body) {
      let res = Object.assign({}, node);
      res.body = newBody;
      return res;
    }

    return node; // nothing else to replace in a labeled statement
  }

  _replaceCallExpression(node) {
    let replacement = this.callReplacements.get(node);
    if (replacement !== undefined) return replacement.node;
    return this._replaceFallback(node);
  }

  _replaceFunctionExpression(node) {
    // Our goal is replacing duplicate nested function so skip root residual function itself.
    if (this.root !== node) {
      const functionExpression = node;
      const functionTag = functionExpression.body.uniqueOrderedTag; // Un-interpreted nested function?

      if (functionTag !== undefined) {
        // Un-interpreted nested function.
        const duplicateFunctionInfo = this.factoryFunctionInfos.get(functionTag);

        if (duplicateFunctionInfo && canShareFunctionBody(duplicateFunctionInfo)) {
          const {
            factoryId
          } = duplicateFunctionInfo;
          return t.callExpression(t.memberExpression(factoryId, t.identifier("bind")), [_babelhelpers.nullExpression]);
        }
      }
    }

    return this._replaceFallback(node);
  }

  _replaceIfStatement(node) {
    let testTruthiness = this._getLiteralTruthiness(node.test);

    if (testTruthiness === true) {
      // Strictly speaking this is not safe: Annex B.3.4 allows FunctionDeclarations as the body of IfStatements in sloppy mode,
      // which have weird hoisting behavior: `console.log(typeof f); if (true) function f(){} console.log(typeof f)` will print 'undefined', 'function', but
      // `console.log(typeof f); function f(){} console.log(typeof f)` will print 'function', 'function'.
      // However, Babylon can't parse these, so it doesn't come up.
      return this._replace(node.consequent);
    } else if (testTruthiness === false) {
      if (node.alternate !== null) {
        return this._replace(node.alternate);
      } else {
        return t.emptyStatement();
      }
    }

    return this._replaceFallback(node);
  }

  _replaceConditionalExpression(node) {
    let testTruthiness = this._getLiteralTruthiness(node.test);

    if (testTruthiness !== undefined) {
      return testTruthiness ? this._replace(node.consequent) : this._replace(node.alternate);
    }

    return this._replaceFallback(node);
  }

  _replaceLogicalExpression(node) {
    let leftTruthiness = this._getLiteralTruthiness(node.left);

    if (node.operator === "&&" && leftTruthiness !== undefined) {
      return leftTruthiness ? this._replace(node.right) : this._replace(node.left);
    } else if (node.operator === "||" && leftTruthiness !== undefined) {
      return leftTruthiness ? this._replace(node.left) : this._replace(node.right);
    }

    return this._replaceFallback(node);
  }

  _replaceWhileStatement(node) {
    let testTruthiness = this._getLiteralTruthiness(node.test);

    if (testTruthiness === false) {
      return t.emptyStatement();
    }

    return this._replaceFallback(node);
  }

  _replaceFallback(node) {
    let newNode;

    for (let key in node) {
      let subNode = node[key];
      if (!subNode) continue;
      let newSubNode;

      if (Array.isArray(subNode)) {
        let newArray;

        for (let i = 0; i < subNode.length; i++) {
          let elementNode = subNode[i];
          if (!elementNode) continue;

          let newElementNode = this._replace(elementNode);

          if (newElementNode !== elementNode) {
            if (newArray === undefined) newArray = subNode.slice(0);
            newArray[i] = newElementNode;
          }
        }

        if (newArray === undefined) continue;
        newSubNode = newArray;
      } else if (subNode.type) {
        newSubNode = this._replace(subNode);
        if (newSubNode === subNode) continue;
      } else continue;

      if (newNode === undefined) newNode = Object.assign({}, node);
      newNode[key] = newSubNode;
    }

    return newNode || node;
  }

  _replace(node) {
    switch (node.type) {
      case "Identifier":
        return this._replaceIdentifier(node);

      case "LabeledStatement":
        return this._replaceLabeledStatement(node);

      case "BreakStatement":
      case "ContinueStatement":
        return node;

      case "JSXIdentifier":
      case "JSXMemberExpressions":
        return this._replaceJSXIdentifier(node);

      case "CallExpression":
        return this._replaceCallExpression(node);

      case "FunctionExpression":
        return this._replaceFunctionExpression(node);

      case "IfStatement":
        return this._replaceIfStatement(node);

      case "ConditionalExpression":
        return this._replaceConditionalExpression(node);

      case "LogicalExpression":
        return this._replaceLogicalExpression(node);

      case "WhileStatement":
        return this._replaceWhileStatement(node);

      default:
        return this._replaceFallback(node);
    }
  }

}

exports.ResidualFunctionInstantiator = ResidualFunctionInstantiator;
//# sourceMappingURL=ResidualFunctionInstantiator.js.map

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertExpressionToJSXIdentifier = convertExpressionToJSXIdentifier;
exports.convertJSXExpressionToIdentifier = convertJSXExpressionToIdentifier;
exports.convertKeyValueToJSXAttribute = convertKeyValueToJSXAttribute;

var t = _interopRequireWildcard(__webpack_require__(21));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils = __webpack_require__(291);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function convertExpressionToJSXIdentifier(expr, isRoot) {
  switch (expr.type) {
    case "ThisExpression":
      (0, _invariant.default)(isRoot === false, `invalid conversion of root expression to JSXIdentifier for ThisExpression`);
      return t.jSXIdentifier("this");

    case "Identifier":
      let name = expr.name;
      (0, _invariant.default)( // ensure the 1st character of the string is uppercase
      // for a component unless it is not the root
      isRoot === false || (0, _utils.isReactComponent)(name), "invalid JSXIdentifer from Identifier, Identifier name must be uppercase");
      return t.jSXIdentifier(name);

    case "StringLiteral":
      let value = expr.value;
      (0, _invariant.default)( // ensure the 1st character of the string is lowercase
      // otherwise it will appear as a component
      value.length > 0 && value[0] === value[0].toLowerCase(), "invalid JSXIdentifer from string, strings must be lowercase");
      return t.jSXIdentifier(value);

    case "MemberExpression":
      (0, _invariant.default)(expr.computed === false, "Cannot inline computed expressions in JSX type.");
      return t.jSXMemberExpression(convertExpressionToJSXIdentifier(expr.object, false), convertExpressionToJSXIdentifier(expr.property, false));

    default:
      (0, _invariant.default)(false, "Invalid JSX type");
  }
}

function convertJSXExpressionToIdentifier(expr) {
  switch (expr.type) {
    case "JSXIdentifier":
      return t.identifier(expr.name);

    case "JSXMemberExpression":
      return t.memberExpression(convertJSXExpressionToIdentifier(expr.object), convertJSXExpressionToIdentifier(expr.property));

    default:
      (0, _invariant.default)(false, "Invalid JSX type");
  }
}

function convertKeyValueToJSXAttribute(key, expr) {
  let wrapInContainer = true;

  if (expr && t.isStringLiteral(expr) && typeof expr.value === "string") {
    let value = expr.value;
    wrapInContainer = value.includes('"') || value.includes("'");
  }

  return t.jSXAttribute(t.jSXIdentifier(key), wrapInContainer ? t.jSXExpressionContainer(expr) : expr);
}
//# sourceMappingURL=jsx.js.map

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualFunctionInitializers = void 0;

var _index = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _NameGenerator = __webpack_require__(240);

var _traverseFast = _interopRequireDefault(__webpack_require__(279));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _babelhelpers = __webpack_require__(239);

var _factorify = __webpack_require__(438);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// This class manages information about values
// which are only referenced by residual functions,
// and it provides the ability to generate initialization code for those values that
// can be placed into the residual functions.
class ResidualFunctionInitializers {
  constructor(locationService) {
    this.functionInitializerInfos = new Map();
    this.initializers = new Map();
    this.sharedInitializers = new Map();
    this.locationService = locationService;
  } // ownId: uid of the FunctionValue, initializer ids are strings of sorted lists of FunctionValues referencing the value


  registerValueOnlyReferencedByResidualFunctions(functionValues, val) {
    (0, _invariant.default)(functionValues.length >= 1);
    let infos = [];

    for (let functionValue of functionValues) {
      let info = this.functionInitializerInfos.get(functionValue);
      if (info === undefined) this.functionInitializerInfos.set(functionValue, info = {
        ownId: this.functionInitializerInfos.size.toString(),
        initializerIds: new Set()
      });
      infos.push(info);
    }

    let id = infos.map(info => info.ownId).sort().join();

    for (let info of infos) info.initializerIds.add(id);

    let initializer = this.initializers.get(id);
    if (initializer === undefined) this.initializers.set(id, initializer = {
      id,
      order: infos.length,
      values: [],
      body: {
        type: "DelayInitializations",
        parentBody: undefined,
        entries: [],
        done: false
      }
    });
    initializer.values.push(val);
    return initializer.body;
  }

  scrubFunctionInitializers() {
    // Deleting trivial entries in order to avoid creating empty initialization functions that serve no purpose.
    for (let initializer of this.initializers.values()) if (initializer.body.entries.length === 0) this.initializers.delete(initializer.id);

    for (let [functionValue, info] of this.functionInitializerInfos) {
      for (let id of info.initializerIds) {
        let initializer = this.initializers.get(id);

        if (initializer === undefined) {
          info.initializerIds.delete(id);
        }
      }

      if (info.initializerIds.size === 0) this.functionInitializerInfos.delete(functionValue);
    }
  }

  _conditionalInitialization(containingAdditionalFunction, initializedValues, initializationStatements) {
    if (initializationStatements.length === 1 && t.isIfStatement(initializationStatements[0])) {
      return initializationStatements[0];
    } // We have some initialization code, and it should only get executed once,
    // so we are going to guard it.
    // First, let's see if one of the initialized values is guaranteed to not
    // be undefined after initialization. In that case, we can use that state-change
    // to figure out if initialization needs to run.


    let location;

    for (let value of initializedValues) {
      // function declarations get hoisted, so let's not use their initialization state as a marker
      if (!value.mightBeUndefined() && !(value instanceof _index.FunctionValue)) {
        location = this.locationService.getLocation(value);
        if (location !== undefined) break;
      }
    }

    if (location === undefined) {
      // Second, if we didn't find a non-undefined value, let's make one up.
      // It will transition from `undefined` to `null`.
      location = this.locationService.createLocation(containingAdditionalFunction);
      initializationStatements.unshift(t.expressionStatement(t.assignmentExpression("=", location, _babelhelpers.nullExpression)));
    }

    return t.ifStatement(t.binaryExpression("===", location, _babelhelpers.voidExpression), t.blockStatement(initializationStatements));
  }

  hasInitializerStatement(functionValue) {
    return !!this.functionInitializerInfos.get(functionValue);
  }

  factorifyInitializers(nameGenerator) {
    for (const initializer of this.initializers.values()) {
      (0, _factorify.factorifyObjects)(initializer.body.entries, nameGenerator);
    }
  }

  getInitializerStatement(functionValue) {
    let initializerInfo = this.functionInitializerInfos.get(functionValue);
    if (initializerInfo === undefined) return undefined;
    let containingAdditionalFunction = this.locationService.getContainingAdditionalFunction(functionValue);
    (0, _invariant.default)(initializerInfo.initializerIds.size > 0);
    let ownInitializer = this.initializers.get(initializerInfo.ownId);
    let initializedValues;
    let initializationStatements = [];
    let initializers = [];

    for (let initializerId of initializerInfo.initializerIds) {
      let initializer = this.initializers.get(initializerId);
      (0, _invariant.default)(initializer !== undefined);
      (0, _invariant.default)(initializer.body.entries.length > 0);
      initializers.push(initializer);
    } // Sorting initializers by the number of scopes they are required by.
    // Note that the scope sets form a lattice, and this sorting effectively
    // ensures that value initializers that depend on other value initializers
    // get called in the right order.


    initializers.sort((i, j) => j.order - i.order);

    for (let initializer of initializers) {
      if (initializerInfo.initializerIds.size === 1 || initializer === ownInitializer) {
        initializedValues = initializer.values;
      }

      if (initializer === ownInitializer) {
        initializationStatements = initializationStatements.concat(initializer.body.entries);
      } else {
        let ast = this.sharedInitializers.get(initializer.id);

        if (ast === undefined) {
          ast = this._conditionalInitialization(containingAdditionalFunction, initializer.values, initializer.body.entries); // We inline compact initializers, as calling a function would introduce too much
          // overhead. To determine if an initializer is compact, we count the number of
          // nodes in the AST, and check if it exceeds a certain threshold.
          // TODO #885: Study in more detail which threshold is the best compromise in terms of
          // code size and performance.

          let count = 0;
          (0, _traverseFast.default)(t.file(t.program([ast])), node => {
            count++;
            return false;
          });

          if (count > 24) {
            let id = this.locationService.createFunction(containingAdditionalFunction, [ast]);
            ast = t.expressionStatement(t.callExpression(id, []));
          }

          this.sharedInitializers.set(initializer.id, ast);
        }

        initializationStatements.push(ast);
      }
    }

    return this._conditionalInitialization(containingAdditionalFunction, initializedValues || [], initializationStatements);
  }

}

exports.ResidualFunctionInitializers = ResidualFunctionInitializers;
//# sourceMappingURL=ResidualFunctionInitializers.js.map

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.factorifyObjects = factorifyObjects;

var t = _interopRequireWildcard(__webpack_require__(21));

var _NameGenerator = __webpack_require__(240);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function isLiteral(node) {
  switch (node.type) {
    case "NullLiteral":
    case "BooleanLiteral":
    case "StringLiteral":
    case "NumericLiteral":
      return true;

    case "UnaryExpression":
      return node.operator === "void" && isLiteral(node.argument);

    default:
      return false;
  }
}

function isSameNode(left, right) {
  let type = left.type;

  if (type !== right.type) {
    return false;
  }

  if (type === "Identifier") {
    return left.name === right.name;
  }

  if (type === "NullLiteral") {
    return true;
  }

  if (type === "BooleanLiteral" || type === "StringLiteral" || type === "NumericLiteral") {
    return Object.is(left.value, right.value);
  }

  if (type === "UnaryExpression") {
    return left.operator === "void" && right.operator === "void" && isLiteral(left.argument) && isLiteral(right.argument);
  }

  return false;
}

function getObjectKeys(obj) {
  let keys = [];

  for (let prop of obj.properties) {
    if (prop.type !== "ObjectProperty") return false;
    let key = prop.key;

    if (key.type === "StringLiteral") {
      keys.push(key.value);
    } else if (key.type === "Identifier") {
      if (prop.computed) return false;
      keys.push(key.name);
    } else {
      return false;
    }
  }

  for (let key of keys) {
    if (key.indexOf("|") >= 0) return false;
  }

  return keys.join("|");
} // This function looks for recurring initialization patterns in the code of the form
//   var x = { a: literal1, b: literal2 }
//   var y = { a: literal1, b: literal3 }
// and transforms them into something like
//   function factory(b) { return { a: literal1, b } }
//   var x = factory(literal2);
//   var y = factory(literal3);
// TODO #884: Right now, the visitor below only looks into top-level variable declaration
// with a flat object literal initializer.
// It should also look into conditional control flow, residual functions, and nested object literals.


function factorifyObjects(body, factoryNameGenerator) {
  let signatures = Object.create(null);

  for (let node of body) {
    switch (node.type) {
      case "VariableDeclaration":
        for (let declar of node.declarations) {
          let {
            init
          } = declar;
          if (!init) continue;
          if (init.type !== "ObjectExpression") continue;
          let keys = getObjectKeys(init);
          if (!keys) continue;
          let initializerAstNodeName = "init";
          let declars = signatures[keys] = signatures[keys] || [];
          declars.push({
            declar,
            initializerAstNodeName
          });
        }

        break;

      case "ExpressionStatement":
        const expr = node.expression;

        if (expr.type !== "AssignmentExpression") {
          break;
        }

        const {
          right
        } = expr;

        if (right.type !== "ObjectExpression") {
          break;
        }

        let keys = getObjectKeys(right);
        if (!keys) continue;
        let initializerAstNodeName = "right";
        let declars = signatures[keys] = signatures[keys] || [];
        declars.push({
          declar: node.expression,
          initializerAstNodeName
        });
        break;

      default:
        // Continue to next node.
        break;
    }
  }

  for (let signatureKey in signatures) {
    let declars = signatures[signatureKey];
    if (declars.length < 5) continue;
    let keys = signatureKey.split("|");
    let rootFactoryParams = [];
    let rootFactoryProps = [];

    for (let keyIndex = 0; keyIndex < keys.length; keyIndex++) {
      let key = keys[keyIndex];
      let id = t.identifier(`__${keyIndex}`);
      rootFactoryParams.push(id);
      let keyNode = t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key);
      rootFactoryProps.push(t.objectProperty(keyNode, id));
    }

    let rootFactoryId = t.identifier(factoryNameGenerator.generate("root"));
    let rootFactoryBody = t.blockStatement([t.returnStatement(t.objectExpression(rootFactoryProps))]);
    let rootFactory = t.functionDeclaration(rootFactoryId, rootFactoryParams, rootFactoryBody);
    body.unshift(rootFactory);

    for (let _ref of declars) {
      let {
        declar,
        initializerAstNodeName
      } = _ref;
      let args = [];

      for (let prop of declar[initializerAstNodeName].properties) {
        args.push(prop.value);
      }

      declar[initializerAstNodeName] = t.callExpression(rootFactoryId, args);
    }

    let seen = new Set();

    for (let _ref2 of declars) {
      let {
        declar,
        initializerAstNodeName
      } = _ref2;
      if (seen.has(declar)) continue; // build up a map containing the arguments that are shared

      let common = [];
      let mostSharedArgsLength = 0;

      for (let _ref3 of declars) {
        let {
          declar: declar2,
          initializerAstNodeName: initializerAstNodeName2
        } = _ref3;
        if (seen.has(declar2)) continue;
        if (declar === declar2) continue;
        let sharedArgs = [];

        for (let i = 0; i < keys.length; i++) {
          if (isSameNode(declar[initializerAstNodeName].arguments[i], declar2[initializerAstNodeName2].arguments[i])) {
            sharedArgs.push(i);
          }
        }

        if (!sharedArgs.length) continue;
        mostSharedArgsLength = Math.max(mostSharedArgsLength, sharedArgs.length);
        common.push({
          declar: declar2,
          initializerAstNodeName: initializerAstNodeName2,
          sharedArgs
        });
      } // build up a mapping of the argument positions that are shared so we can pick the top one


      let sharedPairs = Object.create(null);

      for (let _ref4 of common) {
        let {
          declar: declar2,
          initializerAstNodeName: initializerAstNodeName2,
          sharedArgs
        } = _ref4;

        if (sharedArgs.length === mostSharedArgsLength) {
          sharedArgs = sharedArgs.join(",");
          let pair = sharedPairs[sharedArgs] = sharedPairs[sharedArgs] || [{
            declar,
            initializerAstNodeName
          }];
          pair.push({
            declar: declar2,
            initializerAstNodeName: initializerAstNodeName2
          });
        }
      } // get the highest pair


      let highestPairArgs;
      let highestPairCount;

      for (let pairArgs in sharedPairs) {
        let pair = sharedPairs[pairArgs];

        if (highestPairArgs === undefined || pair.length > highestPairCount) {
          highestPairCount = pair.length;
          highestPairArgs = pairArgs;
        }
      }

      if (highestPairArgs === undefined) continue;
      let declarsSub = sharedPairs[highestPairArgs];
      let removeArgs = highestPairArgs.split(",");
      let subFactoryArgs = [];
      let subFactoryParams = [];
      let sharedArgs = declar[initializerAstNodeName].arguments;

      for (let i = 0; i < sharedArgs.length; i++) {
        let arg = sharedArgs[i];

        if (removeArgs.indexOf(i + "") >= 0) {
          subFactoryArgs.push(arg);
        } else {
          let id = t.identifier(`__${i}`);
          subFactoryArgs.push(id);
          subFactoryParams.push(id);
        }
      }

      let subFactoryId = t.identifier(factoryNameGenerator.generate("sub"));
      let subFactoryBody = t.blockStatement([t.returnStatement(t.callExpression(rootFactoryId, subFactoryArgs))]);
      let subFactory = t.functionDeclaration(subFactoryId, subFactoryParams, subFactoryBody);
      body.unshift(subFactory);

      for (let _ref5 of declarsSub) {
        let {
          declar: declar2,
          initializerAstNodeName: initializerAstNodeName2
        } = _ref5;
        seen.add(declar2);
        let call = declar2[initializerAstNodeName2];
        call.callee = subFactoryId;
        call.arguments = call.arguments.filter(function (val, i) {
          return removeArgs.indexOf(i + "") < 0;
        });
      }
    }
  }
}
//# sourceMappingURL=factorify.js.map

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Referentializer = void 0;

var _environment = __webpack_require__(20);

var t = _interopRequireWildcard(__webpack_require__(21));

var _generator = _interopRequireDefault(__webpack_require__(335));

var _NameGenerator = __webpack_require__(240);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _statistics = __webpack_require__(407);

var _utils = __webpack_require__(413);

var _realm = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*
 * This class helps fixup names in residual functions for variables that these
 * functions capture from parent scopes.
 * For each ReferentializationScope it creates a _get_scope_binding function
 * that contains the initialization for all of that scope's FunctionInstances
 * which will contain a switch statement with all the initializations.
 */
class Referentializer {
  constructor(realm, options, scopeNameGenerator, scopeBindingNameGenerator, leakedNameGenerator, residualOptimizedFunctions) {
    this._options = options;
    this.scopeNameGenerator = scopeNameGenerator;
    this.scopeBindingNameGenerator = scopeBindingNameGenerator;
    this.referentializationState = new Map();
    this._leakedNameGenerator = leakedNameGenerator;
    this.realm = realm;
    this._residualOptimizedFunctions = residualOptimizedFunctions;
  }

  getStatistics() {
    (0, _invariant.default)(this.realm.statistics instanceof _statistics.SerializerStatistics, "serialization requires SerializerStatistics");
    return this.realm.statistics;
  }

  _createReferentializationState() {
    return {
      capturedScopeInstanceIdx: 0,
      capturedScopesArray: t.identifier(this.scopeNameGenerator.generate("main")),
      capturedScopeAccessFunctionId: t.identifier(this.scopeBindingNameGenerator.generate("get_scope_binding")),
      serializedScopes: new Map()
    };
  }

  _getReferentializationState(referentializationScope) {
    return (0, _utils.getOrDefault)(this.referentializationState, referentializationScope, this._createReferentializationState.bind(this));
  }

  createLeakedIds(referentializationScope) {
    const leakedIds = [];

    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;

    for (const scopeBinding of serializedScopes.values()) leakedIds.push(...scopeBinding.leakedIds);

    if (leakedIds.length === 0) return [];
    return [t.variableDeclaration("var", leakedIds.map(id => t.variableDeclarator(id)))];
  }

  createCapturedScopesPrelude(referentializationScope) {
    let accessFunctionDeclaration = this._createCaptureScopeAccessFunction(referentializationScope);

    if (accessFunctionDeclaration === undefined) return [];
    return [accessFunctionDeclaration, this._createCapturedScopesArrayInitialization(referentializationScope)];
  } // Generate a shared function for accessing captured scope bindings.
  // TODO: skip generating this function if the captured scope is not shared by multiple residual functions.


  _createCaptureScopeAccessFunction(referentializationScope) {
    // One switch case for one scope.
    const cases = [];

    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;

    const initializationCases = new Map();

    for (const scopeBinding of serializedScopes.values()) {
      if (scopeBinding.initializationValues.length === 0) continue;
      const expr = t.arrayExpression(scopeBinding.initializationValues);
      const key = (0, _generator.default)(expr, {}, "").code;

      if (!initializationCases.has(key)) {
        initializationCases.set(key, {
          scopeIDs: [scopeBinding.id],
          value: expr
        });
      } else {
        const ic = initializationCases.get(key);
        (0, _invariant.default)(ic);
        ic.scopeIDs.push(scopeBinding.id);
      }
    }

    if (initializationCases.size === 0) return undefined;
    const body = [];
    const selectorParam = t.identifier("__selector");
    const captured = t.identifier("__captured");

    const capturedScopesArray = this._getReferentializationState(referentializationScope).capturedScopesArray;

    const selectorExpression = t.memberExpression(capturedScopesArray, selectorParam,
    /*Indexer syntax*/
    true);

    for (const ic of initializationCases.values()) {
      ic.scopeIDs.forEach((id, i) => {
        let consequent = [];

        if (i === ic.scopeIDs.length - 1) {
          consequent = [t.expressionStatement(t.assignmentExpression("=", captured, ic.value)), t.breakStatement()];
        }

        cases.push(t.switchCase(t.numericLiteral(id), consequent));
      });
    } // Default case.


    if (this.realm.invariantLevel >= 1) {
      cases.push(t.switchCase(null, [t.throwStatement(t.newExpression(t.identifier("Error"), [t.stringLiteral("Unknown scope selector")]))]));
    }

    body.push(t.variableDeclaration("var", [t.variableDeclarator(captured)]));
    body.push(t.switchStatement(selectorParam, cases));
    body.push(t.expressionStatement(t.assignmentExpression("=", selectorExpression, captured)));
    body.push(t.returnStatement(captured));
    const factoryFunction = t.functionExpression(null, [selectorParam], t.blockStatement(body));

    const accessFunctionId = this._getReferentializationState(referentializationScope).capturedScopeAccessFunctionId;

    return t.variableDeclaration("var", [t.variableDeclarator(accessFunctionId, factoryFunction)]);
  }

  _getReferentializationScope(residualBinding) {
    if (residualBinding.potentialReferentializationScopes.has("GLOBAL")) return "GLOBAL";

    if (residualBinding.potentialReferentializationScopes.size > 1) {
      // Here we know potentialReferentializationScopes cannot contain "GLOBAL"; Set<FunctionValue> is
      // compatible with Set<FunctionValue | Generator>
      let scopes = residualBinding.potentialReferentializationScopes;

      let parentOptimizedFunction = this._residualOptimizedFunctions.tryGetOutermostOptimizedFunction(scopes);

      return parentOptimizedFunction || "GLOBAL";
    }

    for (let scope of residualBinding.potentialReferentializationScopes) return scope;

    (0, _invariant.default)(false);
  }

  _getSerializedBindingScopeInstance(residualBinding) {
    let declarativeEnvironmentRecord = residualBinding.declarativeEnvironmentRecord;
    (0, _invariant.default)(declarativeEnvironmentRecord);

    let referentializationScope = this._getReferentializationScope(residualBinding); // figure out if this is accessed only from additional functions


    let refState = this._getReferentializationState(referentializationScope);

    let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);

    if (!scope) {
      scope = {
        name: this.scopeNameGenerator.generate(),
        id: refState.capturedScopeInstanceIdx++,
        initializationValues: [],
        leakedIds: [],
        referentializationScope
      };
      refState.serializedScopes.set(declarativeEnvironmentRecord, scope);
    }

    (0, _invariant.default)(scope.referentializationScope === referentializationScope);
    (0, _invariant.default)(!residualBinding.scope || residualBinding.scope === scope);
    residualBinding.scope = scope;
    return scope;
  }

  getReferentializedScopeInitialization(scope, scopeName) {
    const capturedScope = scope.capturedScope;
    (0, _invariant.default)(capturedScope);

    const state = this._getReferentializationState(scope.referentializationScope);

    const funcName = state.capturedScopeAccessFunctionId;
    const scopeArray = state.capturedScopesArray; // First get scope array entry and check if it's already initialized.
    // Only if not yet, then call the initialization function.

    const init = t.logicalExpression("||", t.memberExpression(scopeArray, scopeName, true), t.callExpression(funcName, [scopeName]));
    return [t.variableDeclaration("var", [t.variableDeclarator(t.identifier(capturedScope), init)])];
  }

  referentializeLeakedBinding(residualBinding) {
    (0, _invariant.default)(residualBinding.hasLeaked); // When simpleClosures is enabled, then space for captured mutable bindings is allocated upfront.

    let serializedBindingId = t.identifier(this._leakedNameGenerator.generate(residualBinding.name));

    let scope = this._getSerializedBindingScopeInstance(residualBinding);

    scope.leakedIds.push(serializedBindingId);
    residualBinding.serializedValue = residualBinding.serializedUnscopedLocation = serializedBindingId;
    this.getStatistics().referentialized++;
  }

  referentializeModifiedBinding(residualBinding) {
    (0, _invariant.default)(residualBinding.modified); // Space for captured mutable bindings is allocated lazily.

    let scope = this._getSerializedBindingScopeInstance(residualBinding);

    let capturedScope = "__captured" + scope.name; // Save the serialized value for initialization at the top of
    // the factory.
    // This can serialize more variables than are necessary to execute
    // the function because every function serializes every
    // modified variable of its parent scope. In some cases it could be
    // an improvement to split these variables into multiple
    // scopes.

    const variableIndexInScope = scope.initializationValues.length;
    const indexExpression = t.numericLiteral(variableIndexInScope);
    (0, _invariant.default)(residualBinding.serializedValue);
    scope.initializationValues.push(residualBinding.serializedValue);
    scope.capturedScope = capturedScope; // Replace binding usage with scope references
    // The rewritten .serializedValue refers to a local capturedScope variable
    // which is only accessible from within residual functions where code
    // to create this variable is emitted.

    residualBinding.serializedValue = t.memberExpression(t.identifier(capturedScope), indexExpression, true // Array style access.
    ); // .serializedUnscopedLocation is initialized with a more general expressions
    // that can be used outside of residual functions.
    // TODO: Creating these expressions just in case looks expensive. Measure, and potentially only create lazily.

    const state = this._getReferentializationState(scope.referentializationScope);

    const funcName = state.capturedScopeAccessFunctionId;
    const scopeArray = state.capturedScopesArray; // First get scope array entry and check if it's already initialized.
    // Only if not yet, then call the initialization function.

    const scopeName = t.numericLiteral(scope.id);
    const capturedScopeExpression = t.logicalExpression("||", t.memberExpression(scopeArray, scopeName, true), t.callExpression(funcName, [scopeName]));
    residualBinding.serializedUnscopedLocation = t.memberExpression(capturedScopeExpression, indexExpression, true // Array style access.
    );
    this.getStatistics().referentialized++;
  } // Cleans all scopes between passes of the serializer


  cleanInstance(instance) {
    instance.initializationStatements = [];

    for (let b of instance.residualFunctionBindings.values()) {
      let binding = b;

      if (binding.referentialized && binding.declarativeEnvironmentRecord) {
        let declarativeEnvironmentRecord = binding.declarativeEnvironmentRecord;

        let referentializationScope = this._getReferentializationScope(binding);

        let refState = this.referentializationState.get(referentializationScope);

        if (refState) {
          let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);

          if (scope) {
            scope.initializationValues = [];
            scope.leakedIds = [];
          }
        }
      }

      delete binding.serializedValue;
    }
  }

  referentialize(instance) {
    let residualBindings = instance.residualFunctionBindings;

    for (let residualBinding of residualBindings.values()) {
      if (residualBinding === undefined) continue;

      if (residualBinding.modified) {
        // Initialize captured scope at function call instead of globally
        if (!residualBinding.declarativeEnvironmentRecord) residualBinding.referentialized = true;

        if (!residualBinding.referentialized) {
          if (!residualBinding.hasLeaked) this._getSerializedBindingScopeInstance(residualBinding);
          residualBinding.referentialized = true;
        }

        (0, _invariant.default)(residualBinding.referentialized);

        if (residualBinding.declarativeEnvironmentRecord && residualBinding.scope) {
          instance.scopeInstances.set(residualBinding.scope.name, residualBinding.scope);
        }
      }
    }
  }

  _createCapturedScopesArrayInitialization(referentializationScope) {
    return t.variableDeclaration("var", [t.variableDeclarator(this._getReferentializationState(referentializationScope).capturedScopesArray, t.newExpression(t.identifier("Array"), [t.numericLiteral(this._getReferentializationState(referentializationScope).capturedScopeInstanceIdx)]))]);
  }

}

exports.Referentializer = Referentializer;
//# sourceMappingURL=Referentializer.js.map

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emitter = void 0;

var _index = __webpack_require__(10);

var _generator = __webpack_require__(237);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _types = __webpack_require__(408);

var _ResidualFunctions = __webpack_require__(434);

var _utils = __webpack_require__(291);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// The emitter keeps track of a stack of what's currently being emitted.
// There are two kinds of interesting dependencies the emitter is dealing with:
// 1. Value dependencies:
//    If an emission task depends on the result of another emission task which
//    is still currently being emitted, then the emission task must be performed later,
//    once the dependency is available.
//    To this end, the emitter maintains the `_activeValues` and `_waitingForValues` datastructures.
// 2. Generator dependencies:
//    For each generator, there's a corresponding "body", i.e. a stream of babel statements
//    that the emitter is appending to.
//    There's always a "current" body that is currently being emitted to.
//    There's also a distinguished `mainBody` to which all statements get directly or indirectly appended.
//    If there are multiple generators/bodies involved, then they form a stack.
//    Nested bodies are usually composed into an instruction emitted to the outer body.
//    For example, two nested generators may yield the then and else-branch of an `if` statement.
//    When an emission is supposed to target a body that is the current body, i.e. when it sits
//    lower on the stack, then the emission task gets delayed until the next emission task on
//    the lower body entry is finished.
//    To this end, the emitter maintains the `_activeGeneratorStack` and `_waitingForBodies` datastructures.
class Emitter {
  constructor(residualFunctions, referencedDeclaredValues, conditionalFeasibility, derivedIds) {
    this._mainBody = {
      type: "MainGenerator",
      parentBody: undefined,
      entries: [],
      done: false
    };
    this._waitingForValues = new Map();
    this._waitingForBodies = new Map();
    this._body = this._mainBody;
    this._residualFunctions = residualFunctions;
    this._activeStack = [];
    this._activeValues = new Set();
    this._activeGeneratorStack = [this._mainBody];
    this._finalized = false;

    let mustWaitForValue = val => {
      if (this.cannotDeclare()) return false;
      if (this.hasBeenDeclared(val)) return false;
      let activeOptimizedFunction = this.getActiveOptimizedFunction();
      if (activeOptimizedFunction === undefined) return true;
      let optimizedFunctionWhereValueWasDeclared = referencedDeclaredValues.get(val);
      return optimizedFunctionWhereValueWasDeclared === activeOptimizedFunction;
    };

    this._getReasonToWaitForDependenciesCallbacks = {
      onActive: val => val,
      // cyclic dependency; we need to wait until this value has finished emitting
      onFunction: val => {
        // Functions are currently handled in a special way --- they are all defined ahead of time. Thus, we never have to wait for functions.
        this._residualFunctions.addFunctionUsage(val, this.getBodyReference());

        return undefined;
      },
      onAbstractValueWithIdentifier: val => derivedIds.has(val.getIdentifier()) && mustWaitForValue(val) ? val : undefined,
      onIntrinsicDerivedObject: val => mustWaitForValue(val) ? val : undefined
    };
    this._conditionalFeasibility = conditionalFeasibility;
  }

  // Begin to emit something. Such sessions can be nested.
  // The dependency indicates what is being emitted; until this emission ends, other parties might have to wait for the dependency.
  // The targetBody is a wrapper that holds the sequence of statements that are going to be emitted.
  // If isChild, then we are starting a new emitting session as a branch off the previously active emitting session.
  beginEmitting(dependency, targetBody, isChild = false) {
    (0, _invariant.default)(!this._finalized);
    (0, _invariant.default)(targetBody.type === "OptimizedFunction" === !!targetBody.optimizedFunction);

    this._activeStack.push(dependency);

    if (dependency instanceof _index.Value) {
      (0, _invariant.default)(!this._activeValues.has(dependency));

      this._activeValues.add(dependency);
    } else if (dependency instanceof _generator.Generator) {
      (0, _invariant.default)(!this._activeGeneratorStack.includes(targetBody));

      this._activeGeneratorStack.push(targetBody);
    }

    if (isChild) {
      targetBody.parentBody = this._body;
      targetBody.nestingLevel = (this._body.nestingLevel || 0) + 1;
    }

    let oldBody = this._body;
    this._body = targetBody;
    return oldBody;
  }

  emit(statement) {
    (0, _invariant.default)(!this._finalized);

    this._body.entries.push(statement);

    this._processCurrentBody();
  }

  finalizeCurrentBody() {
    (0, _invariant.default)(!this._finalized);

    this._processCurrentBody();
  } // End to emit something. The parameters dependency and isChild must match a previous call to beginEmitting.
  // oldBody should be the value returned by the previous matching beginEmitting call.
  // valuesToProcess is filled with values that have been newly declared since the last corresponding beginEmitting call;
  // other values not yet have been emitted as they might be waiting for valuesToProcess;
  // processValues(valuesToProcess) should be called once the returned body has been embedded in the outer context.


  endEmitting(dependency, oldBody, valuesToProcess, isChild = false) {
    (0, _invariant.default)(!this._finalized);

    let lastDependency = this._activeStack.pop();

    (0, _invariant.default)(dependency === lastDependency);

    if (dependency instanceof _index.Value) {
      (0, _invariant.default)(this._activeValues.has(dependency));

      this._activeValues.delete(dependency);

      this._processValue(dependency);
    } else if (dependency instanceof _generator.Generator) {
      (0, _invariant.default)(this._isEmittingActiveGenerator());

      this._activeGeneratorStack.pop();
    }

    let lastBody = this._body;
    this._body = oldBody;

    if (isChild) {
      (0, _invariant.default)(lastBody.parentBody === oldBody);
      (0, _invariant.default)((lastBody.nestingLevel || 0) > 0);
      (0, _invariant.default)(!lastBody.done);
      lastBody.done = true; // When we are done processing a body, we can propogate all declared abstract values
      // to its parent, possibly unlocking further processing...

      if (lastBody.declaredValues) {
        let anyPropagated = true;

        for (let b = lastBody; b.done && b.parentBody !== undefined && anyPropagated; b = b.parentBody) {
          anyPropagated = false;
          let parentDeclaredValues = b.parentBody.declaredValues;
          if (parentDeclaredValues === undefined) b.parentBody.declaredValues = parentDeclaredValues = new Map();
          (0, _invariant.default)(b.declaredValues);

          for (let [key, value] of b.declaredValues) {
            if (!parentDeclaredValues.has(key)) {
              parentDeclaredValues.set(key, value);
              if (valuesToProcess !== undefined) valuesToProcess.add(key);
              anyPropagated = true;
            }
          }
        }
      }
    }

    return lastBody;
  }

  processValues(valuesToProcess) {
    for (let value of valuesToProcess) this._processValue(value);
  }

  finalize() {
    (0, _invariant.default)(!this._finalized);
    (0, _invariant.default)(this._activeGeneratorStack.length === 1);
    (0, _invariant.default)(this._activeGeneratorStack[0] === this._body);
    (0, _invariant.default)(this._body === this._mainBody);

    this._processCurrentBody();

    this._activeGeneratorStack.pop();

    this._finalized = true;
    (0, _invariant.default)(this._waitingForBodies.size === 0);
    (0, _invariant.default)(this._waitingForValues.size === 0);
    (0, _invariant.default)(this._activeStack.length === 0);
    (0, _invariant.default)(this._activeValues.size === 0);
    (0, _invariant.default)(this._activeGeneratorStack.length === 0);
  }
  /**
   * Emitter is emitting in two modes:
   * 1. Emitting to entries in current active generator
   * 2. Emitting to body of another scope(generator or residual function)
   * This function checks the first condition above.
   */


  _isEmittingActiveGenerator() {
    (0, _invariant.default)(this._activeGeneratorStack.length > 0);
    return this._activeGeneratorStack[this._activeGeneratorStack.length - 1] === this._body;
  }

  _isGeneratorBody(body) {
    return body.type === "MainGenerator" || body.type === "Generator" || body.type === "OptimizedFunction";
  }

  _processCurrentBody() {
    if (!this._isEmittingActiveGenerator() || this._body.processing) {
      return;
    }

    let a = this._waitingForBodies.get(this._body);

    if (a === undefined) return;
    this._body.processing = true;

    while (a.length > 0) {
      let {
        dependencies,
        func
      } = a.shift();
      this.emitNowOrAfterWaitingForDependencies(dependencies, func, this._body);
    }

    this._waitingForBodies.delete(this._body);

    this._body.processing = false;
  }

  _processValue(value) {
    let a = this._waitingForValues.get(value);

    if (a === undefined) return;
    let currentBody = this._body;

    while (a.length > 0) {
      let {
        body,
        dependencies,
        func
      } = a.shift(); // If body is not generator body no need to wait for it.

      if (this._isGeneratorBody(body) && body !== currentBody) {
        this._emitAfterWaitingForGeneratorBody(body, dependencies, func);
      } else {
        this.emitNowOrAfterWaitingForDependencies(dependencies, func, body);
      }
    }

    this._waitingForValues.delete(value);
  } // Find the first ancestor in input generator body stack that is in current active stack.
  // It can always find one because the bottom one in the stack is the main generator.


  _getFirstAncestorGeneratorWithActiveBody(bodyStack) {
    const activeBody = bodyStack.slice().reverse().find(body => this._activeGeneratorStack.includes(body));
    (0, _invariant.default)(activeBody);
    return activeBody;
  } // Serialization of a statement related to a value MUST be delayed if
  // the creation of the value's identity requires the availability of either:
  // 1. a value that is also currently being serialized
  //    (tracked by `_activeValues`).
  // 2. a time-dependent value that is declared by some generator entry
  //    that has not yet been processed
  //    (tracked by `declaredValues` in bodies)


  getReasonToWaitForDependencies(dependencies) {
    return this.dependenciesVisitor(dependencies, this._getReasonToWaitForDependenciesCallbacks);
  } // Visitor of dependencies that require delaying serialization


  dependenciesVisitor(dependencies, callbacks) {
    (0, _invariant.default)(!this._finalized);
    let result;

    let recurse = value => this.dependenciesVisitor(value, callbacks);

    if (Array.isArray(dependencies)) {
      let values = dependencies;

      for (let value of values) {
        result = recurse(value);
        if (result !== undefined) return result;
      }

      return undefined;
    }

    let val = dependencies;

    if (this._activeValues.has(val)) {
      // If a value is active and it's a function, then we still shouldn't wait on it.
      if (val instanceof _index.FunctionValue && !(val instanceof _index.BoundFunctionValue)) {
        // We ran into a function value.
        result = callbacks.onFunction ? callbacks.onFunction(val) : undefined;
        return result;
      } // We ran into a cyclic dependency, where the value we are dependending on is still in the process of being emitted.


      result = callbacks.onActive ? callbacks.onActive(val) : undefined;
      if (result !== undefined) return result;
    }

    if (val instanceof _index.BoundFunctionValue) {
      result = recurse(val.$BoundTargetFunction);
      if (result !== undefined) return result;
      result = recurse(val.$BoundThis);
      if (result !== undefined) return result;
      result = recurse(val.$BoundArguments);
      if (result !== undefined) return result;
    } else if (val instanceof _index.FunctionValue) {
      // We ran into a function value.
      result = callbacks.onFunction ? callbacks.onFunction(val) : undefined;
      if (result !== undefined) return result;
    } else if (val instanceof _index.AbstractValue) {
      if (val.hasIdentifier()) {
        // We ran into an abstract value that might have to be declared.
        result = callbacks.onAbstractValueWithIdentifier ? callbacks.onAbstractValueWithIdentifier(val) : undefined;
        if (result !== undefined) return result;
      }

      let argsToRecurse;

      if (val.kind === "conditional") {
        let cf = this._conditionalFeasibility.get(val);

        (0, _invariant.default)(cf !== undefined);
        argsToRecurse = [];
        if (cf.t && cf.f) argsToRecurse.push(val.args[0]);
        if (cf.t) argsToRecurse.push(val.args[1]);
        if (cf.f) argsToRecurse.push(val.args[2]);
      } else argsToRecurse = val.args;

      result = recurse(argsToRecurse);
      if (result !== undefined) return result;
    } else if (val instanceof _index.ProxyValue) {
      result = recurse(val.$ProxyTarget);
      if (result !== undefined) return result;
      result = recurse(val.$ProxyHandler);
      if (result !== undefined) return result;
    } else if (val instanceof _index.SymbolValue) {
      if (val.$Description instanceof _index.Value) {
        result = recurse(val.$Description);
        if (result !== undefined) return result;
      }
    } else if (val instanceof _index.ObjectValue && _index.ObjectValue.isIntrinsicDerivedObject(val)) {
      result = callbacks.onIntrinsicDerivedObject ? callbacks.onIntrinsicDerivedObject(val) : undefined;
      if (result !== undefined) return result;
    } else if (val instanceof _index.ObjectValue) {
      let kind = val.getKind();

      switch (kind) {
        case "Object":
          let proto = val.$Prototype;

          if (proto instanceof _index.ObjectValue && // if this is falsy, prototype chain might be cyclic
          proto.usesOrdinaryObjectInternalPrototypeMethods()) {
            result = recurse(val.$Prototype);
            if (result !== undefined) return result;
          }

          break;

        case "Date":
          (0, _invariant.default)(val.$DateValue !== undefined);
          result = recurse(val.$DateValue);
          if (result !== undefined) return result;
          break;

        case "ReactElement":
          let realm = val.$Realm;
          let type = (0, _utils.getProperty)(realm, val, "type");
          let props = (0, _utils.getProperty)(realm, val, "props");
          let key = (0, _utils.getProperty)(realm, val, "key");
          let ref = (0, _utils.getProperty)(realm, val, "ref");
          result = recurse(type);
          if (result !== undefined) return result;
          result = recurse(props);
          if (result !== undefined) return result;
          result = recurse(key);
          if (result !== undefined) return result;
          result = recurse(ref);
          if (result !== undefined) return result;
          break;

        default:
          break;
      }
    }

    return undefined;
  } // Wait for a known-to-be active value if a condition is met.


  getReasonToWaitForActiveValue(value, condition) {
    (0, _invariant.default)(!this._finalized);
    (0, _invariant.default)(this._activeValues.has(value));
    return condition ? value : undefined;
  }

  emitAfterWaiting(delayReason, dependencies, func, targetBody) {
    if (delayReason === undefined && this._isGeneratorBody(targetBody)) {
      delayReason = targetBody;
    }

    if (delayReason === undefined || delayReason === this._body) {
      if (targetBody === this._body) {
        // Emit into current body.
        func();
      } else {
        (0, _invariant.default)(!this._isGeneratorBody(targetBody)); // TODO: Check if effects really don't matter here,
        // since we are going to emit something in an out-of-band body
        // that might depend on applied effects.

        const oldBody = this.beginEmitting(targetBody.type, targetBody);
        func();
        this.endEmitting(targetBody.type, oldBody);
      }
    } else {
      (0, _invariant.default)(delayReason !== undefined);

      if (delayReason instanceof _index.Value) {
        this._emitAfterWaitingForValue(delayReason, dependencies, targetBody, func);
      } else if (this._isGeneratorBody(delayReason)) {
        // delayReason is a generator body.
        this._emitAfterWaitingForGeneratorBody(delayReason, dependencies, func);
      } else {
        // Unknown delay reason.
        (0, _invariant.default)(false);
      }
    }
  }

  _emitAfterWaitingForValue(reason, dependencies, targetBody, func) {
    (0, _invariant.default)(!this._finalized);
    (0, _invariant.default)(!(reason instanceof _index.AbstractValue && this.hasBeenDeclared(reason)) || this._activeValues.has(reason));

    let a = this._waitingForValues.get(reason);

    if (a === undefined) this._waitingForValues.set(reason, a = []);
    a.push({
      body: targetBody,
      dependencies,
      func
    });
  }

  _emitAfterWaitingForGeneratorBody(reason, dependencies, func) {
    (0, _invariant.default)(this._isGeneratorBody(reason));
    (0, _invariant.default)(!this._finalized);
    (0, _invariant.default)(this._activeGeneratorStack.includes(reason));

    let b = this._waitingForBodies.get(reason);

    if (b === undefined) {
      this._waitingForBodies.set(reason, b = []);
    }

    b.push({
      dependencies,
      func
    });
  }

  emitNowOrAfterWaitingForDependencies(dependencies, func, targetBody) {
    this.emitAfterWaiting(this.getReasonToWaitForDependencies(dependencies), dependencies, func, targetBody);
  }

  declare(value) {
    (0, _invariant.default)(!this._finalized);
    (0, _invariant.default)(!this._activeValues.has(value));
    (0, _invariant.default)(value instanceof _index.ObjectValue || value.hasIdentifier());
    (0, _invariant.default)(this._isEmittingActiveGenerator());
    (0, _invariant.default)(!this.cannotDeclare());
    (0, _invariant.default)(!this._body.done);
    if (this._body.declaredValues === undefined) this._body.declaredValues = new Map();

    this._body.declaredValues.set(value, this._body);

    this._processValue(value);
  }

  getActiveOptimizedFunction() {
    // Whether we are directly or indirectly emitting to an optimized function
    for (let b = this._body; b !== undefined; b = b.parentBody) if (b.type === "OptimizedFunction") return b.optimizedFunction;

    return undefined;
  }

  cannotDeclare() {
    // Bodies of the following types will never contain any (temporal) abstract value declarations.
    return this._body.type === "DelayInitializations" || this._body.type === "LazyObjectInitializer";
  }

  hasBeenDeclared(value) {
    return this.getDeclarationBody(value) !== undefined;
  }

  getDeclarationBody(value) {
    for (let b = this._body; b !== undefined; b = b.parentBody) {
      if (b.declaredValues !== undefined && b.declaredValues.has(value)) {
        return b;
      }
    }

    return undefined;
  }

  declaredCount() {
    let declaredValues = this._body.declaredValues;
    return declaredValues === undefined ? 0 : declaredValues.size;
  }

  getBody() {
    return this._body;
  }

  isCurrentBodyOffspringOf(targetBody) {
    let currentBody = this._body;

    while (currentBody !== undefined) {
      if (currentBody === targetBody) {
        return true;
      }

      currentBody = currentBody.parentBody;
    }

    return false;
  }

  getBodyReference() {
    (0, _invariant.default)(!this._finalized);
    return new _types.BodyReference(this._body, this._body.entries.length);
  }

}

exports.Emitter = Emitter;
//# sourceMappingURL=Emitter.js.map

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapValueIdentifiers = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// This class maintains a map of values to babel identifiers.
// This class can optionally track how often such value identifiers are referenced
// when pass 1 is activated, which is usually followed by pass 2 in which
// unneeded identifiers (those which were only ever referenced once) are
// eliminated as the defining expression can be inlined.
class ResidualHeapValueIdentifiers {
  constructor(values, preludeGenerator) {
    this.collectValToRefCountOnly = false;
    this._valueNameGenerator = preludeGenerator.createNameGenerator("_");

    this._populateIdentifierMap(values);
  }

  initPass1() {
    this.collectValToRefCountOnly = true;
    this.valToRefCount = new Map();
  }

  initPass2() {
    this.collectValToRefCountOnly = false;
  }

  _populateIdentifierMap(values) {
    this.refs = new Map();

    for (const val of values) {
      this._setIdentifier(val, this._createNewIdentifier(val));
    }
  }

  _createNewIdentifier(val) {
    const name = this._valueNameGenerator.generate(val.__originalName || "");

    return t.identifier(name);
  }

  _setIdentifier(val, id) {
    (0, _invariant.default)(!this.refs.has(val));
    this.refs.set(val, id);
  }

  hasIdentifier(val) {
    return this.refs.has(val);
  }

  getIdentifier(val) {
    let id = this.refs.get(val);
    (0, _invariant.default)(id !== undefined);
    return id;
  }

  deleteIdentifier(val) {
    (0, _invariant.default)(this.refs.has(val));
    this.refs.delete(val);
  }

  getIdentifierAndIncrementReferenceCount(val) {
    this.incrementReferenceCount(val);
    let id = this.refs.get(val);
    (0, _invariant.default)(id !== undefined, "Value Id cannot be null or undefined");
    return id;
  }

  incrementReferenceCount(val) {
    if (this.collectValToRefCountOnly) {
      let valToRefCount = this.valToRefCount;
      (0, _invariant.default)(valToRefCount !== undefined);
      let refCount = valToRefCount.get(val);

      if (refCount !== undefined) {
        refCount++;
      } else {
        refCount = 1;
      }

      valToRefCount.set(val, refCount);
    }
  }

  needsIdentifier(val) {
    if (this.collectValToRefCountOnly || this.valToRefCount === undefined) return true;
    let refCount = this.valToRefCount.get(val);
    (0, _invariant.default)(refCount !== undefined && refCount > 0);
    return refCount !== 1;
  }

}

exports.ResidualHeapValueIdentifiers = ResidualHeapValueIdentifiers;
//# sourceMappingURL=ResidualHeapValueIdentifiers.js.map

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualReactElementSerializer = void 0;

var _realm = __webpack_require__(7);

var _ResidualHeapSerializer = __webpack_require__(433);

var _hoisting = __webpack_require__(428);

var t = _interopRequireWildcard(__webpack_require__(21));

var _index = __webpack_require__(10);

var _jsx = __webpack_require__(436);

var _logger = __webpack_require__(412);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _errors = __webpack_require__(3);

var _elements = __webpack_require__(420);

var _utils = __webpack_require__(291);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class ResidualReactElementSerializer {
  constructor(realm, residualHeapSerializer, residualOptimizedFunctions) {
    this.realm = realm;
    this.residualHeapSerializer = residualHeapSerializer;
    this.logger = residualHeapSerializer.logger;
    this.reactOutput = realm.react.output || "create-element";
    this._lazilyHoistedNodes = new Map();
    this._residualOptimizedFunctions = residualOptimizedFunctions;
  }

  _createReactElement(value) {
    return {
      attributes: [],
      children: [],
      declared: false,
      type: undefined,
      value
    };
  }

  _createReactElementAttribute() {
    return {
      expr: undefined,
      key: undefined,
      type: "PENDING"
    };
  }

  _createReactElementChild() {
    return {
      expr: undefined,
      type: "PENDING"
    };
  }

  _emitHoistedReactElement(reactElement, id, reactElementAst, hoistedCreateElementIdentifier, originalCreateElementIdentifier) {
    // if the currentHoistedReactElements is not defined, we create it an emit the function call
    // this should only occur once per additional function
    const optimizedFunction = this._residualOptimizedFunctions.tryGetOptimizedFunctionRoot(reactElement);

    (0, _invariant.default)(optimizedFunction);

    let lazilyHoistedNodes = this._lazilyHoistedNodes.get(optimizedFunction);

    if (lazilyHoistedNodes === undefined) {
      let funcId = t.identifier(this.residualHeapSerializer.functionNameGenerator.generate());
      lazilyHoistedNodes = {
        id: funcId,
        createElementIdentifier: hoistedCreateElementIdentifier,
        nodes: []
      };

      this._lazilyHoistedNodes.set(optimizedFunction, lazilyHoistedNodes);

      let statement = t.expressionStatement(t.logicalExpression("&&", t.binaryExpression("===", id, t.unaryExpression("void", t.numericLiteral(0), true)), // pass the createElementIdentifier if it's not null
      t.callExpression(funcId, originalCreateElementIdentifier ? [originalCreateElementIdentifier] : [])));
      this.residualHeapSerializer.getPrelude(optimizedFunction).push(statement);
    } // we then push the reactElement and its id into our list of elements to process after
    // the current additional function has serialzied


    lazilyHoistedNodes.nodes.push({
      id,
      astNode: reactElementAst
    });
  }

  _getReactLibraryValue() {
    let reactLibraryObject = this.realm.fbLibraries.react; // if there is no React library, then we should throw and error

    if (reactLibraryObject === undefined) {
      throw new _errors.FatalError("unable to find React library reference in scope");
    }

    return reactLibraryObject;
  }

  _getReactCreateElementValue() {
    let reactLibraryObject = this._getReactLibraryValue();

    return (0, _utils.getProperty)(this.realm, reactLibraryObject, "createElement");
  }

  _emitReactElement(reactElement) {
    let {
      value
    } = reactElement;
    let typeValue = (0, _utils.getProperty)(this.realm, value, "type");
    let keyValue = (0, _utils.getProperty)(this.realm, value, "key");
    let refValue = (0, _utils.getProperty)(this.realm, value, "ref");
    let propsValue = (0, _utils.getProperty)(this.realm, value, "props");
    let shouldHoist = this._residualOptimizedFunctions.tryGetOptimizedFunctionRoot(value) !== undefined && (0, _hoisting.canHoistReactElement)(this.realm, value);
    let id = this.residualHeapSerializer.getSerializeObjectIdentifier(value); // this identifier is used as the deafult, but also passed to the hoisted factory function

    let originalCreateElementIdentifier = null; // this name is used when hoisting, and is passed into the factory function, rather than the original

    let hoistedCreateElementIdentifier = null;
    let reactElementAstNode;
    let dependencies = [typeValue, keyValue, refValue, propsValue, value];
    let createElement;

    if (this.reactOutput === "create-element") {
      createElement = this._getReactCreateElementValue();
      dependencies.push(createElement);
    }

    this.residualHeapSerializer.emitter.emitNowOrAfterWaitingForDependencies(dependencies, () => {
      if (this.reactOutput === "jsx") {
        reactElementAstNode = this._serializeReactElementToJSXElement(value, reactElement);
      } else if (this.reactOutput === "create-element") {
        originalCreateElementIdentifier = this.residualHeapSerializer.serializeValue(createElement);

        if (shouldHoist) {
          const optimizedFunction = this._residualOptimizedFunctions.tryGetOptimizedFunctionRoot(value);

          (0, _invariant.default)(optimizedFunction);

          const lazilyHoistedNodes = this._lazilyHoistedNodes.get(optimizedFunction); // if we haven't created a lazilyHoistedNodes before, then this is the first time
          // so we only create the hoisted identifier once


          if (lazilyHoistedNodes === undefined) {
            // create a new unique instance
            hoistedCreateElementIdentifier = t.identifier(this.residualHeapSerializer.intrinsicNameGenerator.generate());
          } else {
            hoistedCreateElementIdentifier = lazilyHoistedNodes.createElementIdentifier;
          }
        }

        let createElementIdentifier = shouldHoist ? hoistedCreateElementIdentifier : originalCreateElementIdentifier;
        reactElementAstNode = this._serializeReactElementToCreateElement(value, reactElement, createElementIdentifier);
      } else {
        (0, _invariant.default)(false, "Unknown reactOutput specified");
      } // if we are hoisting this React element, put the assignment in the body
      // also ensure we are in an additional function


      if (shouldHoist) {
        this._emitHoistedReactElement(value, id, reactElementAstNode, hoistedCreateElementIdentifier, originalCreateElementIdentifier);
      } else {
        // Note: it can be expected that we assign to the same variable multiple times
        // this is due to fact ReactElements are immutable objects and the fact that
        // when we inline/fold logic, the same ReactElements are referenced at different
        // points with different attributes. Given we can't mutate an immutable object,
        // we instead create new objects and assign to the same binding
        if (reactElement.declared) {
          this.residualHeapSerializer.emitter.emit(t.expressionStatement(t.assignmentExpression("=", id, reactElementAstNode)));
        } else {
          reactElement.declared = true;
          this.residualHeapSerializer.emitter.emit(t.variableDeclaration("var", [t.variableDeclarator(id, reactElementAstNode)]));
        }
      }
    }, this.residualHeapSerializer.emitter.getBody());
    return id;
  }

  _serializeNowOrAfterWaitingForDependencies(value, reactElement, func, shouldSerialize = true) {
    let reason = this.residualHeapSerializer.emitter.getReasonToWaitForDependencies(value);

    const serialize = () => {
      func();
    };

    if (reason) {
      this.residualHeapSerializer.emitter.emitAfterWaiting(reason, [value], () => {
        serialize();

        this._emitReactElement(reactElement);
      }, this.residualHeapSerializer.emitter.getBody());
    } else {
      serialize();
    }
  }

  _serializeReactFragmentType(typeValue) {
    let reactLibraryObject = this._getReactLibraryValue();

    return t.memberExpression(this.residualHeapSerializer.serializeValue(reactLibraryObject), t.identifier("Fragment"));
  }

  serializeReactElement(val) {
    let reactElementData = this.realm.react.reactElements.get(val);
    (0, _invariant.default)(reactElementData !== undefined);
    let {
      firstRenderOnly
    } = reactElementData;

    let reactElement = this._createReactElement(val);

    (0, _elements.traverseReactElement)(this.realm, reactElement.value, {
      visitType: typeValue => {
        this._serializeNowOrAfterWaitingForDependencies(typeValue, reactElement, () => {
          let expr;

          if (typeValue instanceof _index.SymbolValue && typeValue === (0, _utils.getReactSymbol)("react.fragment", this.realm)) {
            expr = this._serializeReactFragmentType(typeValue);
          } else {
            expr = this.residualHeapSerializer.serializeValue(typeValue); // Increment ref count one more time to ensure that this object will be assigned a unique id.
            // Abstract values that are emitted as first argument to JSX elements needs a proper id.

            this.residualHeapSerializer.residualHeapValueIdentifiers.incrementReferenceCount(typeValue);
          }

          reactElement.type = expr;
        });
      },
      visitKey: keyValue => {
        let reactElementKey = this._createReactElementAttribute();

        this._serializeNowOrAfterWaitingForDependencies(keyValue, reactElement, () => {
          let expr = this.residualHeapSerializer.serializeValue(keyValue);
          reactElementKey.expr = expr;
          reactElementKey.key = "key";
          reactElementKey.type = "PROPERTY";
        });

        reactElement.attributes.push(reactElementKey);
      },
      visitRef: refValue => {
        if (!firstRenderOnly) {
          let reactElementRef = this._createReactElementAttribute();

          this._serializeNowOrAfterWaitingForDependencies(refValue, reactElement, () => {
            let expr = this.residualHeapSerializer.serializeValue(refValue);
            reactElementRef.expr = expr;
            reactElementRef.key = "ref";
            reactElementRef.type = "PROPERTY";
          });

          reactElement.attributes.push(reactElementRef);
        }
      },
      visitAbstractOrPartialProps: propsValue => {
        let reactElementSpread = this._createReactElementAttribute();

        this._serializeNowOrAfterWaitingForDependencies(propsValue, reactElement, () => {
          let expr = this.residualHeapSerializer.serializeValue(propsValue);
          reactElementSpread.expr = expr;
          reactElementSpread.type = "SPREAD";
        });

        reactElement.attributes.push(reactElementSpread);
      },
      visitConcreteProps: propsValue => {
        for (let [propName, binding] of propsValue.properties) {
          if (binding.descriptor === undefined || propName === "children") {
            continue;
          }

          let propValue = (0, _utils.getProperty)(this.realm, propsValue, propName);

          if ((0, _utils.canExcludeReactElementObjectProperty)(this.realm, val, propName, propValue)) {
            continue;
          }

          let reactElementAttribute = this._createReactElementAttribute();

          this._serializeNowOrAfterWaitingForDependencies(propValue, reactElement, () => {
            let expr = this.residualHeapSerializer.serializeValue(propValue);
            reactElementAttribute.expr = expr;
            reactElementAttribute.key = propName;
            reactElementAttribute.type = "PROPERTY";
          });

          reactElement.attributes.push(reactElementAttribute);
        }
      },
      visitChildNode: childValue => {
        reactElement.children.push(this._serializeReactElementChild(childValue, reactElement));
      }
    });
    return this._emitReactElement(reactElement);
  }

  _addSerializedValueToJSXAttriutes(prop, expr, attributes) {
    if (prop === null) {
      attributes.push(t.jSXSpreadAttribute(expr));
    } else {
      attributes.push((0, _jsx.convertKeyValueToJSXAttribute)(prop, expr));
    }
  }

  _serializeReactElementToCreateElement(val, reactElement, createElementIdentifier) {
    let {
      type,
      attributes,
      children
    } = reactElement;
    let createElementArguments = [type]; // check if we need to add attributes

    if (attributes.length !== 0) {
      let astAttributes = [];

      for (let attribute of attributes) {
        let expr = attribute.expr;

        if (attribute.type === "SPREAD") {
          astAttributes.push(t.spreadElement(expr));
        } else if (attribute.type === "PROPERTY") {
          let attributeKey = attribute.key;
          let key;
          (0, _invariant.default)(typeof attributeKey === "string");

          if (attributeKey.includes("-")) {
            key = t.stringLiteral(attributeKey);
          } else {
            key = t.identifier(attributeKey);
          }

          astAttributes.push(t.objectProperty(key, expr));
        }
      }

      createElementArguments.push(t.objectExpression(astAttributes));
    }

    if (children.length !== 0) {
      if (attributes.length === 0) {
        createElementArguments.push(t.nullLiteral());
      }

      let astChildren = [];

      for (let child of children) {
        let expr = child.expr;

        if (child.type === "NORMAL") {
          astChildren.push(expr);
        }
      }

      createElementArguments.push(...astChildren);
    } // cast to any for createElementArguments as casting it to BabelNodeExpresion[] isn't working


    let createElementCall = t.callExpression(createElementIdentifier, createElementArguments);

    this._addBailOutMessageToBabelNode(val, createElementCall);

    return createElementCall;
  }

  _serializeReactElementToJSXElement(val, reactElement) {
    let {
      type,
      attributes,
      children
    } = reactElement;
    let jsxTypeIdentifer = (0, _jsx.convertExpressionToJSXIdentifier)(type, true);
    let astAttributes = [];

    for (let attribute of attributes) {
      let expr = attribute.expr;

      if (attribute.type === "SPREAD") {
        astAttributes.push(t.jSXSpreadAttribute(expr));
      } else if (attribute.type === "PROPERTY") {
        let attributeKey = attribute.key;
        (0, _invariant.default)(typeof attributeKey === "string");
        astAttributes.push((0, _jsx.convertKeyValueToJSXAttribute)(attributeKey, expr));
      }
    }

    let astChildren = [];

    for (let child of children) {
      let expr = child.expr;

      if (child.type === "NORMAL") {
        if (t.isStringLiteral(expr) || t.isNumericLiteral(expr)) {
          astChildren.push(t.jSXText(expr.value + ""));
        } else if (t.isJSXElement(expr)) {
          astChildren.push(expr);
        } else {
          astChildren.push(t.jSXExpressionContainer(expr));
        }
      }
    }

    let openingElement = t.jSXOpeningElement(jsxTypeIdentifer, astAttributes, astChildren.length === 0);
    let closingElement = t.jSXClosingElement(jsxTypeIdentifer);
    let jsxElement = t.jSXElement(openingElement, closingElement, astChildren, astChildren.length === 0);

    this._addBailOutMessageToBabelNode(val, jsxElement);

    return jsxElement;
  }

  _addBailOutMessageToBabelNode(val, node) {
    // if there has been a bail-out, we create an inline BlockComment node before the JSX element
    if (val.$BailOutReason !== undefined) {
      // $BailOutReason contains an optional string of what to print out in the comment
      node.leadingComments = [{
        type: "BlockComment",
        value: `${val.$BailOutReason}`
      }];
    }
  }

  _serializeReactElementChild(child, reactElement) {
    let reactElementChild = this._createReactElementChild();

    this._serializeNowOrAfterWaitingForDependencies(child, reactElement, () => {
      let expr = this.residualHeapSerializer.serializeValue(child);
      reactElementChild.expr = expr;
      reactElementChild.type = "NORMAL";
    });

    return reactElementChild;
  }

  serializeLazyHoistedNodes(optimizedFunction) {
    const entries = [];

    const lazilyHoistedNodes = this._lazilyHoistedNodes.get(optimizedFunction);

    if (lazilyHoistedNodes !== undefined) {
      let {
        id,
        nodes,
        createElementIdentifier
      } = lazilyHoistedNodes; // create a function that initializes all the hoisted nodes

      let func = t.functionExpression(null, // use createElementIdentifier if it's not null
      createElementIdentifier ? [createElementIdentifier] : [], t.blockStatement(nodes.map(node => t.expressionStatement(t.assignmentExpression("=", node.id, node.astNode))))); // push it to the mainBody of the module

      entries.push(t.variableDeclaration("var", [t.variableDeclarator(id, func)])); // output all the empty variable declarations that will hold the nodes lazily

      entries.push(...nodes.map(node => t.variableDeclaration("var", [t.variableDeclarator(node.id)]))); // reset the _lazilyHoistedNodes so other additional functions work

      this._lazilyHoistedNodes.delete(optimizedFunction);
    }

    return entries;
  }

}

exports.ResidualReactElementSerializer = ResidualReactElementSerializer;
//# sourceMappingURL=ResidualReactElementSerializer.js.map

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeToString = typeToString;
exports.getTypeFromName = getTypeFromName;
exports.describeValue = describeValue;
exports.jsonToDisplayString = jsonToDisplayString;
exports.verboseToDisplayJson = verboseToDisplayJson;
exports.createModelledFunctionCall = createModelledFunctionCall;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _ShapeInformation = __webpack_require__(419);

var _errors = __webpack_require__(3);

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function typeToString(type) {
  function isInstance(proto, Constructor) {
    return proto instanceof Constructor || proto === Constructor.prototype;
  }

  let proto = type.prototype;

  if (isInstance(proto, _index.UndefinedValue)) {
    return "undefined";
  } else if (isInstance(proto, _index.NullValue)) {
    return "object";
  } else if (isInstance(proto, _index.StringValue)) {
    return "string";
  } else if (isInstance(proto, _index.BooleanValue)) {
    return "boolean";
  } else if (isInstance(proto, _index.NumberValue)) {
    return "number";
  } else if (isInstance(proto, _index.SymbolValue)) {
    return "symbol";
  } else if (isInstance(proto, _index.ObjectValue)) {
    if (_index.Value.isTypeCompatibleWith(type, _index.FunctionValue)) {
      return "function";
    }

    return "object";
  } else {
    return undefined;
  }
}

function getTypeFromName(typeName) {
  switch (typeName) {
    case "empty":
      return _index.EmptyValue;

    case "void":
      return _index.UndefinedValue;

    case "null":
      return _index.NullValue;

    case "boolean":
      return _index.BooleanValue;

    case "string":
      return _index.StringValue;

    case "symbol":
      return _index.SymbolValue;

    case "number":
      return _index.NumberValue;

    case "object":
      return _index.ObjectValue;

    case "array":
      return _index.ArrayValue;

    case "function":
      return _index.FunctionValue;

    case "integral":
      return _index.IntegralValue;

    default:
      return undefined;
  }
}

function describeValue(value) {
  let title;
  let suffix = "";
  if (value instanceof _index.PrimitiveValue) title = value.toDisplayString();else if (value instanceof _index.ObjectValue) title = "[object]";else {
    (0, _invariant.default)(value instanceof _index.AbstractValue, value.constructor.name);
    title = "[abstract]";
    if (value.kind !== undefined) title += `, kind: ${value.kind}`;

    for (let arg of value.args) {
      let desc = describeValue(arg);
      suffix += desc.split("\n").map(u => "  " + u).join("\n") + "\n";
    }
  }
  title += `, hash: ${value.getHash()}`;
  if (value.intrinsicName !== undefined) title += `, intrinsic name: ${value.intrinsicName}`;
  if (value.__originalName !== undefined) title += `, original name: ${value.__originalName}`;
  return suffix ? `${title}\n${suffix}` : title;
}

function jsonToDisplayString(instance, depth) {
  let result = instance.toDisplayJson(depth);
  return typeof result === "string" ? result : JSON.stringify(result, null, 2).replace(/\"/g, "");
}

function verboseToDisplayJson(obj, depth) {
  let result = {};

  function valueOfProp(prop) {
    if (typeof prop === "function") return undefined;

    if (Array.isArray(prop)) {
      // Try to return a 1-line string if possible
      if (prop.length === 0) return "[]";
      let valuesArray = prop.map(x => valueOfProp(x));

      if (valuesArray.length < 5) {
        let string = "[" + valuesArray.reduce((acc, x) => `${acc}, ${x instanceof Object ? JSON.stringify(x) : x}`) + "]";
        string = string.replace(/\"/g, "");
        if (string.length < 60) return string;
      }

      return valuesArray;
    }

    if (prop instanceof Set || prop instanceof Map) return `${prop.constructor.name}(${prop.size})`;
    if (prop.toDisplayJson) return prop.toDisplayJson(depth - 1);
    if (prop.toDisplayString) return prop.toDisplayString();
    if (prop.toJSON) return prop.toJSON();
    return prop.toString();
  }

  for (let key in obj) {
    let prop = obj[key];
    if (!prop) continue;
    let value = valueOfProp(prop);
    if (value !== undefined && value !== "[object Object]") result[key] = value;
  }

  return result;
}

function createModelledFunctionCall(realm, funcValue, argModelInput, thisValue) {
  let call = funcValue.$Call;
  (0, _invariant.default)(call);
  let numArgs = funcValue.getLength();
  let args = [];
  let argModel = typeof argModelInput === "string" ? JSON.parse(argModelInput) : argModelInput;
  (0, _invariant.default)(funcValue instanceof _index.ECMAScriptSourceFunctionValue);
  let params = funcValue.$FormalParameters;

  if (numArgs !== undefined && numArgs > 0 && params) {
    for (let parameterId of params) {
      if (t.isIdentifier(parameterId)) {
        // $FlowFixMe: Flow strict file does not allow for casting
        let paramName = parameterId.name;

        let shape = _ShapeInformation.ShapeInformation.createForArgument(argModel, paramName); // Create an AbstractValue similar to __abstract being called


        args.push(_index.AbstractValue.createAbstractArgument(realm, paramName, funcValue.expressionLocation, shape !== undefined ? shape.getAbstractType() : _index.Value, shape));
      } else {
        realm.handleError(new _errors.CompilerDiagnostic("Non-identifier args to additional functions unsupported", funcValue.expressionLocation, "PP1005", "FatalError"));
        throw new _errors.FatalError("Non-identifier args to additional functions unsupported");
      }
    }
  }

  let thisArg = thisValue !== undefined ? thisValue : _index.AbstractValue.createAbstractArgument(realm, "this", funcValue.expressionLocation, _index.ObjectValue);
  return () => {
    let savedPathConditions = realm.pathConditions;
    let newPathConditions = funcValue.pathConditionDuringDeclaration || savedPathConditions;
    realm.pathConditions = newPathConditions;

    try {
      let result = call(thisArg, args);
      return result;
    } finally {
      realm.pathConditions = savedPathConditions;
    }
  };
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualOperationSerializer = void 0;

var _realm = __webpack_require__(7);

var _generator = __webpack_require__(237);

var _PreludeGenerator = __webpack_require__(238);

var _babelhelpers = __webpack_require__(239);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var t = _interopRequireWildcard(__webpack_require__(21));

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function serializeBody(generator, context, valuesToProcess) {
  let statements = context.serializeGenerator(generator, valuesToProcess);
  if (statements.length === 1 && statements[0].type === "BlockStatement") return statements[0];
  return t.blockStatement(statements);
}

function isSelfReferential(value, pathNode) {
  if (value === pathNode) return true;

  if (value instanceof _index.AbstractValue && pathNode !== undefined) {
    for (let v of value.args) {
      if (isSelfReferential(v, pathNode)) return true;
    }
  }

  return false;
}

class ResidualOperationSerializer {
  constructor(realm, preludeGenerator) {
    this.realm = realm;
    this.preludeGenerator = preludeGenerator;
  }

  getErrorStatement(message) {
    if (this.realm.invariantMode === "throw") return t.throwStatement(t.newExpression(this.preludeGenerator.memoizeReference("Error"), [message]));else {
      let targetReference = this.realm.invariantMode;
      let args = [message];
      let i = targetReference.indexOf("+");

      if (i !== -1) {
        let s = targetReference.substr(i + 1);
        let x = Number.parseInt(s, 10);
        args.push(isNaN(x) ? t.stringLiteral(s) : t.numericLiteral(x));
        targetReference = targetReference.substr(0, i);
      }

      return t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference(targetReference), args));
    }
  }

  serializeStatement(operationDescriptor, nodes, context, valuesToProcess, declaredId) {
    let {
      data,
      type
    } = operationDescriptor;
    let babelNode;

    switch (type) {
      case "ASSUME_CALL":
        babelNode = this._serializeAssumeCall(data, nodes);
        break;

      case "CONCRETE_MODEL":
        babelNode = this._serializeConcreteModel(data, nodes);
        break;

      case "CONDITIONAL_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeConditionalPropertyAssignment(data, nodes, context, valuesToProcess);
        break;

      case "CONDITIONAL_THROW":
        babelNode = this._serializeConditionalThrow(data, nodes, context);
        break;

      case "CONSOLE_LOG":
        babelNode = this._serializeConsoleLog(data, nodes);
        break;

      case "DEFINE_PROPERTY":
        babelNode = this._serializeDefineProperty(data, nodes, context);
        break;

      case "DO_WHILE":
        babelNode = this._serializeDoWhile(data, nodes, context, valuesToProcess);
        break;

      case "EMIT_CALL":
        babelNode = this._serializeEmitCall(data, nodes);
        break;

      case "EMIT_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeEmitPropertyAssignment(data, nodes, context);
        break;

      case "FOR_IN":
        babelNode = this._serializeForIn(data, nodes);
        break;

      case "GLOBAL_ASSIGNMENT":
        babelNode = this._serializeGlobalAssignment(data, nodes);
        break;

      case "GLOBAL_DELETE":
        babelNode = this._serializeGlobalDelete(data, nodes);
        break;

      case "JOIN_GENERATORS":
        babelNode = this._serializeJoinGenerators(data, nodes, context, valuesToProcess);
        break;

      case "LOCAL_ASSIGNMENT":
        babelNode = this._serializeLocalAssignment(data, nodes, context, valuesToProcess);
        break;

      case "NOOP":
        babelNode = t.emptyStatement();
        break;

      case "OBJECT_SET_PARTIAL":
        babelNode = this._serializeObjectSetPartial(data, nodes);
        break;

      case "PROPERTY_ASSIGNMENT":
        babelNode = this._serializePropertyAssignment(data, nodes, context, valuesToProcess);
        break;

      case "PROPERTY_DELETE":
        babelNode = this._serializePropertyDelete(data, nodes);
        break;

      case "THROW":
        babelNode = this._serializeThrow(data, nodes);
        break;
      // Invariants

      case "INVARIANT":
        babelNode = this._serializeInvariant(data, nodes);
        break;
      // React

      case "REACT_SSR_REGEX_CONSTANT":
        return t.variableDeclaration("var", [t.variableDeclarator(t.identifier("matchHtmlRegExp"), t.regExpLiteral("[\"'&<>]"))]);

      case "REACT_SSR_PREV_TEXT_NODE":
        return t.variableDeclaration("var", [t.variableDeclarator(t.identifier("previousWasTextNode"), t.booleanLiteral(false))]);

      default:
        let babelNodeExpression = this.serializeExpression(operationDescriptor, nodes, context);
        if (declaredId !== undefined) babelNode = this._serializeDerivedOperationDescriptor(declaredId, babelNodeExpression);else babelNode = this._serializeVoidOperationDescriptor(babelNodeExpression);
        return babelNode;
    }

    (0, _invariant.default)(declaredId === undefined);
    return babelNode;
  }

  serializeExpression(operationDescriptor, nodes, context, valuesToProcess) {
    let {
      data,
      type
    } = operationDescriptor;
    let babelNode;

    switch (type) {
      case "IDENTIFIER":
        babelNode = this._serializeIdentifier(data, nodes);
        break;

      case "REBUILT_OBJECT":
        babelNode = this._serializeRebuiltObject(data, nodes);
        break;

      case "BINARY_EXPRESSION":
        babelNode = this._serializeBinaryExpression(data, nodes);
        break;

      case "LOGICAL_EXPRESSION":
        babelNode = this._serializeLogicalExpression(data, nodes);
        break;

      case "CONDITIONAL_EXPRESSION":
        babelNode = this._serializeConditionalExpression(data, nodes);
        break;

      case "UNARY_EXPRESSION":
        babelNode = this._serializeUnaryExpression(data, nodes);
        break;

      case "ABSTRACT_PROPERTY":
        babelNode = this._serializeAbstractProperty(data, nodes);
        break;

      case "ABSTRACT_FROM_TEMPLATE":
        babelNode = this._serializeAbstractFromTemplate(data, nodes);
        break;

      case "COERCE_TO_STRING":
        babelNode = this._serializeCoerceToString(data, nodes);
        break;

      case "OBJECT_ASSIGN":
        babelNode = this._serializeObjectAssign(data, nodes);
        break;

      case "SINGLE_ARG":
        babelNode = this._serializeSingleArg(data, nodes);
        break;

      case "CALL_BAILOUT":
        babelNode = this._serializeCallBailout(data, nodes);
        break;

      case "EMIT_CALL_AND_CAPTURE_RESULT":
        babelNode = this._serializeEmitCallAndCaptureResults(data, nodes);
        break;

      case "NEW_EXPRESSION":
        babelNode = this._serializeNewExpression(data, nodes);
        break;

      case "FOR_STATEMENT_FUNC":
        babelNode = this._serializeForFunctionCall(data, nodes);
        break;

      case "GET_BINDING":
        babelNode = this._serializeGetBinding(data, nodes, context);
        break;

      case "UNKNOWN_ARRAY_METHOD_CALL":
        babelNode = this._serializeUnknownArrayMethodCall(data, nodes);
        break;

      case "UNKNOWN_ARRAY_METHOD_PROPERTY_CALL":
        babelNode = this._serializeUnknownArrayMethodPropertyCall(data, nodes);
        break;

      case "UNKNOWN_ARRAY_LENGTH":
        babelNode = this._serializeUnknownArrayLength(data, nodes);
        break;

      case "UNKNOWN_ARRAY_GET_PARTIAL":
        babelNode = this._serializeUnknownArrayGetPartial(data, nodes);
        break;

      case "OBJECT_GET_PARTIAL":
        babelNode = this._serializeObjectGetPartial(data, nodes);
        break;

      case "ABSTRACT_OBJECT_GET_PARTIAL":
        babelNode = this._serializeAbstractObjectGetPartial(data, nodes);
        break;

      case "ABSTRACT_OBJECT_GET_PROTO_OF":
        babelNode = this._serializeAbstractObjectGetProtoOf(data, nodes);
        break;

      case "ABSTRACT_OBJECT_GET":
        babelNode = this._serializeAbstractObjectGet(data, nodes);
        break;

      case "OBJECT_PROTO_HAS_OWN_PROPERTY":
        babelNode = this._serializeObjectProtoHasOwnProperty(data, nodes);
        break;

      case "OBJECT_PROTO_GET_OWN_PROPERTY_DESCRIPTOR":
        babelNode = this._serializeObjectProtoGetOwnPropertyDescriptor(data, nodes);
        break;

      case "DIRECT_CALL_WITH_ARG_LIST":
        babelNode = this._serializeDirectCallWithArgList(data, nodes);
        break;

      case "CALL_ABSTRACT_FUNC":
        babelNode = this._serializeCallAbstractFunc(data, nodes);
        break;

      case "CALL_ABSTRACT_FUNC_THIS":
        babelNode = this._serializeCallAbstractFuncThis(data, nodes);
        break;

      case "LOGICAL_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeLogicalPropertyAssignment(data, nodes);
        break;

      case "UPDATE_INCREMENTOR":
        babelNode = this._serializeUpdateIncrementor(data, nodes);
        break;

      case "MODULES_REQUIRE":
        babelNode = this._serializeModulesRequires(data, nodes);
        break;

      case "RESIDUAL_CALL":
        babelNode = this._serializeResidualCall(data, nodes);
        break;

      case "CANNOT_BECOME_OBJECT":
        babelNode = this._serializeCannotBecomeObject(data, nodes);
        break;

      case "WIDENED_IDENTIFIER":
        babelNode = this._serializeIdentifier(data, nodes);
        break;

      case "WIDEN_PROPERTY":
        babelNode = this._serializeWidenProperty(data, nodes);
        break;

      case "WIDEN_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeWidenPropertyAssignment(data, nodes);
        break;
      // Invariants

      case "DERIVED_ABSTRACT_INVARIANT":
        babelNode = this._serializeDerivedAbstractInvariant(data, nodes);
        break;

      case "PROPERTY_INVARIANT":
        babelNode = this._serializePropertyInvariant(data, nodes);
        break;

      case "INVARIANT_APPEND":
        babelNode = this._serializeInvariantAppend(data, nodes);
        break;

      case "FULL_INVARIANT":
        babelNode = this._serializeFullInvariant(data, nodes);
        break;

      case "FULL_INVARIANT_ABSTRACT":
        babelNode = this._serializeFullInvariantAbstract(data, nodes);
        break;

      case "FULL_INVARIANT_FUNCTION":
        babelNode = this._serializeFullInvariantFunction(data, nodes);
        break;
      // React

      case "REACT_DEFAULT_PROPS_HELPER":
        babelNode = this._serializeReactDefaultPropsHelper(data, nodes);
        break;

      case "REACT_SSR_RENDER_VALUE_HELPER":
        babelNode = this._serializeReactRenderValueHelper(data, nodes);
        break;

      case "REACT_SSR_TEMPLATE_LITERAL":
        babelNode = this._serializeReactSSRTemplateLiteral(data, nodes);
        break;

      case "REACT_TEMPORAL_FUNC":
        babelNode = this._serializeReactTemporalFunc(data, nodes);
        break;

      case "REACT_CREATE_CONTEXT_PROVIDER":
        babelNode = this._serializeReactCreateContextProvider(data, nodes);
        break;

      case "REACT_NATIVE_STRING_LITERAL":
        babelNode = this._serializeReactNativeStringLiteral(data, nodes);
        break;

      case "REACT_RELAY_MOCK_CONTAINER":
        babelNode = this._serializeReactRelayMockContainer(data, nodes);
        break;
      // FB Mocks

      case "FB_MOCKS_BOOTLOADER_LOAD_MODULES":
        babelNode = this._serializeFBMocksBootloaderLoadModules(data, nodes);
        break;

      case "FB_MOCKS_MAGIC_GLOBAL_FUNCTION":
        babelNode = this._serializeFBMocksMagicGlobalFunction(data, nodes);
        break;
      // Babel helpers

      case "BABEL_HELPERS_OBJECT_WITHOUT_PROPERTIES":
        babelNode = this._serializeBabelHelpersObjectWithoutProperties(data, nodes);
        break;

      default:
        (0, _invariant.default)(false, `operation descriptor "type" not recognized when serializing operation descriptor`);
    }

    return babelNode;
  }

  _serializeAssumeCall({}, [c, s]) {
    let errorLiteral = s.type === "StringLiteral" ? s : t.stringLiteral("Assumption violated");
    return t.ifStatement(t.unaryExpression("!", c), t.blockStatement([t.throwStatement(t.newExpression(t.identifier("Error"), [errorLiteral]))]));
  }

  _serializeWidenPropertyAssignment({}, [o, propName, v]) {
    return t.assignmentExpression("=", (0, _babelhelpers.memberExpressionHelper)(o, propName), v);
  }

  _serializeWidenAbstractProperty({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeWidenProperty({}, [o, propName]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, propName);
  }

  _serializeAbstractObjectGet({
    propertyGetter
  }, [o, P]) {
    return propertyGetter !== undefined ? t.callExpression(t.memberExpression(t.identifier("global"), t.identifier("__prop_" + propertyGetter)), [o, P]) : (0, _babelhelpers.memberExpressionHelper)(o, P);
  }

  _serializeAbstractObjectGetProtoOf({}, [p]) {
    (0, _invariant.default)(this.realm.preludeGenerator !== undefined);
    let getPrototypeOf = this.realm.preludeGenerator.memoizeReference("Object.getPrototypeOf");
    return this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) || this.realm.isCompatibleWith("mobile") ? t.memberExpression(p, _babelhelpers.protoExpression) : t.callExpression(getPrototypeOf, [p]);
  }

  _serializeCannotBecomeObject({}, [n]) {
    let callFunc = t.identifier("global.__cannotBecomeObject");
    return t.callExpression(callFunc, [n]);
  }

  _serializeResidualCall({}, nodes) {
    return t.callExpression(nodes[0], nodes.slice(1));
  }

  _serializeModulesRequires({}, [propName]) {
    return t.callExpression(t.identifier("require"), [propName]);
  }

  _serializeConcreteModel({}, [valueNode, propName]) {
    let propString = propName.value;
    return t.expressionStatement(t.assignmentExpression("=", this.preludeGenerator.globalReference(propString, false), valueNode));
  }

  _serializeConsoleLog({}, [propName, ...nodes]) {
    let propString = propName.value;
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("console"), t.identifier(propString)), [...nodes]));
  }

  _serializeDoWhile({
    generator,
    value
  }, nodes, context, valuesToProcess) {
    (0, _invariant.default)(context !== undefined);
    (0, _invariant.default)(valuesToProcess !== undefined);
    (0, _invariant.default)(value !== undefined);
    let testId = value.intrinsicName;
    (0, _invariant.default)(testId !== undefined);
    (0, _invariant.default)(generator !== undefined);
    let statements = context.serializeGenerator(generator, valuesToProcess);
    let block = t.blockStatement(statements);
    return t.doWhileStatement(t.identifier(testId), block);
  }

  _serializeForIn({
    boundName,
    lh
  }, [obj, tgt, src]) {
    (0, _invariant.default)(boundName !== undefined);
    (0, _invariant.default)(lh !== undefined);
    return t.forInStatement(lh, obj, t.blockStatement([t.expressionStatement(t.assignmentExpression("=", (0, _babelhelpers.memberExpressionHelper)(tgt, boundName), (0, _babelhelpers.memberExpressionHelper)(src, boundName)))]));
  }

  _serializeFullInvariant({}, [propName, objectNode, valueNode]) {
    return t.binaryExpression("!==", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName), valueNode);
  }

  _serializeFullInvariantFunction({}, [propName, objectNode]) {
    return t.binaryExpression("!==", t.unaryExpression("typeof", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName), true), t.stringLiteral("function"));
  }

  _serializeFullInvariantAbstract({
    concreteComparisons,
    typeComparisons
  }, [propName, valueNode]) {
    (0, _invariant.default)(concreteComparisons !== undefined);
    (0, _invariant.default)(typeComparisons !== undefined); // Create `object.property !== concreteValue`

    let checks = concreteComparisons.map(concreteValue => t.binaryExpression("!==", valueNode, t.valueToNode(concreteValue.serialize()))); // Create `typeof object.property !== typeValue`

    checks = checks.concat([...typeComparisons].map(typeValue => {
      let typeString = _singletons.Utils.typeToString(typeValue);

      (0, _invariant.default)(typeString !== undefined, typeValue);
      return t.binaryExpression("!==", t.unaryExpression("typeof", valueNode, true), t.stringLiteral(typeString));
    }));
    return checks.reduce((expr, newCondition) => t.logicalExpression("&&", expr, newCondition));
  }

  _serializeInvariantAppend({}, [propName, objectNode]) {
    return (0, _babelhelpers.memberExpressionHelper)(objectNode, propName);
  }

  _serializePropertyInvariant({
    state
  }, [propName, objectNode]) {
    (0, _invariant.default)(state !== undefined);
    let n = t.callExpression(t.memberExpression(this.preludeGenerator.memoizeReference("Object.prototype.hasOwnProperty"), t.identifier("call")), [objectNode, propName]);

    if (state !== "MISSING") {
      n = t.unaryExpression("!", n, true);
      if (state === "DEFINED") n = t.logicalExpression("||", n, t.binaryExpression("===", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName), t.valueToNode(undefined)));
    }

    return n;
  }

  _serializeUpdateIncrementor({
    incrementor
  }, [oldValNode]) {
    (0, _invariant.default)(incrementor !== undefined);
    return t.binaryExpression(incrementor, oldValNode, t.numericLiteral(1));
  }

  _serializeDerivedAbstractInvariant({}, [typeOfStringNode, typeofNode]) {
    let typeofString = typeOfStringNode.value;
    let condition = t.binaryExpression("!==", t.unaryExpression("typeof", typeofNode), t.stringLiteral(typeofString));

    if (typeofString === "object") {
      condition = t.logicalExpression("&&", condition, t.binaryExpression("!==", t.unaryExpression("typeof", typeofNode), t.stringLiteral("function")));
      condition = t.logicalExpression("||", condition, t.binaryExpression("===", typeofNode, _babelhelpers.nullExpression));
    }

    return condition;
  }

  _serializeInvariant({
    appendLastToInvariantOperationDescriptor,
    violationConditionOperationDescriptor
  }, nodes) {
    (0, _invariant.default)(violationConditionOperationDescriptor !== undefined);
    let messageComponents = [t.stringLiteral("Prepack model invariant violation ("), t.numericLiteral(this.preludeGenerator.nextInvariantId++)];

    if (appendLastToInvariantOperationDescriptor) {
      let propName = nodes[0];
      let last = nodes.pop();
      messageComponents.push(t.stringLiteral("): "));
      messageComponents.push(this.serializeExpression(appendLastToInvariantOperationDescriptor, [propName, last]));
    } else {
      messageComponents.push(t.stringLiteral(")"));
    }

    let throwString = messageComponents[0];

    for (let i = 1; i < messageComponents.length; i++) throwString = t.binaryExpression("+", throwString, messageComponents[i]);

    let condition = this.serializeExpression(violationConditionOperationDescriptor, nodes);
    let consequent = this.getErrorStatement(throwString);
    return t.ifStatement(condition, consequent);
  }

  _serializeReactRelayMockContainer({}, [reactRelayIdent, propName, ...otherArgs]) {
    let propString = propName.value;
    return t.callExpression(t.memberExpression(reactRelayIdent, t.identifier(propString)), otherArgs);
  }

  _serializePropertyAssignment({
    path
  }, [o, p, v, e], context, valuesToProcess) {
    (0, _invariant.default)(path instanceof _index.AbstractValue);
    (0, _invariant.default)(path.operationDescriptor !== undefined);
    let lh = this.serializeExpression(path.operationDescriptor, [o, p], context, valuesToProcess);
    return t.expressionStatement(t.assignmentExpression("=", lh, v));
  }

  _serializeConditionalPropertyAssignment({
    path,
    value
  }, [o, v, e, keyKey], context, valuesToProcess) {
    (0, _invariant.default)(value instanceof _index.AbstractValue);
    (0, _invariant.default)(path instanceof _index.AbstractValue);
    let mightHaveBeenDeleted = value.mightHaveBeenDeleted();
    let mightBeUndefined = value.mightBeUndefined();
    (0, _invariant.default)(path.operationDescriptor !== undefined);
    let lh = this.serializeExpression(path.operationDescriptor, [o, keyKey], context, valuesToProcess);
    let r = t.expressionStatement(t.assignmentExpression("=", lh, v));

    if (mightHaveBeenDeleted) {
      // If v === __empty || (v === undefined  && !(key.key in o))  then delete it
      let emptyTest = t.binaryExpression("===", v, e);
      let undefinedTest = t.binaryExpression("===", v, _babelhelpers.voidExpression);
      let inTest = t.unaryExpression("!", t.binaryExpression("in", keyKey, o));
      let guard = t.logicalExpression("||", emptyTest, t.logicalExpression("&&", undefinedTest, inTest));
      let deleteIt = t.expressionStatement(t.unaryExpression("delete", lh));
      return t.ifStatement(mightBeUndefined ? emptyTest : guard, deleteIt, r);
    }

    return r;
  }

  _serializeLogicalPropertyAssignment({
    propertyBinding,
    value
  }, [o, n]) {
    (0, _invariant.default)(value instanceof _index.Value);
    (0, _invariant.default)(propertyBinding !== undefined);

    if (typeof propertyBinding.key === "string" && value.mightHaveBeenDeleted() && isSelfReferential(value, propertyBinding.pathNode)) {
      let inTest = t.binaryExpression("in", t.stringLiteral(propertyBinding.key), o);
      let addEmpty = t.conditionalExpression(inTest, n, _babelhelpers.emptyExpression);
      n = t.logicalExpression("||", n, addEmpty);
    }

    return n;
  }

  _serializeLocalAssignment({
    value
  }, [v], context, valuesToProcess) {
    (0, _invariant.default)(value instanceof _index.AbstractValue);
    (0, _invariant.default)(value.operationDescriptor !== undefined);
    let id = this.serializeExpression(value.operationDescriptor, [], context, valuesToProcess);
    return t.expressionStatement(t.assignmentExpression("=", id, v));
  }

  _serializeReactNativeStringLiteral({}, [propName]) {
    return propName;
  }

  _serializeReactCreateContextProvider({}, [consumerNode]) {
    return t.memberExpression(consumerNode, t.identifier("Provider"));
  }

  _serializeReactTemporalFunc({}, [renderNode, ..._args]) {
    return t.callExpression(renderNode, _args);
  }

  _serializeCallAbstractFunc({}, nodes) {
    let fun_args = nodes.slice(1);
    return t.callExpression(nodes[0], fun_args);
  }

  _serializeCallAbstractFuncThis({}, nodes) {
    let fun_args = nodes.slice(1);
    return t.callExpression(t.memberExpression(nodes[0], t.identifier("call")), fun_args);
  }

  _serializeDirectCallWithArgList({}, nodes) {
    let fun_args = nodes.slice(1);
    return t.callExpression(nodes[0], fun_args);
  }

  _serializeObjectProtoHasOwnProperty({}, [methodNode, objectNode, nameNode]) {
    return t.callExpression(t.memberExpression(methodNode, t.identifier("call")), [objectNode, nameNode]);
  }

  _serializeRebuiltObject({}, [node, propName]) {
    let propString = propName.value;
    return t.isValidIdentifier(propString) ? t.memberExpression(node, t.identifier(propString), false) : t.memberExpression(node, propName, true);
  }

  _serializeGlobalDelete({}, [propName]) {
    let propString = propName.value;
    return t.expressionStatement(t.unaryExpression("delete", this.preludeGenerator.globalReference(propString, false)));
  }

  _serializeDefineProperty({
    object,
    descriptor
  }, [propName], context) {
    let propString = propName.value;
    (0, _invariant.default)(object !== undefined);
    (0, _invariant.default)(descriptor !== undefined);
    (0, _invariant.default)(context !== undefined);
    return context.emitDefinePropertyBody(object, propString, descriptor);
  }

  _serializeFBMocksMagicGlobalFunction({}, [propName, ...args]) {
    let propString = propName.value;
    return t.callExpression(t.identifier(propString), args);
  }

  _serializeFBMocksBootloaderLoadModules({}, args) {
    return t.callExpression(t.memberExpression(t.identifier("Bootloader"), t.identifier("loadModules")), args);
  }

  _serializeUnknownArrayGetPartial({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeObjectGetPartial({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeAbstractObjectGetPartial({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeObjectSetPartial({}, [objectNode, keyNode, valueNode]) {
    return t.expressionStatement(t.assignmentExpression("=", (0, _babelhelpers.memberExpressionHelper)(objectNode, keyNode), valueNode));
  }

  _serializeIdentifier({
    id
  }, nodes) {
    (0, _invariant.default)(id !== undefined);
    return t.identifier(id);
  }

  _serializeCoerceToString({}, [p]) {
    return t.binaryExpression("+", t.stringLiteral(""), p);
  }

  _serializeBabelHelpersObjectWithoutProperties({}, [methodNode, objNode, propRemoveNode]) {
    return t.callExpression(methodNode, [objNode, propRemoveNode]);
  }

  _serializeReactDefaultPropsHelper({}, [methodNode, ..._args]) {
    return t.callExpression(methodNode, _args);
  }

  _serializeUnknownArrayMethodCall({}, [methodNode, ..._args]) {
    return t.callExpression(methodNode, _args);
  }

  _serializeUnknownArrayLength({}, [o]) {
    return t.memberExpression(o, t.identifier("length"), false);
  }

  _serializeUnknownArrayMethodPropertyCall({}, [objNode, propName, ..._args]) {
    let propString = propName.value;
    return t.callExpression(t.memberExpression(objNode, t.identifier(propString)), _args);
  }

  _serializeThrow({}, [argument]) {
    return t.throwStatement(argument);
  }

  _serializeConditionalThrow({
    value
  }, nodes, context) {
    (0, _invariant.default)(value instanceof _index.Value);

    function createStatement(val) {
      (0, _invariant.default)(context !== undefined);

      if (!(val instanceof _index.AbstractValue) || val.kind !== "conditional") {
        return t.throwStatement(context.serializeValue(val));
      }

      let [cond, trueVal, falseVal] = val.args;
      let condVal = context.serializeValue(cond);
      let trueStat, falseStat;
      if (trueVal instanceof _index.EmptyValue) trueStat = t.blockStatement([]);else trueStat = createStatement(trueVal);
      if (falseVal instanceof _index.EmptyValue) falseStat = t.blockStatement([]);else falseStat = createStatement(falseVal);
      return t.ifStatement(condVal, trueStat, falseStat);
    }

    return createStatement(value);
  }

  _serializeReactSSRTemplateLiteral({
    quasis
  }, valueNodes) {
    (0, _invariant.default)(quasis !== undefined);
    return t.templateLiteral(quasis, valueNodes);
  }

  _serializeReactRenderValueHelper({}, [helperNode, valueNode]) {
    return t.callExpression(helperNode, [valueNode]);
  }

  _serializePropertyDelete({}, [objectNode, propName]) {
    return t.expressionStatement(t.unaryExpression("delete", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName)));
  }

  _serializeGetBinding({
    binding
  }, nodes, context) {
    (0, _invariant.default)(binding !== undefined);
    (0, _invariant.default)(context !== undefined);
    return context.serializeBinding(binding);
  }

  _serializeForFunctionCall({
    usesThis
  }, [func, thisExpr]) {
    return usesThis ? t.callExpression(t.memberExpression(func, t.identifier("call")), [thisExpr]) : t.callExpression(func, []);
  }

  _serializeNewExpression({}, [constructorNode, ...argListNodes]) {
    return t.newExpression(constructorNode, argListNodes);
  }

  _serializeEmitCall({
    callFunctionRef
  }, nodes) {
    (0, _invariant.default)(callFunctionRef !== undefined);
    let callFunction = this.preludeGenerator.memoizeReference(callFunctionRef);
    return t.expressionStatement(t.callExpression(callFunction, [...nodes]));
  }

  _serializeEmitCallAndCaptureResults({
    callFunctionRef
  }, nodes) {
    (0, _invariant.default)(callFunctionRef !== undefined);
    let callFunction = this.preludeGenerator.memoizeReference(callFunctionRef);
    return t.callExpression(callFunction, nodes);
  }

  _serializeObjectProtoGetOwnPropertyDescriptor({}, [funcNode, ...args]) {
    return t.callExpression(funcNode, args);
  }

  _serializeCallBailout({
    propRef,
    thisArg
  }, nodes) {
    let callFunc;
    let argStart = 1;

    if (thisArg instanceof _index.Value) {
      if (typeof propRef === "string") {
        callFunc = (0, _babelhelpers.memberExpressionHelper)(nodes[0], propRef);
      } else {
        callFunc = (0, _babelhelpers.memberExpressionHelper)(nodes[0], nodes[1]);
        argStart = 2;
      }
    } else {
      callFunc = nodes[0];
    }

    let fun_args = nodes.slice(argStart);
    return t.callExpression(callFunc, fun_args);
  }

  _serializeJoinGenerators({
    generators
  }, [cond], context, valuesToProcess) {
    (0, _invariant.default)(context !== undefined);
    (0, _invariant.default)(valuesToProcess !== undefined);
    (0, _invariant.default)(generators !== undefined);
    let [generator1, generator2] = generators;
    let block1 = generator1.empty() ? null : serializeBody(generator1, context, valuesToProcess);
    let block2 = generator2.empty() ? null : serializeBody(generator2, context, valuesToProcess);
    if (block1) return t.ifStatement(cond, block1, block2);
    (0, _invariant.default)(block2);
    return t.ifStatement(t.unaryExpression("!", cond), block2);
  }

  _serializeEmitPropertyAssignment({
    value
  }, [objectNode, valueNode, propName], context) {
    (0, _invariant.default)(context !== undefined);
    (0, _invariant.default)(value instanceof _index.Value);
    return context.getPropertyAssignmentStatement((0, _babelhelpers.memberExpressionHelper)(objectNode, propName), value, value.mightHaveBeenDeleted(),
    /* deleteIfMightHaveBeenDeleted */
    true);
  }

  _serializeGlobalAssignment({}, [valueNode, propName]) {
    let propString = propName.value;
    return t.expressionStatement(t.assignmentExpression("=", this.preludeGenerator.globalReference(propString, false), valueNode));
  }

  _serializeSingleArg({}, [o]) {
    return o;
  }

  _serializeAbstractProperty({}, [o, propName]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, propName);
  }

  _serializeUnaryExpression({
    unaryOperator,
    prefix
  }, [x, y]) {
    (0, _invariant.default)(unaryOperator !== undefined);
    return t.unaryExpression(unaryOperator, x, prefix);
  }

  _serializeBinaryExpression({
    binaryOperator
  }, [x, y]) {
    (0, _invariant.default)(binaryOperator !== undefined);
    return t.binaryExpression(binaryOperator, x, y);
  }

  _serializeLogicalExpression({
    logicalOperator
  }, [x, y]) {
    (0, _invariant.default)(logicalOperator !== undefined);
    return t.logicalExpression(logicalOperator, x, y);
  }

  _serializeConditionalExpression({}, [c, x, y]) {
    return t.conditionalExpression(c, x, y);
  }

  _serializeDerivedOperationDescriptor(id, babelNode) {
    return t.variableDeclaration("var", [t.variableDeclarator(t.identifier(id), babelNode)]);
  }

  _serializeVoidOperationDescriptor(babelNode) {
    return t.expressionStatement(babelNode);
  }

  _serializeAbstractFromTemplate({
    templateSource
  }, nodes) {
    let templateArguments = {};
    let i = 0;

    for (let node of nodes) templateArguments[_PreludeGenerator.Placeholders[i++]] = node;

    (0, _invariant.default)(templateSource !== undefined);
    return this.preludeGenerator.buildExpression(templateSource, templateArguments);
  }

  _serializeObjectAssign({}, [targetNode, ...sourceNodes]) {
    return t.callExpression(this.preludeGenerator.memoizeReference("Object.assign"), [targetNode, ...sourceNodes]);
  }

}

exports.ResidualOperationSerializer = ResidualOperationSerializer;
//# sourceMappingURL=ResidualOperationSerializer.js.map

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LazyObjectsSerializer = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _logger = __webpack_require__(412);

var _modules = __webpack_require__(411);

var _HeapInspector = __webpack_require__(426);

var _ResidualHeapValueIdentifiers = __webpack_require__(441);

var _ResidualHeapSerializer = __webpack_require__(433);

var _utils = __webpack_require__(413);

var _GeneratorTree = __webpack_require__(432);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
const LAZY_OBJECTS_SERIALIZER_BODY_TYPE = "LazyObjectInitializer";
/**
 * Serialize objects in lazy mode by leveraging the JS runtime that support this feature.
 * Objects are serialized into two parts:
 * 1. All lazy objects are created via lightweight LazyObjectsRuntime.createLazyObject() call.
 * 2. Lazy objects' property assignments are delayed in a callback function which is registered with the runtime.
 *    lazy objects runtime will execute this callback to hydrate the lazy objects.
 *
 * Currently only the raw objects are taking part in the lazy objects feature.
 * TODO: support for other objects, like array, regex etc...
 */

class LazyObjectsSerializer extends _ResidualHeapSerializer.ResidualHeapSerializer {
  constructor(realm, logger, modules, residualHeapValueIdentifiers, residualHeapInspector, residualHeapInfo, options, additionalFunctionValuesAndEffects, referentializer, generatorTree, residualOptimizedFunctions) {
    super(realm, logger, modules, residualHeapValueIdentifiers, residualHeapInspector, residualHeapInfo, options, additionalFunctionValuesAndEffects, referentializer, generatorTree, residualOptimizedFunctions);
    this._lazyObjectIdSeed = 1;
    this._valueLazyIds = new Map();
    this._lazyObjectInitializers = new Map();
    this._callbackLazyObjectParam = t.identifier("obj");
    (0, _invariant.default)(this._options.lazyObjectsRuntime != null);
    this._lazyObjectJSRuntimeName = t.identifier(this._options.lazyObjectsRuntime);
    this._initializationCallbackName = t.identifier("__initializerCallback");
  }

  _getValueLazyId(obj) {
    return (0, _utils.getOrDefault)(this._valueLazyIds, obj, () => this._lazyObjectIdSeed++);
  } // TODO: change to use _getTarget() to get the lazy objects initializer body.


  _serializeLazyObjectInitializer(obj, emitIntegrityCommand) {
    const initializerBody = {
      type: LAZY_OBJECTS_SERIALIZER_BODY_TYPE,
      parentBody: undefined,
      entries: [],
      done: false
    };
    let oldBody = this.emitter.beginEmitting(LAZY_OBJECTS_SERIALIZER_BODY_TYPE, initializerBody);

    this._emitObjectProperties(obj);

    if (emitIntegrityCommand !== undefined) emitIntegrityCommand(this.emitter.getBody());
    this.emitter.endEmitting(LAZY_OBJECTS_SERIALIZER_BODY_TYPE, oldBody);
    return initializerBody;
  }

  _serializeLazyObjectInitializerSwitchCase(obj, initializer) {
    // TODO: only serialize this switch case if the initializer(property assignment) is not empty.
    const caseBody = initializer.entries.concat(t.breakStatement());

    const lazyId = this._getValueLazyId(obj);

    return t.switchCase(t.numericLiteral(lazyId), caseBody);
  }

  _serializeInitializationCallback() {
    const body = [];
    const switchCases = [];

    for (const [obj, initializer] of this._lazyObjectInitializers) {
      switchCases.push(this._serializeLazyObjectInitializerSwitchCase(obj, initializer));
    } // Default case.


    switchCases.push(t.switchCase(null, [t.throwStatement(t.newExpression(t.identifier("Error"), [t.stringLiteral("Unknown lazy id")]))]));
    const selector = t.identifier("id");
    body.push(t.switchStatement(selector, switchCases));
    const params = [this._callbackLazyObjectParam, selector];
    const initializerCallbackFunction = t.functionExpression(null, params, t.blockStatement(body)); // TODO: use NameGenerator.

    return t.variableDeclaration("var", [t.variableDeclarator(this._initializationCallbackName, initializerCallbackFunction)]);
  }

  _serializeRegisterInitializationCallback() {
    return t.expressionStatement(t.callExpression(t.memberExpression(this._lazyObjectJSRuntimeName, t.identifier("setLazyObjectInitializer")), [this._initializationCallbackName]));
  }

  _serializeCreateLazyObject(obj) {
    const lazyId = this._getValueLazyId(obj);

    return t.callExpression(t.memberExpression(this._lazyObjectJSRuntimeName, t.identifier("createLazyObject"),
    /*computed*/
    false), [t.numericLiteral(lazyId)]);
  }
  /**
   * Check if the object currently being emitted is lazy object(inside _lazyObjectInitializers map) and
   * that its emitting body is the offspring of this lazy object's initializer body.
   * This is needed because for "lazy1.p = lazy2" case,
   * we need to replace "lazy1" with "obj" but not for "lazy2".
   * The offspring checking is needed because object may be emitting in a "ConditionalAssignmentBranch" of
   * lazy object's initializer body.
   */


  _isEmittingIntoLazyObjectInitializerBody(obj) {
    const objLazyBody = this._lazyObjectInitializers.get(obj);

    return objLazyBody !== undefined && this.emitter.isCurrentBodyOffspringOf(objLazyBody);
  } // Override default behavior.
  // Inside lazy objects callback, the lazy object identifier needs to be replaced with the
  // parameter passed from the runtime.


  getSerializeObjectIdentifier(val) {
    return val instanceof _index.ObjectValue && this._isEmittingIntoLazyObjectInitializerBody(val) ? this._callbackLazyObjectParam : super.getSerializeObjectIdentifier(val);
  } // Override default serializer with lazy mode.


  serializeValueRawObject(obj, skipPrototype, emitIntegrityCommand) {
    if (obj.temporalAlias !== undefined) return super.serializeValueRawObject(obj, skipPrototype, emitIntegrityCommand);

    this._lazyObjectInitializers.set(obj, this._serializeLazyObjectInitializer(obj, emitIntegrityCommand));

    return this._serializeCreateLazyObject(obj);
  } // Override.
  // Serialize the initialization callback and its registration in prelude if there are object being lazied.


  postGeneratorSerialization() {
    if (this._lazyObjectInitializers.size > 0) {
      // Insert initialization callback at the end of prelude code.
      this.prelude.push(this._serializeInitializationCallback());
      this.prelude.push(this._serializeRegisterInitializationCallback());
    }
  }

}

exports.LazyObjectsSerializer = LazyObjectsSerializer;
//# sourceMappingURL=LazyObjectsSerializer.js.map

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapRefCounter = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(10);

var _HeapInspector = __webpack_require__(426);

var _ResidualHeapVisitor = __webpack_require__(423);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/**
 * Record residual heap object's incoming and outgoing reference counts.
 */
class ResidualHeapRefCounter extends _ResidualHeapVisitor.ResidualHeapVisitor {
  constructor(realm, logger, modules, additionalFunctionValuesAndEffects) {
    super(realm, logger, modules, additionalFunctionValuesAndEffects);
    this._valueToEdgeRecord = new Map();
    this._path = [];
  }

  // Contains the path of nodes from root to current visiting node.
  getResult() {
    return this._valueToEdgeRecord;
  }

  _shouldIgnore(val) {
    return val instanceof _index.EmptyValue || val.isIntrinsic() || _HeapInspector.HeapInspector.isLeaf(val);
  }

  preProcessValue(val) {
    if (this._shouldIgnore(val)) {
      return false;
    }

    if (this._path.length > 0) {
      this._updateParentOutgoingEdgeCount();
    }

    this._path.push(val);

    return this._updateValueIncomingEdgeCount(val);
  }

  _updateParentOutgoingEdgeCount() {
    const parent = this._path[this._path.length - 1];

    const edgeRecord = this._valueToEdgeRecord.get(parent);

    (0, _invariant.default)(edgeRecord);
    ++edgeRecord.outGoing;
  }

  _updateValueIncomingEdgeCount(val) {
    let edgeRecord = this._valueToEdgeRecord.get(val);

    if (edgeRecord === undefined) {
      this._valueToEdgeRecord.set(val, {
        inComing: 1,
        outGoing: 0
      });

      return true;
    } else {
      ++edgeRecord.inComing;
      return false; // visited node, skip its children.
    }
  } // Override.


  postProcessValue(val) {
    if (this._shouldIgnore(val)) {
      return;
    }

    (0, _invariant.default)(this._path.length > 0);

    this._path.pop();
  } // Override.


  visitRoots() {
    super.visitRoots();
    (0, _invariant.default)(this._path.length === 0, "Path should be balanced empty after traversal.");
  }

}

exports.ResidualHeapRefCounter = ResidualHeapRefCounter;
//# sourceMappingURL=ResidualHeapRefCounter.js.map

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualHeapGraphGenerator = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(10);

var _HeapInspector = __webpack_require__(426);

var _ResidualHeapVisitor = __webpack_require__(423);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/**
 * Generate a visualizable objects graph for Prepack heap.
 */
class ResidualHeapGraphGenerator extends _ResidualHeapVisitor.ResidualHeapVisitor {
  constructor(realm, logger, modules, additionalFunctionValuesAndEffects, valueIdentifiers, valueToEdgeRecord) {
    super(realm, logger, modules, additionalFunctionValuesAndEffects);
    this._valueToEdgeRecord = valueToEdgeRecord;
    this._valueIdentifiers = valueIdentifiers;
    this._visitedValues = new Set();
    this._valueIds = new Map();
    this._idSeed = 0;
    this._path = [];
    this._edges = [];
  }

  // Override.
  preProcessValue(val) {
    if (this._shouldIgnore(val)) {
      return true;
    }

    this._updateEdge(val);

    if (this._visitedValues.has(val)) {
      return false; // Already visited.
    }

    this._visitedValues.add(val);

    return true;
  } // Override.


  postProcessValue(val) {
    if (this._shouldIgnore(val)) {
      return;
    }

    (0, _invariant.default)(this._path.length > 0);

    this._path.pop();
  }

  _getValueId(val) {
    let id = this._valueIds.get(val);

    if (id === undefined) {
      this._valueIds.set(val, ++this._idSeed);

      id = this._idSeed;
    }

    return id;
  }

  _shouldIgnore(val) {
    return val instanceof _index.EmptyValue || val.isIntrinsic() || _HeapInspector.HeapInspector.isLeaf(val);
  }

  _updateEdge(val) {
    if (this._path.length > 0) {
      const parent = this._path[this._path.length - 1];

      this._edges.push({
        fromId: this._getValueId(parent),
        toId: this._getValueId(val)
      });
    }

    this._path.push(val);
  }

  _getValueLabel(val) {
    // TODO: does not use ref count yet, figure out how to best visualize it later.
    const serializedId = this._valueIdentifiers.getIdentifier(val);

    (0, _invariant.default)(serializedId);
    return val.__originalName !== undefined ? `${serializedId.name}(${val.__originalName})` : serializedId.name;
  }

  _generateDotGraphData(nodes, edges) {
    let content = "digraph{\n";

    for (const val of nodes) {
      const nodeId = this._getValueId(val);

      content += `  node${nodeId} [shape=${this._getValueShape(val)} label=${this._getValueLabel(val)}];\n`;
    }

    for (const edge of edges) {
      content += `  node${edge.fromId} -> node${edge.toId};\n`;
    }

    content += "}";
    return content;
  }

  _generateVisJSGraphData(nodes, edges) {
    let nodesData = [];
    let edgesData = [];

    for (let node of nodes) {
      const nodeId = this._getValueId(node);

      let nodeData = {
        id: `${nodeId}`,
        label: this._getValueLabel(node),
        shape: this._getValueShape(node),
        color: this._getValueColor(node)
      };
      nodesData.push(nodeData);
    }

    for (let [index, edge] of edges.entries()) {
      let edgeData = {
        id: index,
        from: `${edge.fromId}`,
        to: `${edge.toId}`,
        arrows: "to"
      };
      edgesData.push(edgeData);
    }

    let graphData = {
      nodes: nodesData,
      edges: edgesData
    };
    return JSON.stringify(graphData);
  } // TODO: find a way to comment the meaning of shape => value mapping in final graph language.


  _getValueShape(val) {
    let shape = null;

    if (val instanceof _index.FunctionValue) {
      shape = "circle";
    } else if (val instanceof _index.AbstractValue) {
      shape = "diamond";
    } else if (val instanceof _index.ProxyValue) {
      shape = "triangle";
    } else if (val instanceof _index.SymbolValue) {
      shape = "star";
    } else if (val instanceof _index.ObjectValue) {
      shape = "box";
    } else {
      shape = "ellipse";
    }

    return shape;
  } // TODO: find a way to comment the meaning of shape => value mapping in final graph language.


  _getValueColor(val) {
    let shape = null;

    if (val instanceof _index.FunctionValue) {
      shape = "red";
    } else if (val instanceof _index.AbstractValue) {
      shape = "green";
    } else if (val instanceof _index.ProxyValue) {
      shape = "orange";
    } else if (val instanceof _index.SymbolValue) {
      shape = "yellow";
    } else if (val instanceof _index.ObjectValue) {
      shape = "#3BB9FF"; // light blue
    } else {
      shape = "grey";
    }

    return shape;
  }

  generateResult(heapGraphFormat) {
    return heapGraphFormat === "DotLanguage" ? this._generateDotGraphData(this._visitedValues, this._edges) : this._generateVisJSGraphData(this._visitedValues, this._edges);
  }

}

exports.ResidualHeapGraphGenerator = ResidualHeapGraphGenerator;
//# sourceMappingURL=ResidualHeapGraphGenerator.js.map

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualOptimizedFunctions = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _GeneratorTree = __webpack_require__(432);

var _environment = __webpack_require__(20);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class ResidualOptimizedFunctions {
  constructor(generatorTree, optimizedFunctionsAndEffects, residualValues) {
    this._generatorTree = generatorTree;
    this._optimizedFunctionsAndEffects = optimizedFunctionsAndEffects;
    this._residualValues = residualValues;
  }

  _isDefinedInsideFunction(childFunction, maybeParentFunctions) {
    for (let maybeParentFunction of maybeParentFunctions) {
      if (childFunction === maybeParentFunction) {
        continue;
      } // for optimized functions, we should use created objects


      let maybeParentFunctionInfo = this._optimizedFunctionsAndEffects.get(maybeParentFunction);

      if (maybeParentFunctionInfo && maybeParentFunctionInfo.effects.createdObjects.has(childFunction)) return true;else {
        // for other functions, check environment records
        let env = childFunction.$Environment;

        while (env.parent !== null) {
          let envRecord = env.environmentRecord;
          if (envRecord instanceof _environment.FunctionEnvironmentRecord && envRecord.$FunctionObject === maybeParentFunction) return true;
          env = env.parent;
        }
      }
    }

    return false;
  } // Check if an optimized function defines the given set of functions.


  _definesFunctions(possibleParentFunction, functions) {
    let maybeParentFunctionInfo = this._optimizedFunctionsAndEffects.get(possibleParentFunction);

    (0, _invariant.default)(maybeParentFunctionInfo);
    let createdObjects = maybeParentFunctionInfo.effects.createdObjects;

    for (let func of functions) if (func !== possibleParentFunction && !createdObjects.has(func)) return false;

    return true;
  } // Try and get the root optimized function when passed in an optimized function
  // that may or may not be nested in the tree of said root, or is the root optimized function


  tryGetOptimizedFunctionRoot(val) {
    let scopes = this._residualValues.get(val);

    (0, _invariant.default)(scopes !== undefined);
    return this.tryGetOutermostOptimizedFunction(scopes);
  } // Try and get the optimized function that contains all the scopes passed in (may be one of the
  // scopes passed in)


  tryGetOutermostOptimizedFunction(scopes) {
    let functionValues = new Set();
    (0, _invariant.default)(scopes !== undefined);

    for (let scope of scopes) {
      let s = scope;

      while (s instanceof _generator.Generator) {
        s = this._generatorTree.getParent(s);
      }

      if (s === "GLOBAL") return undefined;
      (0, _invariant.default)(s instanceof _index.FunctionValue);
      functionValues.add(s);
    }

    let outermostAdditionalFunctions = new Set(); // Get the set of optimized functions that may be the root

    for (let functionValue of functionValues) {
      if (this._optimizedFunctionsAndEffects.has(functionValue)) {
        if (!this._isDefinedInsideFunction(functionValue, functionValues)) outermostAdditionalFunctions.add(functionValue);
      } else {
        let f = this.tryGetOptimizedFunctionRoot(functionValue);
        if (f === undefined) return undefined;
        if (!this._isDefinedInsideFunction(f, functionValues)) outermostAdditionalFunctions.add(f);
      }
    }

    if (outermostAdditionalFunctions.size === 1) return [...outermostAdditionalFunctions][0]; // See if any of the outermost (or any of their parents) are the outermost optimized function

    let possibleRoots = [...outermostAdditionalFunctions];

    while (possibleRoots.length > 0) {
      let possibleRoot = possibleRoots.shift();
      if (this._definesFunctions(possibleRoot, outermostAdditionalFunctions)) return possibleRoot;

      let additionalFunctionEffects = this._optimizedFunctionsAndEffects.get(possibleRoot);

      (0, _invariant.default)(additionalFunctionEffects);
      let parent = additionalFunctionEffects.parentAdditionalFunction;
      if (parent) possibleRoots.push(parent);
    }

    return undefined;
  }

}

exports.ResidualOptimizedFunctions = ResidualOptimizedFunctions;
//# sourceMappingURL=ResidualOptimizedFunctions.js.map

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _realm = __webpack_require__(7);

var _initializeSingletons = _interopRequireDefault(__webpack_require__(450));

var _index = __webpack_require__(464);

var _global = _interopRequireDefault(__webpack_require__(561));

var _statistics = __webpack_require__(8);

var evaluators = _interopRequireWildcard(__webpack_require__(562));

var _singletons = __webpack_require__(236);

var _index3 = __webpack_require__(10);

var _Debugger = __webpack_require__(617);

var _simplifier = _interopRequireDefault(__webpack_require__(629));

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(opts = {}, debuggerConfigArgs, statistics = undefined, debugReproArgs) {
  (0, _initializeSingletons.default)();
  let r = new _realm.Realm(opts, statistics || new _statistics.RealmStatistics()); // Presence of debugChannel indicates we wish to use debugger.

  if (debuggerConfigArgs) {
    let debugChannel = debuggerConfigArgs.debugChannel;

    if (debugChannel) {
      (0, _invariant.default)(debugChannel.debuggerIsAttached(), "Debugger intends to be used but is not attached.");
      r.debuggerInstance = new _Debugger.DebugServer(debugChannel, r, debuggerConfigArgs);
    }
  }

  if (debugReproArgs !== undefined) r.debugReproManager = _singletons.DebugReproManager.construct(debugReproArgs);
  let i = r.intrinsics;
  (0, _index.initialize)(i, r); // TODO: Find a way to let different environments initialize their own global
  // object for special magic host objects such as the window object in the DOM.

  r.$GlobalObject = new _index3.ObjectValue(r, i.ObjectPrototype, "global");
  (0, _global.default)(r);

  for (let name in evaluators) r.evaluators[name] = evaluators[name];

  r.simplifyAndRefineAbstractValue = _simplifier.default.bind(null, r, false);
  r.simplifyAndRefineAbstractCondition = _simplifier.default.bind(null, r, true);
  r.$GlobalEnv = _singletons.Environment.NewGlobalEnvironment(r, r.$GlobalObject, r.$GlobalObject);
  return r;
}
//# sourceMappingURL=construct_realm.js.map

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var Singletons = _interopRequireWildcard(__webpack_require__(236));

var _create = __webpack_require__(451);

var _environment = __webpack_require__(453);

var _function = __webpack_require__(454);

var _leak = __webpack_require__(455);

var _join = __webpack_require__(456);

var _paths = __webpack_require__(457);

var _properties = __webpack_require__(458);

var _to = __webpack_require__(459);

var _widen = __webpack_require__(460);

var _ConcreteModelConverter = __webpack_require__(461);

var _DebugReproManager = __webpack_require__(462);

var _types = __webpack_require__(19);

var utils = _interopRequireWildcard(__webpack_require__(443));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default() {
  Singletons.setCreate(new _create.CreateImplementation());
  Singletons.setEnvironment(new _environment.EnvironmentImplementation());
  Singletons.setFunctions(new _function.FunctionImplementation());
  Singletons.setLeak(new _leak.LeakImplementation());
  Singletons.setMaterialize(new _leak.MaterializeImplementation());
  Singletons.setJoin(new _join.JoinImplementation());
  Singletons.setPath(new _paths.PathImplementation());
  Singletons.setPathConditions(val => new _paths.PathConditionsImplementation(val));
  Singletons.setProperties(new _properties.PropertiesImplementation());
  Singletons.setTo(new _to.ToImplementation());
  Singletons.setWiden(new _widen.WidenImplementation());
  Singletons.setConcretize(_ConcreteModelConverter.concretize);
  Singletons.setUtils(utils);
  Singletons.setDebugReproManager(new _DebugReproManager.DebugReproManagerImplementation());
}
//# sourceMappingURL=initialize-singletons.js.map

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CreateImplementation = void 0;

var _index = __webpack_require__(10);

var _get = __webpack_require__(230);

var _is = __webpack_require__(229);

var _abstract = __webpack_require__(233);

var _construct = __webpack_require__(228);

var _singletons = __webpack_require__(236);

var _strict = _interopRequireDefault(__webpack_require__(452));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _parse = _interopRequireDefault(__webpack_require__(227));

var _traverseFast = _interopRequireDefault(__webpack_require__(279));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const allElementTypes = ["Undefined", "Null", "Boolean", "String", "Symbol", "Number", "Object"];

class CreateImplementation {
  // ECMA262 9.4.3.3
  StringCreate(realm, value, prototype) {
    // 1. Assert: Type(value) is String.
    (0, _invariant.default)(value instanceof _index.StringValue, "expected string value"); // 2. Let S be a newly created String exotic object.

    let S = new _index.StringExotic(realm); // 3. Set the [[StringData]] internal slot of S to value.

    S.$StringData = value; // 4. Set S's essential internal methods to the default ordinary object definitions specified in 9.1.
    // 5. Set the [[GetOwnProperty]] internal method of S as specified in 9.4.3.1.
    // 6. Set the [[OwnPropertyKeys]] internal method of S as specified in 9.4.3.2.
    // 7. Set the [[Prototype]] internal slot of S to prototype.

    S.$Prototype = prototype; // 8. Set the [[Extensible]] internal slot of S to true.

    S.setExtensible(true); // 9. Let length be the number of code unit elements in value.

    let length = value.value.length; // 10. Perform ! DefinePropertyOrThrow(S, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).

    _singletons.Properties.DefinePropertyOrThrow(realm, S, "length", new _descriptors.PropertyDescriptor({
      value: new _index.NumberValue(realm, length),
      writable: false,
      enumerable: false,
      configurable: false
    })); // 11. Return S.


    return S;
  } // B.2.3.2.1


  CreateHTML(realm, string, tag, attribute, value) {
    // 1. Let str be ? RequireObjectCoercible(string).
    let str = (0, _abstract.RequireObjectCoercible)(realm, string); // 2. Let S be ? ToString(str).

    let S = _singletons.To.ToStringPartial(realm, str); // 3. Let p1 be the String value that is the concatenation of "<" and tag.


    let p1 = `<${tag}`; // 4. If attribute is not the empty String, then

    if (attribute) {
      // a. Let V be ? ToString(value).
      let V = _singletons.To.ToStringPartial(realm, value); // b. Let escapedV be the String value that is the same as V except that each occurrence of the code unit
      //    0x0022 (QUOTATION MARK) in V has been replaced with the six code unit sequence "&quot;".


      let escapedV = V.replace(/"/g, "&quot;"); // c. Let p1 be the String value that is the concatenation of the following String values:
      // - The String value of p1
      // - Code unit 0x0020 (SPACE)
      // - The String value of attribute
      // - Code unit 0x003D (EQUALS SIGN)
      // - Code unit 0x0022 (QUOTATION MARK)
      // - The String value of escapedV
      // - Code unit 0x0022 (QUOTATION MARK)

      p1 = `${p1} ${attribute}="${escapedV}"`;
    } // 5. Let p2 be the String value that is the concatenation of p1 and ">".


    let p2 = `${p1}>`; // 6. Let p3 be the String value that is the concatenation of p2 and S.

    let p3 = `${p2}${S}`; // 7. Let p4 be the String value that is the concatenation of p3, "</", tag, and ">".

    let p4 = `${p3}</${tag}>`; // 8. Return p4.

    return new _index.StringValue(realm, p4);
  } // ECMA262 9.4.4.8.1


  MakeArgGetter(realm, name, env) {
    return new _index.NativeFunctionValue(realm, undefined, undefined, 0, context => {
      return env.GetBindingValue(name, false);
    }, false);
  } // ECMA262 9.4.4.8.1


  MakeArgSetter(realm, name, env) {
    return new _index.NativeFunctionValue(realm, undefined, undefined, 1, (context, [value]) => {
      return env.SetMutableBinding(name, value, false);
    }, false);
  } // ECMA262 21.1.5.1


  CreateStringIterator(realm, string) {
    // 1. Assert: Type(string) is String.
    (0, _invariant.default)(string instanceof _index.StringValue, "expected string to be a string value"); // 2. Let iterator be ObjectCreate(%StringIteratorPrototype%,  [[IteratedString]], [[StringIteratorNextIndex]] ).

    let iterator = this.ObjectCreate(realm, realm.intrinsics.StringIteratorPrototype, {
      $IteratedString: undefined,
      $StringIteratorNextIndex: undefined
    }); // 3. Set iterator's [[IteratedString]] internal slot to string.

    iterator.$IteratedString = string; // 4. Set iterator's [[StringIteratorNextIndex]] internal slot to 0.

    iterator.$StringIteratorNextIndex = 0; // 5. Return iterator.

    return iterator;
  } // ECMA262 9.4.2.3


  ArraySpeciesCreate(realm, originalArray, length) {
    // 1. Assert: length is an integer Number  0.
    (0, _invariant.default)(length >= 0, "expected length >= 0"); // 2. If length is -0, let length be +0.

    if (Object.is(length, -0)) length = +0; // 3. Let C be undefined.

    let C = realm.intrinsics.undefined; // 4. Let isArray be ? IsArray(originalArray).

    let isArray = (0, _is.IsArray)(realm, originalArray); // 5. If isArray is true, then

    if (isArray) {
      // a. Let C be ? Get(originalArray, "constructor").
      C = (0, _get.Get)(realm, originalArray, "constructor"); // b. If IsConstructor(C) is true, then

      if ((0, _is.IsConstructor)(realm, C)) {
        (0, _invariant.default)(C instanceof _index.ObjectValue); // i. Let thisRealm be the current Realm Record.

        let thisRealm = realm; // ii. Let realmC be ? GetFunctionRealm(C).

        let realmC = (0, _get.GetFunctionRealm)(realm, C); // iii. If thisRealm and realmC are not the same Realm Record, then

        if (thisRealm !== realmC) {
          // 1. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, let C be undefined.
          if ((0, _abstract.SameValue)(realm, C, realmC.intrinsics.Array)) {
            C = realm.intrinsics.undefined;
          }
        }
      } // c. If Type(C) is Object, then


      if (C.mightBeObject()) {
        if (C.mightNotBeObject()) C.throwIfNotConcrete();
        (0, _invariant.default)(C instanceof _index.ObjectValue || C instanceof _index.AbstractObjectValue); // i. Let C be ? Get(C, @@species).

        C = (0, _get.Get)(realm, C, realm.intrinsics.SymbolSpecies); // ii. If C is null, let C be undefined.

        if (C instanceof _index.NullValue) C = realm.intrinsics.undefined;
      }
    } // 6. If C is undefined, return ? ArrayCreate(length).


    if (C instanceof _index.UndefinedValue) return this.ArrayCreate(realm, length); // 7. If IsConstructor(C) is false, throw a TypeError exception.

    if (!(0, _is.IsConstructor)(realm, C)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a constructor");
    } // 8. Return ? Construct(C,  length ).


    return (0, _construct.Construct)(realm, C.throwIfNotConcreteObject(), [new _index.NumberValue(realm, length)]).throwIfNotConcreteObject();
  } // ECMA262 7.4.7


  CreateIterResultObject(realm, value, done) {
    // 1. Assert: Type(done) is Boolean.
    (0, _invariant.default)(typeof done === "boolean", "expected done to be a boolean"); // 2. Let obj be ObjectCreate(%ObjectPrototype%).

    let obj = this.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 3. Perform CreateDataProperty(obj, "value", value).

    this.CreateDataProperty(realm, obj, "value", value); // 4. Perform CreateDataProperty(obj, "done", done).

    this.CreateDataProperty(realm, obj, "done", new _index.BooleanValue(realm, done)); // 5. Return obj.

    return obj;
  } // ECMA262 22.1.5.1


  CreateArrayIterator(realm, array, kind) {
    // 1. Assert: Type(array) is Object.
    (0, _invariant.default)(array instanceof _index.ObjectValue, "expected object"); // 2. Let iterator be ObjectCreate(%ArrayIteratorPrototype%,  [[IteratedObject]],
    //    [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] ).

    let iterator = this.ObjectCreate(realm, realm.intrinsics.ArrayIteratorPrototype, {
      $IteratedObject: undefined,
      $ArrayIteratorNextIndex: undefined,
      $ArrayIterationKind: undefined
    }); // 3. Set iterator's [[IteratedObject]] internal slot to array.

    iterator.$IteratedObject = array; // 4. Set iterator's [[ArrayIteratorNextIndex]] internal slot to 0.

    iterator.$ArrayIteratorNextIndex = new _index.NumberValue(realm, 0); // 5. Set iterator's [[ArrayIterationKind]] internal slot to kind.

    iterator.$ArrayIterationKind = kind; // 6. Return iterator.

    return iterator;
  } // ECMA262 9.4.2.2


  ArrayCreate(realm, length, proto) {
    // 1. Assert: length is an integer Number  0.
    (0, _invariant.default)(length >= 0); // 2. If length is -0, let length be +0.

    if (Object.is(length, -0)) length = +0; // 3. If length>232-1, throw a RangeError exception.

    if (length > Math.pow(2, 32) - 1) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "length>2^32-1");
    } // 4. If the proto argument was not passed, let proto be the intrinsic object %ArrayPrototype%.


    proto = proto || realm.intrinsics.ArrayPrototype; // 5. Let A be a newly created Array exotic object.

    let A = new _index.ArrayValue(realm); // 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.
    // 7. Set the [[DefineOwnProperty]] internal method of A as specified in 9.4.2.1.
    // 8. Set the [[Prototype]] internal slot of A to proto.

    A.$Prototype = proto; // 9. Set the [[Extensible]] internal slot of A to true.

    A.setExtensible(true); // 10. Perform ! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).

    _singletons.Properties.OrdinaryDefineOwnProperty(realm, A, "length", new _descriptors.PropertyDescriptor({
      value: new _index.NumberValue(realm, length),
      writable: true,
      enumerable: false,
      configurable: false
    })); // 11. Return A.


    return A;
  } // ECMA262 7.3.16


  CreateArrayFromList(realm, elems) {
    // 1. Assert: elements is a List whose elements are all ECMAScript language values.
    for (let elem of elems) (0, _invariant.default)(elem instanceof _index.Value, "value expected"); // 2. Let array be ArrayCreate(0) (see 9.4.2.2).


    let arr = this.ArrayCreate(realm, 0); // 3. Let n be 0.

    let n = 0; // 4. For each element e of elements

    for (let elem of elems) {
      // a. Let status be CreateDataProperty(array, ! ToString(n), e).
      let status = this.CreateDataProperty(realm, arr, new _index.StringValue(realm, n + ""), elem); // b. Assert: status is true.

      (0, _invariant.default)(status, "couldn't create data property"); // c. Increment n by 1.

      n++;
    } // 5. Return array.


    return arr;
  } // ECMA262 9.4.4.7


  CreateUnmappedArgumentsObject(realm, argumentsList) {
    // 1. Let len be the number of elements in argumentsList.
    let len = argumentsList.length; // 2. Let obj be ObjectCreate(%ObjectPrototype%,  [[ParameterMap]] ).

    let obj = this.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 3. Set obj's [[ParameterMap]] internal slot to undefined.

    obj.$ParameterMap = obj; // The value is never used, but allows us to use undefined for "not in"
    // 4. Perform DefinePropertyOrThrow(obj, "length", PropertyDescriptor{[[Value]]: len,
    //    [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).

    _singletons.Properties.DefinePropertyOrThrow(realm, obj, "length", new _descriptors.PropertyDescriptor({
      value: new _index.NumberValue(realm, len),
      writable: true,
      enumerable: false,
      configurable: true
    })); // 5. Let index be 0.


    let index = 0; // 6. Repeat while index < len,

    while (index < len) {
      // a. Let val be argumentsList[index].
      let val = argumentsList[index]; // b. Perform CreateDataProperty(obj, ! ToString(index), val).

      this.CreateDataProperty(realm, obj, new _index.StringValue(realm, index + ""), val); // c. Let index be index + 1.

      index++;
    } // 7. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]:
    //    %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).


    _singletons.Properties.DefinePropertyOrThrow(realm, obj, realm.intrinsics.SymbolIterator, new _descriptors.PropertyDescriptor({
      value: realm.intrinsics.ArrayProto_values,
      writable: true,
      enumerable: false,
      configurable: true
    })); // 8. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor {[[Get]]:
    // %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false}).


    _singletons.Properties.DefinePropertyOrThrow(realm, obj, "callee", new _descriptors.PropertyDescriptor({
      get: realm.intrinsics.ThrowTypeError,
      set: realm.intrinsics.ThrowTypeError,
      enumerable: false,
      configurable: false
    })); // 10. Return obj.


    return obj;
  } // ECMA262 9.4.4.8


  CreateMappedArgumentsObject(realm, func, formals, argumentsList, env) {
    // 1. Assert: formals does not contain a rest parameter, any binding patterns, or any
    //    initializers. It may contain duplicate identifiers.
    for (let param of formals) {
      (0, _invariant.default)(param.type === "Identifier", "expected only simple params");
    } // 2. Let len be the number of elements in argumentsList.


    let len = argumentsList.length; // 3. Let obj be a newly created arguments exotic object with a [[ParameterMap]] internal slot.

    let obj = new _index.ArgumentsExotic(realm); // 4. Set the [[GetOwnProperty]] internal method of obj as specified in 9.4.4.1.
    // 5. Set the [[DefineOwnProperty]] internal method of obj as specified in 9.4.4.2.
    // 6. Set the [[Get]] internal method of obj as specified in 9.4.4.3.
    // 7. Set the [[Set]] internal method of obj as specified in 9.4.4.4.
    // 8. Set the [[Delete]] internal method of obj as specified in 9.4.4.6.
    // 9. Set the remainder of obj's essential internal methods to the default ordinary
    //    object definitions specified in 9.1.
    // 10. Set the [[Prototype]] internal slot of obj to %ObjectPrototype%.

    obj.$Prototype = realm.intrinsics.ObjectPrototype; // 11. Set the [[Extensible]] internal slot of obj to true.

    obj.setExtensible(true); // 12. Let map be ObjectCreate(null).

    let map = new _index.ObjectValue(realm); // 13. Set the [[ParameterMap]] internal slot of obj to map.

    obj.$ParameterMap = map; // 14. Let parameterNames be the BoundNames of formals.

    let parameterNames = [];

    for (let param of formals) {
      parameterNames.push(param.name);
    } // 15. Let numberOfParameters be the number of elements in parameterNames.


    let numberOfParameters = parameterNames.length; // 16. Let index be 0.

    let index = 0; // 17. Repeat while index < len,

    while (index < len) {
      // a. Let val be argumentsList[index].
      let val = argumentsList[index]; // b. Perform CreateDataProperty(obj, ! ToString(index), val).

      this.CreateDataProperty(realm, obj, new _index.StringValue(realm, index + ""), val); // c. Let index be index + 1.

      index++;
    } // 18. Perform DefinePropertyOrThrow(obj, "length", PropertyDescriptor{[[Value]]: len,
    //     [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).


    _singletons.Properties.DefinePropertyOrThrow(realm, obj, "length", new _descriptors.PropertyDescriptor({
      value: new _index.NumberValue(realm, len),
      writable: true,
      enumerable: false,
      configurable: true
    })); // 19. Let mappedNames be an empty List.


    let mappedNames = []; // 20. Let index be numberOfParameters - 1.

    index = numberOfParameters - 1; // 21. Repeat while index  0,

    while (index >= 0) {
      // a. Let name be parameterNames[index].
      let name = parameterNames[index]; // b. If name is not an element of mappedNames, then

      if (mappedNames.indexOf(name) < 0) {
        // i. Add name as an element of the list mappedNames.
        mappedNames.push(name); // ii. If index < len, then

        if (index < len) {
          // 1. Let g be MakeArgGetter(name, env).
          let g = this.MakeArgGetter(realm, name, env); // 2. Let p be MakeArgSetter(name, env).

          let p = this.MakeArgSetter(realm, name, env); // 3. Perform map.[[DefineOwnProperty]](! ToString(index), PropertyDescriptor{[[Set]]: p, [[Get]]: g,
          //    [[Enumerable]]: false, [[Configurable]]: true}).

          map.$DefineOwnProperty(new _index.StringValue(realm, index + ""), new _descriptors.PropertyDescriptor({
            set: p,
            get: g,
            enumerable: false,
            configurable: true
          }));
        }
      } // c. Let index be index - 1.


      index--;
    } // 22. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]:
    //     %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).


    _singletons.Properties.DefinePropertyOrThrow(realm, obj, realm.intrinsics.SymbolIterator, new _descriptors.PropertyDescriptor({
      value: realm.intrinsics.ArrayProto_values,
      writable: true,
      enumerable: false,
      configurable: true
    })); // 23. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor {[[Value]]:
    //     func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).


    _singletons.Properties.DefinePropertyOrThrow(realm, obj, "callee", new _descriptors.PropertyDescriptor({
      value: func,
      writable: true,
      enumerable: false,
      configurable: true
    })); // 24. Return obj.


    return obj;
  } // ECMA262 7.3.4


  CreateDataProperty(realm, O, P, V) {
    // 1. Assert: Type(O) is Object.
    // 2. Assert: IsPropertyKey(P) is true.
    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "Not a property key"); // 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.

    let newDesc = new _descriptors.PropertyDescriptor({
      value: V,
      writable: true,
      enumerable: true,
      configurable: true
    }); // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).

    return O.$DefineOwnProperty(P, newDesc);
  }

  CopyDataProperties(realm, target, source, excluded) {
    // Assert: Type(target) is Object.
    (0, _invariant.default)(target instanceof _index.ObjectValue, "Not an object value"); // Assert: Type(excluded) is List.

    (0, _invariant.default)(excluded instanceof Array, "Not an array"); //   If source is undefined or null,

    if (source === realm.intrinsics.null || source === realm.intrinsics.undefined) {// let keys be a new empty List.
    } else {
      //   Else,
      // Let from be ! ToObject(source).
      let from = _singletons.To.ToObject(realm, source); // Let keys be ? from.[[OwnPropertyKeys]]().


      let keys = from.$OwnPropertyKeys(); //   Repeat for each element nextKey of keys in List order,

      for (let nextKey of keys) {
        // Let found be false.
        let found = false; //   Repeat for each element e of excluded,

        for (let e of excluded) {
          // Seems necessary. Flow complained too. Did I go wrong somewhere else?
          (0, _invariant.default)(e instanceof _index.StringValue);
          (0, _invariant.default)(nextKey instanceof _index.StringValue); // If e is not empty and SameValue(e, nextKey) is true, then

          if (!e.mightBeFalse() && (0, _abstract.SameValue)(realm, e, nextKey)) {
            // Set found to true.
            found = true;
          }
        } // If found is false, then


        if (found === false) {
          // Let desc be ? from.[[GetOwnProperty]](nextKey).
          let desc = from.$GetOwnProperty(nextKey); // If desc is not undefined and desc.[[Enumerable]] is true, then

          if (desc !== undefined && desc.throwIfNotConcrete(realm).enumerable === true) {
            // Let propValue be ? Get(from, nextKey).
            let propValue = (0, _get.Get)(realm, from, nextKey); // Perform ! CreateDataProperty(target, nextKey, propValue).

            this.CreateDataProperty(realm, target, nextKey, propValue);
          }
        }
      }
    } // Return target.


    return target;
  } // ECMA262 7.3.5


  CreateMethodProperty(realm, O, P, V) {
    // 1. Assert: Type(O) is Object.
    (0, _invariant.default)(O instanceof _index.ObjectValue, "Not an object value"); // 2. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "Not a property key"); // 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.

    let newDesc = new _descriptors.PropertyDescriptor({
      value: V,
      writable: true,
      enumerable: false,
      configurable: true
    }); // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).

    return O.$DefineOwnProperty(P, newDesc);
  } // ECMA262 7.3.6


  CreateDataPropertyOrThrow(realm, O, P, V) {
    // 1. Assert: Type(O) is Object.
    (0, _invariant.default)(O instanceof _index.ObjectValue, "Not an object value"); // 2. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _is.IsPropertyKey)(realm, P), "Not a property key"); //3. Let success be ? CreateDataProperty(O, P, V).

    let success = this.CreateDataProperty(realm, O, P, V); // 4. If success is false, throw a TypeError exception.

    if (success === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 5. Return success.


    return success;
  } // ECMA262 9.1.12


  ObjectCreate(realm, proto, internalSlotsList) {
    // 1. If internalSlotsList was not provided, let internalSlotsList be an empty List.
    internalSlotsList = internalSlotsList || {}; // 2. Let obj be a newly created object with an internal slot for each name in internalSlotsList.

    let obj = new _index.ObjectValue(realm);
    Object.assign(obj, internalSlotsList); // 3. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
    // 4. Set the [[Prototype]] internal slot of obj to proto.

    obj.$Prototype = proto; // 5. Set the [[Extensible]] internal slot of obj to true.

    obj.setExtensible(true); // 6. Return obj.

    return obj;
  } // ECMA262 9.1.13


  OrdinaryCreateFromConstructor(realm, constructor, intrinsicDefaultProto, internalSlotsList) {
    // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic
    //    object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]
    //    value of an object.
    (0, _invariant.default)(realm.intrinsics[intrinsicDefaultProto], "not a valid proto ref"); // 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).

    let proto = (0, _get.GetPrototypeFromConstructor)(realm, constructor, intrinsicDefaultProto); // 3. Return ObjectCreate(proto, internalSlotsList).

    return this.ObjectCreate(realm, proto, internalSlotsList);
  } // ECMA262 7.3.17


  CreateListFromArrayLike(realm, obj, elementTypes) {
    // 1. If elementTypes was not passed, let elementTypes be  Undefined, Null, Boolean, String, Symbol, Number, Object .
    elementTypes = elementTypes || allElementTypes; // 2. If Type(obj) is not Object, throw a TypeError exception.

    if (!(obj instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Not an object");
    } // 3. Let len be ? ToLength(? Get(obj, "length")).


    let len = _singletons.To.ToLength(realm, (0, _get.Get)(realm, obj, "length")); // 4. Let list be a new empty List.


    let list = []; // 5. Let index be 0.

    let index = 0; // 6. Repeat while index < len

    while (index < len) {
      // a. Let indexName be ! ToString(index).
      let indexName = index + ""; // b. Let next be ? Get(obj, indexName).

      let next = (0, _get.Get)(realm, obj, indexName); // c. If Type(next) is not an element of elementTypes, throw a TypeError exception.

      if (elementTypes !== allElementTypes && elementTypes.indexOf((0, _abstract.Type)(realm, next)) < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "invalid element type");
      } // d. Append next as the last element of list.


      list.push(next); // e. Set index to index + 1.

      index++;
    } // 7. Return list.


    return list;
  } // ECMA262 19.2.1.1.1


  CreateDynamicFunction(realm, constructor, newTarget, kind, args) {
    // 1. If newTarget is undefined, let newTarget be constructor.
    newTarget = !newTarget ? constructor : newTarget;
    let fallbackProto; // 2. If kind is "normal", then

    if (kind === "normal") {
      // a. Let goal be the grammar symbol FunctionBody.
      // b. Let parameterGoal be the grammar symbol FormalParameters.
      // c. Let fallbackProto be "%FunctionPrototype%".
      fallbackProto = "FunctionPrototype";
    } else {
      // 3. Else,
      // a. Let goal be the grammar symbol GeneratorBody.
      // b. Let parameterGoal be the grammar symbol FormalParameters[Yield].
      // c. Let fallbackProto be "%Generator%".
      fallbackProto = "Generator";
    } // 4. Let argCount be the number of elements in args.


    let argCount = args.length; // 5. Let P be the empty String.

    let P = "";
    let bodyText; // 6. If argCount = 0, let bodyText be the empty String.

    if (argCount === 0) {
      bodyText = realm.intrinsics.emptyString;
    } else if (argCount === 1) {
      // 7. Else if argCount = 1, let bodyText be args[0].
      bodyText = args[0];
    } else {
      // 8. Else argCount > 1,
      // a. Let firstArg be args[0].
      let firstArg = args[0]; // b. Let P be ? ToString(firstArg).

      P = _singletons.To.ToStringPartial(realm, firstArg); // c. Let k be 1.

      let k = 1; // d. Repeat, while k < argCount-1

      while (k < argCount - 1) {
        // i. Let nextArg be args[k].
        let nextArg = args[k]; // ii. Let nextArgString be ? ToString(nextArg).

        let nextArgString = _singletons.To.ToStringPartial(realm, nextArg); // iii. Let P be the result of concatenating the previous value of P, the String "," (a comma), and nextArgString.


        P = P + "," + nextArgString; // iv. Increase k by 1.

        k += 1;
      } // e. Let bodyText be args[k].


      bodyText = args[k];
    } // 9. Let bodyText be ? ToString(bodyText).


    bodyText = _singletons.To.ToStringPartial(realm, bodyText); // 10. Let parameters be the result of parsing P, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using parameterGoal as the goal symbol. Throw a SyntaxError exception if the parse fails.
    // 11. Let body be the result of parsing bodyText, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using goal as the goal symbol. Throw a SyntaxError exception if the parse fails.

    let ast;

    try {
      ast = (0, _parse.default)(realm, "function" + (kind === "generator" ? "*" : "") + " _(" + P + "){" + bodyText + "}", "eval");
    } catch (e) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "parse failed");
    }

    let {
      program: {
        body: [functionDeclaration]
      }
    } = ast;

    if (!functionDeclaration) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "parse failed");
    }

    (0, _invariant.default)(functionDeclaration.type === "FunctionDeclaration");
    let {
      params,
      body
    } = functionDeclaration; // 12. If bodyText is strict mode code, then let strict be true, else let strict be false.

    let strict = (0, _strict.default)(body); // 13. If any static semantics errors are detected for parameters or body, throw a SyntaxError or a ReferenceError exception, depending on the type of the error. If strict is true, the Early Error rules for StrictFormalParameters:FormalParameters are applied. Parsing and early error detection may be interweaved in an implementation dependent manner.
    // 14. If ContainsUseStrict of body is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.
    // 15. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.
    // 16. If body Contains SuperCall is true, throw a SyntaxError exception.
    // 17. If parameters Contains SuperCall is true, throw a SyntaxError exception.
    // 18. If body Contains SuperProperty is true, throw a SyntaxError exception.
    // 19. If parameters Contains SuperProperty is true, throw a SyntaxError exception.
    // 20. If kind is "generator", then

    if (kind === "generator") {
      // a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.
      let containsYield = false;

      for (let param of params) {
        (0, _traverseFast.default)(param, node => {
          if (node.type === "YieldExpression") {
            containsYield = true;
            return true;
          }

          if (node.type === "Identifier" && node.name === "yield") {
            containsYield = true;
            return true;
          }

          return false;
        });
      }

      if (containsYield) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, "parse failed");
      }
    } // 21. If strict is true, then


    if (strict === true) {} // a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.
    // 22. Let proto be ? GetPrototypeFromConstructor(newTarget, fallbackProto).


    let proto = (0, _get.GetPrototypeFromConstructor)(realm, newTarget, fallbackProto); // 23. Let F be FunctionAllocate(proto, strict, kind).

    let F = _singletons.Functions.FunctionAllocate(realm, proto, strict, kind); // 24. Let realmF be the value of F's [[Realm]] internal slot.


    let realmF = F.$Realm; // 25. Let scope be realmF.[[GlobalEnv]].

    let scope = realmF.$GlobalEnv; // 26. Perform FunctionInitialize(F, Normal, parameters, body, scope).

    _singletons.Functions.FunctionInitialize(realm, F, "normal", params, body, scope); // 27. If kind is "generator", then


    if (kind === "generator") {
      // a. Let prototype be ObjectCreate(%GeneratorPrototype%).
      let prototype = this.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);
      prototype.originalConstructor = F; // b. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).

      _singletons.Properties.DefinePropertyOrThrow(realm, F, "prototype", new _descriptors.PropertyDescriptor({
        value: prototype,
        writable: true,
        enumerable: false,
        configurable: false
      }));
    } else {
      // 28. Else, perform MakeConstructor(F).
      (0, _construct.MakeConstructor)(realm, F);
    } // 29. Perform SetFunctionName(F, "anonymous").


    _singletons.Functions.SetFunctionName(realm, F, "anonymous"); // 30. Return F.


    return F;
  }

}

exports.CreateImplementation = CreateImplementation;
//# sourceMappingURL=create.js.map

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = IsStrict;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function IsStrict(node) {
  if (node.type !== "BlockStatement" && node.type !== "Program") return false;
  let directives = node.directives;
  if (!directives) return false;
  return directives.some(directive => {
    if (directive.type !== "Directive") {
      return false;
    }

    if (directive.value.type !== "DirectiveLiteral") {
      return false;
    }

    return directive.value.value === "use strict";
  });
}
//# sourceMappingURL=strict.js.map

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnvironmentImplementation = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(10);

var _environment = __webpack_require__(20);

var _completions = __webpack_require__(18);

var _errors = __webpack_require__(3);

var _ObjectExpression = __webpack_require__(275);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class EnvironmentImplementation {
  // 2.6 RestBindingInitialization (please suggest an appropriate section name)
  RestBindingInitialization(realm, property, value, excludedNames, strictCode, environment) {
    let BindingIdentifier = property.argument; // 1. Let restObj be ObjectCreate(%ObjectPrototype%).

    let restObj = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 2. Let assignStatus be CopyDataProperties(restObj, value, excludedNames).

    /* let assignStatus = */


    _singletons.Create.CopyDataProperties(realm, restObj, value, excludedNames); // 3. ReturnIfAbrupt(assignStatus).
    // 4. Let bindingId be StringValue of BindingIdentifier.


    let bindingId = BindingIdentifier.name; // 5. Let lhs be ResolveBinding(bindingId, environment).

    let lhs = this.ResolveBinding(realm, bindingId, strictCode, environment); // 6. ReturnIfAbrupt(lhs).
    // 7. If environment is undefined, return PutValue(lhs, restObj).

    if (environment === undefined) {
      return _singletons.Properties.PutValue(realm, lhs, restObj);
    } // 8. Return InitializeReferencedBinding(lhs, restObj).


    return this.InitializeReferencedBinding(realm, lhs, restObj);
  } // 2.5  PropertyBindingInitialization (please suggest an appropriate section name)


  PropertyBindingInitialization(realm, properties, value, strictCode, environment) {
    // Base condition for recursive call below
    if (properties.length === 0) {
      return [];
    }

    let BindingProperty = properties.slice(-1)[0];
    let BindingPropertyList = properties.slice(0, -1); // 1. Let boundNames be the result of performing PropertyBindingInitialization for BindingPropertyList using value and environment as arguments.

    let boundNames = this.PropertyBindingInitialization(realm, BindingPropertyList, value, strictCode, environment); // 2. ReturnIfAbrupt(status boundNames).
    // 3. Let nextNames be the result of performing PropertyBindingInitialization for BindingProperty using value and environment as arguments.

    let nextNames; // SingleNameBinding
    // PropertyName : BindingElement
    // 1. Let P be the result of evaluating PropertyName.

    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;
    let P = (0, _ObjectExpression.EvalPropertyName)(BindingProperty, env, realm, strictCode); // 2. ReturnIfAbrupt(P).
    // 3. Let status be the result of performing KeyedBindingInitialization of BindingElement with value, environment, and P as the arguments.

    /* let status = */

    this.KeyedBindingInitialization(realm, BindingProperty.value, value, strictCode, environment, P); // 4. ReturnIfAbrupt(status).
    // 5. Return a new List containing P.

    nextNames = [P]; // 4. ReturnIfAbrupt(nextNames).
    // 5. Append each item in nextNames to the end of boundNames.

    boundNames = boundNames.concat(nextNames);
    return boundNames;
  } // ECMA262 6.2.3
  // IsSuperReference(V). Returns true if this reference has a thisValue component.


  IsSuperReference(realm, V) {
    return V.thisValue !== undefined;
  } // ECMA262 6.2.3
  // HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.


  HasPrimitiveBase(realm, V) {
    let base = this.GetBase(realm, V); // void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord | AbstractValue;

    if (!base || base instanceof _environment.EnvironmentRecord) return false;
    let type = base.getType();
    return type === _index.BooleanValue || type === _index.StringValue || type === _index.SymbolValue || type === _index.NumberValue || type === _index.IntegralValue;
  } // ECMA262 6.2.3
  // GetReferencedName(V). Returns the referenced name component of the reference V.


  GetReferencedName(realm, V) {
    if (V.referencedName instanceof _index.AbstractValue) {
      _index.AbstractValue.reportIntrospectionError(V.referencedName);

      throw new _errors.FatalError();
    }

    return V.referencedName;
  }

  GetReferencedNamePartial(realm, V) {
    return V.referencedName;
  } // ECMA262 6.2.3.1


  GetValue(realm, V) {
    let val = this._dereference(realm, V);

    if (val instanceof _index.AbstractValue) return realm.simplifyAndRefineAbstractValue(val);
    return val;
  }

  GetConditionValue(realm, V) {
    let val = this._dereference(realm, V);

    if (val instanceof _index.AbstractValue) return realm.simplifyAndRefineAbstractCondition(val);
    return val;
  }

  _dereferenceConditional(realm, ref, condValue, consequentVal, alternateVal) {
    return realm.evaluateWithAbstractConditional(condValue, () => {
      return realm.evaluateForEffects(() => {
        if ((0, _environment.isValidBaseValue)(consequentVal)) {
          let consequentRef = new _environment.Reference(consequentVal, ref.referencedName, ref.strict, ref.thisValue);
          return this._dereference(realm, consequentRef);
        }

        return this._dereference(realm, ref, false);
      }, null, "_dereferenceConditional consequent");
    }, () => {
      return realm.evaluateForEffects(() => {
        if ((0, _environment.isValidBaseValue)(alternateVal)) {
          let alternateRef = new _environment.Reference(alternateVal, ref.referencedName, ref.strict, ref.thisValue);
          return this._dereference(realm, alternateRef);
        }

        return this._dereference(realm, ref, false);
      }, null, "_dereferenceConditional alternate");
    });
  }

  _dereference(realm, V, deferenceConditionals = true) {
    // This step is not necessary as we propagate completions with exceptions.
    // 1. ReturnIfAbrupt(V).
    // 2. If Type(V) is not Reference, return V.
    if (!(V instanceof _environment.Reference)) return V; // 3. Let base be GetBase(V).

    let base = this.GetBase(realm, V); // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.

    if (this.IsUnresolvableReference(realm, V)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${V.referencedName.toString()} is not defined`);
    } // 5. If IsPropertyReference(V) is true, then


    if (this.IsPropertyReference(realm, V)) {
      if (base instanceof _index.AbstractValue) {
        if (deferenceConditionals && !(base instanceof _index.AbstractObjectValue)) {
          if (base.kind === "conditional") {
            let [condValue, consequentVal, alternateVal] = base.args;
            (0, _invariant.default)(condValue instanceof _index.AbstractValue);

            if ((0, _environment.isValidBaseValue)(consequentVal) || (0, _environment.isValidBaseValue)(alternateVal)) {
              return this._dereferenceConditional(realm, V, condValue, consequentVal, alternateVal);
            }
          } else if (base.kind === "||") {
            let [leftValue, rightValue] = base.args;
            (0, _invariant.default)(leftValue instanceof _index.AbstractValue);
            return this._dereferenceConditional(realm, V, leftValue, leftValue, rightValue);
          } else if (base.kind === "&&") {
            let [leftValue, rightValue] = base.args;
            (0, _invariant.default)(leftValue instanceof _index.AbstractValue);
            return this._dereferenceConditional(realm, V, leftValue, rightValue, leftValue);
          }
        } // Ensure that abstract values are coerced to objects. This might yield
        // an operation that might throw.


        base = _singletons.To.ToObject(realm, base);
      } // a. If HasPrimitiveBase(V) is true, then


      if (this.HasPrimitiveBase(realm, V)) {
        // i. Assert: In this case, base will never be null or undefined.
        (0, _invariant.default)(base instanceof _index.Value && !(0, _index2.HasSomeCompatibleType)(base, _index.UndefinedValue, _index.NullValue)); // ii. Let base be To.ToObject(base).

        base = _singletons.To.ToObject(realm, base);
      }

      (0, _invariant.default)(base instanceof _index.ObjectValue || base instanceof _index.AbstractObjectValue); // b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).

      return base.$GetPartial(this.GetReferencedNamePartial(realm, V), (0, _index2.GetThisValue)(realm, V));
    } // 6. Else base must be an Environment Record,


    if (base instanceof _environment.EnvironmentRecord) {
      // a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).
      let referencedName = this.GetReferencedName(realm, V);
      (0, _invariant.default)(typeof referencedName === "string");
      return base.GetBindingValue(referencedName, this.IsStrictReference(realm, V));
    }

    (0, _invariant.default)(false);
  } // ECMA262 6.2.3
  // IsStrictReference(V). Returns the strict reference flag component of the reference V.


  IsStrictReference(realm, V) {
    return V.strict;
  } // ECMA262 6.2.3
  // IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.


  IsPropertyReference(realm, V) {
    // V.base is AbstractValue | void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;
    return V.base instanceof _index.AbstractValue || V.base instanceof _index.ObjectValue || this.HasPrimitiveBase(realm, V);
  } // ECMA262 6.2.3
  // GetBase(V). Returns the base value component of the reference V.


  GetBase(realm, V) {
    return V.base;
  } // ECMA262 6.2.3
  // IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.


  IsUnresolvableReference(realm, V) {
    return !V.base;
  } // ECMA262 8.1.2.2


  NewDeclarativeEnvironment(realm, E, active = true) {
    // 1. Let env be a new Lexical Environment.
    let env = new _environment.LexicalEnvironment(realm);
    if (active) realm.activeLexicalEnvironments.add(env); // 2. Let envRec be a new declarative Environment Record containing no bindings.

    let envRec = new _environment.DeclarativeEnvironmentRecord(realm); // 3. Set env's EnvironmentRecord to envRec.

    env.environmentRecord = envRec; // 4. Set the outer lexical environment reference of env to E.

    env.parent = E; // 5. Return env.

    return env;
  }

  BoundNames(realm, node) {
    return Object.keys(t.getOuterBindingIdentifiers(node));
  } // ECMA262 13.3.3.2


  ContainsExpression(realm, node) {
    if (!node) {
      return false;
    }

    switch (node.type) {
      case "ObjectPattern":
        for (let prop of node.properties) {
          if (this.ContainsExpression(realm, prop)) return true;
        }

        return false;

      case "ArrayPattern":
        for (let elem of node.elements) {
          if (this.ContainsExpression(realm, elem)) return true;
        }

        return false;

      case "RestElement":
        return this.ContainsExpression(realm, node.argument);

      case "AssignmentPattern":
        return true;

      default:
        return false;
    }
  } // ECMA262 8.3.2


  ResolveBinding(realm, name, strict, env) {
    // 1. If env was not passed or if env is undefined, then
    if (!env) {
      // a. Let env be the running execution context's LexicalEnvironment.
      env = realm.getRunningContext().lexicalEnvironment;
    } // 2. Assert: env is a Lexical Environment.


    (0, _invariant.default)(env instanceof _environment.LexicalEnvironment, "expected lexical environment"); // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.
    // 4. Return ? GetIdentifierReference(env, name, strict).

    return this.GetIdentifierReference(realm, env, name, strict);
  } // ECMA262 8.1.2.1


  GetIdentifierReference(realm, lex, name, strict) {
    // 1. If lex is the value null, then
    if (!lex) {
      // a. Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict.
      return new _environment.Reference(undefined, name, strict);
    } // 2. Let envRec be lex's EnvironmentRecord.


    let envRec = lex.environmentRecord; // 3. Let exists be ? envRec.HasBinding(name).

    let exists = envRec.HasBinding(name); // 4. If exists is true, then

    if (exists) {
      // a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict.
      return new _environment.Reference(envRec, name, strict);
    } else {
      // 5. Else,
      // a. Let outer be the value of lex's outer environment reference.
      let outer = lex.parent; // b. Return ? GetIdentifierReference(outer, name, strict).

      return this.GetIdentifierReference(realm, outer, name, strict);
    }
  } // ECMA262 6.2.3.4


  InitializeReferencedBinding(realm, V, W) {
    // 1. ReturnIfAbrupt(V).
    // 2. ReturnIfAbrupt(W).
    // 3. Assert: Type(V) is Reference.
    (0, _invariant.default)(V instanceof _environment.Reference, "expected reference"); // 4. Assert: IsUnresolvableReference(V) is false.

    (0, _invariant.default)(!this.IsUnresolvableReference(realm, V), "expected resolvable reference"); // 5. Let base be GetBase(V).

    let base = this.GetBase(realm, V); // 6. Assert: base is an Environment Record.

    (0, _invariant.default)(base instanceof _environment.EnvironmentRecord, "expected environment record"); // 7. Return base.InitializeBinding(GetReferencedName(V), W).

    let referencedName = this.GetReferencedName(realm, V);
    (0, _invariant.default)(typeof referencedName === "string");
    return base.InitializeBinding(referencedName, W);
  } // ECMA262 13.2.14


  BlockDeclarationInstantiation(realm, strictCode, body, env) {
    // 1. Let envRec be env's EnvironmentRecord.
    let envRec = env.environmentRecord; // 2. Assert: envRec is a declarative Environment Record.

    (0, _invariant.default)(envRec instanceof _environment.DeclarativeEnvironmentRecord, "expected declarative environment record"); // 3. Let declarations be the LexicallyScopedDeclarations of code.

    let declarations = [];

    for (let node of body) {
      if (node.type === "ClassDeclaration" || node.type === "FunctionDeclaration" || node.type === "VariableDeclaration" && node.kind !== "var") {
        declarations.push(node);
      }
    } // 4. For each element d in declarations do


    for (let d of declarations) {
      // a. For each element dn of the BoundNames of d do
      for (let dn of this.BoundNames(realm, d)) {
        if (envRec.HasBinding(dn)) {
          //ECMA262 13.2.1
          throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, dn + " already declared");
        } // i. If IsConstantDeclaration of d is true, then


        if (d.type === "VariableDeclaration" && d.kind === "const") {
          // 1. Perform ! envRec.CreateImmutableBinding(dn, true).
          envRec.CreateImmutableBinding(dn, true);
        } else {
          // ii. Else,
          // 1. Perform ! envRec.CreateMutableBinding(dn, false).
          envRec.CreateMutableBinding(dn, false);
        }
      } // b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then


      if (d.type === "FunctionDeclaration") {
        // i. Let fn be the sole element of the BoundNames of d.
        let fn = this.BoundNames(realm, d)[0]; // ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.

        let fo = env.evaluate(d, strictCode);
        (0, _invariant.default)(fo instanceof _index.Value); // iii. Perform envRec.InitializeBinding(fn, fo).

        envRec.InitializeBinding(fn, fo);
      }
    }
  } // ECMA262 8.1.2.5


  NewGlobalEnvironment(realm, G, thisValue) {
    // 1. Let env be a new Lexical Environment.
    let env = new _environment.LexicalEnvironment(realm); // 2. Let objRec be a new object Environment Record containing G as the binding object.

    let objRec = new _environment.ObjectEnvironmentRecord(realm, G); // 3. Let dclRec be a new declarative Environment Record containing no bindings.

    let dclRec = new _environment.DeclarativeEnvironmentRecord(realm); // 4. Let globalRec be a new global Environment Record.

    let globalRec = new _environment.GlobalEnvironmentRecord(realm); // 5. Set globalRec.[[ObjectRecord]] to objRec.

    globalRec.$ObjectRecord = objRec; // 6. Set globalRec.[[GlobalThisValue]] to thisValue.

    globalRec.$GlobalThisValue = thisValue; // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.

    globalRec.$DeclarativeRecord = dclRec; // 8. Set globalRec.[[VarNames]] to a new empty List.

    globalRec.$VarNames = []; // 9. Set env's EnvironmentRecord to globalRec.

    env.environmentRecord = globalRec;
    realm.activeLexicalEnvironments.add(env); // 10. Set the outer lexical environment reference of env to null.

    env.parent = null; // 11. Return env.

    return env;
  } // ECMA262 8.1.2.3


  NewObjectEnvironment(realm, O, E) {
    // 1. Let env be a new Lexical Environment.
    let env = new _environment.LexicalEnvironment(realm);
    realm.activeLexicalEnvironments.add(env); // 2. Let envRec be a new object Environment Record containing O as the binding object.

    let envRec = new _environment.ObjectEnvironmentRecord(realm, O); // 3. Set env's EnvironmentRecord to envRec.

    env.environmentRecord = envRec; // 4. Set the outer lexical environment reference of env to E.

    env.parent = E; // 5. Return env.

    return env;
  } // ECMA262 8.1.2.4


  NewFunctionEnvironment(realm, F, newTarget) {
    // 1. Assert: F is an ECMAScript function.
    (0, _invariant.default)(F instanceof _index.ECMAScriptFunctionValue, "expected a function"); // 2. Assert: Type(newTarget) is Undefined or Object.

    (0, _invariant.default)(newTarget === undefined || newTarget instanceof _index.ObjectValue, "expected undefined or object value for new target"); // 3. Let env be a new Lexical Environment.

    let env = new _environment.LexicalEnvironment(realm);
    realm.activeLexicalEnvironments.add(env); // 4. Let envRec be a new function Environment Record containing no bindings.

    let envRec = new _environment.FunctionEnvironmentRecord(realm); // 5. Set envRec.[[FunctionObject]] to F.

    envRec.$FunctionObject = F; // 6. If F's [[ThisMode]] internal slot is lexical, set envRec.[[ThisBindingStatus]] to "lexical".

    if (F.$ThisMode === "lexical") {
      envRec.$ThisBindingStatus = "lexical";
    } else {
      // 7. Else, set envRec.[[ThisBindingStatus]] to "uninitialized".
      envRec.$ThisBindingStatus = "uninitialized";
    } // 8. Let home be the value of F's [[HomeObject]] internal slot.


    let home = F.$HomeObject; // 9. Set envRec.[[HomeObject]] to home.

    envRec.$HomeObject = home; // 10. Set envRec.[[NewTarget]] to newTarget.

    envRec.$NewTarget = newTarget; // 11. Set env's EnvironmentRecord to envRec.

    env.environmentRecord = envRec; // 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot.

    env.parent = F.$Environment; // 13. Return env.

    return env;
  } // ECMA262 8.3.1


  GetActiveScriptOrModule(realm) {
    // The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the active function object.
    // GetActiveScriptOrModule performs the following steps:
    //
    // If the execution context stack is empty, return null.
    if (realm.contextStack.length === 0) return null; // Let ec be the topmost execution context on the execution context stack whose Function component's [[ScriptOrModule]] component is not null.
    // If such an execution context exists, return ec's Function component's [[ScriptOrModule]] slot's value.

    let ec;

    for (let i = realm.contextStack.length - 1; i >= 0; i--) {
      ec = realm.contextStack[i];
      let F = ec.function;
      if (F == null) continue;

      if (F.$ScriptOrModule instanceof Object) {
        return F.$ScriptOrModule;
      }
    } // Otherwise, let ec be the running execution context.


    ec = realm.getRunningContext(); // Assert: ec's ScriptOrModule component is not null.

    (0, _invariant.default)(ec.ScriptOrModule !== null); // Return ec's ScriptOrModule component.

    return ec.ScriptOrModule;
  } // ECMA262 8.3.3


  GetThisEnvironment(realm) {
    // 1. Let lex be the running execution context's LexicalEnvironment.
    let lex = realm.getRunningContext().lexicalEnvironment; // 2. Repeat

    while (true) {
      // a. Let envRec be lex's EnvironmentRecord.
      let envRec = lex.environmentRecord; // b. Let exists be envRec.HasThisBinding().

      let exists = envRec.HasThisBinding(); // c. If exists is true, return envRec.

      if (exists) return envRec; // d. Let outer be the value of lex's outer environment reference.

      let outer = lex.parent;
      (0, _invariant.default)(outer); // e. Let lex be outer.

      lex = outer;
    }

    (0, _invariant.default)(false);
  } // ECMA262 8.3.4


  ResolveThisBinding(realm) {
    // 1. Let envRec be GetThisEnvironment( ).
    let envRec = this.GetThisEnvironment(realm); // 2. Return ? envRec.GetThisBinding().

    return envRec.GetThisBinding();
  }

  BindingInitialization(realm, node, value, strictCode, environment) {
    if (node.type === "ArrayPattern") {
      // ECMA262 13.3.3.5
      // 1. Let iterator be ? GetIterator(value).
      let iterator = (0, _index2.GetIterator)(realm, value); // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.

      let iteratorRecord = {
        $Iterator: iterator,
        $Done: false
      };
      let result; // 3. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.

      try {
        result = this.IteratorBindingInitialization(realm, node.elements, iteratorRecord, strictCode, environment);
      } catch (error) {
        // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).
        if (iteratorRecord.$Done === false && error instanceof _completions.AbruptCompletion) {
          throw (0, _index2.IteratorClose)(realm, iterator, error);
        }

        throw error;
      } // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).


      if (iteratorRecord.$Done === false) {
        let completion = (0, _index2.IteratorClose)(realm, iterator, new _completions.SimpleNormalCompletion(realm.intrinsics.undefined));

        if (completion instanceof _completions.AbruptCompletion) {
          throw completion;
        }
      } // 5. Return result.


      return result;
    } else if (node.type === "ObjectPattern") {
      (0, _index2.RequireObjectCoercible)(realm, value);
      let BindingPropertyList = [],
          BindingRestElement = null;

      for (let property of node.properties) {
        if (property.type === "RestElement") {
          BindingRestElement = property;
        } else {
          BindingPropertyList.push(property);
        }
      } // ObjectBindingPattern:
      //   { BindingPropertyList }
      //   { BindingPropertyList, }


      if (!BindingRestElement) {
        // 1. Let excludedNames be the result of performing PropertyBindingInitialization for BindingPropertyList using value and environment as the argument.

        /* let excludedNames = */
        this.PropertyBindingInitialization(realm, BindingPropertyList, value, strictCode, environment); // 2. ReturnIfAbrupt(excludedNames).
        // 3. Return NormalCompletion(empty).

        return realm.intrinsics.empty;
      } // ObjectBindingPattern : { BindingRestElement }


      if (BindingPropertyList.length === 0) {
        // 1. Let excludedNames be a new empty List.
        let excludedNames = []; // 2. Return the result of performing RestBindingInitialization of BindingRestElement with value, environment and excludedNames as the arguments.

        return this.RestBindingInitialization(realm, BindingRestElement, value, excludedNames, strictCode, environment);
      } else {
        // ObjectBindingPattern : { BindingPropertyList, BindingRestElement }
        // 1. Let excludedNames be the result of performing PropertyBindingInitialization of BindingPropertyList using value and environment as arguments.
        let excludedNames = this.PropertyBindingInitialization(realm, BindingPropertyList, value, strictCode, environment); // 2. ReturnIfAbrupt(excludedNames).
        // 3. Return the result of performing RestBindingInitialization of BindingRestElement with value, environment and excludedNames as the arguments.

        return this.RestBindingInitialization(realm, BindingRestElement, value, excludedNames, strictCode, environment);
      }
    } else if (node.type === "Identifier") {
      // ECMA262 12.1.5
      // 1. Let name be StringValue of Identifier.
      let name = node.name; // 2. Return ? InitializeBoundName(name, value, environment).

      return this.InitializeBoundName(realm, name, value, environment);
    } else {
      (0, _invariant.default)(node.type === "VariableDeclaration"); // ECMA262 13.7.5.9

      for (let decl of node.declarations) {
        this.BindingInitialization(realm, decl.id, value, strictCode, environment);
      }
    }
  } // ECMA262 13.3.3.6
  // ECMA262 14.1.19


  IteratorBindingInitialization(realm, formals, iteratorRecord, strictCode, environment) {
    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment; // Check if the last formal is a rest element. If so then we want to save the
    // element and handle it separately after we iterate through the other
    // formals. This also enforces that a rest element may only ever be in the
    // last position.

    let restEl;

    if (formals.length > 0) {
      let lastFormal = formals[formals.length - 1];

      if (lastFormal !== null && lastFormal.type === "RestElement") {
        restEl = lastFormal;
        formals = formals.slice(0, -1);
      }
    }

    for (let param of formals) {
      if (param === null) {
        // Elision handling in IteratorDestructuringAssignmentEvaluation
        // 1. If iteratorRecord.[[Done]] is false, then
        if (iteratorRecord.$Done === false) {
          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
          let next;

          try {
            next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
          } catch (e) {
            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (e instanceof _completions.AbruptCompletion) {
              iteratorRecord.$Done = true;
            } // c. ReturnIfAbrupt(next).


            throw e;
          } // d. If next is false, set iteratorRecord.[[Done]] to true.


          if (next === false) {
            iteratorRecord.$Done = true;
          }
        } // 2. Return NormalCompletion(empty).


        continue;
      }

      let Initializer;

      if (param.type === "AssignmentPattern") {
        Initializer = param.right;
        param = param.left;
      }

      if (param.type === "Identifier") {
        // SingleNameBinding : BindingIdentifier Initializer
        // 1. Let bindingId be StringValue of BindingIdentifier.
        let bindingId = param.name; // 2. Let lhs be ? ResolveBinding(bindingId, environment).

        let lhs = this.ResolveBinding(realm, param.name, strictCode, environment); // Initialized later in the algorithm.

        let v; // 3. If iteratorRecord.[[Done]] is false, then

        if (iteratorRecord.$Done === false) {
          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
          let next;

          try {
            next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
          } catch (e) {
            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (e instanceof _completions.AbruptCompletion) {
              iteratorRecord.$Done = true;
            } // c. ReturnIfAbrupt(next).


            throw e;
          } // d. If next is false, set iteratorRecord.[[Done]] to true.


          if (next === false) {
            iteratorRecord.$Done = true; // Normally this assignment would be done in step 4, but we do it
            // here so that Flow knows `v` will always be initialized by step 5.

            v = realm.intrinsics.undefined;
          } else {
            // e. Else,
            // i. Let v be IteratorValue(next).
            try {
              v = (0, _index2.IteratorValue)(realm, next);
            } catch (e) {
              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
              if (e instanceof _completions.AbruptCompletion) {
                iteratorRecord.$Done = true;
              } // iii. ReturnIfAbrupt(v).


              throw e;
            }
          }
        } else {
          // 4. If iteratorRecord.[[Done]] is true, let v be undefined.
          v = realm.intrinsics.undefined;
        } // 5. If Initializer is present and v is undefined, then


        if (Initializer && v instanceof _index.UndefinedValue) {
          // a. Let defaultValue be the result of evaluating Initializer.
          let defaultValue = env.evaluate(Initializer, strictCode); // b. Let v be ? GetValue(defaultValue).

          v = this.GetValue(realm, defaultValue); // c. If IsAnonymousFunctionDefinition(Initializer) is true, then

          if ((0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer) && v instanceof _index.ObjectValue) {
            // i. Let hasNameProperty be ? HasOwnProperty(v, "name").
            let hasNameProperty = (0, _index2.HasOwnProperty)(realm, v, "name"); // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).

            if (hasNameProperty === false) {
              _singletons.Functions.SetFunctionName(realm, v, bindingId);
            }
          }
        } // 6. If environment is undefined, return ? PutValue(lhs, v).


        if (!environment) {
          _singletons.Properties.PutValue(realm, lhs, v);

          continue;
        } // 7. Return InitializeReferencedBinding(lhs, v).


        this.InitializeReferencedBinding(realm, lhs, v);
        continue;
      } else {
        (0, _invariant.default)(param.type === "ObjectPattern" || param.type === "ArrayPattern"); // BindingElement : BindingPatternInitializer
        // Initialized later in the algorithm.

        let v; // 1. If iteratorRecord.[[Done]] is false, then

        if (iteratorRecord.$Done === false) {
          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
          let next;

          try {
            next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
          } catch (e) {
            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (e instanceof _completions.AbruptCompletion) {
              iteratorRecord.$Done = true;
            } // c. ReturnIfAbrupt(next).


            throw e;
          } // d. If next is false, set iteratorRecord.[[Done]] to true.


          if (next === false) {
            iteratorRecord.$Done = true; // Normally this assignment would be done in step 2, but we do it
            // here so that Flow knows `v` will always be initialized by step 3.

            v = realm.intrinsics.undefined;
          } else {
            // e. Else,
            // i. Let v be IteratorValue(next).
            try {
              v = (0, _index2.IteratorValue)(realm, next);
            } catch (e) {
              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
              if (e instanceof _completions.AbruptCompletion) {
                iteratorRecord.$Done = true;
              } // iii. ReturnIfAbrupt(v).


              throw e;
            }
          }
        } else {
          // 2. If iteratorRecord.[[Done]] is true, let v be undefined.
          v = realm.intrinsics.undefined;
        } // 3. If Initializer is present and v is undefined, then


        if (Initializer && v instanceof _index.UndefinedValue) {
          // a. Let defaultValue be the result of evaluating Initializer.
          let defaultValue = env.evaluate(Initializer, strictCode); // b. Let v be ? GetValue(defaultValue).

          v = this.GetValue(realm, defaultValue);
        } // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.


        this.BindingInitialization(realm, param, v, strictCode, environment);
        continue;
      }
    } // Handle the rest element if we have one.


    if (restEl && restEl.argument.type === "Identifier") {
      // BindingRestElement : ...BindingIdentifier
      // 1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).
      let lhs = this.ResolveBinding(realm, restEl.argument.name, strictCode, environment); // 2. Let A be ArrayCreate(0).

      let A = _singletons.Create.ArrayCreate(realm, 0); // 3. Let n be 0.


      let n = 0; // 4. Repeat,

      while (true) {
        // Initialized later in the algorithm.
        let next; // a. If iteratorRecord.[[Done]] is false, then

        if (iteratorRecord.$Done === false) {
          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
          try {
            next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
          } catch (e) {
            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (e instanceof _completions.AbruptCompletion) {
              iteratorRecord.$Done = true;
            } // iii. ReturnIfAbrupt(next).


            throw e;
          } // iv. If next is false, set iteratorRecord.[[Done]] to true.


          if (next === false) {
            iteratorRecord.$Done = true;
          }
        } // b. If iteratorRecord.[[Done]] is true, then


        if (iteratorRecord.$Done === true) {
          // i. If environment is undefined, return ? PutValue(lhs, A).
          if (!environment) {
            _singletons.Properties.PutValue(realm, lhs, A);

            break;
          } // ii. Return InitializeReferencedBinding(lhs, A).


          this.InitializeReferencedBinding(realm, lhs, A);
          break;
        } // Given the nature of the algorithm this should always be true, however
        // it is difficult to arrange the code in such a way where Flow's control
        // flow analysis will pick that up, so we add an invariant here.


        (0, _invariant.default)(next instanceof _index.ObjectValue); // c. Let nextValue be IteratorValue(next).

        let nextValue;

        try {
          nextValue = (0, _index2.IteratorValue)(realm, next);
        } catch (e) {
          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
          if (e instanceof _completions.AbruptCompletion) {
            iteratorRecord.$Done = true;
          } // e. ReturnIfAbrupt(nextValue).


          throw e;
        } // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).


        let status = _singletons.Create.CreateDataProperty(realm, A, n.toString(), nextValue); // g. Assert: status is true.


        (0, _invariant.default)(status, "expected to create data property"); // h. Increment n by 1.

        n += 1;
      }
    } else if (restEl) {
      (0, _invariant.default)(restEl.argument.type === "ArrayPattern" || restEl.argument.type === "ObjectPattern"); // 1. Let A be ArrayCreate(0).

      let A = _singletons.Create.ArrayCreate(realm, 0); // 2. Let n be 0.


      let n = 0; // 3. Repeat,

      while (true) {
        // Initialized later in the algorithm.
        let next; // a. If iteratorRecord.[[Done]] is false, then

        if (iteratorRecord.$Done === false) {
          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).
          try {
            next = (0, _index2.IteratorStep)(realm, iteratorRecord.$Iterator);
          } catch (e) {
            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (e instanceof _completions.AbruptCompletion) {
              iteratorRecord.$Done = true;
            } // iii. ReturnIfAbrupt(next).


            throw e;
          } // iv. If next is false, set iteratorRecord.[[Done]] to true.


          if (next === false) {
            iteratorRecord.$Done = true;
          }
        } // b. If iteratorRecord.[[Done]] is true, then


        if (iteratorRecord.$Done === true) {
          // i. Return the result of performing BindingInitialization of BindingPattern with A and environment as the arguments.
          this.BindingInitialization(realm, restEl.argument, A, strictCode, environment);
          break;
        } // Given the nature of the algorithm this should always be true, however
        // it is difficult to arrange the code in such a way where Flow's control
        // flow analysis will pick that up, so we add an invariant here.


        (0, _invariant.default)(next instanceof _index.ObjectValue); // c. Let nextValue be IteratorValue(next).

        let nextValue;

        try {
          nextValue = (0, _index2.IteratorValue)(realm, next);
        } catch (e) {
          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
          if (e instanceof _completions.AbruptCompletion) {
            iteratorRecord.$Done = true;
          } // e. ReturnIfAbrupt(nextValue).


          throw e;
        } // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).


        let status = _singletons.Create.CreateDataProperty(realm, A, n.toString(), nextValue); // g. Assert: status is true.


        (0, _invariant.default)(status, "expected to create data property"); // h. Increment n by 1.

        n += 1;
      }
    }
  } // ECMA262 12.1.5.1


  InitializeBoundName(realm, name, value, environment) {
    // 1. Assert: Type(name) is String.
    (0, _invariant.default)(typeof name === "string", "expected name to be a string"); // 2. If environment is not undefined, then

    if (environment) {
      // a. Let env be the EnvironmentRecord component of environment.
      let env = environment.environmentRecord; // b. Perform env.InitializeBinding(name, value).

      env.InitializeBinding(name, value); // c. Return NormalCompletion(undefined).

      return realm.intrinsics.undefined;
    } else {
      // 3. Else,
      // a. Let lhs be ResolveBinding(name).
      // Note that the undefined environment implies non-strict.
      let lhs = this.ResolveBinding(realm, name, false); // b. Return ? PutValue(lhs, value).

      return _singletons.Properties.PutValue(realm, lhs, value);
    }
  } // ECMA262 12.3.1.3 and 13.7.5.6


  IsDestructuring(ast) {
    switch (ast.type) {
      case "VariableDeclaration":
        for (let decl of ast.declarations) {
          switch (decl.type) {
            case "VariableDeclarator":
              switch (decl.id.type) {
                case "ArrayPattern":
                case "AssignmentPattern":
                case "ObjectPattern":
                  return true;

                default:
                  break;
              }

              break;

            default:
              break;
          }
        }

        return false;

      case "ArrayLiteral":
      case "ObjectLiteral":
        return true;

      case "ArrayPattern":
      case "ObjectPattern":
        return true;

      default:
        return false;
    }
  } // ECMA262 13.3.3.7


  KeyedBindingInitialization(realm, node, value, strictCode, environment, propertyName) {
    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;
    let Initializer;

    if (node.type === "AssignmentPattern") {
      Initializer = node.right;
      node = node.left;
    }

    if (node.type === "Identifier") {
      // SingleNameBinding : BindingIdentifier Initializer
      // 1. Let bindingId be StringValue of BindingIdentifier.
      let bindingId = node.name; // 2. Let lhs be ? ResolveBinding(bindingId, environment).

      let lhs = this.ResolveBinding(realm, bindingId, strictCode, environment); // 3. Let v be ? GetV(value, propertyName).

      let v = (0, _index2.GetV)(realm, value, propertyName); // 4. If Initializer is present and v is undefined, then

      if (Initializer && v instanceof _index.UndefinedValue) {
        // a. Let defaultValue be the result of evaluating Initializer.
        let defaultValue = env.evaluate(Initializer, strictCode); // b. Let v be ? GetValue(defaultValue).

        v = this.GetValue(realm, defaultValue); // c. If IsAnonymousFunctionDefinition(Initializer) is true, then

        if ((0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer) && v instanceof _index.ObjectValue) {
          // i. Let hasNameProperty be ? HasOwnProperty(v, "name").
          let hasNameProperty = (0, _index2.HasOwnProperty)(realm, v, "name"); // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).

          if (hasNameProperty === false) {
            _singletons.Functions.SetFunctionName(realm, v, bindingId);
          }
        }
      } // 5. If environment is undefined, return ? PutValue(lhs, v).


      if (!environment) return _singletons.Properties.PutValue(realm, lhs, v); // 6. Return InitializeReferencedBinding(lhs, v).

      return this.InitializeReferencedBinding(realm, lhs, v);
    } else if (node.type === "ObjectPattern" || node.type === "ArrayPattern") {
      // BindingElement : BindingPattern Initializer
      // 1. Let v be ? GetV(value, propertyName).
      let v = (0, _index2.GetV)(realm, value, propertyName); // 2. If Initializer is present and v is undefined, then

      if (Initializer && v instanceof _index.UndefinedValue) {
        // a. Let defaultValue be the result of evaluating Initializer.
        let defaultValue = env.evaluate(Initializer, strictCode); // b. Let v be ? GetValue(defaultValue).

        v = this.GetValue(realm, defaultValue);
      } // 3. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.


      return this.BindingInitialization(realm, node, v, strictCode, env);
    }
  }

}

exports.EnvironmentImplementation = EnvironmentImplementation;
//# sourceMappingURL=environment.js.map

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionImplementation = void 0;

var _errors = __webpack_require__(3);

var _completions = __webpack_require__(18);

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _call = __webpack_require__(234);

var _abstract = __webpack_require__(233);

var _construct = __webpack_require__(228);

var _index2 = __webpack_require__(232);

var _iterator = __webpack_require__(272);

var _ObjectExpression = __webpack_require__(275);

var _singletons = __webpack_require__(236);

var _traverseFast = _interopRequireDefault(__webpack_require__(279));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _parse = _interopRequireDefault(__webpack_require__(227));

var _strict = _interopRequireDefault(__webpack_require__(452));

var t = _interopRequireWildcard(__webpack_require__(21));

var _descriptors = __webpack_require__(268);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function InternalCall(realm, F, thisArgument, argsList, tracerIndex) {
  realm.startCall();

  try {
    // 1. Assert: F is an ECMAScript function object.
    (0, _invariant.default)(F instanceof _index.FunctionValue, "expected function value"); // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.

    while (tracerIndex < realm.tracers.length) {
      let tracer = realm.tracers[tracerIndex];
      let nextIndex = ++tracerIndex;
      let detourResult = tracer.detourCall(F, thisArgument, argsList, undefined, () => InternalCall(realm, F, thisArgument, argsList, nextIndex));
      if (detourResult instanceof _index.Value) return detourResult;
    } // 2. If F's [[FunctionKind]] internal slot is "classConstructor", throw a TypeError exception.


    if (F.$FunctionKind === "classConstructor") throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable"); // 3. Let callerContext be the running execution context.

    let callerContext = realm.getRunningContext(); // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).

    let calleeContext = (0, _call.PrepareForOrdinaryCall)(realm, F, undefined);
    let calleeEnv = calleeContext.lexicalEnvironment;
    let result;

    try {
      for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argsList, undefined); // 5. Assert: calleeContext is now the running execution context.


      (0, _invariant.default)(realm.getRunningContext() === calleeContext, "calleeContext should be current execution context"); // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).

      (0, _call.OrdinaryCallBindThis)(realm, F, calleeContext, thisArgument); // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).

      result = (0, _call.OrdinaryCallEvaluateBody)(realm, F, argsList);
    } finally {
      // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
      realm.popContext(calleeContext);
      realm.onDestroyScope(calleeContext.lexicalEnvironment);
      if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);
      (0, _invariant.default)(realm.getRunningContext() === callerContext);

      for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argsList, undefined, result);
    } // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).


    if (result instanceof _completions.ReturnCompletion) {
      return result.value;
    } // 10. ReturnIfAbrupt(result).


    if (result instanceof _completions.AbruptCompletion) {
      throw result;
    } // 11. Return NormalCompletion(undefined).


    return realm.intrinsics.undefined;
  } finally {
    realm.endCall();
  }
} // ECMA262 9.4.1.1


function $BoundCall(realm, F, thisArgument, argumentsList) {
  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.
  let target = F.$BoundTargetFunction; // 2. Let boundThis be the value of F's [[BoundThis]] internal slot.

  let boundThis = F.$BoundThis; // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.

  let boundArgs = F.$BoundArguments; // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed
  //    by the same values as the list argumentsList in the same order.

  let args = boundArgs.concat(argumentsList); // 5. Return ? Call(target, boundThis, args).

  return (0, _call.Call)(realm, target, boundThis, args);
} // ECMA262 9.4.1.2


function $BoundConstruct(realm, F, argumentsList, newTarget) {
  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.
  let target = F.$BoundTargetFunction; // 2. Assert: target has a [[Construct]] internal method.

  (0, _invariant.default)(target.$Construct !== undefined, "doesn't have a construct internal method"); // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.

  let boundArgs = F.$BoundArguments; // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed
  //    by the same values as the list argumentsList in the same order.

  let args = boundArgs.concat(argumentsList); // 5. If SameValue(F, newTarget) is true, let newTarget be target.

  if ((0, _abstract.SameValue)(realm, F, newTarget)) newTarget = target; // 6. Return ? Construct(target, args, newTarget).

  return (0, _construct.Construct)(realm, target, args, newTarget);
}

function InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, tracerIndex) {
  realm.startCall();

  try {
    // 1. Assert: F is an ECMAScript function object.
    (0, _invariant.default)(F instanceof _index.FunctionValue, "expected function"); // 2. Assert: Type(newTarget) is Object.

    (0, _invariant.default)(newTarget instanceof _index.ObjectValue, "expected object");

    if (!realm.hasRunningContext()) {
      (0, _invariant.default)(realm.useAbstractInterpretation);
      throw new _errors.FatalError("no running context");
    } // 3. Let callerContext be the running execution context.


    let callerContext = realm.getRunningContext(); // 4. Let kind be F's [[ConstructorKind]] internal slot.

    let kind = F.$ConstructorKind; // 5. If kind is "base", then

    if (thisArgument === undefined && kind === "base") {
      // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, "%ObjectPrototype%").
      thisArgument = _singletons.Create.OrdinaryCreateFromConstructor(realm, newTarget, "ObjectPrototype");
    } // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.


    while (tracerIndex < realm.tracers.length) {
      let tracer = realm.tracers[tracerIndex];
      let nextIndex = ++tracerIndex;
      let detourResult = tracer.detourCall(F, thisArgument, argumentsList, newTarget, () => InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, nextIndex));
      if (detourResult instanceof _index.ObjectValue) return detourResult;
      (0, _invariant.default)(detourResult === undefined);
    } // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).


    let calleeContext = (0, _call.PrepareForOrdinaryCall)(realm, F, newTarget);
    let calleeEnv = calleeContext.lexicalEnvironment; // 7. Assert: calleeContext is now the running execution context.

    (0, _invariant.default)(realm.getRunningContext() === calleeContext, "expected calleeContext to be running context");
    let result, envRec;

    try {
      for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argumentsList, newTarget); // 8. If kind is "base", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).


      if (kind === "base") {
        (0, _invariant.default)(thisArgument, "this wasn't initialized for some reason");
        (0, _call.OrdinaryCallBindThis)(realm, F, calleeContext, thisArgument);
      } // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.


      let constructorEnv = calleeContext.lexicalEnvironment; // 10. Let envRec be constructorEnv's EnvironmentRecord.

      envRec = constructorEnv.environmentRecord; // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).

      result = (0, _call.OrdinaryCallEvaluateBody)(realm, F, argumentsList);
    } finally {
      // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
      realm.popContext(calleeContext);
      realm.onDestroyScope(calleeContext.lexicalEnvironment);
      if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);
      (0, _invariant.default)(realm.getRunningContext() === callerContext);

      for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argumentsList, newTarget, result);
    } // 13. If result.[[Type]] is return, then


    if (result instanceof _completions.ReturnCompletion) {
      const v = map(result.value);
      (0, _invariant.default)(v instanceof _index.ObjectValue || v instanceof _index.AbstractObjectValue);
      return v;

      function map(value) {
        if (value === realm.intrinsics.__bottomValue) return value;

        if (value instanceof _index.AbstractValue) {
          if (value.kind === "conditional") {
            const [condition, consequent, alternate] = value.args;
            return realm.evaluateWithAbstractConditional(condition, () => realm.evaluateForEffects(() => map(consequent), undefined, "AbstractValue/conditional/true"), () => realm.evaluateForEffects(() => map(alternate), undefined, "AbstractValue/conditional/false"));
          }

          if (!(value instanceof _index.AbstractObjectValue)) {
            if (kind === "base") {
              (0, _invariant.default)(thisArgument, "this wasn't initialized for some reason");
              return _index.AbstractValue.createFromTemplate(realm, "typeof A === 'object' || typeof A === 'function' ? A : B", _index.ObjectValue, [value, thisArgument]);
            } else {
              value.throwIfNotConcreteObject(); // Not yet supported.
            }
          }
        } // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).


        if (value instanceof _index.ObjectValue || value instanceof _index.AbstractObjectValue) return value; // b. If kind is "base", return NormalCompletion(thisArgument).

        if (kind === "base") {
          (0, _invariant.default)(thisArgument, "this wasn't initialized for some reason");
          return thisArgument;
        } // c. If result.[[Value]] is not undefined, throw a TypeError exception.


        if (!value.mightBeUndefined()) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "constructor must return Object");
        }

        value.throwIfNotConcrete(); // 15. Return ? envRec.GetThisBinding().

        let envRecThisBinding = envRec.GetThisBinding();
        (0, _invariant.default)(envRecThisBinding instanceof _index.ObjectValue);
        return envRecThisBinding;
      }
    } else if (result instanceof _completions.AbruptCompletion) {
      // 14. Else, ReturnIfAbrupt(result).
      throw result;
    } // 15. Return ? envRec.GetThisBinding().


    let envRecThisBinding = envRec.GetThisBinding();
    (0, _invariant.default)(envRecThisBinding instanceof _index.ObjectValue);
    return envRecThisBinding;
  } finally {
    realm.endCall();
  }
}

class FunctionImplementation {
  FindVarScopedDeclarations(ast_node) {
    function FindVarScopedDeclarationsFor(ast, level) {
      let statements = [];

      switch (ast.type) {
        case "Program":
          statements = ast.body;
          break;

        case "BlockStatement":
          statements = ast.body;
          break;

        case "DoWhileStatement":
          statements = [ast.body];
          break;

        case "WhileStatement":
          statements = [ast.body];
          break;

        case "IfStatement":
          let astIfStatement = ast;
          statements = [astIfStatement.consequent, astIfStatement.alternate];
          break;

        case "ForStatement":
          let astForStatement = ast;
          statements = [astForStatement.init, astForStatement.body];
          break;

        case "ForInStatement":
          let astForInStatement = ast;
          statements = [astForInStatement.left, astForInStatement.body];
          break;

        case "ForOfStatement":
          let astForOfStatement = ast;
          statements = [astForOfStatement.left, astForOfStatement.body];
          break;

        case "LabeledStatement":
          statements = [ast.body];
          break;

        case "WithStatement":
          statements = [ast.body];
          break;

        case "SwitchStatement":
          for (let switchCase of ast.cases) {
            statements.push(...switchCase.consequent);
          }

          break;

        case "TryStatement":
          let astTryStatement = ast;
          statements = [astTryStatement.block];
          if (astTryStatement.finalizer) statements.push(astTryStatement.finalizer);
          if (astTryStatement.handler) statements.push(astTryStatement.handler.body);
          break;

        case "VariableDeclaration":
          return ast.kind === "var" ? [ast] : [];

        case "FunctionDeclaration":
          return level < 2 ? [ast] : [];

        default:
          return [];
      }

      let decls = [];

      for (let statement of statements) {
        if (statement) {
          decls = decls.concat(FindVarScopedDeclarationsFor(statement, level + 1));
        }
      }

      return decls;
    }

    return FindVarScopedDeclarationsFor(ast_node, 0);
  } // ECMA262 9.2.12


  FunctionDeclarationInstantiation(realm, func, argumentsList) {
    // 1. Let calleeContext be the running execution context.
    let calleeContext = realm.getRunningContext(); // 2. Let env be the LexicalEnvironment of calleeContext.

    let env = calleeContext.lexicalEnvironment; // 3. Let envRec be env's EnvironmentRecord.

    let envRec = env.environmentRecord; // 4. Let code be the value of the [[ECMAScriptCode]] internal slot of func.

    let code = func.$ECMAScriptCode;
    (0, _invariant.default)(code !== undefined); // 5. Let strict be the value of the [[Strict]] internal slot of func.

    let strict = func.$Strict; // 6. Let formals be the value of the [[FormalParameters]] internal slot of func.

    let formals = func.$FormalParameters;
    (0, _invariant.default)(formals !== undefined); // 7. Let parameterNames be the BoundNames of formals.

    let parameterNames = Object.create(null);

    for (let param of formals) {
      let paramBindings = t.getBindingIdentifiers(param, true);

      for (let name in paramBindings) {
        parameterNames[name] = (parameterNames[name] || []).concat(paramBindings[name]);
      }
    } // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.


    let hasDuplicates = false;

    for (let name in parameterNames) {
      let identifiers = parameterNames[name];
      if (identifiers.length > 1) hasDuplicates = true;
    }

    parameterNames = Object.keys(parameterNames); // 9. Let simpleParameterList be IsSimpleParameterList of formals.

    let simpleParameterList = true;

    for (let param of formals) {
      if (param.type !== "Identifier") {
        simpleParameterList = false;
        break;
      }
    } // 10. Let hasParameterExpressions be ContainsExpression of formals.


    let hasParameterExpressions = false;
    (0, _invariant.default)(formals !== undefined);

    for (let param of formals) {
      if (_singletons.Environment.ContainsExpression(realm, param)) {
        hasParameterExpressions = true;
        break;
      }
    } // 11. Let varNames be the VarDeclaredNames of code.


    let varNames = [];
    (0, _traverseFast.default)(code, node => {
      if (node.type === "VariableDeclaration" && node.kind === "var") {
        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));
      }

      if (node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
        return true;
      }

      return false;
    }); // 12. Let varDeclarations be the VarScopedDeclarations of code.

    let varDeclarations = this.FindVarScopedDeclarations(code); // 13. Let lexicalNames be the LexicallyDeclaredNames of code.

    let lexicalNames = []; // 14. Let functionNames be an empty List.

    let functionNames = []; // 15. Let functionsToInitialize be an empty List.

    let functionsToInitialize = []; // 16. For each d in varDeclarations, in reverse list order do

    for (let d of varDeclarations.reverse()) {
      // a. If d is neither a VariableDeclaration or a ForBinding, then
      if (d.type !== "VariableDeclaration") {
        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.
        (0, _invariant.default)(d.type === "FunctionDeclaration" || d.type === "GeneratorDeclaration"); // ii. Let fn be the sole element of the BoundNames of d.

        let fn = _singletons.Environment.BoundNames(realm, d)[0]; // iii. If fn is not an element of functionNames, then


        if (functionNames.indexOf(fn) < 0) {
          // 1. Insert fn as the first element of functionNames.
          functionNames.unshift(fn); // 2. NOTE If there are multiple FunctionDeclarations or GeneratorDeclarations for the same name, the last declaration is used.
          // 3. Insert d as the first element of functionsToInitialize.

          functionsToInitialize.unshift(d);
        }
      }
    } // 17. Let argumentsObjectNeeded be true.


    let argumentsObjectNeeded = true; // 18. If the value of the [[realmMode]] internal slot of func is lexical, then

    if (func.$ThisMode === "lexical") {
      // a. NOTE Arrow functions never have an arguments objects.
      // b. Let argumentsObjectNeeded be false.
      argumentsObjectNeeded = false;
    } else if (parameterNames.indexOf("arguments") >= 0) {
      // 19. Else if "arguments" is an element of parameterNames, then
      // a. Let argumentsObjectNeeded be false.
      argumentsObjectNeeded = false;
    } else if (hasParameterExpressions === false) {
      // 20. Else if hasParameterExpressions is false, then
      // a. If "arguments" is an element of functionNames or if "arguments" is an element of lexicalNames, then
      if (functionNames.indexOf("arguments") >= 0 || lexicalNames.indexOf("arguments") >= 0) {
        // i. Let argumentsObjectNeeded be false.
        argumentsObjectNeeded = true;
      }
    } // 21. For each String paramName in parameterNames, do


    for (let paramName of parameterNames) {
      // a. Let alreadyDeclared be envRec.HasBinding(paramName).
      let alreadyDeclared = envRec.HasBinding(paramName); // b. NOTE Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.
      // c. If alreadyDeclared is false, then

      if (alreadyDeclared === false) {
        // i. Perform ! envRec.CreateMutableBinding(paramName, false).
        envRec.CreateMutableBinding(paramName, false); // ii. If hasDuplicates is true, then

        if (hasDuplicates === true) {
          // 1. Perform ! envRec.InitializeBinding(paramName, undefined).
          envRec.InitializeBinding(paramName, realm.intrinsics.undefined);
        }
      }
    } // 22. If argumentsObjectNeeded is true, then


    if (argumentsObjectNeeded === true) {
      let ao; // a. If strict is true or if simpleParameterList is false, then

      if (strict === true || simpleParameterList === false) {
        // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).
        ao = _singletons.Create.CreateUnmappedArgumentsObject(realm, argumentsList);
      } else {
        // b. Else,
        // i. NOTE mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
        // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).
        (0, _invariant.default)(formals !== undefined);
        ao = _singletons.Create.CreateMappedArgumentsObject(realm, func, formals, argumentsList, envRec);
      } // c. If strict is true, then


      if (strict === true) {
        // i. Perform ! envRec.CreateImmutableBinding("arguments", false).
        envRec.CreateImmutableBinding("arguments", false);
      } else {
        // d. Else,
        // i. Perform ! envRec.CreateMutableBinding("arguments", false).
        envRec.CreateMutableBinding("arguments", false);
      } // e. Call envRec.InitializeBinding("arguments", ao).


      envRec.InitializeBinding("arguments", ao); // f. Append "arguments" to parameterNames.

      parameterNames.push("arguments");
    } // 23. Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.


    let iteratorRecord = {
      $Iterator: (0, _iterator.CreateListIterator)(realm, argumentsList),
      $Done: false
    }; // 24. If hasDuplicates is true, then

    if (hasDuplicates === true) {
      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.
      (0, _invariant.default)(formals !== undefined);

      _singletons.Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict);
    } else {
      // 25. Else,
      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.
      (0, _invariant.default)(formals !== undefined);

      _singletons.Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict, env);
    } // 26. If hasParameterExpressions is false, then


    let varEnv, varEnvRec;

    if (hasParameterExpressions === false) {
      // a. NOTE Only a single lexical environment is needed for the parameters and top-level vars.
      // b. Let instantiatedVarNames be a copy of the List parameterNames.
      let instantiatedVarNames = parameterNames.slice(); // c. For each n in varNames, do

      for (let n of varNames) {
        // i. If n is not an element of instantiatedVarNames, then
        if (instantiatedVarNames.indexOf(n) < 0) {
          // 1. Append n to instantiatedVarNames.
          instantiatedVarNames.push(n); // 2. Perform ! envRec.CreateMutableBinding(n, false).

          envRec.CreateMutableBinding(n, false); // 3. Call envRec.InitializeBinding(n, undefined).

          envRec.InitializeBinding(n, realm.intrinsics.undefined);
        }
      } // e. Let varEnv be env.


      varEnv = env; // f. Let varEnvRec be envRec.

      varEnvRec = envRec;
    } else {
      // 27. Else,
      // a. NOTE A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
      // b. Let varEnv be NewDeclarativeEnvironment(env).
      varEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, env); // At this point we haven't set any context's lexical environment to varEnv (and we might never do so),
      // so it shouldn't be active

      realm.activeLexicalEnvironments.delete(varEnv); // c. Let varEnvRec be varEnv's EnvironmentRecord.

      varEnvRec = varEnv.environmentRecord; // d. Set the VariableEnvironment of calleeContext to varEnv.

      calleeContext.variableEnvironment = varEnv; // e. Let instantiatedVarNames be a new empty List.

      let instantiatedVarNames = []; // f. For each n in varNames, do

      for (let n of varNames) {
        // i. If n is not an element of instantiatedVarNames, then
        if (instantiatedVarNames.indexOf(n) < 0) {
          // 1. Append n to instantiatedVarNames.
          instantiatedVarNames.push(n); // 2. Perform ! varEnvRec.CreateMutableBinding(n, false).

          varEnvRec.CreateMutableBinding(n, false); // 3. If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.

          let initialValue;

          if (parameterNames.indexOf(n) < 0 || functionNames.indexOf(n) < 0) {
            initialValue = realm.intrinsics.undefined;
          } else {
            // 4. Else,
            // a. Let initialValue be ! envRec.GetBindingValue(n, false).
            initialValue = envRec.GetBindingValue(n, false);
          } // 5. Call varEnvRec.InitializeBinding(n, initialValue).


          varEnvRec.InitializeBinding(n, initialValue); // 6. NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.
        }
      }
    } // 28. NOTE: Annex B.3.3.1 adds additional steps at realm point.


    let lexEnv; // 29. If strict is false, then

    if (strict === false) {
      // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).
      lexEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, varEnv); // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval (see 12.3.4.1) can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. realm is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
    } else {
      // 30. Else, let lexEnv be varEnv.
      lexEnv = varEnv; // Since we previously removed varEnv, make sure to re-add it when it's used.

      realm.activeLexicalEnvironments.add(varEnv);
    } // 31. Let lexEnvRec be lexEnv's EnvironmentRecord.


    let lexEnvRec = lexEnv.environmentRecord; // 32. Set the LexicalEnvironment of calleeContext to lexEnv.

    calleeContext.lexicalEnvironment = lexEnv; // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.

    let lexDeclarations = []; // 34. For each element d in lexDeclarations do

    for (let d of lexDeclarations) {
      // a. NOTE A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
      // b. For each element dn of the BoundNames of d do
      for (let dn of _singletons.Environment.BoundNames(realm, d)) {
        // i. If IsConstantDeclaration of d is true, then
        if (d.kind === "const") {
          // 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).
          lexEnvRec.CreateImmutableBinding(dn, true);
        } else {
          // ii. Else,
          // 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).
          lexEnvRec.CreateMutableBinding(dn, false);
        }
      }
    } // 35. For each parsed grammar phrase f in functionsToInitialize, do


    for (let f of functionsToInitialize) {
      // a. Let fn be the sole element of the BoundNames of f.
      let fn = _singletons.Environment.BoundNames(realm, f)[0]; // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.


      let fo = lexEnv.evaluate(f, strict);
      (0, _invariant.default)(fo instanceof _index.Value); // c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).

      varEnvRec.SetMutableBinding(fn, fo, false);
    } // 36. Return NormalCompletion(empty).


    return realm.intrinsics.empty;
  } // ECMA262 9.2.11


  SetFunctionName(realm, F, _name, prefix) {
    // 1. Assert: F is an extensible object that does not have a name own property.
    (0, _invariant.default)(F.getExtensible(), "expected object to be extensible and not have a name property"); // 2. Assert: Type(name) is either Symbol or String.

    (0, _invariant.default)(typeof _name === "string" || _name instanceof _index.StringValue || _name instanceof _index.SymbolValue || _name instanceof _index.AbstractValue, "expected name to be a string or symbol");
    let name = typeof _name === "string" ? new _index.StringValue(realm, _name) : _name; // 3. Assert: If prefix was passed, then Type(prefix) is String.

    (0, _invariant.default)(prefix === undefined || typeof prefix === "string", "expected prefix to be a string if passed"); // 4. If Type(name) is Symbol, then

    if (name instanceof _index.SymbolValue) {
      // a. Let description be name's [[Description]] value.
      let description = name.$Description; // b. If description is undefined, let name be the empty String.

      if (description === undefined) {
        name = realm.intrinsics.emptyString;
      } else {
        // c. Else, let name be the concatenation of "[", description, and "]".
        (0, _invariant.default)(description instanceof _index.Value);
        name = new _index.StringValue(realm, `[${description.throwIfNotConcreteString().value}]`);
      }
    } // 5. If prefix was passed, then


    if (prefix) {
      // a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and name.
      if (name instanceof _index.AbstractValue) {
        let prefixVal = new _index.StringValue(realm, prefix + " ");
        name = _index.AbstractValue.createFromBinaryOp(realm, "+", prefixVal, name, name.expressionLocation);
      } else {
        name = new _index.StringValue(realm, `${prefix} ${name.value}`);
      }
    } // 6. Return ! DefinePropertyOrThrow(F, "name", PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).


    return _singletons.Properties.DefinePropertyOrThrow(realm, F, "name", new _descriptors.PropertyDescriptor({
      value: name,
      enumerable: false,
      writable: false,
      configurable: true
    }));
  } // ECMA262 9.2.3


  FunctionInitialize(realm, F, kind, ParameterList, Body, Scope) {
    // Tell the realm to mark any local bindings that are visible to this function as being potentially captured by it.
    realm.markVisibleLocalBindingsAsPotentiallyCaptured(); // Note that F is a new object, and we can thus write to internal slots

    (0, _invariant.default)(realm.isNewObject(F)); // 1. Assert: F is an extensible object that does not have a length own property.

    (0, _invariant.default)(F.getExtensible(), "expected to be extensible and no length property"); // 2. Let len be the ExpectedArgumentCount of ParameterList.

    let len = 0;

    for (let FormalParameter of ParameterList) {
      if (FormalParameter.type === "AssignmentPattern") {
        break;
      }

      len += 1;
    } // 3. Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).


    _singletons.Properties.DefinePropertyOrThrow(realm, F, "length", new _descriptors.PropertyDescriptor({
      value: new _index.NumberValue(realm, len),
      writable: false,
      enumerable: false,
      configurable: true
    })); // 4. Let Strict be the value of the [[Strict]] internal slot of F.


    let Strict = F.$Strict;

    if (!Strict) {
      _singletons.Properties.DefinePropertyOrThrow(realm, F, "caller", new _descriptors.PropertyDescriptor({
        value: new _index.UndefinedValue(realm),
        writable: true,
        enumerable: false,
        configurable: true
      }));
    } // 5. Set the [[Environment]] internal slot of F to the value of Scope.


    F.$Environment = Scope; // 6. Set the [[FormalParameters]] internal slot of F to ParameterList. + 7. Set the [[ECMAScriptCode]] internal slot of F to Body.

    F.initialize(ParameterList, Body); // 8. Set the [[ScriptOrModule]] internal slot of F to GetActiveScriptOrModule().

    F.$ScriptOrModule = _singletons.Environment.GetActiveScriptOrModule(realm); // 9. If kind is Arrow, set the [[realmMode]] internal slot of F to lexical.

    if (kind === "arrow") {
      F.$ThisMode = "lexical";
    } else if (Strict === true) {
      // 10. Else if Strict is true, set the [[realmMode]] internal slot of F to strict.
      F.$ThisMode = "strict";
    } else {
      // 11. Else set the [[realmMode]] internal slot of F to global.
      F.$ThisMode = "global";
    } // Return F.


    return F;
  } // ECMA262 9.2.6


  GeneratorFunctionCreate(realm, kind, ParameterList, Body, Scope, Strict) {
    // 1. Let functionPrototype be the intrinsic object %Generator%.
    let functionPrototype = realm.intrinsics.Generator; // 2. Let F be FunctionAllocate(functionPrototype, Strict, "generator").

    let F = this.FunctionAllocate(realm, functionPrototype, Strict, "generator"); // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).

    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);
  } // ECMA262 9.2.7


  AddRestrictedFunctionProperties(F, realm) {
    // 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.
    // 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].
    let thrower = realm.intrinsics.ThrowTypeError;
    (0, _invariant.default)(thrower);
    let desc = new _descriptors.PropertyDescriptor({
      get: thrower,
      set: thrower,
      enumerable: false,
      configurable: true
    }); // 3. Perform ! DefinePropertyOrThrow(F, "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).

    _singletons.Properties.DefinePropertyOrThrow(realm, F, "caller", desc); // 4. Return ! DefinePropertyOrThrow(F, "arguments", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).


    return _singletons.Properties.DefinePropertyOrThrow(realm, F, "arguments", desc);
  } // ECMA262 9.2.1


  $Call(realm, F, thisArgument, argsList) {
    return InternalCall(realm, F, thisArgument, argsList, 0);
  } // ECMA262 9.2.2


  $Construct(realm, F, argumentsList, newTarget) {
    return InternalConstruct(realm, F, argumentsList, newTarget, undefined, 0);
  } // ECMA262 9.2.3


  FunctionAllocate(realm, functionPrototype, strict, functionKind) {
    // 1. Assert: Type(functionPrototype) is Object.
    (0, _invariant.default)(functionPrototype instanceof _index.ObjectValue, "expected functionPrototype to be an object"); // 2. Assert: functionKind is either "normal", "non-constructor" or "generator".

    (0, _invariant.default)(functionKind === "normal" || functionKind === "non-constructor" || functionKind === "generator", "invalid functionKind"); // 3. If functionKind is "normal", let needsConstruct be true.

    let needsConstruct;

    if (functionKind === "normal") {
      needsConstruct = true;
    } else {
      // 4. Else, let needsConstruct be false.
      needsConstruct = false;
    } // 5. If functionKind is "non-constructor", let functionKind be "normal".


    if (functionKind === "non-constructor") {
      functionKind = "normal";
    } // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.


    let F = new _index.ECMAScriptSourceFunctionValue(realm); // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.
    // 8. Set F's [[Call]] internal method to the definition specified in 9.2.1.

    F.$Call = (thisArgument, argsList) => {
      return this.$Call(realm, F, thisArgument, argsList);
    }; // 9. If needsConstruct is true, then


    if (needsConstruct === true) {
      // a. Set F's [[Construct]] internal method to the definition specified in 9.2.2.
      F.$Construct = (argumentsList, newTarget) => {
        return this.$Construct(realm, F, argumentsList, newTarget);
      }; // b. Set the [[ConstructorKind]] internal slot of F to "base".


      F.$ConstructorKind = "base";
    } // 10. Set the [[Strict]] internal slot of F to strict.


    F.$Strict = strict; // 11. Set the [[FunctionKind]] internal slot of F to functionKind.

    F.$FunctionKind = functionKind; // 12. Set the [[Prototype]] internal slot of F to functionPrototype.

    F.$Prototype = functionPrototype; // 13. Set the [[Extensible]] internal slot of F to true.

    F.setExtensible(true); // 14. Set the [[Realm]] internal slot of F to the current Realm Record.

    F.$Realm = realm; // 15. Return F.

    return F;
  } // ECMA262 9.4.1.3


  BoundFunctionCreate(realm, targetFunction, boundThis, boundArgs) {
    // 1. Assert: Type(targetFunction) is Object.
    (0, _invariant.default)(targetFunction instanceof _index.ObjectValue, "expected an object"); // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().

    let proto = targetFunction.$GetPrototypeOf(); // 3. Let obj be a newly created object.

    let obj = new _index.BoundFunctionValue(realm); // 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
    // 5. Set the [[Call]] internal method of obj as described in 9.4.1.1.

    obj.$Call = (thisArgument, argsList) => {
      return $BoundCall(realm, obj, thisArgument, argsList);
    }; // 6. If targetFunction has a [[Construct]] internal method, then


    if (targetFunction.$Construct) {
      // a. Set the [[Construct]] internal method of obj as described in 9.4.1.2.
      obj.$Construct = (thisArgument, argsList) => {
        return $BoundConstruct(realm, obj, thisArgument, argsList);
      };
    } // 7. Set the [[Prototype]] internal slot of obj to proto.


    obj.$Prototype = proto; // 8. Set the [[Extensible]] internal slot of obj to true.

    obj.setExtensible(true); // 9. Set the [[BoundTargetFunction]] internal slot of obj to targetFunction.

    obj.$BoundTargetFunction = targetFunction; // 10. Set the [[BoundThis]] internal slot of obj to the value of boundThis.

    obj.$BoundThis = boundThis; // 11. Set the [[BoundArguments]] internal slot of obj to boundArgs.

    obj.$BoundArguments = boundArgs; // 12. Return obj.

    return obj;
  } // ECMA262 18.2.1.1


  PerformEval(realm, x, evalRealm, strictCaller, direct) {
    // 1. Assert: If direct is false, then strictCaller is also false.
    if (direct === false) (0, _invariant.default)(strictCaller === false, "strictCaller is only allowed on direct eval"); // 2. If Type(x) is not String, return x.

    if (!(x instanceof _index.StringValue)) return x; // 3. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text
    //    as described in 6.1.4, for the goal symbol Script. If the parse fails, throw a SyntaxError exception. If any
    //    early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the
    //    error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation
    //    dependent manner.

    let ast = (0, _parse.default)(realm, x.value, "eval", "script");
    let script = ast.program; // 4. If script Contains ScriptBody is false, return undefined.

    if (!script.body) return realm.intrinsics.undefined; // 5. Let body be the ScriptBody of script.

    let body = t.blockStatement(script.body, script.directives); // 6. If strictCaller is true, let strictEval be true.

    let strictEval;

    if (strictCaller) {
      strictEval = true;
    } else {
      // 7. Else, let strictEval be IsStrict of script.
      strictEval = (0, _strict.default)(script);
    } // 8. Let ctx be the running execution context. If direct is true, ctx will be the execution context that
    //    performed the direct eval. If direct is false, ctx will be the execution context for the invocation of
    //    the eval function.


    let ctx = realm.getRunningContext(); // 9. If direct is true, then

    let lexEnv, varEnv;

    if (direct) {
      // a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).
      lexEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, ctx.lexicalEnvironment); // b. Let varEnv be ctx's VariableEnvironment.

      varEnv = ctx.variableEnvironment;
    } else {
      // 10. Else,
      // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).
      lexEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, evalRealm.$GlobalEnv); // b. Let varEnv be evalRealm.[[GlobalEnv]].

      varEnv = evalRealm.$GlobalEnv;
    } // 11. If strictEval is true, let varEnv be lexEnv.


    if (strictEval) varEnv = lexEnv; // 12. If ctx is not already suspended, suspend ctx.

    ctx.suspend(); // 13. Let evalCxt be a new ECMAScript code execution context.

    let evalCxt = realm.createExecutionContext();
    evalCxt.isStrict = strictEval; // 14. Set the evalCxt's Function to null.

    evalCxt.setFunction(null); // 15. Set the evalCxt's Realm to evalRealm.

    evalCxt.setRealm(evalRealm); // 16. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.

    evalCxt.ScriptOrModule = ctx.ScriptOrModule; // 17. Set the evalCxt's VariableEnvironment to varEnv.

    evalCxt.variableEnvironment = varEnv; // 18. Set the evalCxt's LexicalEnvironment to lexEnv.

    evalCxt.lexicalEnvironment = lexEnv; // 19. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.

    realm.pushContext(evalCxt);
    let result;

    try {
      // 20. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).
      (0, _invariant.default)(varEnv);

      try {
        result = this.EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strictEval);
      } catch (e) {
        if (e instanceof _completions.AbruptCompletion) {
          result = e;
        } else {
          throw e;
        }
      }

      (0, _invariant.default)(result instanceof _index.Value || result instanceof _completions.AbruptCompletion); // 21. If result.[[Type]] is normal, then

      if (result instanceof _index.Value) {
        // Evaluate expressions that passed for directives.
        if (script.directives) {
          for (let directive of script.directives) {
            result = new _index.StringValue(realm, directive.value.value);
          }
        } // a. Let result be the result of evaluating body.


        result = this.EvaluateStatements(script.body, result, strictEval, lexEnv, realm);
      } // 22. If result.[[Type]] is normal and result.[[Value]] is empty, then


      if (result instanceof _index.EmptyValue) {
        // a. Let result be NormalCompletion(undefined).
        result = realm.intrinsics.undefined;
      }
    } finally {
      // 23. Suspend evalCxt and remove it from the execution context stack.
      evalCxt.suspend();
      realm.popContext(evalCxt);
      realm.onDestroyScope(evalCxt.lexicalEnvironment);
    } // 24. Resume the context that is now on the top of the execution context stack as the running execution context.


    (0, _invariant.default)(realm.getRunningContext() === ctx);
    ctx.resume(); // 25. Return Completion(result).

    if (result instanceof _index.Value) {
      return result;
    } else {
      (0, _invariant.default)(result instanceof _completions.AbruptCompletion);
      throw result;
    }
  } // Composes realm.savedCompletion with c, clears realm.savedCompletion and return the composition.
  // Call this only when a join point has been reached.


  incorporateSavedCompletion(realm, c) {
    let savedCompletion = realm.savedCompletion;

    if (savedCompletion !== undefined) {
      realm.savedCompletion = undefined;
      realm.pathConditions = savedCompletion.pathConditionsAtCreation;
      if (c === undefined) c = realm.intrinsics.empty;
      if (c instanceof _index.Value) c = new _completions.SimpleNormalCompletion(c);

      if (savedCompletion instanceof _completions.JoinedNormalAndAbruptCompletions) {
        let subsequentEffects = realm.getCapturedEffects(c);
        realm.stopEffectCaptureAndUndoEffects(savedCompletion);

        let joinedEffects = _singletons.Join.composeWithEffects(savedCompletion, subsequentEffects);

        realm.applyEffects(joinedEffects);
        realm.savedCompletion = savedCompletion.composedWith;
        if (realm.savedCompletion !== undefined) return this.incorporateSavedCompletion(realm, joinedEffects.result);
        return joinedEffects.result;
      }

      return _singletons.Join.composeCompletions(savedCompletion, c);
    }

    return c;
  }

  EvaluateStatements(body, initialBlockValue, strictCode, blockEnv, realm) {
    let blockValue = initialBlockValue;

    for (let node of body) {
      if (node.type !== "FunctionDeclaration") {
        let res = blockEnv.evaluateCompletionDeref(node, strictCode);

        if (!(res instanceof _index.EmptyValue)) {
          if (res instanceof _completions.AbruptCompletion) throw (0, _index2.UpdateEmpty)(realm, res, blockValue || realm.intrinsics.empty);
          (0, _invariant.default)(res instanceof _index.Value);
          blockValue = res;
        }
      }
    } // 7. Return blockValue.


    return blockValue || realm.intrinsics.empty;
  } // ECMA262 9.2.5


  FunctionCreate(realm, kind, ParameterList, Body, Scope, Strict, prototype) {
    // 1. If the prototype argument was not passed, then
    if (!prototype) {
      // a. Let prototype be the intrinsic object %FunctionPrototype%.
      prototype = realm.intrinsics.FunctionPrototype;
    } // 2. If kind is not Normal, let allocKind be "non-constructor".


    let allocKind;

    if (kind !== "normal") {
      allocKind = "non-constructor";
    } else {
      // 3. Else, let allocKind be "normal".
      allocKind = "normal";
    } // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).


    let F = this.FunctionAllocate(realm, prototype, Strict, allocKind); // ECMAScript 2016, section 17:
    //   "Every other data property described in clauses 18 through 26 and in Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified."
    // Because we call `AddRestrictedFunctionProperties` on `FunctionPrototype`, accessing property "arguments" will raise a `TypeError` by default.
    // However, in non-strict mode this behavior is not desired, so we will add them as own properties of each `FunctionValue`, in accordance with ECMA 17.
    // Note: "arguments" ***MUST NOT*** be set if the function is in strict mode or is an arrow, method, constructor, or generator function.
    //   See 16.2 "Forbidden Extensions"

    if (!Strict && kind === "normal") {
      _singletons.Properties.DefinePropertyOrThrow(realm, F, "arguments", new _descriptors.PropertyDescriptor({
        value: realm.intrinsics.undefined,
        enumerable: false,
        writable: true,
        configurable: true
      }));
    } // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).


    let result = this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);
    (0, _invariant.default)(F.pathConditionDuringDeclaration === undefined, "Function should only have one declaration site"); // Create a new path condition to make the saved condition readonly

    F.pathConditionDuringDeclaration = realm.pathConditions.isEmpty() ? undefined : realm.pathConditions;
    if (F.pathConditionDuringDeclaration) (0, _invariant.default)(F.pathConditionDuringDeclaration.isReadOnly());
    return result;
  } // ECMA262 18.2.1.2


  EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strict) {
    // 1. Let varNames be the VarDeclaredNames of body.
    let varNames = [];
    (0, _traverseFast.default)(body, node => {
      if (node.type === "VariableDeclaration" && node.kind === "var") {
        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));
      }

      if (node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
        return true;
      }

      return false;
    }); // 2. Let varDeclarations be the VarScopedDeclarations of body.

    let varDeclarations = this.FindVarScopedDeclarations(body); // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.

    let lexEnvRec = lexEnv.environmentRecord; // 4. Let varEnvRec be varEnv's EnvironmentRecord.

    let varEnvRec = varEnv.environmentRecord; // 5. If strict is false, then

    if (!strict) {
      // a. If varEnvRec is a global Environment Record, then
      if (varEnvRec instanceof _environment.GlobalEnvironmentRecord) {
        // i. For each name in varNames, do
        for (let name of varNames) {
          // 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
          if (varEnvRec.HasLexicalDeclaration(name)) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, new _index.StringValue(realm, name + " global object is restricted"));
          } // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.

        }
      } // b. Let thisLex be lexEnv.


      let thisLex = lexEnv; // c. Assert: The following loop will terminate.
      // d. Repeat while thisLex is not the same as varEnv,

      while (thisLex !== varEnv) {
        // i. Let thisEnvRec be thisLex's EnvironmentRecord.
        let thisEnvRec = thisLex.environmentRecord; // ii. If thisEnvRec is not an object Environment Record, then

        if (!(thisEnvRec instanceof _environment.ObjectEnvironmentRecord)) {
          // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
          // 2. For each name in varNames, do
          for (let name of varNames) {
            // a. If thisEnvRec.HasBinding(name) is true, then
            if (thisEnvRec.HasBinding(name)) {
              // i. Throw a SyntaxError exception.
              throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + " global object is restricted"); // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.
            } // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.

          }
        } // iii. Let thisLex be thisLex's outer environment reference.


        thisLex = thisLex.parent;
        (0, _invariant.default)(thisLex !== null);
      }
    } // 6. Let functionsToInitialize be a new empty List.


    let functionsToInitialize = []; // 7. Let declaredFunctionNames be a new empty List.

    let declaredFunctionNames = []; // 8. For each d in varDeclarations, in reverse list order do

    for (let d of varDeclarations.reverse()) {
      // a. If d is neither a VariableDeclaration or a ForBinding, then
      if (d.type !== "VariableDeclaration") {
        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.
        (0, _invariant.default)(d.type === "FunctionDeclaration" || d.type === "GeneratorDeclaration"); // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.
        // iii. Let fn be the sole element of the BoundNames of d.

        let fn = _singletons.Environment.BoundNames(realm, d)[0]; // iv. If fn is not an element of declaredFunctionNames, then


        if (declaredFunctionNames.indexOf(fn) < 0) {
          // 1. If varEnvRec is a global Environment Record, then
          if (varEnvRec instanceof _environment.GlobalEnvironmentRecord) {
            // a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).
            let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn); // b. If fnDefinable is false, throw a TypeError exception.

            if (!fnDefinable) {
              throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, fn + " is not definable");
            }
          } // 2. Append fn to declaredFunctionNames.


          declaredFunctionNames.push(fn); // 3. Insert d as the first element of functionsToInitialize.

          functionsToInitialize.unshift(d);
        }
      }
    } // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.
    // 10. Let declaredVarNames be a new empty List.


    let declaredVarNames = []; // 11. For each d in varDeclarations, do

    for (let d of varDeclarations) {
      // a. If d is a VariableDeclaration or a ForBinding, then
      if (d.type === "VariableDeclaration") {
        // i. For each String vn in the BoundNames of d, do
        for (let vn of _singletons.Environment.BoundNames(realm, d)) {
          // 1. If vn is not an element of declaredFunctionNames, then
          if (declaredFunctionNames.indexOf(vn) < 0) {
            // a. If varEnvRec is a global Environment Record, then
            if (varEnvRec instanceof _environment.GlobalEnvironmentRecord) {
              // i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).
              let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn); // ii. If vnDefinable is false, throw a TypeError exception.

              if (!vnDefinable) {
                throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, vn + " is not definable");
              }
            } // b. If vn is not an element of declaredVarNames, then


            if (declaredVarNames.indexOf(vn) < 0) {
              // i. Append vn to declaredVarNames.
              declaredVarNames.push(vn);
            }
          }
        }
      }
    } // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.
    // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.


    let lexDeclarations = [];

    for (let s of body.body) {
      if (s.type === "VariableDeclaration" && s.kind !== "var") {
        lexDeclarations.push(s);
      }
    } // 14. For each element d in lexDeclarations do


    for (let d of lexDeclarations) {
      // a. NOTE Lexically declared names are only instantiated here but not initialized.
      // b. For each element dn of the BoundNames of d do
      for (let dn of _singletons.Environment.BoundNames(realm, d)) {
        // c. If IsConstantDeclaration of d is true, then
        if (d.kind === "const") {
          // i. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).
          lexEnvRec.CreateImmutableBinding(dn, true);
        } else {
          // d. Else,
          // i. Perform ? lexEnvRec.CreateMutableBinding(dn, false).
          lexEnvRec.CreateMutableBinding(dn, false);
        }
      }
    } // 15. For each production f in functionsToInitialize, do


    for (let f of functionsToInitialize) {
      // a. Let fn be the sole element of the BoundNames of f.
      let fn = _singletons.Environment.BoundNames(realm, f)[0]; // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.


      let fo = lexEnv.evaluate(f, strict);
      (0, _invariant.default)(fo instanceof _index.Value); // c. If varEnvRec is a global Environment Record, then

      if (varEnvRec instanceof _environment.GlobalEnvironmentRecord) {
        // i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).
        varEnvRec.CreateGlobalFunctionBinding(fn, fo, true);
      } else {
        // d. Else,
        // i. Let bindingExists be varEnvRec.HasBinding(fn).
        let bindingExists = varEnvRec.HasBinding(fn); // ii. If bindingExists is false, then

        if (!bindingExists) {
          // 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).
          varEnvRec.CreateMutableBinding(fn, true); // 2. Assert: status is not an abrupt completion because of validation preceding step 12.
          // 3. Perform ! varEnvRec.InitializeBinding(fn, fo).

          varEnvRec.InitializeBinding(fn, fo);
        } else {
          // iii. Else,
          // 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).
          varEnvRec.SetMutableBinding(fn, fo, false);
        }
      }
    } // 16. For each String vn in declaredVarNames, in list order do


    for (let vn of declaredVarNames) {
      // a. If varEnvRec is a global Environment Record, then
      if (varEnvRec instanceof _environment.GlobalEnvironmentRecord) {
        // i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).
        varEnvRec.CreateGlobalVarBinding(vn, true);
      } else {
        // b. Else,
        // i. Let bindingExists be varEnvRec.HasBinding(vn).
        let bindingExists = varEnvRec.HasBinding(vn); // ii. If bindingExists is false, then

        if (!bindingExists) {
          // 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).
          varEnvRec.CreateMutableBinding(vn, true); // 2. Assert: status is not an abrupt completion because of validation preceding step 12.
          // 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).

          varEnvRec.InitializeBinding(vn, realm.intrinsics.undefined);
        }
      }
    } // 17. Return NormalCompletion(empty).


    return realm.intrinsics.empty;
  } // ECMA 9.2.10


  MakeMethod(realm, F, homeObject) {
    // Note that F is a new object, and we can thus write to internal slots
    (0, _invariant.default)(realm.isNewObject(F)); // 1. Assert: F is an ECMAScript function object.

    (0, _invariant.default)(F instanceof _index.ECMAScriptSourceFunctionValue, "F is an ECMAScript function object."); // 2. Assert: Type(homeObject) is Object.

    (0, _invariant.default)(homeObject instanceof _index.ObjectValue, "Type(homeObject) is Object."); // 3. Set the [[HomeObject]] internal slot of F to homeObject.

    F.$HomeObject = homeObject; // 4. Return NormalCompletion(undefined).

    return realm.intrinsics.undefined;
  } // ECMA 14.3.8


  DefineMethod(realm, prop, obj, env, strictCode, functionPrototype) {
    // 1. Let propKey be the result of evaluating PropertyName.
    let propKey = (0, _ObjectExpression.EvalPropertyName)(prop, env, realm, strictCode); // 2. ReturnIfAbrupt(propKey).
    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.

    let strict = strictCode || (0, _strict.default)(prop.body); // 4. Let scope be the running execution context's LexicalEnvironment.

    let scope = env; // 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method.

    let kind;

    if (functionPrototype) {
      // let kind be Normal;
      kind = "normal";
    } else {
      // otherwise let kind be Method.
      kind = "method";
    } // 6. Let closure be FunctionCreate(kind, StrictFormalParameters, FunctionBody, scope, strict). If functionPrototype was passed as a parameter, then pass its value as the prototype optional argument of FunctionCreate.


    let closure = this.FunctionCreate(realm, kind, prop.params, prop.body, scope, strict, functionPrototype); // 7. Perform MakeMethod(closure, object).

    this.MakeMethod(realm, closure, obj); // 8. Return the Record{[[Key]]: propKey, [[Closure]]: closure}.

    return {
      $Key: propKey,
      $Closure: closure
    };
  }

}

exports.FunctionImplementation = FunctionImplementation;
//# sourceMappingURL=function.js.map

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MaterializeImplementation = exports.LeakImplementation = void 0;

var _errors = __webpack_require__(3);

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var t = _interopRequireWildcard(__webpack_require__(21));

var _traverse = _interopRequireDefault(__webpack_require__(293));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _HeapInspector = __webpack_require__(426);

var _logger = __webpack_require__(412);

var _utils = __webpack_require__(291);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function visitName(path, state, name, read, write) {
  // Is the name bound to some local identifier? If so, we don't need to do anything
  if (path.scope.hasBinding(name,
  /*noGlobals*/
  true)) return; // Otherwise, let's record that there's an unbound identifier

  if (read) state.unboundReads.add(name);
  if (write) state.unboundWrites.add(name);
}

function ignorePath(path) {
  let parent = path.parent;
  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);
}

let LeakedClosureRefVisitor = {
  ReferencedIdentifier(path, state) {
    if (ignorePath(path)) return;
    let innerName = path.node.name;

    if (innerName === "arguments") {
      return;
    }

    visitName(path, state, innerName, true, false);
  },

  "AssignmentExpression|UpdateExpression"(path, state) {
    let doesRead = path.node.operator !== "=";

    for (let name in path.getBindingIdentifiers()) {
      visitName(path, state, name, doesRead, true);
    }
  }

};

function getLeakedFunctionInfo(value) {
  // TODO: This should really be cached on a per AST basis in case we have
  // many uses of the same closure. It should ideally share this cache
  // and data with ResidualHeapVisitor.
  (0, _invariant.default)(value instanceof _index.ECMAScriptSourceFunctionValue);
  (0, _invariant.default)(value.constructor === _index.ECMAScriptSourceFunctionValue);
  let functionInfo = {
    unboundReads: new Set(),
    unboundWrites: new Set()
  };
  let formalParameters = value.$FormalParameters;
  (0, _invariant.default)(formalParameters != null);
  let code = value.$ECMAScriptCode;
  (0, _invariant.default)(code != null);
  (0, _traverse.default)(t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])), LeakedClosureRefVisitor, null, functionInfo);

  _traverse.default.cache.clear();

  return functionInfo;
}

function materializeObject(realm, object, getCachingHeapInspector) {
  let generator = realm.generator;

  if (object.symbols.size > 0) {
    throw new _errors.FatalError("TODO: Support havocing objects with symbols");
  }

  if (object.unknownProperty !== undefined) {// TODO: Support unknown properties, or throw FatalError.
    // We have repros, e.g. test/serializer/additional-functions/ArrayConcat.js.
  }

  let getHeapInspector = getCachingHeapInspector || (() => new _HeapInspector.HeapInspector(realm, new _logger.Logger(realm,
  /*internalDebug*/
  false))); // TODO: We should emit current value and then reset value for all *internal slots*; this will require deep serializer support; or throw FatalError when we detect any non-initial values in internal slots.


  for (let [name, propertyBinding] of object.properties) {
    // ignore properties with their correct default values
    if (getHeapInspector().canIgnoreProperty(object, name)) continue;
    let descriptor = propertyBinding.descriptor;

    if (descriptor === undefined) {
      // TODO: This happens, e.g. test/serializer/pure-functions/ObjectAssign2.js
      // If it indeed means deleted binding, should we initialize descriptor with a deleted value?
      if (generator !== undefined) generator.emitPropertyDelete(object, name);
    } else {
      (0, _invariant.default)(descriptor instanceof _descriptors.PropertyDescriptor); // TODO: Deal with joined descriptors.

      let value = descriptor.value;
      (0, _invariant.default)(value === undefined || value instanceof _index.Value, "cannot be an array because we are not dealing with intrinsics here");

      if (value === undefined) {// TODO: Deal with accessor properties
        // We have repros, e.g. test/serializer/pure-functions/AbstractPropertyObjectKeyAssignment.js
      } else {
        (0, _invariant.default)(value instanceof _index.Value);

        if (value instanceof _index.EmptyValue) {
          if (generator !== undefined) generator.emitPropertyDelete(object, name);
        } else {
          if (generator !== undefined) {
            let targetDescriptor = getHeapInspector().getTargetIntegrityDescriptor(object);

            if (!(0, _utils.isReactElement)(object)) {
              if (descriptor.writable !== targetDescriptor.writable || descriptor.configurable !== targetDescriptor.configurable) {
                generator.emitDefineProperty(object, name, descriptor);
              } else {
                generator.emitPropertyAssignment(object, name, value);
              }
            }
          }
        }
      }
    }
  }
}

class ObjectValueLeakingVisitor {
  // ObjectValues to visit if they're reachable.
  // Values that has been visited.
  constructor(realm, objectsTrackedForLeaks) {
    this.realm = realm;
    this.objectsTrackedForLeaks = objectsTrackedForLeaks;
    this.visitedValues = new Set();
  }

  mustVisit(val) {
    if (val instanceof _index.ObjectValue) {
      // For Objects we only need to visit it if it is tracked
      // as a newly created object that might still be mutated.
      // Abstract values gets their arguments visited.
      if (!this.objectsTrackedForLeaks.has(val)) return false;
    }

    if (this.visitedValues.has(val)) return false;
    this.visitedValues.add(val);
    return true;
  }

  visitObjectProperty(binding) {
    let desc = binding.descriptor;
    if (desc === undefined) return; //deleted

    this.visitDescriptor(desc);
  }

  visitObjectProperties(obj, kind) {
    // visit symbol properties
    for (let [, propertyBindingValue] of obj.symbols) {
      (0, _invariant.default)(propertyBindingValue);
      this.visitObjectProperty(propertyBindingValue);
    } // visit string properties


    for (let [, propertyBindingValue] of obj.properties) {
      (0, _invariant.default)(propertyBindingValue);
      this.visitObjectProperty(propertyBindingValue);
    } // inject properties with computed names


    if (obj.unknownProperty !== undefined) {
      let desc = obj.unknownProperty.descriptor;
      this.visitObjectPropertiesWithComputedNamesDescriptor(desc);
    } // prototype


    this.visitObjectPrototype(obj);
    if ((0, _index2.TestIntegrityLevel)(this.realm, obj, "frozen")) return; // if this object wasn't already leaked, we need mark it as leaked
    // so that any mutation and property access get tracked after this.

    if (obj.mightNotBeLeakedObject()) {
      obj.leak(); // materialization is a common operation and needs to be invoked
      // whenever non-final values need to be made available at intermediate
      // points in a program's control flow. An object can be materialized by
      // calling materializeObject(). Sometimes, objects
      // are materialized in cohorts (such as during leaking).
      // In these cases, we provide a caching mechanism for HeapInspector().

      let makeAndCacheHeapInspector = () => {
        let heapInspector = this._heapInspector;
        if (heapInspector !== undefined) return heapInspector;else {
          heapInspector = new _HeapInspector.HeapInspector(this.realm, new _logger.Logger(this.realm,
          /*internalDebug*/
          false));
          this._heapInspector = heapInspector;
          return heapInspector;
        }
      };

      (0, _invariant.default)(this.realm.generator !== undefined);
      materializeObject(this.realm, obj, makeAndCacheHeapInspector);
    }
  }

  visitObjectPrototype(obj) {
    let proto = obj.$Prototype;
    this.visitValue(proto);
  }

  visitObjectPropertiesWithComputedNamesDescriptor(desc) {
    if (desc !== undefined) {
      if (desc instanceof _descriptors.PropertyDescriptor) {
        let val = desc.value;
        (0, _invariant.default)(val instanceof _index.AbstractValue);
        this.visitObjectPropertiesWithComputedNames(val);
      } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
        this.visitValue(desc.joinCondition);
        this.visitObjectPropertiesWithComputedNamesDescriptor(desc.descriptor1);
        this.visitObjectPropertiesWithComputedNamesDescriptor(desc.descriptor2);
      } else {
        (0, _invariant.default)(false, "unknown descriptor");
      }
    }
  }

  visitObjectPropertiesWithComputedNames(absVal) {
    if (absVal.kind === "widened property") return;
    if (absVal.kind === "template for prototype member expression") return;

    if (absVal.kind === "conditional") {
      let cond = absVal.args[0];
      (0, _invariant.default)(cond instanceof _index.AbstractValue);

      if (cond.kind === "template for property name condition") {
        let P = cond.args[0];
        (0, _invariant.default)(P instanceof _index.AbstractValue);
        let V = absVal.args[1];
        let earlier_props = absVal.args[2];
        if (earlier_props instanceof _index.AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);
        this.visitValue(P);
        this.visitValue(V);
      } else {
        // conditional assignment
        this.visitValue(cond);
        let consequent = absVal.args[1];

        if (consequent instanceof _index.AbstractValue) {
          this.visitObjectPropertiesWithComputedNames(consequent);
        }

        let alternate = absVal.args[2];

        if (alternate instanceof _index.AbstractValue) {
          this.visitObjectPropertiesWithComputedNames(alternate);
        }
      }
    } else {
      this.visitValue(absVal);
    }
  }

  visitDescriptor(desc) {
    if (desc === undefined) {} else if (desc instanceof _descriptors.PropertyDescriptor) {
      if (desc.value !== undefined) this.visitValue(desc.value);
      if (desc.get !== undefined) this.visitValue(desc.get);
      if (desc.set !== undefined) this.visitValue(desc.set);
    } else if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
      this.visitValue(desc.joinCondition);
      if (desc.descriptor1 !== undefined) this.visitDescriptor(desc.descriptor1);
      if (desc.descriptor2 !== undefined) this.visitDescriptor(desc.descriptor2);
    } else {
      (0, _invariant.default)(false, "unknown descriptor");
    }
  }

  visitDeclarativeEnvironmentRecordBinding(record, remainingLeakedBindings) {
    let bindings = record.bindings;

    for (let bindingName of Object.keys(bindings)) {
      let binding = bindings[bindingName]; // Check if this binding is referenced, and if so delete it from the set.

      let isRead = remainingLeakedBindings.unboundReads.delete(bindingName);
      let isWritten = remainingLeakedBindings.unboundWrites.delete(bindingName);

      if (isRead) {
        // If this binding can be read from the closure, its value has now leaked.
        let value = binding.value;

        if (value) {
          this.visitValue(value);
        }
      }

      if (isWritten || isRead) {
        // If this binding could have been mutated from the closure, then the
        // binding itself has now leaked, but not necessarily the value in it.
        // TODO: We could tag a leaked binding as read and/or write. That way
        // we don't have to leak values written to this binding if only the binding
        // has been written to. We also don't have to leak reads from this binding
        // if it is only read from.
        (0, _environment.leakBinding)(binding);
      }
    }
  }

  visitValueMap(val) {
    let kind = val.getKind();
    let entries;

    if (kind === "Map") {
      entries = val.$MapData;
    } else {
      (0, _invariant.default)(kind === "WeakMap");
      entries = val.$WeakMapData;
    }

    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;

    for (let i = 0; i < len; i++) {
      let entry = entries[i];
      let key = entry.$Key;
      let value = entry.$Value;
      if (key === undefined || value === undefined) continue;
      this.visitValue(key);
      this.visitValue(value);
    }
  }

  visitValueSet(val) {
    let kind = val.getKind();
    let entries;

    if (kind === "Set") {
      entries = val.$SetData;
    } else {
      (0, _invariant.default)(kind === "WeakSet");
      entries = val.$WeakSetData;
    }

    (0, _invariant.default)(entries !== undefined);
    let len = entries.length;

    for (let i = 0; i < len; i++) {
      let entry = entries[i];
      if (entry === undefined) continue;
      this.visitValue(entry);
    }
  }

  visitValueFunction(val) {
    if (!val.mightNotBeLeakedObject()) {
      return;
    }

    this.visitObjectProperties(val);

    if (val instanceof _index.BoundFunctionValue) {
      this.visitValue(val.$BoundTargetFunction);
      this.visitValue(val.$BoundThis);

      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);

      return;
    }

    (0, _invariant.default)(!(val instanceof _index.NativeFunctionValue), "all native function values should have already been created outside this pure function");
    let remainingLeakedBindings = getLeakedFunctionInfo(val);
    let environment = val.$Environment;

    while (environment) {
      let record = environment.environmentRecord;

      if (record instanceof _environment.ObjectEnvironmentRecord) {
        this.visitValue(record.object);
        continue;
      }

      if (record instanceof _environment.GlobalEnvironmentRecord) {
        break;
      }

      (0, _invariant.default)(record instanceof _environment.DeclarativeEnvironmentRecord);
      this.visitDeclarativeEnvironmentRecordBinding(record, remainingLeakedBindings);

      if (record instanceof _environment.FunctionEnvironmentRecord) {
        // If this is a function environment, which is not tracked for leaks,
        // we can bail out because its bindings should not be mutated in a
        // pure function.
        let fn = record.$FunctionObject;

        if (!this.objectsTrackedForLeaks.has(fn)) {
          break;
        }
      }

      environment = environment.parent;
    }
  }

  visitValueObject(val) {
    if (!val.mightNotBeLeakedObject()) {
      return;
    }

    let kind = val.getKind();
    this.visitObjectProperties(val, kind);

    switch (kind) {
      case "RegExp":
      case "Number":
      case "String":
      case "Boolean":
      case "ReactElement":
      case "ArrayBuffer":
      case "Array":
        return;

      case "Date":
        let dateValue = val.$DateValue;
        (0, _invariant.default)(dateValue !== undefined);
        this.visitValue(dateValue);
        return;

      case "Float32Array":
      case "Float64Array":
      case "Int8Array":
      case "Int16Array":
      case "Int32Array":
      case "Uint8Array":
      case "Uint16Array":
      case "Uint32Array":
      case "Uint8ClampedArray":
      case "DataView":
        let buf = val.$ViewedArrayBuffer;
        (0, _invariant.default)(buf !== undefined);
        this.visitValue(buf);
        return;

      case "Map":
      case "WeakMap":
        this.visitValueMap(val);
        return;

      case "Set":
      case "WeakSet":
        this.visitValueSet(val);
        return;

      default:
        (0, _invariant.default)(kind === "Object", `Object of kind ${kind} is not supported in calls to abstract functions.`);
        (0, _invariant.default)(val.$ParameterMap === undefined, `Arguments object is not supported in calls to abstract functions.`);
        return;
    }
  }

  visitValueProxy(val) {
    this.visitValue(val.$ProxyTarget);
    this.visitValue(val.$ProxyHandler);
  }

  visitAbstractValue(val) {
    if (!val.mightBeObject()) {
      // Only objects need to be leaked.
      return;
    }

    if (val.values.isTop()) {
      // If we don't know which object instances it might be,
      // then it might be one of the arguments that created
      // this value. See #2179.
      if (val.kind === "conditional") {
        // For a conditional, we only have to visit each case. Not the condition itself.
        this.visitValue(val.args[1]);
        this.visitValue(val.args[2]);
        return;
      } // To ensure that we don't forget to provide arguments
      // that can be havoced, we require at least one argument.


      let whitelistedKind = val.kind && (val.kind === "widened numeric property" || // TODO: Widened properties needs to be havocable.
      val.kind.startsWith("abstractCounted"));
      (0, _invariant.default)(whitelistedKind !== undefined || val.intrinsicName !== undefined || val.args.length > 0, "Havoced unknown object requires havocable arguments"); // TODO: This is overly conservative. We recursively leak all the inputs
      // to this operation whether or not they can possible be part of the
      // result value or not.

      for (let i = 0, n = val.args.length; i < n; i++) {
        this.visitValue(val.args[i]);
      }

      return;
    } // If we know which object this might be, then leak each of them.


    for (let element of val.values.getElements()) {
      this.visitValue(element);
    }
  }

  visitValue(val) {
    if (val instanceof _index.AbstractValue) {
      if (this.mustVisit(val)) this.visitAbstractValue(val);
    } else if (val.isIntrinsic()) {
      // All intrinsic values exist from the beginning of time (except arrays with widened properties)...
      // ...except for a few that come into existance as templates for abstract objects.
      if (val instanceof _index.ArrayValue && _index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(val)) {
        if (this.mustVisit(val)) this.visitValueObject(val);
      } else {
        this.mustVisit(val);
      }
    } else if (val instanceof _index.EmptyValue) {
      this.mustVisit(val);
    } else if (val instanceof _index.PrimitiveValue) {
      this.mustVisit(val);
    } else if (val instanceof _index.ProxyValue) {
      if (this.mustVisit(val)) this.visitValueProxy(val);
    } else if (val instanceof _index.FunctionValue) {
      (0, _invariant.default)(val instanceof _index.FunctionValue);
      if (this.mustVisit(val)) this.visitValueFunction(val);
    } else {
      (0, _invariant.default)(val instanceof _index.ObjectValue);
      if (this.mustVisit(val)) this.visitValueObject(val);
    }
  }

}

function ensureFrozenValue(realm, value, loc) {
  // TODO: This should really check if it is recursively immutability.
  if (value instanceof _index.ObjectValue && !(0, _index2.TestIntegrityLevel)(realm, value, "frozen")) {
    let diag = new _errors.CompilerDiagnostic("Unfrozen object leaked before end of global code", loc || realm.currentLocation, "PP0017", "RecoverableError");
    if (realm.handleError(diag) !== "Recover") throw new _errors.FatalError();
  }
} // Ensure that a value is immutable. If it is not, set all its properties to abstract values
// and all reachable bindings to abstract values.


class LeakImplementation {
  value(realm, value, loc) {
    if (realm.instantRender.enabled) {
      // TODO: For InstantRender...
      // - For declarative bindings, we do want proper materialization/leaking/havocing
      // - For object properties, we conceptually want materialization
      //   (however, not via statements that mutate the objects,
      //   but only as part of the initial object literals),
      //   but actual no leaking or leaking as there should be a way to annotate/enforce
      //   that external/abstract functions are pure with regards to heap objects
      return;
    }

    let objectsTrackedForLeaks = realm.createdObjectsTrackedForLeaks;

    if (objectsTrackedForLeaks === undefined) {
      // We're not tracking a pure function. That means that we would track
      // everything as leaked. We'll assume that any object argument
      // is invalid unless it's frozen.
      ensureFrozenValue(realm, value, loc);
    } else {
      // If we're tracking a pure function, we can assume that only newly
      // created objects and bindings, within it, are mutable. Any other
      // object can safely be assumed to be deeply immutable as far as this
      // pure function is concerned. However, any mutable object needs to
      // be tainted as possibly having changed to anything.
      let visitor = new ObjectValueLeakingVisitor(realm, objectsTrackedForLeaks);
      visitor.visitValue(value);
    }
  }

}

exports.LeakImplementation = LeakImplementation;

class MaterializeImplementation {
  // TODO: Understand relation to snapshots: #2441
  materializeObject(realm, val) {
    if (realm.instantRender.enabled) // Materialization leads to runtime code that mutates objects
      // this is at best undesirable in InstantRender
      val.makeFinal();else materializeObject(realm, val);
  } // This routine materializes objects reachable from non-local bindings read
  // by a function. It does this for the purpose of outlining calls to that function.
  //
  // Notes:
  // - Locations that are only read need not materialize because their values are up-to-date
  // at optimization time,
  // - Locations that are written to are ignored, because we make the assumption, for now,
  // that the function being outlined is pure.
  // - Previously havoced locations (#2446) should be reloaded, but are currently rejected.
  // - Specialization depends on the assumption that the Array op will only be used once.
  // First, we will enforce it: #2448. Later we will relax it: #2454


  computeReachableObjects(realm, rootValue) {
    (0, _invariant.default)(realm.isInPureScope());
    let reachableObjects = new Set();
    let visitedValues = new Set();
    computeFromValue(rootValue);
    return reachableObjects;

    function computeFromBindings(func, nonLocalReadBindings) {
      (0, _invariant.default)(func instanceof _index.ECMAScriptSourceFunctionValue);
      let environment = func.$Environment;

      while (environment) {
        let record = environment.environmentRecord;
        if (record instanceof _environment.ObjectEnvironmentRecord) computeFromValue(record.object);else if (record instanceof _environment.DeclarativeEnvironmentRecord || record instanceof _environment.FunctionEnvironmentRecord) computeFromDeclarativeEnvironmentRecord(record, nonLocalReadBindings);else if (record instanceof _environment.GlobalEnvironmentRecord) {
          // TODO: #2484
          break;
        }
        environment = environment.parent;
      }
    }

    function computeFromDeclarativeEnvironmentRecord(record, nonLocalReadBindings) {
      let environmentBindings = record.bindings;

      for (let bindingName of Object.keys(environmentBindings)) {
        let binding = environmentBindings[bindingName];
        (0, _invariant.default)(binding !== undefined);
        let found = nonLocalReadBindings.delete(bindingName); // Check what undefined could mean here, besides absent binding
        // #2446

        if (found && binding.value !== undefined) {
          computeFromValue(binding.value);
        }
      }
    }

    function computeFromAbstractValue(value) {
      if (value.values.isTop()) {
        for (let arg of value.args) {
          computeFromValue(arg);
        }
      } else {
        // If we know which object this might be, then leak each of them.
        for (let element of value.values.getElements()) {
          computeFromValue(element);
        }
      }
    }

    function computeFromProxyValue(value) {
      computeFromValue(value.$ProxyTarget);
      computeFromValue(value.$ProxyHandler);
    }

    function computeFromValue(value) {
      (0, _invariant.default)(value !== undefined);

      if (value.isIntrinsic() || value instanceof _index.EmptyValue || value instanceof _index.PrimitiveValue) {
        visit(value);
      } else if (value instanceof _index.AbstractValue) {
        ifNotVisited(value, computeFromAbstractValue);
      } else if (value instanceof _index.FunctionValue) {
        ifNotVisited(value, computeFromFunctionValue);
      } else if (value instanceof _index.ObjectValue) {
        ifNotVisited(value, computeFromObjectValue);
      } else if (value instanceof _index.ProxyValue) {
        ifNotVisited(value, computeFromProxyValue);
      }
    }

    function computeFromObjectValue(value) {
      (0, _invariant.default)(value instanceof _index.ObjectValue);
      let kind = value.getKind();
      computeFromObjectProperties(value, kind);

      switch (kind) {
        case "RegExp":
        case "Number":
        case "String":
        case "Boolean":
        case "ReactElement":
        case "ArrayBuffer":
        case "Array":
          break;

        case "Date":
          let dateValue = value.$DateValue;
          (0, _invariant.default)(dateValue !== undefined);
          computeFromValue(dateValue);
          break;

        case "Float32Array":
        case "Float64Array":
        case "Int8Array":
        case "Int16Array":
        case "Int32Array":
        case "Uint8Array":
        case "Uint16Array":
        case "Uint32Array":
        case "Uint8ClampedArray":
        case "DataView":
          let buf = value.$ViewedArrayBuffer;
          (0, _invariant.default)(buf !== undefined);
          computeFromValue(buf);
          break;

        case "Map":
        case "WeakMap":
          ifNotVisited(value, computeFromMap);
          break;

        case "Set":
        case "WeakSet":
          ifNotVisited(value, computeFromSet);
          break;

        default:
          (0, _invariant.default)(kind === "Object", `Object of kind ${kind} is not supported in calls to abstract functions.`);
          (0, _invariant.default)(value.$ParameterMap === undefined, `Arguments object is not supported in calls to abstract functions.`);
          break;
      }

      if (!reachableObjects.has(value)) reachableObjects.add(value);
    }

    function computeFromDescriptor(descriptor) {
      if (descriptor === undefined) {} else if (descriptor instanceof _descriptors.PropertyDescriptor) {
        if (descriptor.value !== undefined) computeFromValue(descriptor.value);
        if (descriptor.get !== undefined) computeFromValue(descriptor.get);
        if (descriptor.set !== undefined) computeFromValue(descriptor.set);
      } else if (descriptor instanceof _descriptors.AbstractJoinedDescriptor) {
        computeFromValue(descriptor.joinCondition);
        if (descriptor.descriptor1 !== undefined) computeFromDescriptor(descriptor.descriptor1);
        if (descriptor.descriptor2 !== undefined) computeFromDescriptor(descriptor.descriptor2);
      } else {
        (0, _invariant.default)(false, "unknown descriptor");
      }
    }

    function computeFromObjectPropertyBinding(binding) {
      let descriptor = binding.descriptor;
      if (descriptor === undefined) return; //deleted

      computeFromDescriptor(descriptor);
    }

    function computeFromObjectProperties(obj, kind) {
      // symbol properties
      for (let [, propertyBindingValue] of obj.symbols) {
        (0, _invariant.default)(propertyBindingValue);
        computeFromObjectPropertyBinding(propertyBindingValue);
      } // string properties


      for (let [, propertyBindingValue] of obj.properties) {
        (0, _invariant.default)(propertyBindingValue);
        computeFromObjectPropertyBinding(propertyBindingValue);
      } // inject properties with computed names


      if (obj.unknownProperty !== undefined) {
        let descriptor = obj.unknownProperty.descriptor;
        computeFromObjectPropertiesWithComputedNamesDescriptor(descriptor);
      } // prototype


      computeFromObjectPrototype(obj);
    }

    function computeFromObjectPrototype(obj) {
      if (obj.$Prototype !== undefined) computeFromValue(obj.$Prototype);
    }

    function computeFromFunctionValue(fn) {
      computeFromObjectProperties(fn);

      if (fn instanceof _index.BoundFunctionValue) {
        computeFromValue(fn.$BoundTargetFunction);
        computeFromValue(fn.$BoundThis);

        for (let boundArg of fn.$BoundArguments) computeFromValue(boundArg);

        return;
      }

      (0, _invariant.default)(!(fn instanceof _index.NativeFunctionValue), "all native function values should have already been created outside this pure function");
      let nonLocalReadBindings = nonLocalReadBindingsOfFunction(fn);
      computeFromBindings(fn, nonLocalReadBindings);
    }

    function computeFromObjectPropertiesWithComputedNamesDescriptor(descriptor) {
      // TODO: #2484
      notSupportedForTransitiveMaterialization();
    }

    function computeFromMap(val) {
      let kind = val.getKind();
      let entries;

      if (kind === "Map") {
        entries = val.$MapData;
      } else {
        (0, _invariant.default)(kind === "WeakMap");
        entries = val.$WeakMapData;
      }

      (0, _invariant.default)(entries !== undefined);
      let len = entries.length;

      for (let i = 0; i < len; i++) {
        let entry = entries[i];
        let key = entry.$Key;
        let value = entry.$Value;
        if (key === undefined || value === undefined) continue;
        computeFromValue(key);
        computeFromValue(value);
      }
    }

    function computeFromSet(val) {
      let kind = val.getKind();
      let entries;

      if (kind === "Set") {
        entries = val.$SetData;
      } else {
        (0, _invariant.default)(kind === "WeakSet");
        entries = val.$WeakSetData;
      }

      (0, _invariant.default)(entries !== undefined);
      let len = entries.length;

      for (let i = 0; i < len; i++) {
        let entry = entries[i];
        if (entry === undefined) continue;
        computeFromValue(entry);
      }
    }

    function nonLocalReadBindingsOfFunction(func) {
      // unboundWrites is currently not used, but we leave it in place
      // to reuse the function closure visitor implemented for leaking
      let functionInfo = {
        unboundReads: new Set(),
        unboundWrites: new Set()
      };
      (0, _invariant.default)(func instanceof _index.ECMAScriptSourceFunctionValue);
      let formalParameters = func.$FormalParameters;
      (0, _invariant.default)(formalParameters != null);
      let code = func.$ECMAScriptCode;
      (0, _invariant.default)(code != null);
      (0, _traverse.default)(t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])), LeakedClosureRefVisitor, null, functionInfo);

      _traverse.default.cache.clear(); // TODO #2478: add invariant that there are no write bindings


      return functionInfo.unboundReads;
    }

    function ifNotVisited(value, computeFrom) {
      if (!visitedValues.has(value)) {
        visitedValues.add(value);
        computeFrom(value);
      }
    }

    function visit(value) {
      visitedValues.add(value);
    }

    function notSupportedForTransitiveMaterialization() {
      let error = new _errors.CompilerDiagnostic("Not supported for transitive materialization", rootValue.expressionLocation, "PP0041", "FatalError");
      realm.handleError(error);
      throw new _errors.FatalError();
    }
  }

}

exports.MaterializeImplementation = MaterializeImplementation;
//# sourceMappingURL=leak.js.map

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JoinImplementation = void 0;

var _realm = __webpack_require__(7);

var _descriptors = __webpack_require__(268);

var _completions = __webpack_require__(18);

var _index = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _generator = __webpack_require__(237);

var _index2 = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function joinGenerators(joinCondition, generator1, generator2) {
  let realm = joinCondition.$Realm;
  let result = new _generator.Generator(realm, "joined", realm.pathConditions);

  if (!generator1.empty() || !generator2.empty()) {
    result.joinGenerators(joinCondition, generator1, generator2);
  }

  return result;
}

function joinArrays(realm, v1, v2, getAbstractValue) {
  let e = v1 && v1[0] || v2 && v2[0];
  if (e instanceof _index2.Value) return joinArraysOfValues(realm, v1, v2, getAbstractValue);else return joinArrayOfsMapEntries(realm, v1, v2, getAbstractValue);
}

function joinArrayOfsMapEntries(realm, a1, a2, getAbstractValue) {
  let empty = realm.intrinsics.empty;
  let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);
  let result = [];

  for (let i = 0; i < n; i++) {
    let {
      $Key: key1,
      $Value: val1
    } = a1 && a1[i] || {
      $Key: empty,
      $Value: empty
    };
    let {
      $Key: key2,
      $Value: val2
    } = a2 && a2[i] || {
      $Key: empty,
      $Value: empty
    };

    if (key1 === undefined && key2 === undefined) {
      result[i] = {
        $Key: undefined,
        $Value: undefined
      };
    } else {
      let key3 = getAbstractValue(key1, key2);
      let val3 = getAbstractValue(val1, val2);
      result[i] = {
        $Key: key3,
        $Value: val3
      };
    }
  }

  return result;
}

function joinArraysOfValues(realm, a1, a2, getAbstractValue) {
  let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);
  let result = [];

  for (let i = 0; i < n; i++) {
    result[i] = getAbstractValue(a1 && a1[i] || undefined, a2 && a2[i] || undefined);
  }

  return result;
}

class JoinImplementation {
  composeCompletions(leftCompletion, rightCompletion) {
    if (leftCompletion instanceof _completions.AbruptCompletion) return leftCompletion;

    if (leftCompletion instanceof _completions.JoinedNormalAndAbruptCompletions) {
      if (rightCompletion instanceof _completions.JoinedNormalAndAbruptCompletions) {
        rightCompletion.composedWith = leftCompletion;
        rightCompletion.pathConditionsAtCreation = leftCompletion.pathConditionsAtCreation;
        return rightCompletion;
      }

      let c = this.composeCompletions(leftCompletion.consequent, rightCompletion);
      if (c instanceof _index2.Value) c = new _completions.SimpleNormalCompletion(c);
      let a = this.composeCompletions(leftCompletion.alternate, rightCompletion);
      if (a instanceof _index2.Value) a = new _completions.SimpleNormalCompletion(a);
      let joinedCompletion = this.joinCompletions(leftCompletion.joinCondition, c, a);

      if (joinedCompletion instanceof _completions.JoinedNormalAndAbruptCompletions) {
        joinedCompletion.composedWith = leftCompletion.composedWith;
        joinedCompletion.pathConditionsAtCreation = leftCompletion.pathConditionsAtCreation;
        joinedCompletion.savedEffects = leftCompletion.savedEffects;
      }

      return joinedCompletion;
    }

    if (leftCompletion instanceof _index2.Value) leftCompletion = new _completions.SimpleNormalCompletion(leftCompletion);

    if (leftCompletion instanceof _completions.Completion && leftCompletion.value === leftCompletion.value.$Realm.intrinsics.__bottomValue) {
      return leftCompletion;
    }

    if (rightCompletion instanceof _index2.Value) rightCompletion = new _completions.SimpleNormalCompletion(rightCompletion);
    return rightCompletion;
  }

  composeWithEffects(completion, normalEffects) {
    if (completion instanceof _completions.JoinedNormalAndAbruptCompletions) {
      let selectAbrupt = c => c instanceof _completions.AbruptCompletion && c.value !== c.value.$Realm.intrinsics.__bottomValue;

      let composableCompletions = _completions.Completion.makeSelectedCompletionsInfeasibleInCopy(selectAbrupt, completion);

      let composedNormalCompletion = this.composeCompletions(composableCompletions, normalEffects.result);
      normalEffects.result = composedNormalCompletion;

      let selectNormal = c => c instanceof _completions.SimpleNormalCompletion && c.value !== c.value.$Realm.intrinsics.__bottomValue;

      let nonComposableCompletions = _completions.Completion.makeSelectedCompletionsInfeasibleInCopy(selectNormal, completion);

      let nonComposedEffects = (0, _realm.construct_empty_effects)(completion.value.$Realm, nonComposableCompletions);

      let joinCondition = _index2.AbstractValue.createJoinConditionForSelectedCompletions(selectNormal, completion);

      return this.joinEffects(joinCondition, normalEffects, nonComposedEffects);
    } else if (completion instanceof _completions.AbruptCompletion) {
      return (0, _realm.construct_empty_effects)(completion.value.$Realm, completion);
    } else {
      return normalEffects;
    }
  }

  _collapseSimilarCompletions(joinCondition, c1, c2) {
    let realm = joinCondition.$Realm;

    let getAbstractValue = (v1, v2) => {
      if (v1 instanceof _index2.EmptyValue) return v2 || realm.intrinsics.undefined;
      if (v2 instanceof _index2.EmptyValue) return v1 || realm.intrinsics.undefined;
      return _index2.AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);
    };

    if (c1 instanceof _completions.BreakCompletion && c2 instanceof _completions.BreakCompletion && c1.target === c2.target) {
      let val = this.joinValues(realm, c1.value, c2.value, getAbstractValue);
      (0, _invariant.default)(val instanceof _index2.Value);
      return new _completions.BreakCompletion(val, joinCondition.expressionLocation, c1.target);
    }

    if (c1 instanceof _completions.ContinueCompletion && c2 instanceof _completions.ContinueCompletion && c1.target === c2.target) {
      return new _completions.ContinueCompletion(realm.intrinsics.empty, joinCondition.expressionLocation, c1.target);
    }

    if (c1 instanceof _completions.ReturnCompletion && c2 instanceof _completions.ReturnCompletion) {
      let val = this.joinValues(realm, c1.value, c2.value, getAbstractValue);
      (0, _invariant.default)(val instanceof _index2.Value);
      return new _completions.ReturnCompletion(val, joinCondition.expressionLocation);
    }

    if (c1 instanceof _completions.ThrowCompletion && c2 instanceof _completions.ThrowCompletion) {
      getAbstractValue = (v1, v2) => {
        return _index2.AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);
      };

      let val = this.joinValues(realm, c1.value, c2.value, getAbstractValue);
      (0, _invariant.default)(val instanceof _index2.Value);
      return new _completions.ThrowCompletion(val, c1.location);
    }

    if (c1 instanceof _completions.SimpleNormalCompletion && c2 instanceof _completions.SimpleNormalCompletion) {
      return new _completions.SimpleNormalCompletion(getAbstractValue(c1.value, c2.value));
    }

    return undefined;
  }

  joinCompletions(joinCondition, c1, c2) {
    if (!joinCondition.mightNotBeTrue()) return c1;
    if (!joinCondition.mightNotBeFalse()) return c2;
    (0, _invariant.default)(joinCondition instanceof _index2.AbstractValue);

    let c = this._collapseSimilarCompletions(joinCondition, c1, c2);

    if (c === undefined) {
      if (c1 instanceof _completions.AbruptCompletion && c2 instanceof _completions.AbruptCompletion) c = new _completions.JoinedAbruptCompletions(joinCondition, c1, c2);else {
        (0, _invariant.default)(c1 instanceof _completions.AbruptCompletion || c1 instanceof _completions.NormalCompletion);
        (0, _invariant.default)(c2 instanceof _completions.AbruptCompletion || c2 instanceof _completions.NormalCompletion);
        c = new _completions.JoinedNormalAndAbruptCompletions(joinCondition, c1, c2);
      }
    }

    return c;
  }

  joinEffects(joinCondition, e1, e2) {
    (0, _invariant.default)(e1.canBeApplied);
    (0, _invariant.default)(e2.canBeApplied);
    if (!joinCondition.mightNotBeTrue()) return e1;
    if (!joinCondition.mightNotBeFalse()) return e2;
    (0, _invariant.default)(joinCondition instanceof _index2.AbstractValue);
    let {
      result: c1,
      generator: generator1,
      modifiedBindings: modifiedBindings1,
      modifiedProperties: modifiedProperties1,
      createdObjects: createdObjects1
    } = e1;
    let {
      result: c2,
      generator: generator2,
      modifiedBindings: modifiedBindings2,
      modifiedProperties: modifiedProperties2,
      createdObjects: createdObjects2
    } = e2;
    let realm = joinCondition.$Realm;
    let c = this.joinCompletions(joinCondition, c1, c2);

    let [modifiedGenerator1, modifiedGenerator2, bindings] = this._joinBindings(joinCondition, generator1, modifiedBindings1, generator2, modifiedBindings2);

    let generator = joinGenerators(joinCondition, modifiedGenerator1, modifiedGenerator2);
    let properties = this.joinPropertyBindings(realm, joinCondition, modifiedProperties1, modifiedProperties2, createdObjects1, createdObjects2);
    let createdObjects = new Set();
    createdObjects1.forEach(o => {
      createdObjects.add(o);
    });
    createdObjects2.forEach(o => {
      createdObjects.add(o);
    });
    return new _realm.Effects(c, generator, bindings, properties, createdObjects);
  }

  joinValuesOfSelectedCompletions(selector, completion, keepInfeasiblePaths = false) {
    let realm = completion.value.$Realm;
    let bottom = realm.intrinsics.__bottomValue;

    if (completion instanceof _completions.JoinedAbruptCompletions || completion instanceof _completions.JoinedNormalAndAbruptCompletions) {
      let joinCondition = completion.joinCondition;
      let c = this.joinValuesOfSelectedCompletions(selector, completion.consequent);
      let a = this.joinValuesOfSelectedCompletions(selector, completion.alternate); // do some simplification

      if (c === bottom) {
        // joinCondition will never be true when this completion is reached
        if (a instanceof _index2.AbstractValue) {
          a = _singletons.Path.withInverseCondition(joinCondition, () => {
            (0, _invariant.default)(a instanceof _index2.AbstractValue);
            return realm.simplifyAndRefineAbstractValue(a);
          });
        }

        if (!keepInfeasiblePaths) return a;
      } else if (a === bottom) {
        // joinCondition will never be false when this completion is reached
        if (c instanceof _index2.AbstractValue) {
          c = _singletons.Path.withCondition(joinCondition, () => {
            (0, _invariant.default)(c instanceof _index2.AbstractValue);
            return realm.simplifyAndRefineAbstractValue(c);
          });
        }

        if (!keepInfeasiblePaths) return c;
      }

      let getAbstractValue = (v1, v2) => {
        if (v1 === bottom) v1 = realm.intrinsics.empty;
        if (v2 === bottom) v2 = realm.intrinsics.empty;
        return _index2.AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);
      };

      let jv = this.joinValues(realm, c, a, getAbstractValue);
      (0, _invariant.default)(jv instanceof _index2.Value);

      if (completion instanceof _completions.JoinedNormalAndAbruptCompletions && completion.composedWith !== undefined) {
        let composedWith = completion.composedWith;
        if (!composedWith.containsSelectedCompletion(selector)) return jv;
        let cjv = this.joinValuesOfSelectedCompletions(selector, composedWith);
        joinCondition = _index2.AbstractValue.createJoinConditionForSelectedCompletions(selector, composedWith);
        jv = this.joinValues(realm, jv, cjv, getAbstractValue);
        (0, _invariant.default)(jv instanceof _index2.Value);
      }

      return jv;
    }

    if (selector(completion)) return completion.value;
    return bottom;
  } // Creates a single map that joins together maps m1 and m2 using the given join
  // operator. If an entry is present in one map but not the other, the missing
  // entry is treated as if it were there and its value were undefined.


  joinMaps(m1, m2, join) {
    let m3 = new Map();
    m1.forEach((val1, key, map1) => {
      let val2 = m2.get(key);
      let val3 = join(key, val1, val2);
      m3.set(key, val3);
    });
    m2.forEach((val2, key, map2) => {
      if (!m1.has(key)) {
        m3.set(key, join(key, undefined, val2));
      }
    });
    return m3;
  } // Creates a single map that has an key, value pair for the union of the key
  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]
  // where the join is defined to be just m1[key] if m1[key] === m2[key] and
  // and abstract value with expression "joinCondition ? m1[key] : m2[key]" if not.


  _joinBindings(joinCondition, g1, m1, g2, m2) {
    let realm = joinCondition.$Realm;

    let getAbstractValue = (v1, v2) => {
      return _index2.AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2, undefined, true, true);
    };

    let rewritten1 = false;
    let rewritten2 = false;

    let leak = (b, g, v, rewritten) => {
      // just like to what happens in leakBinding, we are going to append a
      // binding-assignment generator entry; however, we play it safe and don't
      // mutate the generator; instead, we create a new one that wraps around the old one.
      if (!rewritten) {
        let h = new _generator.Generator(realm, "RewrittenToAppendBindingAssignments", g.pathConditions);
        if (!g.empty()) h.appendGenerator(g, "");
        g = h;
        rewritten = true;
      }

      if (v !== undefined && v !== realm.intrinsics.undefined) g.emitBindingAssignment(b, v);
      return [g, rewritten];
    };

    let join = (b, b1, b2) => {
      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;
      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;
      let v1 = b1 === undefined ? b.value : b1.value;
      let v2 = b2 === undefined ? b.value : b2.value; // ensure that if either none or both sides have leaked
      // note that if one side didn't have a binding entry yet, then there's nothing to actively leak

      if (!l1 && l2) [g1, rewritten1] = leak(b, g1, v1, rewritten1);else if (l1 && !l2) [g2, rewritten2] = leak(b, g2, v2, rewritten2);
      let hasLeaked = l1 || l2; // For leaked (and mutable) bindings, the actual value is no longer directly available.
      // In that case, we reset the value to undefined to prevent any use of the last known value.

      let value = hasLeaked ? undefined : this.joinValues(realm, v1, v2, getAbstractValue);
      (0, _invariant.default)(value === undefined || value instanceof _index2.Value);
      return {
        hasLeaked,
        value
      };
    };

    let joinedBindings = this.joinMaps(m1, m2, join);
    return [g1, g2, joinedBindings];
  } // If v1 is known and defined and v1 === v2 return v1,
  // otherwise return getAbstractValue(v1, v2)


  joinValues(realm, v1, v2, getAbstractValue) {
    if (Array.isArray(v1) || Array.isArray(v2)) {
      (0, _invariant.default)(v1 === undefined || Array.isArray(v1));
      (0, _invariant.default)(v2 === undefined || Array.isArray(v2));
      return joinArrays(realm, v1, v2, getAbstractValue);
    }

    (0, _invariant.default)(v1 === undefined || v1 instanceof _index2.Value);
    (0, _invariant.default)(v2 === undefined || v2 instanceof _index2.Value);

    if (v1 !== undefined && v2 !== undefined && !(v1 instanceof _index2.AbstractValue) && !(v2 instanceof _index2.AbstractValue) && (0, _index.StrictEqualityComparison)(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())) {
      return v1;
    } else {
      return getAbstractValue(v1, v2);
    }
  }

  joinPropertyBindings(realm, joinCondition, m1, m2, c1, c2) {
    let join = (b, d1, d2) => {
      // If the PropertyBinding object has been freshly allocated do not join
      if (d1 === undefined) {
        if (c2.has(b.object)) return d2; // no join

        if (b.descriptor !== undefined && m1.has(b)) {
          // property was deleted
          d1 = (0, _descriptors.cloneDescriptor)(b.descriptor.throwIfNotConcrete(realm));
          (0, _invariant.default)(d1 !== undefined);
          d1.value = realm.intrinsics.empty;
        } else {
          // no write to property
          d1 = b.descriptor; //Get value of property before the split
        }
      }

      if (d2 === undefined) {
        if (c1.has(b.object)) return d1; // no join

        if (b.descriptor !== undefined && m2.has(b)) {
          // property was deleted
          d2 = (0, _descriptors.cloneDescriptor)(b.descriptor.throwIfNotConcrete(realm));
          (0, _invariant.default)(d2 !== undefined);
          d2.value = realm.intrinsics.empty;
        } else {
          // no write to property
          d2 = b.descriptor; //Get value of property before the split
        }
      }

      return this.joinDescriptors(realm, joinCondition, d1, d2);
    };

    return this.joinMaps(m1, m2, join);
  }

  joinDescriptors(realm, joinCondition, d1, d2) {
    let getAbstractValue = (v1, v2) => {
      return _index2.AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);
    };

    let clone_with_abstract_value = d => {
      (0, _invariant.default)(d === d1 || d === d2);

      if (!(0, _index.IsDataDescriptor)(realm, d)) {
        return new _descriptors.AbstractJoinedDescriptor(joinCondition);
      }

      let dc;
      let dcValue;

      if (d instanceof _descriptors.InternalSlotDescriptor) {
        dc = new _descriptors.InternalSlotDescriptor(d.value);
        dcValue = dc.value;

        if (Array.isArray(dcValue)) {
          (0, _invariant.default)(dcValue.length > 0);
          let elem0 = dcValue[0];

          if (elem0 instanceof _index2.Value) {
            dc.value = dcValue.map(e => {
              return d === d1 ? getAbstractValue(e, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, e);
            });
          } else {
            dc.value = dcValue.map(e => {
              let {
                $Key: key1,
                $Value: val1
              } = e;
              let key3 = d === d1 ? getAbstractValue(key1, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, key1);
              let val3 = d === d1 ? getAbstractValue(val1, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, val1);
              return {
                $Key: key3,
                $Value: val3
              };
            });
          }
        }
      } else {
        dc = (0, _descriptors.cloneDescriptor)(d.throwIfNotConcrete(realm));
        (0, _invariant.default)(dc !== undefined);
        dcValue = dc.value;
      }

      (0, _invariant.default)(dcValue === undefined || dcValue instanceof _index2.Value);
      dc.value = d === d1 ? getAbstractValue(dcValue, realm.intrinsics.empty) : getAbstractValue(realm.intrinsics.empty, dcValue);
      return dc;
    };

    if (d1 === undefined) {
      if (d2 === undefined) return undefined; // d2 is a new property created in only one branch, join with empty

      let d3 = clone_with_abstract_value(d2);
      if (d3 instanceof _descriptors.AbstractJoinedDescriptor) d3.descriptor2 = d2;
      return d3;
    } else if (d2 === undefined) {
      (0, _invariant.default)(d1 !== undefined); // d1 is a new property created in only one branch, join with empty

      let d3 = clone_with_abstract_value(d1);
      if (d3 instanceof _descriptors.AbstractJoinedDescriptor) d3.descriptor1 = d1;
      return d3;
    } else {
      if (d1 instanceof _descriptors.PropertyDescriptor && d2 instanceof _descriptors.PropertyDescriptor && (0, _descriptors.equalDescriptors)(d1, d2) && (0, _index.IsDataDescriptor)(realm, d1)) {
        let dc = (0, _descriptors.cloneDescriptor)(d1);
        (0, _invariant.default)(dc !== undefined);
        let dcValue = this.joinValues(realm, d1.value, d2.value, getAbstractValue);
        (0, _invariant.default)(dcValue instanceof _index2.Value);
        dc.value = dcValue;
        return dc;
      }

      if (d1 instanceof _descriptors.InternalSlotDescriptor && d2 instanceof _descriptors.InternalSlotDescriptor) {
        return new _descriptors.InternalSlotDescriptor(this.joinValues(realm, d1.value, d2.value, getAbstractValue));
      }

      return new _descriptors.AbstractJoinedDescriptor(joinCondition, d1, d2);
    }
  }

  mapAndJoin(realm, values, joinConditionFactory, functionToMap) {
    (0, _invariant.default)(values.size > 1);
    let joinedEffects;

    for (let val of values) {
      let condition = joinConditionFactory(val);
      let effects = realm.evaluateForEffects(() => {
        (0, _invariant.default)(condition instanceof _index2.AbstractValue);
        return _singletons.Path.withCondition(condition, () => {
          return functionToMap(val);
        });
      }, undefined, "mapAndJoin");
      joinedEffects = joinedEffects === undefined ? effects : this.joinEffects(condition, effects, joinedEffects);
    }

    (0, _invariant.default)(joinedEffects !== undefined);
    realm.applyEffects(joinedEffects);
    return realm.returnOrThrowCompletion(joinedEffects.result);
  }

}

exports.JoinImplementation = JoinImplementation;
//# sourceMappingURL=join.js.map

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PathImplementation = exports.PathConditionsImplementation = void 0;

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _realm = __webpack_require__(7);

var _types = __webpack_require__(19);

var _index = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class PathConditionsImplementation extends _types.PathConditions {
  constructor(baseConditions) {
    super();
    this._assumedConditions = new Set();
    this._readonly = false;

    if (baseConditions !== undefined) {
      (0, _invariant.default)(baseConditions instanceof PathConditionsImplementation);
      this._baseConditions = baseConditions;
    }
  }

  add(c) {
    (0, _invariant.default)(!this._readonly);

    this._assumedConditions.add(c);

    this._failedImplications = undefined;
    this._failedNegativeImplications = undefined;
  }

  isReadOnly() {
    return this._readonly;
  } // this => val. A false value does not imply that !(this => val).


  implies(e, depth = 0) {
    if (!e.mightNotBeTrue()) return true;
    if (!e.mightNotBeFalse()) return false;
    (0, _invariant.default)(e instanceof _index.AbstractValue);
    if (this._assumedConditions.has(e)) return true;
    if (this._impliedConditions !== undefined && this._impliedConditions.has(e)) return true;
    if (this._impliedNegatives !== undefined && this._impliedNegatives.has(e)) return false;
    if (this._failedImplications !== undefined && this._failedImplications.has(e)) return false;
    if (depth > 10) return false;
    if (this._baseConditions !== undefined && this._baseConditions.implies(e, depth + 1)) return true;

    for (let assumedCondition of this._assumedConditions) {
      if (assumedCondition.implies(e, depth + 1)) return this.cacheImplicationSuccess(e);
    }

    if (e.kind === "||") {
      let [x, y] = e.args; // this => x || true, regardless of the value of x
      // this => true || y, regardless of the value of y

      if (!x.mightNotBeTrue() || !y.mightNotBeTrue()) return this.cacheImplicationSuccess(e); // this => false || y, if this => y

      if (!x.mightNotBeFalse() && this.implies(y, depth + 1)) return this.cacheImplicationSuccess(e); // this => x || false if this => x

      if (!y.mightNotBeFalse() && this.implies(x, depth + 1)) return this.cacheImplicationSuccess(e); // this => x || y if this => x

      if (this.implies(x, depth + 1)) return this.cacheImplicationSuccess(e); // this => x || y if this => y

      if (this.implies(y, depth + 1)) return this.cacheImplicationSuccess(e);
    }

    if (e.kind === "!==" || e.kind === "!=") {
      let [x, y] = e.args;

      if (x instanceof _index.AbstractValue) {
        // this => x !== null && x !== undefined, if this => x
        // this => x != null && x != undefined, if this => x
        if ((y instanceof _index.NullValue || y instanceof _index.UndefinedValue) && this.implies(x, depth + 1)) return this.cacheImplicationSuccess(e);
      } else {
        (0, _invariant.default)(y instanceof _index.AbstractValue); // otherwise e would have been simplied
        // this => null !== y && undefined !== y, if this => y
        // this => null != y && undefined != y, if this => y

        if ((x instanceof _index.NullValue || x instanceof _index.UndefinedValue) && this.implies(y, depth + 1)) return this.cacheImplicationSuccess(e);
      }
    }

    if (e.kind === "!") {
      let [x] = e.args;
      if (this.impliesNot(x, depth + 1)) return this.cacheImplicationSuccess(e);
    }

    if (this._failedImplications === undefined) this._failedImplications = new Set();

    this._failedImplications.add(e);

    return false;
  }

  cacheImplicationSuccess(e) {
    if (this._impliedConditions === undefined) this._impliedConditions = new Set();

    this._impliedConditions.add(e);

    return true;
  } // this => !val. A false value does not imply that !(this => !val).


  impliesNot(e, depth = 0) {
    if (!e.mightNotBeTrue()) return false;
    if (!e.mightNotBeFalse()) return true;
    (0, _invariant.default)(e instanceof _index.AbstractValue);
    if (this._assumedConditions.has(e)) return false;
    if (this._impliedConditions !== undefined && this._impliedConditions.has(e)) return false;
    if (this._impliedNegatives !== undefined && this._impliedNegatives.has(e)) return true;
    if (this._failedNegativeImplications !== undefined && this._failedNegativeImplications.has(e)) return false;
    if (depth > 10) return false;
    if (this._baseConditions !== undefined && this._baseConditions.impliesNot(e, depth + 1)) return true;

    for (let assumedCondition of this._assumedConditions) {
      if (assumedCondition.impliesNot(e, depth + 1)) return this.cacheNegativeImplicationSuccess(e);
    }

    if (e.kind === "&&") {
      let [x, y] = e.args; // this => !(false && y) regardless of the value of y
      // this => !(x && false) regardless of the value of x

      if (!x.mightNotBeFalse() || !y.mightNotBeFalse()) return this.cacheNegativeImplicationSuccess(e); // this => !(true && y), if this => !y

      if (!x.mightNotBeTrue() && this.impliesNot(y, depth + 1)) return this.cacheNegativeImplicationSuccess(e); // this => !(x && true) if this => !x

      if (!y.mightNotBeTrue() && this.impliesNot(x, depth + 1)) return this.cacheNegativeImplicationSuccess(e); // this => !(x && y) if this => !x

      if (this.impliesNot(x, depth + 1)) return this.cacheNegativeImplicationSuccess(e); // this => !(x && y) if this => !y

      if (this.impliesNot(y, depth + 1)) return this.cacheNegativeImplicationSuccess(e);
    }

    if (e.kind === "===" || e.kind === "==") {
      let [x, y] = e.args;

      if (x instanceof _index.AbstractValue) {
        // this => !(x === null) && !(x === undefined), if this => x
        // this => !(x == null) && !(x == undefined), if this => x
        if ((y instanceof _index.NullValue || y instanceof _index.UndefinedValue) && this.implies(x, depth + 1)) return this.cacheNegativeImplicationSuccess(e);
      } else {
        (0, _invariant.default)(y instanceof _index.AbstractValue); // otherwise e would have been simplied
        // this => !(null === y) && !(undefined === y), if this => y
        // this => !(null == y) && !(undefined == y), if this => y

        if ((x instanceof _index.NullValue || x instanceof _index.UndefinedValue) && this.implies(y, depth + 1)) return this.cacheNegativeImplicationSuccess(e);
      }
    }

    if (e.kind === "!") {
      let [x] = e.args;
      if (this.implies(x, depth + 1)) return this.cacheNegativeImplicationSuccess(e);
    }

    if (this._failedNegativeImplications === undefined) this._failedNegativeImplications = new Set();

    this._failedNegativeImplications.add(e);

    return false;
  }

  cacheNegativeImplicationSuccess(e) {
    if (this._impliedNegatives === undefined) this._impliedNegatives = new Set();

    this._impliedNegatives.add(e);

    return true;
  }

  isEmpty() {
    return this._assumedConditions.size === 0;
  }

  getLength() {
    return this._assumedConditions.size;
  }

  getAssumedConditions() {
    return this._assumedConditions;
  } // Refinement may temporarily make a target non-read-only, but marks the target as read-only at the end.


  refineBaseConditons(realm, totalRefinements = 0, refinementTarget = this) {
    try {
      if (realm.abstractValueImpliesMax > 0) return;
      let total = totalRefinements;

      let refine = condition => {
        let refinedCondition = realm.simplifyAndRefineAbstractCondition(condition);

        if (refinedCondition !== condition) {
          if (!refinedCondition.mightNotBeFalse()) throw new _errors.InfeasiblePathError();

          if (refinedCondition instanceof _index.AbstractValue) {
            refinementTarget._readonly = false;
            refinementTarget.add(refinedCondition);
          }
        }
      };

      if (this._baseConditions !== undefined) {
        let savedBaseConditions = this._baseConditions;

        try {
          this._baseConditions = undefined;

          for (let assumedCondition of savedBaseConditions._assumedConditions) {
            if (assumedCondition.kind === "||") {
              if (++total > 4) break;
              refine(assumedCondition);
            }
          }
        } finally {
          this._baseConditions = savedBaseConditions;
        }

        savedBaseConditions.refineBaseConditons(realm, total, refinementTarget);
      }
    } finally {
      refinementTarget._readonly = true;
    }
  }

}

exports.PathConditionsImplementation = PathConditionsImplementation;

class PathImplementation {
  // this => val. A false value does not imply that !(this => val).
  implies(condition, depth = 0) {
    if (!condition.mightNotBeTrue()) return true; // any path implies true

    if (!condition.mightNotBeFalse()) return false; // no path condition is false

    (0, _invariant.default)(condition instanceof _index.AbstractValue);
    return condition.$Realm.pathConditions.implies(condition, depth);
  } // this => !val. A false value does not imply that !(this => !val).


  impliesNot(condition, depth = 0) {
    if (!condition.mightNotBeFalse()) return true; // any path implies !false

    if (!condition.mightNotBeTrue()) return false; // no path condition is false, so none can imply !true

    (0, _invariant.default)(condition instanceof _index.AbstractValue);
    return condition.$Realm.pathConditions.impliesNot(condition, depth);
  }

  withCondition(condition, evaluate) {
    let realm = condition.$Realm;

    if (!condition.mightNotBeFalse()) {
      if (realm.impliesCounterOverflowed) throw new _errors.InfeasiblePathError();
      (0, _invariant.default)(false, "assuming that false equals true is asking for trouble");
    }

    let savedPath = realm.pathConditions;
    realm.pathConditions = new PathConditionsImplementation(savedPath);

    try {
      pushPathCondition(condition);
      realm.pathConditions.refineBaseConditons(realm);
      return evaluate();
    } catch (e) {
      if (e instanceof _errors.InfeasiblePathError) {
        // if condition is true, one of the saved path conditions must be false
        // since we have to assume that those conditions are true we now know that on this path, condition is false
        realm.pathConditions = savedPath;
        pushInversePathCondition(condition);
      }

      throw e;
    } finally {
      realm.pathConditions = savedPath;
    }
  }

  withInverseCondition(condition, evaluate) {
    let realm = condition.$Realm;

    if (!condition.mightNotBeTrue()) {
      if (realm.impliesCounterOverflowed) throw new _errors.InfeasiblePathError();
      (0, _invariant.default)(false, "assuming that false equals true is asking for trouble");
    }

    let savedPath = realm.pathConditions;
    realm.pathConditions = new PathConditionsImplementation(savedPath);

    try {
      pushInversePathCondition(condition);
      realm.pathConditions.refineBaseConditons(realm);
      return evaluate();
    } catch (e) {
      if (e instanceof _errors.InfeasiblePathError) {
        // if condition is false, one of the saved path conditions must be false
        // since we have to assume that those conditions are true we now know that on this path, condition is true
        realm.pathConditions = savedPath;
        pushPathCondition(condition);
      }

      throw e;
    } finally {
      realm.pathConditions = savedPath;
    }
  }

  pushAndRefine(condition) {
    let realm = condition.$Realm;
    let savedPath = realm.pathConditions;
    realm.pathConditions = new PathConditionsImplementation(savedPath);
    pushPathCondition(condition);
    realm.pathConditions.refineBaseConditons(realm);
  }

  pushInverseAndRefine(condition) {
    let realm = condition.$Realm;
    let savedPath = realm.pathConditions;
    realm.pathConditions = new PathConditionsImplementation(savedPath);
    pushInversePathCondition(condition);
    realm.pathConditions.refineBaseConditons(realm);
  }

} // A path condition is an abstract value that must be true in this particular code path, so we want to assume as much


exports.PathImplementation = PathImplementation;

function pushPathCondition(condition) {
  let realm = condition.$Realm;
  if (realm.pathConditions.isReadOnly()) realm.pathConditions = new PathConditionsImplementation(realm.pathConditions);

  if (!condition.mightNotBeFalse()) {
    if (realm.impliesCounterOverflowed) throw new _errors.InfeasiblePathError();
    (0, _invariant.default)(false, "assuming that false equals true is asking for trouble");
  }

  if (condition instanceof _index.ConcreteValue) return;
  if (!condition.mightNotBeTrue()) return;
  (0, _invariant.default)(condition instanceof _index.AbstractValue);

  if (condition.kind === "&&") {
    let left = condition.args[0];
    let right = condition.args[1];
    (0, _invariant.default)(left instanceof _index.AbstractValue); // it is a mistake to create an abstract value when concrete value will do

    pushPathCondition(left);
    pushPathCondition(right);
  } else if (condition.kind === "===") {
    let [left, right] = condition.args;
    if (right instanceof _index.AbstractValue && right.kind === "conditional") [left, right] === [right, left];

    if (left instanceof _index.AbstractValue && left.kind === "conditional") {
      let [cond, x, y] = left.args;

      if (right instanceof _index.ConcreteValue && x instanceof _index.ConcreteValue && y instanceof _index.ConcreteValue) {
        if (right.equals(x) && !right.equals(y)) {
          pushPathCondition(cond);
        } else if (!right.equals(x) && right.equals(y)) {
          pushInversePathCondition(cond);
        }
      }
    }

    realm.pathConditions.add(condition);
  } else {
    if (condition.kind === "!=" || condition.kind === "==") {
      let left = condition.args[0];
      let right = condition.args[1];
      if (left instanceof _index.ConcreteValue && right instanceof _index.AbstractValue) [left, right] = [right, left];

      if (left instanceof _index.AbstractValue && (right instanceof _index.UndefinedValue || right instanceof _index.NullValue)) {
        if (condition.kind === "!=") {
          // x != null => x!==null && x!==undefined
          pushPathCondition(left);

          let leftNeNull = _index.AbstractValue.createFromBinaryOp(realm, "!==", left, realm.intrinsics.null);

          let leftNeUndefined = _index.AbstractValue.createFromBinaryOp(realm, "!==", left, realm.intrinsics.undefined);

          pushPathCondition(leftNeNull);
          pushPathCondition(leftNeUndefined);
        } else if (condition.kind === "==") {
          // x == null => x===null || x===undefined
          pushInversePathCondition(left);

          let leftEqNull = _index.AbstractValue.createFromBinaryOp(realm, "===", left, realm.intrinsics.null);

          let leftEqUndefined = _index.AbstractValue.createFromBinaryOp(realm, "===", left, realm.intrinsics.undefined);

          let c;
          if (!leftEqNull.mightNotBeFalse()) c = leftEqUndefined;else if (!leftEqUndefined.mightNotBeFalse()) c = leftEqNull;else c = _index.AbstractValue.createFromLogicalOp(realm, "||", leftEqNull, leftEqUndefined);
          pushPathCondition(c);
        }

        return;
      }
    }

    realm.pathConditions.add(condition);
  }
} // An inverse path condition is an abstract value that must be false in this particular code path, so we want to assume as much


function pushInversePathCondition(condition) {
  let realm = condition.$Realm;
  if (realm.pathConditions.isReadOnly()) realm.pathConditions = new PathConditionsImplementation(realm.pathConditions);

  if (!condition.mightNotBeTrue()) {
    if (realm.impliesCounterOverflowed) throw new _errors.InfeasiblePathError();
    (0, _invariant.default)(false, "assuming that false equals true is asking for trouble");
  }

  if (condition instanceof _index.ConcreteValue) return;
  (0, _invariant.default)(condition instanceof _index.AbstractValue);

  if (condition.kind === "||") {
    let left = condition.args[0];
    let right = condition.args[1];
    (0, _invariant.default)(left instanceof _index.AbstractValue); // it is a mistake to create an abstract value when concrete value will do

    pushInversePathCondition(left);
    if (right instanceof _index.AbstractValue) right = realm.simplifyAndRefineAbstractCondition(right);
    if (right.mightNotBeTrue()) pushInversePathCondition(right);
  } else {
    if (condition.kind === "!=" || condition.kind === "==") {
      let left = condition.args[0];
      let right = condition.args[1];
      if (left instanceof _index.ConcreteValue && right instanceof _index.AbstractValue) [left, right] = [right, left];

      if (left instanceof _index.AbstractValue && (right instanceof _index.UndefinedValue || right instanceof _index.NullValue)) {
        let op = condition.kind === "!=" ? "===" : "!==";
        if (op === "!==") pushPathCondition(left);else pushInversePathCondition(left);

        let leftEqNull = _index.AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);

        if (leftEqNull.mightNotBeFalse()) pushPathCondition(leftEqNull);

        let leftEqUndefined = _index.AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);

        if (leftEqUndefined.mightNotBeFalse()) pushPathCondition(leftEqUndefined);
        return;
      }
    }

    let inverseCondition = _index.AbstractValue.createFromUnaryOp(realm, "!", condition, false, undefined, true, true);

    pushPathCondition(inverseCondition);

    if (inverseCondition instanceof _index.AbstractValue) {
      let simplifiedInverseCondition = realm.simplifyAndRefineAbstractCondition(inverseCondition);
      if (!simplifiedInverseCondition.equals(inverseCondition)) pushPathCondition(simplifiedInverseCondition);
    }
  }
}
//# sourceMappingURL=paths.js.map

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertiesImplementation = void 0;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _ObjectExpression = __webpack_require__(275);

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index2 = __webpack_require__(232);

var _types = __webpack_require__(21);

var _singletons = __webpack_require__(236);

var _strict = _interopRequireDefault(__webpack_require__(452));

var _generator = __webpack_require__(237);

var _index3 = __webpack_require__(15);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function StringKey(key) {
  if (key instanceof _index.StringValue) key = key.value;

  if (typeof key !== "string") {
    // The generator currently only supports string keys.
    throw new _errors.FatalError();
  }

  return key;
}

function InternalDescriptorPropertyToValue(realm, value) {
  if (value === undefined) return realm.intrinsics.undefined;
  if (typeof value === "boolean") return new _index.BooleanValue(realm, value);
  (0, _invariant.default)(value instanceof _index.Value);
  return value;
}

function InternalGetPropertiesKey(P) {
  if (typeof P === "string") {
    return P;
  } else if (P instanceof _index.StringValue) {
    return P.value;
  } else if (P instanceof _index.SymbolValue) {
    return P;
  } // otherwise, undefined

}

function InternalGetPropertiesMap(O, P) {
  if (typeof P === "string" || P instanceof _index.StringValue) {
    return O.properties;
  } else if (P instanceof _index.SymbolValue) {
    return O.symbols;
  } else {
    (0, _invariant.default)(false);
  }
}

function InternalSetProperty(realm, O, P, desc) {
  let map = InternalGetPropertiesMap(O, P);
  let key = InternalGetPropertiesKey(P);
  let propertyBinding = map.get(key);

  if (propertyBinding === undefined) {
    propertyBinding = {
      descriptor: undefined,
      object: O,
      key: key
    };
    map.set(key, propertyBinding);
  }

  realm.recordModifiedProperty(propertyBinding);
  propertyBinding.descriptor = desc;
}

function InternalUpdatedProperty(realm, O, P, oldDesc) {
  let generator = realm.generator;
  if (!generator) return;
  if (!O.isIntrinsic() && O.temporalAlias === undefined) return;
  if (P instanceof _index.SymbolValue) return;
  if (P instanceof _index.StringValue) P = P.value;
  (0, _invariant.default)(!O.mightBeLeakedObject()); // leaked objects are never updated

  (0, _invariant.default)(!O.mightBeFinalObject()); // final objects are never updated

  (0, _invariant.default)(typeof P === "string");
  let propertyBinding = InternalGetPropertiesMap(O, P).get(P);
  (0, _invariant.default)(propertyBinding !== undefined); // The callers ensure this

  let desc = propertyBinding.descriptor;

  if (desc === undefined) {
    // The property is being deleted
    if (O === realm.$GlobalObject) {
      generator.emitGlobalDelete(P);
    } else {
      generator.emitPropertyDelete(O, P);
    }
  } else {
    desc = desc.throwIfNotConcrete(realm);

    if (oldDesc === undefined) {
      // The property is being created
      if (O === realm.$GlobalObject) {
        if ((0, _index2.IsDataDescriptor)(realm, desc)) {
          let descValue = desc.value || realm.intrinsics.undefined;

          if ((0, _types.isValidIdentifier)(P) && !desc.configurable && desc.enumerable && desc.writable) {
            generator.emitGlobalDeclaration(P, descValue);
          } else if (desc.configurable && desc.enumerable && desc.writable) {
            generator.emitGlobalAssignment(P, descValue);
          } else {
            generator.emitDefineProperty(O, P, desc);
          }
        } else {
          generator.emitDefineProperty(O, P, desc);
        }
      } else {
        if ((0, _index2.IsDataDescriptor)(realm, desc) && desc.configurable && desc.enumerable && desc.writable) {
          let descValue = desc.value || realm.intrinsics.undefined;
          generator.emitPropertyAssignment(O, P, descValue);
        } else {
          generator.emitDefineProperty(O, P, desc);
        }
      }
    } else {
      (0, _invariant.default)(oldDesc instanceof _descriptors.PropertyDescriptor); // The property is being modified

      if ((0, _descriptors.equalDescriptors)(desc, oldDesc)) {
        (0, _invariant.default)((0, _index2.IsDataDescriptor)(realm, desc));
        let descValue = desc.value || realm.intrinsics.undefined; // only the value is being modified

        if (O === realm.$GlobalObject) {
          generator.emitGlobalAssignment(P, descValue);
        } else {
          generator.emitPropertyAssignment(O, P, descValue);
        }
      } else {
        generator.emitDefineProperty(O, P, desc,
        /*isDescChanged*/
        true);
      }
    }
  }
}

function leakDescriptor(realm, desc) {
  if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
    if (desc.descriptor1) {
      leakDescriptor(realm, desc.descriptor1);
    }

    if (desc.descriptor2) {
      leakDescriptor(realm, desc.descriptor2);
    }
  }

  (0, _invariant.default)(desc instanceof _descriptors.PropertyDescriptor);

  if (desc.value) {
    if (desc.value instanceof _index.Value) _singletons.Leak.value(realm, desc.value);else if (desc.value !== undefined) {
      for (let val of desc.value) _singletons.Leak.value(realm, val);
    }
  }

  if (desc.get) {
    _singletons.Leak.value(realm, desc.get);
  }

  if (desc.set) {
    _singletons.Leak.value(realm, desc.set);
  }
} // Determines if an object with parent O may create its own property P.


function parentPermitsChildPropertyCreation(realm, O, P) {
  if (O.isSimpleObject()) {
    // Simple object always allow property creation since there are no setters.
    // Object.prototype is considered simple even though __proto__ is a setter.
    // TODO: That is probably the incorrect assumption but that is implied everywhere.
    return true;
  }

  let ownDesc = O.$GetOwnProperty(P);

  if (!ownDesc || ownDesc.mightHaveBeenDeleted()) {
    // O might not object, so first ask its parent
    let parent = O.$GetPrototypeOf();

    if (!(parent instanceof _index.NullValue)) {
      parent = parent.throwIfNotConcreteObject(); //TODO #1016: deal with abstract parents

      if (!parentPermitsChildPropertyCreation(realm, parent, P)) return false;
    } // Parent is OK, so if O does not object return true


    if (!ownDesc) return true; // O has no opinion of its ownDesc
  }

  (0, _invariant.default)(ownDesc !== undefined); // O might have a property P and so might object

  if ((0, _index2.IsDataDescriptor)(realm, ownDesc)) {
    if (ownDesc.writable) {
      // The grand parent does not object so it is OK that parent does not have P
      // If parent does have P, it is also OK because it is a writable data property
      return true;
    }
  } // If parent does not have property P, this is too pessimistic, but that is
  // the caller's problem.


  return false;
}

function ensureIsNotFinal(realm, O, P) {
  if (O.mightNotBeFinalObject()) {
    return;
  } // We can't continue because this object is already in its final state


  if (realm.instantRender.enabled) {
    realm.instantRenderBailout("Object mutations that require materialization are currently not supported by InstantRender", realm.currentLocation);
  } else {
    let error = new _errors.CompilerDiagnostic("Mutating a final object, or an object with unknown properties, after some of those " + "properties have already been used, is not supported.", realm.currentLocation, "PP0026", "FatalError");
    realm.handleError(error);
    throw new _errors.FatalError();
  }
}

function isWidenedValue(v) {
  if (!(v instanceof _index.AbstractValue)) return false;
  if (v.kind === "widened" || v.kind === "widened property") return true;

  for (let a of v.args) {
    if (isWidenedValue(a)) return true;
  }

  return false;
}

class PropertiesImplementation {
  // ECMA262 9.1.9.1
  OrdinarySet(realm, O, P, V, Receiver) {
    ensureIsNotFinal(realm, O, P);

    if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {
      // Leaking is transitive, hence writing a value to a leaked object leaks the value
      _singletons.Leak.value(realm, V); // The receiver might leak to a getter so if it's not already leaked, we need to leak it.


      _singletons.Leak.value(realm, Receiver);

      if (realm.generator !== undefined) {
        realm.generator.emitPropertyAssignment(Receiver, StringKey(P), V);
      }

      return true;
    }

    let weakDeletion = V.mightHaveBeenDeleted(); // 1. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected property key"); // 2. Let ownDesc be ? O.[[GetOwnProperty]](P).

    let ownDesc = O.$GetOwnProperty(P); // 3. If ownDesc is undefined (or might be), then

    if (!ownDesc || ownDesc.mightHaveBeenDeleted()) {
      // a. Let parent be ? O.[[GetPrototypeOf]]().
      let parent = O.$GetPrototypeOf(); // b. If parent is not null, then

      if (!(parent instanceof _index.NullValue)) {
        parent = parent.throwIfNotConcreteObject(); //TODO #1016: deal with abstract parents

        if (!ownDesc) {
          // i. Return ? parent.[[Set]](P, V, Receiver).
          return parent.$Set(P, V, Receiver);
        } // But since we don't know if O has its own property P, the parent might
        // actually have a say. Give up, unless the parent would be OK with it.


        if (!parentPermitsChildPropertyCreation(realm, parent, P)) {
          // TODO: Join the effects depending on if the property was deleted or not.
          let error = new _errors.CompilerDiagnostic("assignment might or might not invoke a setter", realm.currentLocation, "PP0043", "RecoverableError");

          if (realm.handleError(error) !== "Recover") {
            throw new _errors.FatalError();
          } // If we recover, we assume that the parent would've been fine creating the property.

        } // Since the parent is OK with us creating a local property for O
        // we can carry on as if there were no parent.

      } // i. Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.


      if (!ownDesc) ownDesc = new _descriptors.PropertyDescriptor({
        value: realm.intrinsics.undefined,
        writable: true,
        enumerable: true,
        configurable: true
      });
    } // joined descriptors need special treatment


    if (ownDesc instanceof _descriptors.AbstractJoinedDescriptor) {
      let joinCondition = ownDesc.joinCondition;
      let descriptor2 = ownDesc.descriptor2;
      ownDesc = ownDesc.descriptor1;

      let e1 = _singletons.Path.withCondition(joinCondition, () => {
        return ownDesc !== undefined ? realm.evaluateForEffects(() => new _index.BooleanValue(realm, OrdinarySetHelper()), undefined, "OrdinarySet/1") : (0, _realm.construct_empty_effects)(realm);
      });

      let {
        result: result1,
        generator: generator1,
        modifiedBindings: modifiedBindings1,
        modifiedProperties: modifiedProperties1,
        createdObjects: createdObjects1
      } = e1;
      ownDesc = descriptor2;

      let e2 = _singletons.Path.withInverseCondition(joinCondition, () => {
        return ownDesc !== undefined ? realm.evaluateForEffects(() => new _index.BooleanValue(realm, OrdinarySetHelper()), undefined, "OrdinarySet/2") : (0, _realm.construct_empty_effects)(realm);
      });

      let {
        result: result2,
        generator: generator2,
        modifiedBindings: modifiedBindings2,
        modifiedProperties: modifiedProperties2,
        createdObjects: createdObjects2
      } = e2; // Join the effects, creating an abstract view of what happened, regardless
      // of the actual value of ownDesc.joinCondition.

      let joinedEffects = _singletons.Join.joinEffects(joinCondition, new _realm.Effects(result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1), new _realm.Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2));

      realm.applyEffects(joinedEffects);
      return _singletons.To.ToBooleanPartial(realm, realm.returnOrThrowCompletion(joinedEffects.result));
    }

    return OrdinarySetHelper();

    function OrdinarySetHelper() {
      (0, _invariant.default)(ownDesc !== undefined); // 4. If IsDataDescriptor(ownDesc) is true, then

      if ((0, _index2.IsDataDescriptor)(realm, ownDesc)) {
        // a. If ownDesc.[[Writable]] is false, return false.
        if (!ownDesc.writable && !weakDeletion) {
          // The write will fail if the property actually exists
          if (ownDesc.value && ownDesc.value.mightHaveBeenDeleted()) {
            // But maybe it does not and thus would succeed.
            // Since we don't know what will happen, give up for now.
            // TODO: Join the effects depending on if the property was deleted or not.
            let error = new _errors.CompilerDiagnostic("assignment might or might not invoke a setter", realm.currentLocation, "PP0043", "RecoverableError");

            if (realm.handleError(error) !== "Recover") {
              throw new _errors.FatalError();
            } // If we recover we assume that the property was there.

          }

          return false;
        } // b. If Type(Receiver) is not Object, return false.


        if (!Receiver.mightBeObject()) return false;
        (0, _invariant.default)(Receiver instanceof _index.ObjectValue || Receiver instanceof _index.AbstractObjectValue); // c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).

        let existingDescriptor = Receiver.$GetOwnProperty(P);

        if (existingDescriptor instanceof _descriptors.AbstractJoinedDescriptor) {
          if (existingDescriptor.descriptor1 === ownDesc) existingDescriptor = ownDesc;else if (existingDescriptor.descriptor2 === ownDesc) existingDescriptor = ownDesc;
        }

        let existingDescValue = !existingDescriptor ? realm.intrinsics.undefined : existingDescriptor.value === undefined ? realm.intrinsics.undefined : existingDescriptor.value;
        (0, _invariant.default)(existingDescValue instanceof _index.Value); // d. If existingDescriptor is not undefined, then

        if (existingDescriptor !== undefined) {
          // i. If IsAccessorDescriptor(existingDescriptor) is true, return false.
          if ((0, _index2.IsAccessorDescriptor)(realm, existingDescriptor)) {
            (0, _invariant.default)(!existingDescValue.mightHaveBeenDeleted(), "should not fail until weak deletes of accessors are suppported");
            return false;
          } // ii. If existingDescriptor.[[Writable]] is false, return false.


          if (!existingDescriptor.writable && !(weakDeletion && existingDescriptor.configurable)) {
            // If we are not sure the receiver actually has a property P we can't just return false here.
            if (existingDescValue.mightHaveBeenDeleted()) {
              (0, _invariant.default)(existingDescValue instanceof _index.AbstractValue);

              _index.AbstractValue.reportIntrospectionError(existingDescValue);

              throw new _errors.FatalError();
            }

            return false;
          } // iii. Let valueDesc be the PropertyDescriptor{[[Value]]: V}.


          let valueDesc = new _descriptors.PropertyDescriptor({
            value: V
          }); // iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).

          if (weakDeletion || existingDescValue.mightHaveBeenDeleted()) {
            // At this point we are not sure that Receiver actually has a property P.
            // If, however, it has -> P. If, however, it has, we are sure that its a
            // data property, and that redefining the property with valueDesc will not
            // change the attributes of the property, so we can reuse the existing
            // descriptor.
            valueDesc = existingDescriptor;
            valueDesc.throwIfNotConcrete(realm).value = V;
          }

          return Receiver.$DefineOwnProperty(P, valueDesc);
        } else {
          // e. Else Receiver does not currently have a property P,
          // i. Return ? CreateDataProperty(Receiver, P, V).
          return _singletons.Create.CreateDataProperty(realm, Receiver, P, V);
        }
      } // 5. Assert: IsAccessorDescriptor(ownDesc) is true.


      (0, _invariant.default)((0, _index2.IsAccessorDescriptor)(realm, ownDesc), "expected accessor"); // 6. Let setter be ownDesc.[[Set]].

      let setter = ownDesc.set; // 7. If setter is undefined, return false.

      if (!setter || setter instanceof _index.UndefinedValue) return false; // 8. Perform ? Call(setter, Receiver,  V ).

      (0, _index2.Call)(realm, setter.throwIfNotConcrete(), Receiver, [V]); // 9. Return true.

      return true;
    }
  }

  OrdinarySetPartial(realm, O, P, V, Receiver) {
    if (!(P instanceof _index.AbstractValue)) return O.$Set(P, V, Receiver);
    let pIsLoopVar = isWidenedValue(P);

    let pIsNumeric = _index.Value.isTypeCompatibleWith(P.getType(), _index.NumberValue); // A string coercion might have side-effects.
    // TODO #1682: We assume that simple objects mean that they don't have a
    // side-effectful valueOf and toString but that's not enforced.


    if (P.mightNotBeString() && P.mightNotBeNumber() && !P.isSimpleObject()) {
      if (realm.isInPureScope()) {
        // If we're in pure scope, we can leak the key and keep going.
        // Coercion can only have effects on anything reachable from the key.
        _singletons.Leak.value(realm, P);
      } else {
        let error = new _errors.CompilerDiagnostic("property key might not have a well behaved toString or be a symbol", realm.currentLocation, "PP0002", "RecoverableError");

        if (realm.handleError(error) !== "Recover") {
          throw new _errors.FatalError();
        }
      }
    } // We assume that simple objects have no getter/setter properties and
    // that all properties are writable.


    if (!O.isSimpleObject()) {
      if (realm.isInPureScope()) {
        // If we're in pure scope, we can leak the object and leave an
        // assignment in place.
        _singletons.Leak.value(realm, Receiver); // We also need to leak the value since it might leak to a setter.


        _singletons.Leak.value(realm, V);

        realm.evaluateWithPossibleThrowCompletion(() => {
          let generator = realm.generator;
          (0, _invariant.default)(generator);
          (0, _invariant.default)(P instanceof _index.AbstractValue);
          generator.emitPropertyAssignment(Receiver, P, V);
          return realm.intrinsics.undefined;
        }, _index3.TypesDomain.topVal, _index3.ValuesDomain.topVal); // The emitted assignment might throw at runtime but if it does, that
        // is handled by evaluateWithPossibleThrowCompletion. Anything that
        // happens after this, can assume we didn't throw and therefore,
        // we return true here.

        return true;
      } else {
        let error = new _errors.CompilerDiagnostic("unknown property access might need to invoke a setter", realm.currentLocation, "PP0030", "RecoverableError");

        if (realm.handleError(error) !== "Recover") {
          throw new _errors.FatalError();
        }
      }
    } // We should never consult the prototype chain for unknown properties.
    // If it was simple, it would've been an assignment to the receiver.
    // The only case the Receiver isn't this, if this was a ToObject
    // coercion from a PrimitiveValue.


    let abstractOverO = false;

    if (Receiver instanceof _index.AbstractObjectValue && !Receiver.values.isTop()) {
      let elements = Receiver.values.getElements();
      (0, _invariant.default)(elements);

      if (elements.has(O)) {
        abstractOverO = true;
      }
    }

    (0, _invariant.default)(O === Receiver || (0, _index2.HasCompatibleType)(Receiver, _index.PrimitiveValue) || abstractOverO);
    P = _singletons.To.ToStringAbstract(realm, P);

    function createTemplate(propName) {
      return _index.AbstractValue.createFromBinaryOp(realm, "===", propName, new _index.StringValue(realm, ""), undefined, "template for property name condition");
    }

    let prop;

    if (O.unknownProperty === undefined) {
      prop = {
        descriptor: undefined,
        object: O,
        key: P
      };
      O.unknownProperty = prop;
    } else {
      prop = O.unknownProperty;
    }

    realm.recordModifiedProperty(prop);
    let desc = prop.descriptor;

    if (desc === undefined) {
      let newVal = V;

      if (!(V instanceof _index.UndefinedValue) && !isWidenedValue(P)) {
        // join V with sentinel, using a property name test as the condition
        let cond = createTemplate(P);

        let sentinel = _index.AbstractValue.createFromType(realm, _index.Value, "template for prototype member expression", [Receiver, P]);

        newVal = _index.AbstractValue.createFromConditionalOp(realm, cond, V, sentinel);
      }

      prop.descriptor = new _descriptors.PropertyDescriptor({
        writable: true,
        enumerable: true,
        configurable: true,
        value: newVal
      });
    } else {
      (0, _invariant.default)(desc instanceof _descriptors.PropertyDescriptor, "unknown properties are only created with Set and have equal descriptors"); // join V with current value of O.unknownProperty. I.e. weak update.

      let oldVal = desc.value;
      (0, _invariant.default)(oldVal);
      let newVal = oldVal;

      if (!(V instanceof _index.UndefinedValue)) {
        if (isWidenedValue(P)) {
          newVal = V; // It will be widened later on
        } else {
          let cond = createTemplate(P);
          newVal = _index.AbstractValue.createFromConditionalOp(realm, cond, V, oldVal);
        }
      }

      desc.value = newVal;
    } // Since we don't know the name of the property we are writing to, we also need
    // to perform weak updates of all of the known properties.
    // First clear out O.unknownProperty so that helper routines know its OK to update the properties


    let savedUnknownProperty = O.unknownProperty;
    O.unknownProperty = undefined;

    for (let [key, propertyBinding] of O.properties) {
      if (pIsLoopVar && pIsNumeric) {
        // Delete numeric properties and don't do weak updates on other properties.
        if (key !== +key + "") continue;
        O.properties.delete(key);
        continue;
      }

      let oldVal = realm.intrinsics.empty;

      if (propertyBinding.descriptor) {
        let d = propertyBinding.descriptor.throwIfNotConcrete(realm);

        if (d.value) {
          oldVal = d.value;
        }
      }

      let cond = _index.AbstractValue.createFromBinaryOp(realm, "===", P, new _index.StringValue(realm, key));

      let newVal = _index.AbstractValue.createFromConditionalOp(realm, cond, V, oldVal);

      this.OrdinarySet(realm, O, key, newVal, Receiver);
    }

    O.unknownProperty = savedUnknownProperty;
    return true;
  } // ECMA262 6.2.4.4


  FromPropertyDescriptor(realm, Desc) {
    // 1. If Desc is undefined, return undefined.
    if (!Desc) return realm.intrinsics.undefined;

    if (Desc instanceof _descriptors.AbstractJoinedDescriptor) {
      return _index.AbstractValue.createFromConditionalOp(realm, Desc.joinCondition, this.FromPropertyDescriptor(realm, Desc.descriptor1), this.FromPropertyDescriptor(realm, Desc.descriptor2));
    }

    (0, _invariant.default)(Desc instanceof _descriptors.PropertyDescriptor); // 2. Let obj be ObjectCreate(%ObjectPrototype%).

    let obj = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 3. Assert: obj is an extensible ordinary object with no own properties.


    (0, _invariant.default)(obj.getExtensible(), "expected an extensible object");
    (0, _invariant.default)(!obj.properties.size, "expected an object with no own properties"); // 4. If Desc has a [[Value]] field, then

    let success = true;

    if (Desc.value !== undefined) {
      // a. Perform CreateDataProperty(obj, "value", Desc.[[Value]]).
      success = _singletons.Create.CreateDataProperty(realm, obj, "value", Desc.value) && success;
    } // 5. If Desc has a [[Writable]] field, then


    if (Desc.writable !== undefined) {
      // a. Perform CreateDataProperty(obj, "writable", Desc.[[Writable]]).
      success = _singletons.Create.CreateDataProperty(realm, obj, "writable", new _index.BooleanValue(realm, Desc.writable)) && success;
    } // 6. If Desc has a [[Get]] field, then


    if (Desc.get !== undefined) {
      // a. Perform CreateDataProperty(obj, "get", Desc.[[Get]]).
      success = _singletons.Create.CreateDataProperty(realm, obj, "get", Desc.get) && success;
    } // 7. If Desc has a [[Set]] field, then


    if (Desc.set !== undefined) {
      // a. Perform CreateDataProperty(obj, "set", Desc.[[Set]]).
      success = _singletons.Create.CreateDataProperty(realm, obj, "set", Desc.set) && success;
    } // 8. If Desc has an [[Enumerable]] field, then


    if (Desc.enumerable !== undefined) {
      // a. Perform CreateDataProperty(obj, "enumerable", Desc.[[Enumerable]]).
      success = _singletons.Create.CreateDataProperty(realm, obj, "enumerable", new _index.BooleanValue(realm, Desc.enumerable)) && success;
    } // 9. If Desc has a [[Configurable]] field, then


    if (Desc.configurable !== undefined) {
      // a. Perform CreateDataProperty(obj, "configurable", Desc.[[Configurable]]).
      success = _singletons.Create.CreateDataProperty(realm, obj, "configurable", new _index.BooleanValue(realm, Desc.configurable)) && success;
    } // 10. Assert: all of the above CreateDataProperty operations return true.


    (0, _invariant.default)(success, "fails to create data property"); // 11. Return obj.

    return obj;
  } //


  OrdinaryDelete(realm, O, P) {
    // 1. Assert: IsPropertyKey(P) is true.
    (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected a property key"); // 2. Let desc be ? O.[[GetOwnProperty]](P).

    let desc = O.$GetOwnProperty(P); // 3. If desc is undefined, return true.

    if (!desc) {
      ensureIsNotFinal(realm, O, P);

      if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {
        if (realm.generator !== undefined) {
          realm.generator.emitPropertyDelete(O, StringKey(P));
        }
      }

      return true;
    }

    desc = desc.throwIfNotConcrete(realm); // 4. If desc.[[Configurable]] is true, then

    if (desc.configurable) {
      ensureIsNotFinal(realm, O, P);

      if (O.mightBeLeakedObject()) {
        if (realm.generator !== undefined) {
          realm.generator.emitPropertyDelete(O, StringKey(P));
        }

        return true;
      } // a. Remove the own property with name P from O.


      let key = InternalGetPropertiesKey(P);
      let map = InternalGetPropertiesMap(O, P);
      let propertyBinding = map.get(key);

      if (propertyBinding === undefined && O.isPartialObject() && O.isSimpleObject()) {
        let generator = realm.generator;

        if (generator) {
          (0, _invariant.default)(typeof key === "string" || key instanceof _index.SymbolValue);
          generator.emitPropertyDelete(O, StringKey(key));
          return true;
        }
      }

      (0, _invariant.default)(propertyBinding !== undefined);
      realm.recordModifiedProperty(propertyBinding);
      propertyBinding.descriptor = undefined;
      InternalUpdatedProperty(realm, O, P, desc); // b. Return true.

      return true;
    } // 5. Return false.


    return false;
  } // ECMA262 7.3.8


  DeletePropertyOrThrow(realm, O, P) {
    // 1. Assert: Type(O) is Object.
    (0, _invariant.default)(O instanceof _index.ObjectValue, "expected an object"); // 2. Assert: IsPropertyKey(P) is true.

    (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected a property key"); // 3. Let success be ? O.[[Delete]](P).

    let success = O.$Delete(P); // 4. If success is false, throw a TypeError exception.

    if (!success) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "couldn't delete property");
    } // 5. Return success.


    return success;
  } // ECMA262 6.2.4.6


  CompletePropertyDescriptor(realm, _Desc) {
    // 1. Assert: Desc is a Property Descriptor.
    let Desc = _Desc.throwIfNotConcrete(realm); // 2. Let like be Record{[[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false}.


    let like = {
      value: realm.intrinsics.undefined,
      get: realm.intrinsics.undefined,
      set: realm.intrinsics.undefined,
      writable: false,
      enumerable: false,
      configurable: false
    }; // 3. If either IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then

    if ((0, _index2.IsGenericDescriptor)(realm, Desc) || (0, _index2.IsDataDescriptor)(realm, Desc)) {
      // a. If Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].
      if (Desc.value === undefined) Desc.value = like.value; // b. If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].

      if (Desc.writable === undefined) Desc.writable = like.writable;
    } else {
      // 4. Else,
      // a. If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].
      if (Desc.get === undefined) Desc.get = like.get; // b. If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].

      if (Desc.set === undefined) Desc.set = like.set;
    } // 5. If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].


    if (Desc.enumerable === undefined) Desc.enumerable = like.enumerable; // 6. If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].

    if (Desc.configurable === undefined) Desc.configurable = like.configurable; // 7. Return Desc.

    return Desc;
  } // ECMA262 9.1.6.2


  IsCompatiblePropertyDescriptor(realm, extensible, Desc, current) {
    // 1. Return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current).
    return this.ValidateAndApplyPropertyDescriptor(realm, undefined, undefined, extensible, Desc, current);
  } // ECMA262 9.1.6.3


  ValidateAndApplyPropertyDescriptor(realm, O, P, extensible, _Desc, _current) {
    let Desc = _Desc;
    let current = _current; // 1. Assert: If O is not undefined, then IsPropertyKey(P) is true.

    if (O !== undefined) {
      (0, _invariant.default)(P !== undefined);
      (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P));
    }

    if (current instanceof _descriptors.AbstractJoinedDescriptor) {
      let jc = current.joinCondition;
      if (_singletons.Path.implies(jc)) current = current.descriptor1;else if (!_index.AbstractValue.createFromUnaryOp(realm, "!", jc, true).mightNotBeTrue()) current = current.descriptor2;
    } // 2. If current is undefined, then


    if (!current) {
      // a. If extensible is false, return false.
      if (!extensible) return false; // b. Assert: extensible is true.

      (0, _invariant.default)(extensible === true, "expected extensible to be true");

      if (O !== undefined && P !== undefined) {
        ensureIsNotFinal(realm, O, P);

        if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {
          leakDescriptor(realm, Desc);

          if (realm.generator !== undefined) {
            realm.generator.emitDefineProperty(O, StringKey(P), Desc.throwIfNotConcrete(realm));
          }

          return true;
        }
      } // c. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then


      if ((0, _index2.IsGenericDescriptor)(realm, Desc) || (0, _index2.IsDataDescriptor)(realm, Desc)) {
        // i. If O is not undefined, create an own data property named P of object O whose [[Value]],
        //    [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the
        //    value of an attribute field of Desc is absent, the attribute of the newly created property is set
        //    to its default value.
        if (O !== undefined) {
          (0, _invariant.default)(P !== undefined);
          InternalSetProperty(realm, O, P, new _descriptors.PropertyDescriptor({
            value: Desc.value !== undefined ? Desc.value : realm.intrinsics.undefined,
            writable: Desc.writable !== undefined ? Desc.writable : false,
            enumerable: Desc.enumerable !== undefined ? Desc.enumerable : false,
            configurable: Desc.configurable !== undefined ? Desc.configurable : false
          }));
          InternalUpdatedProperty(realm, O, P, undefined);
        }
      } else {
        // d. Else Desc must be an accessor Property Descriptor,
        // i. If O is not undefined, create an own accessor property named P of object O whose [[Get]],
        //    [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value
        //    of an attribute field of Desc is absent, the attribute of the newly created property is set to its
        //    default value.
        if (O !== undefined) {
          (0, _invariant.default)(P !== undefined);
          Desc = Desc.throwIfNotConcrete(realm);
          InternalSetProperty(realm, O, P, new _descriptors.PropertyDescriptor({
            get: Desc.get !== undefined ? Desc.get : realm.intrinsics.undefined,
            set: Desc.set !== undefined ? Desc.set : realm.intrinsics.undefined,
            enumerable: Desc.enumerable !== undefined ? Desc.enumerable : false,
            configurable: Desc.configurable !== undefined ? Desc.configurable : false
          }));
          InternalUpdatedProperty(realm, O, P, undefined);
        }
      } // e. Return true.


      return true;
    }

    current = current.throwIfNotConcrete(realm);
    Desc = Desc.throwIfNotConcrete(realm); // 3. Return true, if every field in Desc is absent.

    let allAbsent = true;

    for (let field in Desc) {
      if (Desc[field] !== undefined) {
        allAbsent = false;
        break;
      }
    }

    if (allAbsent) return true; // 4. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the
    // same value as the corresponding field in current when compared using the SameValue algorithm.

    let identical = true;

    for (let field in Desc) {
      if (Desc[field] === undefined) {
        continue;
      }

      if (current[field] === undefined) {
        identical = false;
      } else {
        let dval = InternalDescriptorPropertyToValue(realm, Desc[field]);
        let cval = InternalDescriptorPropertyToValue(realm, current[field]);
        if (dval instanceof _index.ConcreteValue && cval instanceof _index.ConcreteValue) identical = (0, _index2.SameValue)(realm, dval, cval);else {
          identical = dval === cval; // This might be false now but true at runtime. This does not
          // matter because the logic for non identical values will still
          // do the right thing in the cases below that does not blow up
          // when dealing with an abstract value.
        }
      }

      if (!identical) break;
    } // Only return here if the assigment is not temporal.


    if (identical && (O === realm.$GlobalObject || O !== undefined && !O.isIntrinsic())) {
      return true;
    }

    let mightHaveBeenDeleted = current.value instanceof _index.Value && current.value.mightHaveBeenDeleted(); // 5. If the [[Configurable]] field of current is false, then

    if (!current.configurable) {
      (0, _invariant.default)(!mightHaveBeenDeleted, "a non-configurable property can't be deleted"); // a. Return false, if the [[Configurable]] field of Desc is true.

      if (Desc.configurable) return false; // b. Return false, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.

      if (Desc.enumerable !== undefined && Desc.enumerable !== current.enumerable) {
        return false;
      }
    }

    current = current.throwIfNotConcrete(realm);
    Desc = Desc.throwIfNotConcrete(realm);

    if (O !== undefined && P !== undefined) {
      ensureIsNotFinal(realm, O, P);

      if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {
        leakDescriptor(realm, Desc);

        if (realm.generator !== undefined) {
          realm.generator.emitDefineProperty(O, StringKey(P), Desc);
        }

        return true;
      }
    }

    let oldDesc = current;
    current = (0, _descriptors.cloneDescriptor)(current);
    (0, _invariant.default)(current !== undefined); // 6. If IsGenericDescriptor(Desc) is true, no further validation is required.

    if ((0, _index2.IsGenericDescriptor)(realm, Desc)) {} else if ((0, _index2.IsDataDescriptor)(realm, current) !== (0, _index2.IsDataDescriptor)(realm, Desc)) {
      // 7. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
      // a. Return false, if the [[Configurable]] field of current is false.
      if (!current.configurable) return false; // b. If IsDataDescriptor(current) is true, then

      if ((0, _index2.IsDataDescriptor)(realm, current)) {
        // i. If O is not undefined, convert the property named P of object O from a data property to an accessor property.
        // Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.
        if (O !== undefined) {
          (0, _invariant.default)(P !== undefined);
          current.writable = undefined;
          current.value = undefined;
          current.get = realm.intrinsics.undefined;
          current.set = realm.intrinsics.undefined;
        }
      } else {
        // c. Else,
        // i. If O is not undefined, convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.
        if (O !== undefined) {
          (0, _invariant.default)(P !== undefined);
          current.get = undefined;
          current.set = undefined;
          current.writable = false;
          current.value = realm.intrinsics.undefined;
        }
      }
    } else if ((0, _index2.IsDataDescriptor)(realm, current) && (0, _index2.IsDataDescriptor)(realm, Desc)) {
      // 8. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
      // a. If the [[Configurable]] field of current is false, then
      if (!current.configurable) {
        // i. Return false, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.
        if (!current.writable && Desc.writable) return false; // ii. If the [[Writable]] field of current is false, then

        if (!current.writable) {
          // 1. Return false, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.
          let descValue = Desc.value || realm.intrinsics.undefined;
          (0, _invariant.default)(descValue instanceof _index.Value);
          let currentValue = current.value || realm.intrinsics.undefined;
          (0, _invariant.default)(currentValue instanceof _index.Value);

          if (Desc.value && !(0, _index2.SameValuePartial)(realm, descValue, currentValue)) {
            return false;
          }
        }
      } else {// b. Else the [[Configurable]] field of current is true, so any change is acceptable.
      }
    } else {
      // 9. Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,
      // a. If the [[Configurable]] field of current is false, then
      if (!current.configurable) {
        // i. Return false, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.
        if (Desc.set && !(0, _index2.SameValuePartial)(realm, Desc.set, current.set || realm.intrinsics.undefined)) return false; // ii. Return false, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.

        if (Desc.get && !(0, _index2.SameValuePartial)(realm, Desc.get, current.get || realm.intrinsics.undefined)) return false;
      }
    }

    if (mightHaveBeenDeleted) {
      // If the property might have been deleted, we need to ensure that either
      // the new descriptor overrides any existing values, or always results in
      // the default value.
      let unknownEnumerable = Desc.enumerable === undefined && !!current.enumerable;
      let unknownWritable = Desc.writable === undefined && !!current.writable;

      if (unknownEnumerable || unknownWritable) {
        let error = new _errors.CompilerDiagnostic("unknown descriptor attributes on deleted property", realm.currentLocation, "PP0038", "RecoverableError");

        if (realm.handleError(error) !== "Recover") {
          throw new _errors.FatalError();
        }
      }
    } // 10. If O is not undefined, then


    if (O !== undefined) {
      (0, _invariant.default)(P !== undefined);
      let key = InternalGetPropertiesKey(P);
      let map = InternalGetPropertiesMap(O, P);
      let propertyBinding = map.get(key);

      if (propertyBinding === undefined) {
        propertyBinding = {
          descriptor: undefined,
          object: O,
          key: key
        };
        realm.recordModifiedProperty(propertyBinding);
        propertyBinding.descriptor = current;
        map.set(key, propertyBinding);
      } else if (propertyBinding.descriptor === undefined) {
        realm.recordModifiedProperty(propertyBinding);
        propertyBinding.descriptor = current;
      } else {
        realm.recordModifiedProperty(propertyBinding);
        propertyBinding.descriptor = current;
      } // a. For each field of Desc that is present, set the corresponding attribute of the property named P of
      //    object O to the value of the field.


      for (let field in Desc) {
        if (Desc[field] !== undefined) {
          current[field] = Desc[field];
        }
      }

      InternalUpdatedProperty(realm, O, P, oldDesc);
    } // 11. Return true.


    return true;
  } // ECMA262 9.1.6.1


  OrdinaryDefineOwnProperty(realm, O, P, Desc) {
    (0, _invariant.default)(O instanceof _index.ObjectValue); // 1. Let current be ? O.[[GetOwnProperty]](P).

    let current = O.$GetOwnProperty(P); // 2. Let extensible be the value of the [[Extensible]] internal slot of O.

    let extensible = O.getExtensible(); // 3. Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).

    return this.ValidateAndApplyPropertyDescriptor(realm, O, P, extensible, Desc, current);
  } // ECMA262 19.1.2.3.1


  ObjectDefineProperties(realm, O, Properties) {
    // 1. If Type(O) is not Object, throw a TypeError exception.
    if (O.mightNotBeObject()) {
      if (O.mightBeObject()) O.throwIfNotConcrete();
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    (0, _invariant.default)(O instanceof _index.ObjectValue || O instanceof _index.AbstractObjectValue); // 2. Let props be ? ToObject(Properties).

    let props = _singletons.To.ToObject(realm, Properties); // 3. Let keys be ? props.[[OwnPropertyKeys]]().


    let keys = props.$OwnPropertyKeys(); // 4. Let descriptors be a new empty List.

    let descriptors = []; // 5. Repeat for each element nextKey of keys in List order,

    for (let nextKey of keys) {
      // a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).
      let propDesc = props.$GetOwnProperty(nextKey); // b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then

      if (propDesc && propDesc.throwIfNotConcrete(realm).enumerable) {
        this.ThrowIfMightHaveBeenDeleted(propDesc); // i. Let descObj be ? Get(props, nextKey).

        let descObj = (0, _index2.Get)(realm, props, nextKey); // ii. Let desc be ? ToPropertyDescriptor(descObj).

        let desc = _singletons.To.ToPropertyDescriptor(realm, descObj); // iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.


        descriptors.push([nextKey, desc]);
      }
    } // 6. For each pair from descriptors in list order,


    for (let pair of descriptors) {
      // a. Let P be the first element of pair.
      let P = pair[0]; // b. Let desc be the second element of pair.

      let desc = pair[1]; // c. Perform ? DefinePropertyOrThrow(O, P, desc).

      this.DefinePropertyOrThrow(realm, O, P, desc);
    } // 7. Return O.


    return O;
  } // ECMA262 7.3.3


  Set(realm, O, P, V, Throw) {
    // 1. Assert: Type(O) is Object.
    // 2. Assert: IsPropertyKey(P) is true.
    (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected property key"); // 3. Assert: Type(Throw) is Boolean.

    (0, _invariant.default)(typeof Throw === "boolean", "expected boolean"); // 4. Let success be ? O.[[Set]](P, V, O).

    let success = O.$Set(P, V, O); // 5. If success is false and Throw is true, throw a TypeError exception.

    if (success === false && Throw === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 6. Return success.


    return success;
  } // ECMA262 7.3.7


  DefinePropertyOrThrow(realm, O, P, desc) {
    // 1. Assert: Type(O) is Object.
    // 2. Assert: IsPropertyKey(P) is true.
    (0, _invariant.default)(typeof P === "string" || (0, _index2.IsPropertyKey)(realm, P), "expected property key"); // 3. Let success be ? O.[[DefineOwnProperty]](P, desc).

    let success = O.$DefineOwnProperty(P, desc); // 4. If success is false, throw a TypeError exception.

    if (success === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 5. Return success.


    return success;
  } // ECMA262 6.2.3.2


  PutValue(realm, V, W) {
    W = W.promoteEmptyToUndefined(); // The following two steps are not necessary as we propagate completions with exceptions.
    // 1. ReturnIfAbrupt(V).
    // 2. ReturnIfAbrupt(W).
    // 3. If Type(V) is not Reference, throw a ReferenceError exception.

    if (!(V instanceof _environment.Reference)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, "can't put a value to a non-reference");
    } // 4. Let base be GetBase(V).


    let base = _singletons.Environment.GetBase(realm, V); // 5. If IsUnresolvableReference(V) is true, then


    if (_singletons.Environment.IsUnresolvableReference(realm, V)) {
      // a. If IsStrictReference(V) is true, then
      if (_singletons.Environment.IsStrictReference(realm, V)) {
        // i. Throw a ReferenceError exception.
        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
      } // b. Let globalObj be GetGlobalObject().


      let globalObj = (0, _index2.GetGlobalObject)(realm); // c. Return ? Set(globalObj, GetReferencedName(V), W, false).

      return this.Set(realm, globalObj, _singletons.Environment.GetReferencedName(realm, V), W, false);
    } // 6. Else if IsPropertyReference(V) is true, then


    if (_singletons.Environment.IsPropertyReference(realm, V)) {
      if (base instanceof _index.AbstractValue) {
        // Ensure that abstract values are coerced to objects. This might yield
        // an operation that might throw.
        base = _singletons.To.ToObject(realm, base);
      } // a. If HasPrimitiveBase(V) is true, then


      if (_singletons.Environment.HasPrimitiveBase(realm, V)) {
        // i. Assert: In realm case, base will never be null or undefined.
        (0, _invariant.default)(base instanceof _index.Value && !(0, _index2.HasSomeCompatibleType)(base, _index.UndefinedValue, _index.NullValue)); // ii. Set base to ToObject(base).

        base = _singletons.To.ToObject(realm, base);
      }

      (0, _invariant.default)(base instanceof _index.ObjectValue || base instanceof _index.AbstractObjectValue); // b. Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).

      let succeeded = base.$SetPartial(_singletons.Environment.GetReferencedNamePartial(realm, V), W, (0, _index2.GetThisValue)(realm, V)); // c. If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.

      if (succeeded === false && _singletons.Environment.IsStrictReference(realm, V)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // d. Return.


      return;
    } // 7. Else base must be an Environment Record,


    if (base instanceof _environment.EnvironmentRecord) {
      // a. Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).
      let referencedName = _singletons.Environment.GetReferencedName(realm, V);

      (0, _invariant.default)(typeof referencedName === "string");
      return base.SetMutableBinding(referencedName, W, _singletons.Environment.IsStrictReference(realm, V));
    }

    (0, _invariant.default)(false);
  } // ECMA262 9.4.2.4


  ArraySetLength(realm, A, _Desc) {
    let Desc = _Desc.throwIfNotConcrete(realm); // 1. If the [[Value]] field of Desc is absent, then


    let DescValue = Desc.value;

    if (!DescValue) {
      // a. Return OrdinaryDefineOwnProperty(A, "length", Desc).
      return this.OrdinaryDefineOwnProperty(realm, A, "length", Desc);
    }

    (0, _invariant.default)(DescValue instanceof _index.Value); // 2. Let newLenDesc be a copy of Desc.

    let newLenDesc = new _descriptors.PropertyDescriptor(Desc); // 3. Let newLen be ? ToUint32(Desc.[[Value]]).

    let newLen = _singletons.To.ToUint32(realm, DescValue); // 4. Let numberLen be ? ToNumber(Desc.[[Value]]).


    let numberLen = _singletons.To.ToNumber(realm, DescValue); // 5. If newLen  numberLen, throw a RangeError exception.


    if (newLen !== numberLen) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "should be a uint");
    } // 6. Set newLenDesc.[[Value]] to newLen.


    newLenDesc.value = new _index.NumberValue(realm, newLen); // 7. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").

    let oldLenDesc = this.OrdinaryGetOwnProperty(realm, A, "length"); // 8. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created
    //    with a length data property that cannot be deleted or reconfigured.

    (0, _invariant.default)(oldLenDesc !== undefined && !(0, _index2.IsAccessorDescriptor)(realm, oldLenDesc), "cannot be undefined or an accessor descriptor");
    oldLenDesc = oldLenDesc.throwIfNotConcrete(realm); // 9. Let oldLen be oldLenDesc.[[Value]].

    let oldLen = oldLenDesc.value;
    (0, _invariant.default)(oldLen instanceof _index.Value);
    oldLen = oldLen.throwIfNotConcrete();
    (0, _invariant.default)(oldLen instanceof _index.NumberValue, "should be a number");
    oldLen = oldLen.value; // 10. If newLen  oldLen, then

    if (newLen >= oldLen) {
      // a. Return OrdinaryDefineOwnProperty(A, "length", newLenDesc).
      return this.OrdinaryDefineOwnProperty(realm, A, "length", newLenDesc);
    } // 11. If oldLenDesc.[[Writable]] is false, return false.


    if (!oldLenDesc.writable) return false; // 12. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.

    let newWritable;

    if (newLenDesc.writable === undefined || newLenDesc.writable === true) {
      newWritable = true;
    } else {
      // 13. Else,
      // a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
      // b. Let newWritable be false.
      newWritable = false; // c. Set newLenDesc.[[Writable]] to true.

      newLenDesc.writable = true;
    } // 14. Let succeeded be ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).


    let succeeded = this.OrdinaryDefineOwnProperty(realm, A, "length", newLenDesc); // 15. If succeeded is false, return false.

    if (succeeded === false) return false; // Here we diverge from the spec: instead of traversing all indices from
    // oldLen to newLen, only the indices that are actually present are touched.

    let oldLenCopy = oldLen;
    let keys = Array.from(A.properties.keys()).map(x => parseInt(x, 10)).filter(x => newLen <= x && x <= oldLenCopy).sort().reverse(); // 16. While newLen < oldLen repeat,

    for (let key of keys) {
      // a. Set oldLen to oldLen - 1.
      oldLen = key; // b. Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).

      let deleteSucceeded = A.$Delete(oldLen + ""); // c. If deleteSucceeded is false, then

      if (deleteSucceeded === false) {
        // i. Set newLenDesc.[[Value]] to oldLen + 1.
        newLenDesc.value = new _index.NumberValue(realm, oldLen + 1); // ii. If newWritable is false, set newLenDesc.[[Writable]] to false.

        if (newWritable === false) newLenDesc.writable = false; // iii. Let succeeded be ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).

        succeeded = this.OrdinaryDefineOwnProperty(realm, A, "length", newLenDesc); // iv. Return false.

        return false;
      }
    } // 17. If newWritable is false, then


    if (!newWritable) {
      // a. Return OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor{[[Writable]]: false}). This call will always return true.
      return this.OrdinaryDefineOwnProperty(realm, A, "length", new _descriptors.PropertyDescriptor({
        writable: false
      }));
    } // 18. Return true.


    return true;
  } // ECMA262 9.1.5.1


  OrdinaryGetOwnProperty(realm, O, P) {
    // if the object is leaked and final, then it's still safe to read the value from the object
    if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {
      if (!O.mightNotBeFinalObject()) {
        let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));

        if (existingBinding && existingBinding.descriptor) {
          return existingBinding.descriptor;
        } else {
          return undefined;
        }
      }

      let propName = P;

      if (typeof propName === "string") {
        propName = new _index.StringValue(realm, propName);
      }

      let absVal = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O._templateFor || O, propName], (0, _generator.createOperationDescriptor)("ABSTRACT_PROPERTY"), {
        isPure: true
      }); // TODO: We can't be sure what the descriptor will be, but the value will be abstract.


      return new _descriptors.PropertyDescriptor({
        configurable: true,
        enumerable: true,
        value: absVal,
        writable: true
      });
    } // 1. Assert: IsPropertyKey(P) is true.


    (0, _invariant.default)((0, _index2.IsPropertyKey)(realm, P), "expected a property key"); // 2. If O does not have an own property with key P, return undefined.

    let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));

    if (!existingBinding) {
      if (O.isPartialObject()) {
        (0, _invariant.default)(realm.useAbstractInterpretation); // __makePartial will already have thrown an error if not

        if (O.isSimpleObject()) {
          if (P instanceof _index.StringValue) P = P.value;

          if (typeof P === "string") {
            // In this case it is safe to defer the property access to runtime (at this point in time)
            let absVal;

            function createAbstractPropertyValue(type) {
              (0, _invariant.default)(typeof P === "string");

              if (O.isTransitivelySimple()) {
                return _index.AbstractValue.createFromBuildFunction(realm, type, [O._templateFor || O, new _index.StringValue(realm, P)], (0, _generator.createOperationDescriptor)("ABSTRACT_PROPERTY"), {
                  kind: _index.AbstractValue.makeKind("property", P)
                });
              } else if (realm.generator !== undefined) {
                return _index.AbstractValue.createTemporalFromBuildFunction(realm, type, [O._templateFor || O, new _index.StringValue(realm, P)], (0, _generator.createOperationDescriptor)("ABSTRACT_PROPERTY"), {
                  skipInvariant: true,
                  isPure: true
                });
              } else {
                // During environment initialization we'll call Set and DefineOwnProperty
                // to initialize objects. Since these needs to introspect the descriptor,
                // we need some kind of value as its placeholder. This value should never
                // leak to the serialized environment.
                return _index.AbstractValue.createFromBuildFunction(realm, type, [O._templateFor || O, new _index.StringValue(realm, P)], (0, _generator.createOperationDescriptor)("ABSTRACT_PROPERTY"), {
                  kind: "environment initialization expression"
                });
              }
            }

            if (O.isTransitivelySimple()) {
              absVal = createAbstractPropertyValue(_index.ObjectValue);
              (0, _invariant.default)(absVal instanceof _index.AbstractObjectValue);
              absVal.makeSimple("transitive");
              absVal = _index.AbstractValue.createAbstractConcreteUnion(realm, absVal, [realm.intrinsics.undefined, realm.intrinsics.null]);
            } else {
              absVal = createAbstractPropertyValue(_index.Value);
            }

            return new _descriptors.PropertyDescriptor({
              configurable: true,
              enumerable: true,
              value: absVal,
              writable: true
            });
          } else {
            (0, _invariant.default)(P instanceof _index.SymbolValue); // Simple objects don't have symbol properties

            return undefined;
          }
        }

        _index.AbstractValue.reportIntrospectionError(O, P);

        throw new _errors.FatalError();
      } else if (realm.invariantLevel >= 2 && O.isIntrinsic() && !_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O)) {
        let realmGenerator = realm.generator; // TODO: Because global variables are special, checking for missing global object properties doesn't quite work yet.

        if (realmGenerator && typeof P === "string" && O !== realm.$GlobalObject && !realm.hasBindingBeenChecked(O, P)) {
          realm.markPropertyAsChecked(O, P);
          realmGenerator.emitPropertyInvariant(O, P, "MISSING");
        }
      }

      return undefined;
    }

    realm.callReportPropertyAccess(existingBinding, false);

    if (!existingBinding.descriptor) {
      if (realm.invariantLevel >= 2 && O.isIntrinsic()) {
        let realmGenerator = realm.generator; // TODO: Because global variables are special, checking for missing global object properties doesn't quite work yet.

        if (realmGenerator && typeof P === "string" && O !== realm.$GlobalObject && !realm.hasBindingBeenChecked(O, P)) {
          realm.markPropertyAsChecked(O, P);
          realmGenerator.emitPropertyInvariant(O, P, "MISSING");
        }
      }

      return undefined;
    } // 3. Let D be a newly created Property Descriptor with no fields.


    let D = new _descriptors.PropertyDescriptor({}); // 4. Let X be O's own property whose key is P.

    let X = existingBinding.descriptor;
    (0, _invariant.default)(X !== undefined);

    if (X instanceof _descriptors.AbstractJoinedDescriptor) {
      return new _descriptors.AbstractJoinedDescriptor(X.joinCondition, X.descriptor1, X.descriptor2);
    }

    (0, _invariant.default)(X instanceof _descriptors.PropertyDescriptor); // 5. If X is a data property, then

    if ((0, _index2.IsDataDescriptor)(realm, X)) {
      let value = X.value;

      if (O.isIntrinsic() && O.isPartialObject()) {
        if (value instanceof _index.AbstractValue) {
          let savedUnion;

          if (value.kind === "abstractConcreteUnion") {
            // TODO: Simplify this code by using helpers from the AbstractValue factory
            // instead of deriving values directly.
            savedUnion = value;
            value = savedUnion.args[0];
            (0, _invariant.default)(value instanceof _index.AbstractValue);
          }

          if (value.kind !== "resolved") {
            let realmGenerator = realm.generator;
            (0, _invariant.default)(realmGenerator);
            (0, _invariant.default)(value.operationDescriptor);
            const functionResultType = value instanceof _index.AbstractObjectValue ? value.functionResultType : undefined;
            value = realmGenerator.deriveAbstract(value.types, value.values, value.args, value.operationDescriptor, {
              isPure: true,
              kind: "resolved",
              // We can't emit the invariant here otherwise it'll assume the AbstractValue's type not the union type
              skipInvariant: true
            });

            if (savedUnion !== undefined) {
              (0, _invariant.default)(value instanceof _index.AbstractValue);
              let concreteValues = savedUnion.args.filter(e => e instanceof _index.ConcreteValue);
              (0, _invariant.default)(concreteValues.length === savedUnion.args.length - 1);
              value = _index.AbstractValue.createAbstractConcreteUnion(realm, value, concreteValues);
            }

            if (functionResultType !== undefined) {
              (0, _invariant.default)(value instanceof _index.AbstractObjectValue);
              value.functionResultType = functionResultType;
            }

            if (realm.invariantLevel >= 1 && typeof P === "string" && !realm.hasBindingBeenChecked(O, P)) {
              realm.markPropertyAsChecked(O, P);
              realmGenerator.emitFullInvariant(O, P, value);
            }

            InternalSetProperty(realm, O, P, new _descriptors.PropertyDescriptor({
              value: value,
              writable: X.writable !== undefined ? X.writable : false,
              enumerable: X.enumerable !== undefined ? X.enumerable : false,
              configurable: X.configurable !== undefined ? X.configurable : false
            }));
          }
        } else if (realm.invariantLevel >= 1 && value instanceof _index.Value && !(value instanceof _index.AbstractValue)) {
          let realmGenerator = realm.generator;
          (0, _invariant.default)(realmGenerator);

          if (typeof P === "string" && !realm.hasBindingBeenChecked(O, P)) {
            realm.markPropertyAsChecked(O, P);
            realmGenerator.emitFullInvariant(O, P, value);
          }
        }
      } else {
        // TODO: Because global variables are special, checking for global object properties doesn't quite work yet.
        if (O !== realm.$GlobalObject && O.isIntrinsic() && realm.invariantLevel >= 2 && value instanceof _index.Value) {
          let realmGenerator = realm.generator;

          if (realmGenerator && typeof P === "string" && !realm.hasBindingBeenChecked(O, P)) {
            realm.markPropertyAsChecked(O, P);
            realmGenerator.emitFullInvariant(O, P, value);
          }
        }
      } // a. Set D.[[Value]] to the value of X's [[Value]] attribute.


      D.value = value; // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.

      D.writable = X.writable;
    } else {
      // 6. Else X is an accessor property,
      (0, _invariant.default)((0, _index2.IsAccessorDescriptor)(realm, X), "expected accessor property"); // a. Set D.[[Get]] to the value of X's [[Get]] attribute.

      D.get = X.get; // b. Set D.[[Set]] to the value of X's [[Set]] attribute.

      D.set = X.set;
    } // 7. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.


    D.enumerable = X.enumerable; // 8. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.

    D.configurable = X.configurable; // 9. Return D.

    return D;
  } // ECMA262 9.1.2.1


  OrdinarySetPrototypeOf(realm, O, V) {
    ensureIsNotFinal(realm, O);

    if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {
      throw new _errors.FatalError();
    } // 1. Assert: Either Type(V) is Object or Type(V) is Null.


    (0, _invariant.default)(V instanceof _index.ObjectValue || V instanceof _index.NullValue); // 2. Let extensible be the value of the [[Extensible]] internal slot of O.

    let extensible = O.getExtensible(); // 3. Let current be the value of the [[Prototype]] internal slot of O.

    let current = O.$Prototype; // 4. If SameValue(V, current) is true, return true.

    if ((0, _index2.SameValuePartial)(realm, V, current)) return true; // 5. If extensible is false, return false.

    if (!extensible) return false; // 6. Let p be V.

    let p = V; // 7. Let done be false.

    let done = false; // 8. Repeat while done is false,

    while (!done) {
      // a. If p is null, let done be true.
      if (p instanceof _index.NullValue) {
        done = true;
      } else if ((0, _index2.SameValuePartial)(realm, p, O)) {
        // b. Else if SameValue(p, O) is true, return false.
        return false;
      } else {
        // c. Else,
        // If the [[GetPrototypeOf]] internal method of p is not the ordinary object internal method defined in 9.1.1, let done be true.
        if (!p.usesOrdinaryObjectInternalPrototypeMethods()) {
          done = true;
        } else {
          // ii. Else, let p be the value of p's [[Prototype]] internal slot.
          p = p.$Prototype;

          if (p instanceof _index.AbstractObjectValue) {
            _index.AbstractValue.reportIntrospectionError(p);

            throw new _errors.FatalError();
          }
        }
      }
    } // 9. Set the value of the [[Prototype]] internal slot of O to V.


    O.$Prototype = V; // 10. Return true.

    return true;
  } // ECMA262 13.7.5.15


  EnumerateObjectProperties(realm, O) {
    /*global global*/
    let visited = new global.Set();
    let obj = O;
    let keys = O.$OwnPropertyKeys();
    let index = 0;
    let iterator = new _index.ObjectValue(realm);
    iterator.defineNativeMethod("next", 0, () => {
      while (true) {
        if (index >= keys.length) {
          let proto = obj.$GetPrototypeOf();

          if (proto instanceof _index.NullValue) {
            return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
          }

          obj = proto;
          keys = obj.$OwnPropertyKeys();
          index = 0;
        }

        let key = keys[index]; // Omit symbols.

        if (!(key instanceof _index.StringValue)) {
          index += 1;
          continue;
        } // Omit non-enumerable properties.


        let desc = obj.$GetOwnProperty(key);

        if (desc && !desc.throwIfNotConcrete(realm).enumerable) {
          this.ThrowIfMightHaveBeenDeleted(desc);
          index += 1;
          visited.add(key.value);
          continue;
        } // Omit duplicates.


        if (visited.has(key.value)) {
          index += 1;
          continue;
        }

        visited.add(key.value); // Yield the key.

        return _singletons.Create.CreateIterResultObject(realm, key, false);
      }
    });
    return iterator;
  }

  ThrowIfMightHaveBeenDeleted(desc) {
    if (desc instanceof _descriptors.AbstractJoinedDescriptor) {
      if (desc.descriptor1) {
        this.ThrowIfMightHaveBeenDeleted(desc.descriptor1);
      }

      if (desc.descriptor2) {
        this.ThrowIfMightHaveBeenDeleted(desc.descriptor2);
      }
    }

    (0, _invariant.default)(desc instanceof _descriptors.PropertyDescriptor, "internal slots should never assert using this");
    let value = desc.value;

    if (value === undefined) {
      return;
    }

    if (!value.mightHaveBeenDeleted()) return;
    (0, _invariant.default)(value instanceof _index.AbstractValue); // real empty values should never get here

    let v = value.$Realm.simplifyAndRefineAbstractValue(value);
    if (!v.mightHaveBeenDeleted()) return;

    _index.AbstractValue.reportIntrospectionError(value);

    throw new _errors.FatalError();
  }

  ThrowIfInternalSlotNotWritable(realm, object, key) {
    if (!realm.isNewObject(object)) {
      _index.AbstractValue.reportIntrospectionError(object, key);

      throw new _errors.FatalError();
    }

    return object;
  } // ECMA 14.3.9


  PropertyDefinitionEvaluation(realm, MethodDefinition, object, env, strictCode, enumerable) {
    // MethodDefinition : PropertyName ( StrictFormalParameters ) { FunctionBody }
    if (MethodDefinition.kind === "method") {
      // 1. Let methodDef be DefineMethod of MethodDefinition with argument object.
      let methodDef = _singletons.Functions.DefineMethod(realm, MethodDefinition, object, env, strictCode); // 2. ReturnIfAbrupt(methodDef).
      // 3. Perform SetFunctionName(methodDef.[[closure]], methodDef.[[key]]).


      _singletons.Functions.SetFunctionName(realm, methodDef.$Closure, methodDef.$Key); // If the AST name was computed, give the hint to the closure


      methodDef.$Closure.$HasComputedName = !!MethodDefinition.computed; // 4. Let desc be the Property Descriptor{[[Value]]: methodDef.[[closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.

      let desc = new _descriptors.PropertyDescriptor({
        value: methodDef.$Closure,
        writable: true,
        enumerable: enumerable,
        configurable: true
      }); // 5. Return DefinePropertyOrThrow(object, methodDef.[[key]], desc).

      return this.DefinePropertyOrThrow(realm, object, methodDef.$Key, desc);
    } else if (MethodDefinition.kind === "generator") {
      // MethodDefinition : GeneratorMethod
      // See 14.4.
      // ECMA 14.4.13
      // 1. Let propKey be the result of evaluating PropertyName.
      let propKey = (0, _ObjectExpression.EvalPropertyName)(MethodDefinition, env, realm, strictCode); // 2. ReturnIfAbrupt(propKey).
      // 3. If the function code for this GeneratorMethod is strict mode code, let strict be true. Otherwise let strict be false.

      let strict = strictCode || (0, _strict.default)(MethodDefinition.body); // 4. Let scope be the running execution contexts LexicalEnvironment.

      let scope = env; // 5. Let closure be GeneratorFunctionCreate(Method, StrictFormalParameters, GeneratorBody, scope, strict).

      let closure = _singletons.Functions.GeneratorFunctionCreate(realm, "method", MethodDefinition.params, MethodDefinition.body, scope, strict); // 6. Perform MakeMethod(closure, object).


      _singletons.Functions.MakeMethod(realm, closure, object); // 7. Let prototype be ObjectCreate(%GeneratorPrototype%).


      let prototype = _singletons.Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);

      prototype.originalConstructor = closure; // 8. Perform MakeConstructor(closure, true, prototype).

      (0, _index2.MakeConstructor)(realm, closure, true, prototype); // 9. Perform SetFunctionName(closure, propKey).

      _singletons.Functions.SetFunctionName(realm, closure, propKey); // 10. Let desc be the Property Descriptor{[[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.


      let desc = new _descriptors.PropertyDescriptor({
        value: closure,
        writable: true,
        enumerable: enumerable,
        configurable: true
      }); // 11. Return DefinePropertyOrThrow(object, propKey, desc).

      return this.DefinePropertyOrThrow(realm, object, propKey, desc);
    } else if (MethodDefinition.kind === "get") {
      // 1. Let propKey be the result of evaluating PropertyName.
      let propKey = (0, _ObjectExpression.EvalPropertyName)(MethodDefinition, env, realm, strictCode); // 2. ReturnIfAbrupt(propKey).
      // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.

      let strict = strictCode || (0, _strict.default)(MethodDefinition.body); // 4. Let scope be the running execution context's LexicalEnvironment.

      let scope = env; // 5. Let formalParameterList be the production FormalParameters:[empty] .

      let formalParameterList = []; // 6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).

      let closure = _singletons.Functions.FunctionCreate(realm, "method", formalParameterList, MethodDefinition.body, scope, strict); // 7. Perform MakeMethod(closure, object).


      _singletons.Functions.MakeMethod(realm, closure, object); // 8. Perform SetFunctionName(closure, propKey, "get").


      _singletons.Functions.SetFunctionName(realm, closure, propKey, "get"); // If the AST name was computed, give the hint to the closure


      closure.$HasComputedName = !!MethodDefinition.computed; // 9. Let desc be the PropertyDescriptor{[[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.

      let desc = new _descriptors.PropertyDescriptor({
        get: closure,
        enumerable: true,
        configurable: true
      }); // 10. Return ? DefinePropertyOrThrow(object, propKey, desc).

      return this.DefinePropertyOrThrow(realm, object, propKey, desc);
    } else {
      (0, _invariant.default)(MethodDefinition.kind === "set"); // 1. Let propKey be the result of evaluating PropertyName.

      let propKey = (0, _ObjectExpression.EvalPropertyName)(MethodDefinition, env, realm, strictCode); // 2. ReturnIfAbrupt(propKey).
      // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.

      let strict = strictCode || (0, _strict.default)(MethodDefinition.body); // 4. Let scope be the running execution context's LexicalEnvironment.

      let scope = env; // 5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).

      let closure = _singletons.Functions.FunctionCreate(realm, "method", MethodDefinition.params, MethodDefinition.body, scope, strict); // 6. Perform MakeMethod(closure, object).


      _singletons.Functions.MakeMethod(realm, closure, object); // 7. Perform SetFunctionName(closure, propKey, "set").


      _singletons.Functions.SetFunctionName(realm, closure, propKey, "set"); // If the AST name was computed, give the hint to the closure


      closure.$HasComputedName = !!MethodDefinition.computed; // 8. Let desc be the PropertyDescriptor{[[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.

      let desc = new _descriptors.PropertyDescriptor({
        set: closure,
        enumerable: true,
        configurable: true
      }); // 9. Return ? DefinePropertyOrThrow(object, propKey, desc).

      return this.DefinePropertyOrThrow(realm, object, propKey, desc);
    }
  }

  GetOwnPropertyKeysArray(realm, O, allowAbstractKeys, getOwnPropertyKeysEvenIfPartial) {
    if (O.isPartialObject() && !getOwnPropertyKeysEvenIfPartial || O.mightBeLeakedObject() || O.unknownProperty !== undefined) {
      _index.AbstractValue.reportIntrospectionError(O);

      throw new _errors.FatalError();
    }

    let keyArray = Array.from(O.properties.keys());
    keyArray = keyArray.filter(x => {
      let pb = O.properties.get(x);
      if (!pb || pb.descriptor === undefined) return false;
      let pv = pb.descriptor.throwIfNotConcrete(realm).value;
      if (pv === undefined) return true;
      (0, _invariant.default)(pv instanceof _index.Value);
      if (!pv.mightHaveBeenDeleted()) return true; // The property may or may not be there at runtime.
      // We can at best return an abstract keys array.
      // For now, unless the caller has told us that is okay,
      // just terminate.

      (0, _invariant.default)(pv instanceof _index.AbstractValue);
      if (allowAbstractKeys) return true;

      _index.AbstractValue.reportIntrospectionError(pv);

      throw new _errors.FatalError();
    });
    realm.callReportObjectGetOwnProperties(O);
    return keyArray;
  }

}

exports.PropertiesImplementation = PropertiesImplementation;
//# sourceMappingURL=properties.js.map

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToImplementation = void 0;

var _index = __webpack_require__(15);

var _get = __webpack_require__(230);

var _singletons = __webpack_require__(236);

var _has = __webpack_require__(269);

var _call = __webpack_require__(234);

var _errors = __webpack_require__(3);

var _is = __webpack_require__(229);

var _abstract = __webpack_require__(233);

var _index2 = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _generator = __webpack_require__(237);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function modulo(x, y) {
  return x < 0 ? x % y + y : x % y;
}

class ToImplementation {
  constructor() {
    this.ElementConv = {
      Int8: this.ToInt8.bind(this),
      Int16: this.ToInt16.bind(this),
      Int32: this.ToInt32.bind(this),
      Uint8: this.ToUint8.bind(this),
      Uint16: this.ToUint16.bind(this),
      Uint32: this.ToUint32.bind(this),
      Uint8Clamped: this.ToUint8Clamp.bind(this)
    };
  }

  // ECMA262 7.1.5
  ToInt32(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, +0, -0, +, or -, return +0.

    if (isNaN(number) || number === 0 || !isFinite(number)) return +0; // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).

    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number)); // 4. Let int16bit be int modulo 2^32.

    let int32bit = modulo(int, Math.pow(2, 32)); // 5. If int32bit  2^31, return int32bit - 2^32; otherwise return int32bit.

    return int32bit >= Math.pow(2, 31) ? int32bit - Math.pow(2, 32) : int32bit;
  } // ECMA262 7.1.6


  ToUint32(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, +0, -0, +, or -, return +0.

    if (isNaN(number) || number === 0 || !isFinite(number)) return +0; // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).

    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number)); // 4. Let int16bit be int modulo 2^32.

    let int32bit = modulo(int, Math.pow(2, 32)); // 5. Return int32bit.

    return int32bit;
  } // ECMA262 7.1.7


  ToInt16(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, +0, -0, +, or -, return +0.

    if (isNaN(number) || number === 0 || !isFinite(number)) return +0; // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).

    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number)); // 4. Let int16bit be int modulo 2^16.

    let int16bit = modulo(int, Math.pow(2, 16)); // 5. If int16bit  2^15, return int16bit - 2^16; otherwise return int16bit.

    return int16bit >= Math.pow(2, 15) ? int16bit - Math.pow(2, 16) : int16bit;
  } // ECMA262 7.1.8


  ToUint16(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, +0, -0, +, or -, return +0.

    if (isNaN(number) || number === 0 || !isFinite(number)) return +0; // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).

    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number)); // 4. Let int16bit be int modulo 2^16.

    let int16bit = modulo(int, Math.pow(2, 16)); // 5. Return int16bit.

    return int16bit;
  } // ECMA262 7.1.9


  ToInt8(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, +0, -0, +, or -, return +0.

    if (isNaN(number) || number === 0 || !isFinite(number)) return +0; // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).

    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number)); // 4. Let int8bit be int modulo 2^8.

    let int8bit = modulo(int, Math.pow(2, 8)); // 5. If int8bit  2^7, return int8bit - 2^8; otherwise return int8bit.

    return int8bit >= Math.pow(2, 7) ? int8bit - Math.pow(2, 8) : int8bit;
  } // ECMA262 7.1.10


  ToUint8(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, +0, -0, +, or -, return +0.

    if (isNaN(number) || number === 0 || !isFinite(number)) return +0; // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).

    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number)); // 4. Let int8bit be int modulo 2^8.

    let int8bit = modulo(int, Math.pow(2, 8)); // 5. Return int8bit.

    return int8bit;
  } // ECMA262 7.1.11


  ToUint8Clamp(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, return +0.

    if (isNaN(number)) return +0; // 3. If number  0, return +0.

    if (number <= 0) return +0; // 4. If number  255, return 255.

    if (number >= 255) return 255; // 5. Let f be floor(number).

    let f = Math.floor(number); // 6. If f + 0.5 < number, return f + 1.

    if (f + 0.5 < number) return f + 1; // 7. If number < f + 0.5, return f.

    if (number < f + 0.5) return f; // 8. If f is odd, return f + 1.

    if (f % 2 === 1) return f + 1; // 9. Return f.

    return f;
  } // ECMA262 19.3.3.1


  thisBooleanValue(realm, value) {
    // 1. If Type(value) is Boolean, return value.
    if (value instanceof _index2.BooleanValue) return value; // 2. If Type(value) is Object and value has a [[BooleanData]] internal slot, then

    if (value instanceof _index2.ObjectValue && value.$BooleanData) {
      const booleanData = value.$BooleanData.throwIfNotConcreteBoolean(); // a. Assert: value's [[BooleanData]] internal slot is a Boolean value.

      (0, _invariant.default)(booleanData instanceof _index2.BooleanValue, "expected boolean data internal slot to be a boolean value"); // b. Return the value of value's [[BooleanData]] internal slot.

      return booleanData;
    }

    value.throwIfNotConcrete(); // 3. Throw a TypeError exception.

    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // ECMA262 20.1.3


  thisNumberValue(realm, value) {
    // 1. If Type(value) is Number, return value.
    if (value instanceof _index2.NumberValue) return value; // 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then

    if (value instanceof _index2.ObjectValue && value.$NumberData) {
      const numberData = value.$NumberData.throwIfNotConcreteNumber(); // a. Assert: value's [[NumberData]] internal slot is a Number value.

      (0, _invariant.default)(numberData instanceof _index2.NumberValue, "expected number data internal slot to be a number value"); // b. Return the value of value's [[NumberData]] internal slot.

      return numberData;
    }

    value = value.throwIfNotConcrete(); // 3. Throw a TypeError exception.

    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // ECMA262 21.1.3


  thisStringValue(realm, value) {
    // 1. If Type(value) is String, return value.
    if (value instanceof _index2.StringValue) return value; // 2. If Type(value) is Object and value has a [[StringData]] internal slot, then

    if (value instanceof _index2.ObjectValue && value.$StringData) {
      const stringData = value.$StringData.throwIfNotConcreteString(); // a. Assert: value's [[StringData]] internal slot is a String value.

      (0, _invariant.default)(stringData instanceof _index2.StringValue, "expected string data internal slot to be a string value"); // b. Return the value of value's [[StringData]] internal slot.

      return stringData;
    }

    value = value.throwIfNotConcrete(); // 3. Throw a TypeError exception.

    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // ECMA262 6.2.4.5


  ToPropertyDescriptor(realm, Obj) {
    Obj = Obj.throwIfNotConcrete(); // 1. If Type(Obj) is not Object, throw a TypeError exception.

    if (!(Obj instanceof _index2.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let desc be a new Property Descriptor that initially has no fields.


    let desc = new _descriptors.PropertyDescriptor({}); // 3. Let hasEnumerable be ? HasProperty(Obj, "enumerable").

    let hasEnumerable = (0, _has.HasProperty)(realm, Obj, "enumerable"); // 4. If hasEnumerable is true, then

    if (hasEnumerable === true) {
      // a. Let enum be ToBoolean(? Get(Obj, "enumerable")).
      let enu = this.ToBooleanPartial(realm, (0, _get.Get)(realm, Obj, "enumerable")); // b. Set the [[Enumerable]] field of desc to enum.

      desc.enumerable = enu === true;
    } // 5. Let hasConfigurable be ? HasProperty(Obj, "configurable").


    let hasConfigurable = (0, _has.HasProperty)(realm, Obj, "configurable"); // 6. If hasConfigurable is true, then

    if (hasConfigurable === true) {
      // a. Let conf be ToBoolean(? Get(Obj, "configurable")).
      let conf = this.ToBooleanPartial(realm, (0, _get.Get)(realm, Obj, "configurable")); // b. Set the [[Configurable]] field of desc to conf.

      desc.configurable = conf === true;
    } // 7. Let hasValue be ? HasProperty(Obj, "value").


    let hasValue = (0, _has.HasProperty)(realm, Obj, "value"); // 8. If hasValue is true, then

    if (hasValue === true) {
      // a. Let value be ? Get(Obj, "value").
      let value = (0, _get.Get)(realm, Obj, "value"); // b. Set the [[Value]] field of desc to value.

      desc.value = value;
    } // 9. Let hasWritable be ? HasProperty(Obj, "writable").


    let hasWritable = (0, _has.HasProperty)(realm, Obj, "writable"); // 10. If hasWritable is true, then

    if (hasWritable === true) {
      // a. Let writable be ToBoolean(? Get(Obj, "writable")).
      let writable = this.ToBooleanPartial(realm, (0, _get.Get)(realm, Obj, "writable")); // b. Set the [[Writable]] field of desc to writable.

      desc.writable = writable === true;
    } // 11. Let hasGet be ? HasProperty(Obj, "get").


    let hasGet = (0, _has.HasProperty)(realm, Obj, "get"); // 12. If hasGet is true, then

    if (hasGet === true) {
      // a. Let getter be ? Get(Obj, "get").
      let getter = (0, _get.Get)(realm, Obj, "get"); // b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.

      if ((0, _is.IsCallable)(realm, getter) === false && !getter.mightBeUndefined()) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      getter.throwIfNotConcrete(); // c. Set the [[Get]] field of desc to getter.

      desc.get = getter;
    } // 13. Let hasSet be ? HasProperty(Obj, "set").


    let hasSet = (0, _has.HasProperty)(realm, Obj, "set"); // 14. If hasSet is true, then

    if (hasSet === true) {
      // a. Let setter be ? Get(Obj, "set").
      let setter = (0, _get.Get)(realm, Obj, "set"); // b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.

      if ((0, _is.IsCallable)(realm, setter) === false && !setter.mightBeUndefined()) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }

      setter.throwIfNotConcrete(); // c. Set the [[Set]] field of desc to setter.

      desc.set = setter;
    } // 15. If either desc.[[Get]] or desc.[[Set]] is present, then


    if (desc.get || desc.set) {
      // a. If either desc.[[Value]] or desc.[[Writable]] is present, throw a TypeError exception.
      if (desc.value !== undefined || desc.writable !== undefined) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      }
    } // 16. Return desc.


    return desc;
  } // ECMA262 7.1.13


  ToObject(realm, arg) {
    if (arg instanceof _index2.AbstractObjectValue) return arg;

    if (arg instanceof _index2.AbstractValue) {
      return this._WrapAbstractInObject(realm, arg);
    }

    if (arg instanceof _index2.UndefinedValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } else if (arg instanceof _index2.NullValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } else if (arg instanceof _index2.BooleanValue) {
      let obj = new _index2.ObjectValue(realm, realm.intrinsics.BooleanPrototype);
      obj.$BooleanData = arg;
      return obj;
    } else if (arg instanceof _index2.NumberValue) {
      let obj = new _index2.ObjectValue(realm, realm.intrinsics.NumberPrototype);
      obj.$NumberData = arg;
      return obj;
    } else if (arg instanceof _index2.StringValue) {
      let obj = _singletons.Create.StringCreate(realm, arg, realm.intrinsics.StringPrototype);

      return obj;
    } else if (arg instanceof _index2.SymbolValue) {
      let obj = new _index2.ObjectValue(realm, realm.intrinsics.SymbolPrototype);
      obj.$SymbolData = arg;
      return obj;
    } else if (arg instanceof _index2.ObjectValue) {
      return arg;
    }

    (0, _invariant.default)(false);
  }

  _WrapAbstractInObject(realm, arg) {
    let obj;

    switch (arg.getType()) {
      case _index2.IntegralValue:
      case _index2.NumberValue:
        obj = new _index2.ObjectValue(realm, realm.intrinsics.NumberPrototype);
        obj.$NumberData = arg;
        break;

      case _index2.StringValue:
        obj = new _index2.ObjectValue(realm, realm.intrinsics.StringPrototype);
        obj.$StringData = arg;
        break;

      case _index2.BooleanValue:
        obj = new _index2.ObjectValue(realm, realm.intrinsics.BooleanPrototype);
        obj.$BooleanData = arg;
        break;

      case _index2.SymbolValue:
        obj = new _index2.ObjectValue(realm, realm.intrinsics.SymbolPrototype);
        obj.$SymbolData = arg;
        break;

      case _index2.UndefinedValue:
      case _index2.NullValue:
      case _index2.PrimitiveValue:
        if (arg.mightBeNull() || arg.mightHaveBeenDeleted() || arg.mightBeUndefined()) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);

      /*eslint-disable */

      default:
        /*eslint-enable */
        if (realm.isInPureScope()) {
          // will be serialized as Object.assign(serialized_arg)
          obj = _index2.AbstractValue.createFromType(realm, _index2.ObjectValue, "explicit conversion to object", [arg]);
          (0, _invariant.default)(obj instanceof _index2.AbstractObjectValue);
        } else {
          obj = arg.throwIfNotConcreteObject();
        }

        break;
    }

    return obj;
  } // ECMA262 7.1.15


  ToLength(realm, argument) {
    // Let len be ? ToInteger(argument).
    let len = this.ToInteger(realm, argument); // If len  +0, return +0.

    if (len <= 0) return +0; // If len is +, return 2^53-1.

    if (len === +Infinity) return Math.pow(2, 53) - 1; // Return min(len, 2^53-1).

    return Math.min(len, Math.pow(2, 53) - 1);
  } // ECMA262 7.1.4


  ToInteger(realm, argument) {
    // 1. Let number be ? ToNumber(argument).
    let number = this.ToNumber(realm, argument); // 2. If number is NaN, return +0.

    if (isNaN(number)) return +0; // 3. If number is +0, -0, +, or -, return number.

    if (!isFinite(number) || number === 0) return number; // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).

    return number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));
  } // ECMA262 7.1.17


  ToIndex(realm, value) {
    let index; // 1. If value is undefined, then

    if (value instanceof _index2.UndefinedValue) {
      // a. Let index be 0.
      index = 0;
    } else {
      // 2. Else,
      // a. Let integerIndex be ? ToInteger(value).
      let integerIndex = this.ToInteger(realm, value); // b. If integerIndex < 0, throw a RangeError exception.

      if (integerIndex < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "integerIndex < 0");
      } // c. Let index be ! ToLength(integerIndex).


      index = this.ToLength(realm, integerIndex); // d. If SameValueZero(integerIndex, index) is false, throw a RangeError exception.

      if ((0, _abstract.SameValueZero)(realm, new _index2.NumberValue(realm, integerIndex), new _index2.NumberValue(realm, index)) === false) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "integerIndex < 0");
      }
    } // 3. Return index.


    return index;
  }

  ToIndexPartial(realm, value) {
    return this.ToIndex(realm, typeof value === "number" ? value : value.throwIfNotConcrete());
  }

  ToNumber(realm, val) {
    const num = this.ToNumberOrAbstract(realm, val);

    if (typeof num !== "number") {
      _index2.AbstractValue.reportIntrospectionError(num);

      throw new _errors.FatalError();
    }

    return num;
  } // ECMA262 7.1.3


  ToNumberOrAbstract(realm, val) {
    if (typeof val === "number") {
      return val;
    } else if (val instanceof _index2.AbstractValue) {
      return val;
    } else if (val instanceof _index2.UndefinedValue) {
      return NaN;
    } else if (val instanceof _index2.NullValue) {
      return +0;
    } else if (val instanceof _index2.ObjectValue) {
      let prim = this.ToPrimitiveOrAbstract(realm, val, "number");
      return this.ToNumberOrAbstract(realm, prim);
    } else if (val instanceof _index2.BooleanValue) {
      if (val.value === true) {
        return 1;
      } else {
        // `val.value === false`
        return 0;
      }
    } else if (val instanceof _index2.NumberValue) {
      return val.value;
    } else if (val instanceof _index2.StringValue) {
      return Number(val.value);
    } else if (val instanceof _index2.SymbolValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } else {
      (0, _invariant.default)(false, "unexpected type of value");
    }
  }

  IsToNumberPure(realm, val) {
    if (val instanceof _index2.Value) {
      if (this.IsToPrimitivePure(realm, val)) {
        let type = val.getType();
        return type !== _index2.SymbolValue && type !== _index2.PrimitiveValue && type !== _index2.Value;
      }

      return false;
    }

    return true;
  } // ECMA262 7.1.1


  ToPrimitive(realm, input, hint) {
    return this.ToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();
  }

  ToPrimitiveOrAbstract(realm, input, hint) {
    if (input instanceof _index2.PrimitiveValue) {
      return input;
    } // When Type(input) is Object, the following steps are taken


    (0, _invariant.default)(input instanceof _index2.ObjectValue, "expected an object"); // 1. If PreferredType was not passed, let hint be "default".

    hint = hint || "default"; // Following two steps are redundant since we just pass string hints.
    // 2. Else if PreferredType is hint String, let hint be "string".
    // 3. Else PreferredType is hint Number, let hint be "number".
    // 4. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).

    let exoticToPrim = (0, _get.GetMethod)(realm, input, realm.intrinsics.SymbolToPrimitive); // 5. If exoticToPrim is not undefined, then

    if (!(exoticToPrim instanceof _index2.UndefinedValue)) {
      // a. Let result be ? Call(exoticToPrim, input,  hint ).
      let result = (0, _call.Call)(realm, exoticToPrim, input, [new _index2.StringValue(realm, hint)]); // b. If Type(result) is not Object, return result.

      if (!(result instanceof _index2.ObjectValue)) {
        (0, _invariant.default)(result instanceof _index2.PrimitiveValue);
        return result;
      } // c. Throw a TypeError exception.


      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 6. If hint is "default", let hint be "number".


    if (hint === "default") hint = "number"; // 7. Return ? OrdinaryToPrimitive(input, hint).

    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint);
  } // Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.


  GetToPrimitivePureResultType(realm, input) {
    let type = input.getType();
    if (input instanceof _index2.PrimitiveValue) return type;
    if (input instanceof _index2.AbstractValue && !input.mightBeObject()) return _index2.PrimitiveValue;
    return undefined;
  }

  IsToPrimitivePure(realm, input) {
    return this.GetToPrimitivePureResultType(realm, input) !== undefined;
  } // ECMA262 7.1.1


  OrdinaryToPrimitive(realm, input, hint) {
    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();
  }

  OrdinaryToPrimitiveOrAbstract(realm, input, hint) {
    let methodNames; // 1. Assert: Type(O) is Object.

    (0, _invariant.default)(input instanceof _index2.ObjectValue, "Expected object"); // 2. Assert: Type(hint) is String and its value is either "string" or "number".

    (0, _invariant.default)(hint === "string" || hint === "number", "Expected string or number hint"); // 3. If hint is "string", then

    if (hint === "string") {
      // a. Let methodNames be  "toString", "valueOf" .
      methodNames = ["toString", "valueOf"];
    } else {
      // 4. Else,
      // a. Let methodNames be  "valueOf", "toString" .
      methodNames = ["valueOf", "toString"];
    } // 5. For each name in methodNames in List order, do


    for (let name of methodNames) {
      // a. Let method be ? Get(O, name).
      let method = (0, _get.Get)(realm, input, new _index2.StringValue(realm, name)); // b. If IsCallable(method) is true, then

      if ((0, _is.IsCallable)(realm, method)) {
        // i. Let result be ? Call(method, O).
        let result = (0, _call.Call)(realm, method, input);
        let resultType = result.getType(); // ii. If Type(result) is not Object, return result.

        if (resultType === _index2.Value) {
          (0, _invariant.default)(result instanceof _index2.AbstractValue);
          let error = new _errors.CompilerDiagnostic(`${name} might return either an object or primitive`, realm.currentLocation, "PP0028", "RecoverableError");
          realm.handleError(error);
          throw new _errors.FatalError();
        }

        if (_index2.Value.isTypeCompatibleWith(resultType, _index2.PrimitiveValue)) {
          (0, _invariant.default)(result instanceof _index2.AbstractValue || result instanceof _index2.PrimitiveValue);
          return result;
        }
      }
    } // 6. Throw a TypeError exception.


    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "can't turn to primitive");
  } // ECMA262 7.1.12


  ToString(realm, val) {
    if (typeof val === "string") {
      return val;
    } else if (val instanceof _index2.StringValue) {
      return val.value;
    } else if (val instanceof _index2.NumberValue) {
      return val.value + "";
    } else if (val instanceof _index2.UndefinedValue) {
      return "undefined";
    } else if (val instanceof _index2.NullValue) {
      return "null";
    } else if (val instanceof _index2.SymbolValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } else if (val instanceof _index2.BooleanValue) {
      return val.value ? "true" : "false";
    } else if (val instanceof _index2.ObjectValue) {
      let primValue = this.ToPrimitive(realm, val, "string");
      return this.ToString(realm, primValue);
    } else {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown value type, can't coerce to string");
    }
  }

  IsToStringPure(realm, input) {
    if (input instanceof _index2.Value) {
      if (this.IsToPrimitivePure(realm, input)) {
        let type = input.getType();
        return type !== _index2.SymbolValue && type !== _index2.PrimitiveValue && type !== _index2.Value;
      }
    }

    return true;
  }

  ToStringPartial(realm, val) {
    return this.ToString(realm, typeof val === "string" ? val : val.throwIfNotConcrete());
  }

  ToStringValue(realm, val) {
    if (val.getType() === _index2.StringValue) return val;

    if (val instanceof _index2.ObjectValue) {
      let primValue = this.ToPrimitiveOrAbstract(realm, val, "string");
      if (primValue.getType() === _index2.StringValue) return primValue;
      return this.ToStringValue(realm, primValue);
    } else if (val instanceof _index2.ConcreteValue) {
      let str = this.ToString(realm, val);
      return new _index2.StringValue(realm, str);
    } else if (val instanceof _index2.AbstractValue) {
      return this.ToStringAbstract(realm, val);
    } else {
      (0, _invariant.default)(false, "unknown value type, can't coerce to string");
    }
  }

  ToStringAbstract(realm, value) {
    if (value.mightNotBeString()) {
      let result; // If the property is not a string we need to coerce it.

      let coerceToString = (0, _generator.createOperationDescriptor)("COERCE_TO_STRING");

      if (value.mightBeObject() && !value.isSimpleObject()) {
        // If this might be a non-simple object, we need to coerce this at a
        // temporal point since it can have side-effects.
        // We can't rely on comparison to do it later, even if
        // it is non-strict comparison since we'll do multiple
        // comparisons. So we have to be explicit about when this
        // happens.
        result = realm.evaluateWithPossibleThrowCompletion(() => _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.StringValue, [value], coerceToString), _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
      } else {
        result = _index2.AbstractValue.createFromBuildFunction(realm, _index2.StringValue, [value], coerceToString);
      }

      (0, _invariant.default)(result instanceof _index2.AbstractValue);
      return result;
    }

    return value;
  } // ECMA262 7.1.2


  ToBoolean(realm, val) {
    if (val instanceof _index2.BooleanValue) {
      return val.value;
    } else if (val instanceof _index2.UndefinedValue) {
      return false;
    } else if (val instanceof _index2.NullValue) {
      return false;
    } else if (val instanceof _index2.NumberValue) {
      return val.value !== 0 && !isNaN(val.value);
    } else if (val instanceof _index2.StringValue) {
      return val.value.length > 0;
    } else if (val instanceof _index2.ObjectValue) {
      return true;
    } else if (val instanceof _index2.SymbolValue) {
      return true;
    } else {
      (0, _invariant.default)(!(val instanceof _index2.AbstractValue));
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown value type, can't coerce to a boolean");
    }
  }

  ToBooleanPartial(realm, val) {
    if (!val.mightNotBeObject()) return true;
    return this.ToBoolean(realm, val.throwIfNotConcrete());
  } // ECMA262 7.1.14


  ToPropertyKey(realm, arg)
  /* but not StringValue */
  {
    // 1. Let key be ? ToPrimitive(argument, hint String).
    let key = this.ToPrimitive(realm, arg, "string"); // 2. If Type(key) is Symbol, then

    if (key instanceof _index2.SymbolValue) {
      // a. Return key.
      return key;
    } // 3. Return ! ToString(key).


    return this.ToString(realm, key);
  }

  ToPropertyKeyPartial(realm, arg)
  /* but not StringValue */
  {
    if (arg instanceof _index2.ConcreteValue) return this.ToPropertyKey(realm, arg); // if we are in pure scope, we can assume that ToPropertyKey
    // won't cause side-effects even if it's not simple

    if (arg.mightNotBeString() && arg.mightNotBeNumber() && !arg.isSimpleObject() && !realm.isInPureScope()) {
      arg.throwIfNotConcrete();
    }

    (0, _invariant.default)(arg instanceof _index2.AbstractValue);
    return arg;
  } // ECMA262 7.1.16


  CanonicalNumericIndexString(realm, argument) {
    // 1. Assert: Type(argument) is String.
    (0, _invariant.default)(argument instanceof _index2.StringValue); // 2. If argument is "-0", return 0.

    if (argument.value === "-0") return -0; // 3. Let n be ToNumber(argument).

    let n = this.ToNumber(realm, argument); // 4. If SameValue(ToString(n), argument) is false, return undefined.

    if ((0, _abstract.SameValue)(realm, new _index2.StringValue(realm, this.ToString(realm, new _index2.NumberValue(realm, n))), argument) === false) return undefined; // 5. Return n.

    return n;
  }

}

exports.ToImplementation = ToImplementation;
//# sourceMappingURL=to.js.map

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WidenImplementation = void 0;

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _descriptors = __webpack_require__(268);

var _completions = __webpack_require__(18);

var _environment = __webpack_require__(20);

var _index = __webpack_require__(232);

var _generator = __webpack_require__(237);

var _index2 = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class WidenImplementation {
  _widenArrays(realm, v1, v2) {
    if (v1[0] instanceof _index2.Value) {
      (0, _invariant.default)(v2[0] instanceof _index2.Value);
      return this._widenArraysOfValues(realm, v1, v2);
    }

    (0, _invariant.default)(!(v2[0] instanceof _index2.Value));
    return this._widenArrayOfsMapEntries(realm, v1, v2);
  }

  _widenArrayOfsMapEntries(realm, a1, a2) {
    let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);
    let result = [];

    for (let i = 0; i < n; i++) {
      let {
        $Key: key1,
        $Value: val1
      } = a1[i] || {
        $Key: undefined,
        $Value: undefined
      };
      let {
        $Key: key2,
        $Value: val2
      } = a2[i] || {
        $Key: undefined,
        $Value: undefined
      };

      if (key1 === undefined && key2 === undefined) {
        result[i] = {
          $Key: undefined,
          $Value: undefined
        };
      } else {
        if (key1 === undefined) key1 = key2;else if (key2 === undefined) key2 = key1;
        (0, _invariant.default)(key1 !== undefined);
        (0, _invariant.default)(key2 !== undefined);
        let key3 = this.widenValues(realm, key1, key2);
        (0, _invariant.default)(key3 instanceof _index2.Value);

        if (val1 === undefined && val2 === undefined) {
          result[i] = {
            $Key: key3,
            $Value: undefined
          };
        } else {
          if (val1 === undefined) val1 = val2;else if (val2 === undefined) val2 = val1;
          (0, _invariant.default)(val1 !== undefined);
          (0, _invariant.default)(val2 !== undefined);
          let val3 = this.widenValues(realm, val1, val2);
          (0, _invariant.default)(val3 === undefined || val3 instanceof _index2.Value);
          result[i] = {
            $Key: key3,
            $Value: val3
          };
        }
      }
    }

    return result;
  }

  _widenArraysOfValues(realm, a1, a2) {
    let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);
    let result = [];

    for (let i = 0; i < n; i++) {
      let wv = this.widenValues(realm, a1[i], a2[i]);
      (0, _invariant.default)(wv === undefined || wv instanceof _index2.Value);
      result[i] = wv;
    }

    return result;
  } // Returns a new effects summary that includes both e1 and e2.


  widenEffects(realm, e1, e2) {
    let result = this.widenResults(realm, e1.result, e2.result);
    let bindings = this.widenBindings(realm, e1.modifiedBindings, e2.modifiedBindings);
    let properties = this.widenPropertyBindings(realm, e1.modifiedProperties, e2.modifiedProperties, e1.createdObjects, e2.createdObjects);
    let createdObjects = new Set(); // Top, since the empty set knows nothing. There is no other choice for widen.

    let generator = new _generator.Generator(realm, "widen", realm.pathConditions); // code subject to widening will be generated somewhere else

    return new _realm.Effects(result, generator, bindings, properties, createdObjects);
  }

  widenResults(realm, result1, result2) {
    (0, _invariant.default)(!(result1 instanceof _environment.Reference || result2 instanceof _environment.Reference), "loop bodies should not result in refs");
    (0, _invariant.default)(!(result1 instanceof _completions.AbruptCompletion || result2 instanceof _completions.AbruptCompletion), "if a loop iteration ends abruptly, there is no need for fixed point computation");

    if (result1 instanceof _completions.SimpleNormalCompletion && result2 instanceof _completions.SimpleNormalCompletion) {
      let val = this.widenValues(realm, result1.value, result2.value);
      (0, _invariant.default)(val instanceof _index2.Value);
      return new _completions.SimpleNormalCompletion(val);
    }

    if (result1 instanceof _completions.JoinedNormalAndAbruptCompletions || result2 instanceof _completions.JoinedNormalAndAbruptCompletions) {
      //todo: #1174 figure out how to deal with loops that have embedded conditional exits
      // widen join pathConditions
      // widen normal result and Effects
      // use abrupt part of result2, depend stability to make this safe. See below.
      throw new _errors.FatalError();
    }

    (0, _invariant.default)(false);
  }

  widenMaps(m1, m2, widen) {
    let m3 = new Map();
    m1.forEach((val1, key, map1) => {
      let val2 = m2.get(key);
      let val3 = widen(key, val1, val2);
      m3.set(key, val3);
    });
    m2.forEach((val2, key, map2) => {
      if (!m1.has(key)) {
        m3.set(key, widen(key, undefined, val2));
      }
    });
    return m3;
  }

  widenBindings(realm, m1, m2) {
    let widen = (b, b1, b2) => {
      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;
      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;
      let hasLeaked = l1 || l2; // If either has leaked, then this binding has leaked.

      let v1 = b1 === undefined || b1.value === undefined ? b.value : b1.value;
      (0, _invariant.default)(b2 !== undefined); // Local variables are not going to get deleted as a result of widening

      let v2 = b2.value;
      (0, _invariant.default)(v2 !== undefined);
      let result = this.widenValues(realm, v1 || realm.intrinsics.undefined, v2);

      if (result instanceof _index2.AbstractValue && result.kind === "widened") {
        let phiNode = b.phiNode;

        if (phiNode === undefined) {
          // Create a temporal location for binding
          let generator = realm.generator;
          (0, _invariant.default)(generator !== undefined);
          phiNode = generator.deriveAbstract(result.types, result.values, [b.value || realm.intrinsics.undefined], (0, _generator.createOperationDescriptor)("SINGLE_ARG"), {
            skipInvariant: true
          });
          b.phiNode = phiNode;
        } // Let the widened value be a reference to the phiNode of the binding


        (0, _invariant.default)(phiNode.intrinsicName !== undefined);
        let phiName = phiNode.intrinsicName;
        result.intrinsicName = phiName;
        result.operationDescriptor = (0, _generator.createOperationDescriptor)("WIDENED_IDENTIFIER", {
          id: phiName
        });
      }

      (0, _invariant.default)(result instanceof _index2.Value);
      return {
        hasLeaked,
        value: result
      };
    };

    return this.widenMaps(m1, m2, widen);
  } // Returns an abstract value that includes both v1 and v2 as potential values.


  widenValues(realm, v1, v2) {
    if (Array.isArray(v1) || Array.isArray(v2)) {
      (0, _invariant.default)(Array.isArray(v1));
      (0, _invariant.default)(Array.isArray(v2));
      return this._widenArrays(realm, v1, v2);
    }

    (0, _invariant.default)(v1 instanceof _index2.Value);
    (0, _invariant.default)(v2 instanceof _index2.Value);

    if (!(v1 instanceof _index2.AbstractValue) && !(v2 instanceof _index2.AbstractValue) && (0, _index.StrictEqualityComparison)(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())) {
      return v1; // no need to widen a loop invariant value
    } else {
      (0, _invariant.default)(v1 && v2);
      return _index2.AbstractValue.createFromWidening(realm, v1, v2);
    }
  }

  widenPropertyBindings(realm, m1, m2, c1, c2) {
    let widen = (b, d1, d2) => {
      if (d1 === undefined && d2 === undefined) return undefined; // If the PropertyBinding object has been freshly allocated do not widen (that happens in AbstractObjectValue)

      if (d1 === undefined) {
        (0, _invariant.default)(d2 !== undefined);
        if (c2.has(b.object)) return d2; // no widen

        if (b.descriptor !== undefined && m1.has(b)) {
          // property was present in (n-1)th iteration and deleted in nth iteration
          d1 = (0, _descriptors.cloneDescriptor)(b.descriptor.throwIfNotConcrete(realm));
          (0, _invariant.default)(d1 !== undefined);
          d1.value = realm.intrinsics.empty;
        } else {
          // no write to property in nth iteration, use the value from the (n-1)th iteration
          d1 = b.descriptor;

          if (d1 === undefined) {
            d1 = (0, _descriptors.cloneDescriptor)(d2.throwIfNotConcrete(realm));
            (0, _invariant.default)(d1 !== undefined);
            d1.value = realm.intrinsics.empty;
          }
        }
      }

      if (d2 === undefined) {
        if (c1.has(b.object)) return d1; // no widen

        if (m2.has(b)) {
          // property was present in nth iteration and deleted in (n+1)th iteration
          d2 = (0, _descriptors.cloneDescriptor)(d1.throwIfNotConcrete(realm));
          (0, _invariant.default)(d2 !== undefined);
          d2.value = realm.intrinsics.empty;
        } else {
          // no write to property in (n+1)th iteration, use the value from the nth iteration
          d2 = d1;
        }

        (0, _invariant.default)(d2 !== undefined);
      }

      let result = this.widenDescriptors(realm, d1, d2);

      if (result && result.value instanceof _index2.AbstractValue && result.value.kind === "widened") {
        let rval = result.value;
        let pathNode = b.pathNode;

        if (pathNode === undefined) {
          //Since properties already have mutable storage locations associated with them, we do not
          //need phi nodes. What we need is an abstract value with a operation descriptor that results in a memberExpression
          //that resolves to the storage location of the property.
          // For now, we only handle loop invariant properties
          //i.e. properties where the member expresssion does not involve any values written to inside the loop.
          let key = b.key;

          if (typeof key === "string" || key instanceof _index2.AbstractValue && !(key.mightNotBeString() && key.mightNotBeNumber())) {
            if (typeof key === "string") {
              pathNode = _index2.AbstractValue.createFromWidenedProperty(realm, rval, [b.object, new _index2.StringValue(realm, key)], (0, _generator.createOperationDescriptor)("WIDEN_PROPERTY"));
            } else {
              (0, _invariant.default)(key instanceof _index2.AbstractValue);
              pathNode = _index2.AbstractValue.createFromWidenedProperty(realm, rval, [b.object, key], (0, _generator.createOperationDescriptor)("WIDEN_PROPERTY"));
            } // The value of the property at the start of the loop needs to be written to the property
            // before the loop commences, otherwise the memberExpression will result in an undefined value.


            let generator = realm.generator;
            (0, _invariant.default)(generator !== undefined);
            let initVal = b.descriptor && b.descriptor.throwIfNotConcrete(realm).value || realm.intrinsics.empty;

            if (!(initVal instanceof _index2.EmptyValue)) {
              if (key === "length" && b.object instanceof _index2.ArrayValue) {// do nothing, the array length will already be initialized
              } else if (typeof key === "string") {
                generator.emitVoidExpression(rval.types, rval.values, [b.object, new _index2.StringValue(realm, key), initVal], (0, _generator.createOperationDescriptor)("WIDEN_PROPERTY_ASSIGNMENT"));
              } else {
                (0, _invariant.default)(key instanceof _index2.AbstractValue);
                generator.emitVoidExpression(rval.types, rval.values, [b.object, key, initVal], (0, _generator.createOperationDescriptor)("WIDEN_PROPERTY_ASSIGNMENT"));
              }
            }
          } else {
            throw new _errors.FatalError("todo: handle the case where key is an abstract value");
          }

          b.pathNode = pathNode;
        }

        result.value = pathNode;
      }

      return result;
    };

    return this.widenMaps(m1, m2, widen);
  }

  widenDescriptors(realm, d1, d2) {
    d2 = d2.throwIfNotConcrete(realm);

    if (d1 === undefined) {
      // d2 is a property written to only in the (n+1)th iteration
      if (!(0, _index.IsDataDescriptor)(realm, d2)) return d2; // accessor properties need not be widened.

      let dc = (0, _descriptors.cloneDescriptor)(d2);
      (0, _invariant.default)(dc !== undefined);
      let d2value = dc.value;
      (0, _invariant.default)(d2value !== undefined); // because IsDataDescriptor is true for d2/dc

      let dcValue = this.widenValues(realm, d2value, d2value);
      (0, _invariant.default)(dcValue instanceof _index2.Value);
      dc.value = dcValue;
      return dc;
    } else {
      d1 = d1.throwIfNotConcrete(realm);

      if ((0, _descriptors.equalDescriptors)(d1, d2)) {
        if (!(0, _index.IsDataDescriptor)(realm, d1)) return d1; // identical accessor properties need not be widened.
        // equalDescriptors plus IsDataDescriptor guarantee that both have value props and if you have a value prop is value is defined.

        let dc = (0, _descriptors.cloneDescriptor)(d1);
        (0, _invariant.default)(dc !== undefined);
        let d1value = d1.value;
        (0, _invariant.default)(d1value !== undefined);
        let d2value = d2.value;
        (0, _invariant.default)(d2value !== undefined);
        let dcValue = this.widenValues(realm, d1value, d2value);
        (0, _invariant.default)(dcValue instanceof _index2.Value);
        dc.value = dcValue;
        return dc;
      } //todo: #1174 if we get here, the loop body contains a call to create a property and different iterations
      // create them differently. That seems beyond what a fixpoint computation can reasonably handle without
      // losing precision. Report an error here.


      throw new _errors.FatalError();
    }
  } // If e2 is the result of a loop iteration starting with effects e1 and it has a subset of elements of e1,
  // then we have reached a fixed point and no further calls to widen are needed. e1/e2 represent a general
  // summary of the loop, regardless of how many iterations will be performed at runtime.


  containsEffects(e1, e2) {
    if (!this.containsResults(e1.result, e2.result)) return false;
    if (!this.containsBindings(e1.modifiedBindings, e2.modifiedBindings)) return false;
    if (!this.containsPropertyBindings(e1.modifiedProperties, e2.modifiedProperties, e1.createdObjects, e2.createdObjects)) return false;
    return true;
  }

  containsResults(result1, result2) {
    if (result1 instanceof _completions.SimpleNormalCompletion && result2 instanceof _completions.SimpleNormalCompletion) return this._containsValues(result1.value, result2.value);
    return false;
  }

  containsMap(m1, m2, f) {
    for (const [key1, val1] of m1.entries()) {
      if (val1 === undefined) continue; // deleted

      let val2 = m2.get(key1);
      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key

      if (!f(val1, val2)) return false;
    }

    for (const key2 of m2.keys()) {
      if (!m1.has(key2)) return false;
    }

    return true;
  }

  containsBindings(m1, m2) {
    let containsBinding = (b1, b2) => {
      if (b1 === undefined || b2 === undefined || b1.value === undefined || b2.value === undefined || !this._containsValues(b1.value, b2.value) || b1.hasLeaked !== b2.hasLeaked) {
        return false;
      }

      return true;
    };

    return this.containsMap(m1, m2, containsBinding);
  }

  containsPropertyBindings(m1, m2, c1, c2) {
    let containsPropertyBinding = (d1, d2) => {
      let v1, v2;

      if (d1 instanceof _descriptors.InternalSlotDescriptor || d2 instanceof _descriptors.InternalSlotDescriptor) {
        if (d1 !== undefined) {
          (0, _invariant.default)(d1 instanceof _descriptors.InternalSlotDescriptor);
          v1 = d1.value;
        }

        if (d2 !== undefined) {
          (0, _invariant.default)(d2 instanceof _descriptors.InternalSlotDescriptor);
          v2 = d2.value;
        }
      }

      if (d1 instanceof _descriptors.PropertyDescriptor) {
        v1 = d1.value;
      }

      if (d2 instanceof _descriptors.PropertyDescriptor) {
        v2 = d2.value;
      }

      if (v1 === undefined) {
        return v2 === undefined;
      }

      if (v1 instanceof _index2.Value && v2 instanceof _index2.Value) return this._containsValues(v1, v2);

      if (Array.isArray(v1) && Array.isArray(v2)) {
        return this._containsArray(v1, v2);
      }

      return v2 === undefined;
    };

    for (const [key1, val1] of m1.entries()) {
      if (val1 === undefined) continue; // deleted

      let val2 = m2.get(key1);
      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key

      if (c1.has(key1.object)) {
        continue;
      }

      if (!containsPropertyBinding(val1, val2)) return false;
    }

    for (const key2 of m2.keys()) {
      if (c2.has(key2.object)) {
        continue;
      }

      if (!m1.has(key2)) return false;
    }

    return true;
  }

  _containsArray(v1, v2) {
    let e = v1 && v1[0] || v2 && v2[0];
    if (e instanceof _index2.Value) return this.containsArraysOfValue(v1, v2);else return this._containsArrayOfsMapEntries(v1, v2);
  }

  _containsArrayOfsMapEntries(realm, a1, a2) {
    let empty = realm.intrinsics.empty;
    let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);

    for (let i = 0; i < n; i++) {
      let {
        $Key: key1,
        $Value: val1
      } = a1 && a1[i] || {
        $Key: empty,
        $Value: empty
      };
      let {
        $Key: key2,
        $Value: val2
      } = a2 && a2[i] || {
        $Key: empty,
        $Value: empty
      };

      if (key1 === undefined) {
        if (key2 !== undefined) return false;
      } else {
        if (key1 instanceof _index2.Value && key2 instanceof _index2.Value && key1.equals(key2)) {
          if (val1 instanceof _index2.Value && val2 instanceof _index2.Value && this._containsValues(val1, val2)) continue;
        }

        return false;
      }
    }

    return true;
  }

  containsArraysOfValue(realm, a1, a2) {
    let n = Math.max(a1 && a1.length || 0, a2 && a2.length || 0);

    for (let i = 0; i < n; i++) {
      let [val1, val2] = [a1 && a1[i], a2 && a2[i]];
      if (val1 instanceof _index2.Value && val2 instanceof _index2.Value && !this._containsValues(val1, val2)) return false;
    }

    return true;
  }

  _containsValues(val1, val2) {
    if (val1 instanceof _index2.AbstractValue) {
      if (!_index2.Value.isTypeCompatibleWith(val2.getType(), val1.getType()) && !_index2.Value.isTypeCompatibleWith(val1.getType(), val2.getType())) return false;
      return val1.values.containsValue(val2);
    }

    return val1.equals(val2);
  }

}

exports.WidenImplementation = WidenImplementation;
//# sourceMappingURL=widen.js.map

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concretize = concretize;

var _index = __webpack_require__(10);

var t = _interopRequireWildcard(__webpack_require__(21));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _errors = __webpack_require__(3);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * This file contains code that converts abstract models into concrete values.
 */
function reportCompileError(realm, message, loc) {
  let error = new _errors.CompilerDiagnostic(message, loc, "PP9000", "RecoverableError");
  realm.handleError(error);
}

function createEmptyFunction(realm) {
  const concreteFunction = new _index.ECMAScriptSourceFunctionValue(realm);
  concreteFunction.initialize([], t.blockStatement([]));
  return concreteFunction;
}
/**
 * Convert abstract model value into concrete value.
 */


function concretize(realm, val) {
  if (val instanceof _index.ConcreteValue) {
    return val;
  }

  (0, _invariant.default)(val instanceof _index.AbstractValue);

  if (val.kind === "abstractConcreteUnion") {
    (0, _invariant.default)(val.args.length >= 2);
    return concretize(realm, val.args[0]);
  }

  const type = val.types.getType();

  if (val.types.isTop()) {
    return new _index.UndefinedValue(realm);
  } else if (type.prototype instanceof _index.PrimitiveValue) {
    if (val.values.isTop()) {
      switch (type) {
        case _index.StringValue:
          return new _index.StringValue(realm, "__concreteModel");

        case _index.NumberValue:
          return new _index.NumberValue(realm, 42);

        case _index.SymbolValue:
          return new _index.SymbolValue(realm, new _index.StringValue(realm, "__concreteModel"));

        case _index.BooleanValue:
          return new _index.BooleanValue(realm, true);

        case _index.NullValue:
          return new _index.NullValue(realm);

        case _index.UndefinedValue:
          return new _index.UndefinedValue(realm);

        default:
          (0, _invariant.default)(false, "Not yet implemented");
      }
    } else {
      // TODO: This was broken. Is this actually used?
      const values = val.values.getElements();
      (0, _invariant.default)(values.size === 1, "Concrete model should only have one value");

      for (let value in values) {
        (0, _invariant.default)(value instanceof _index.ConcreteValue, "Concrete model should only contain one concrete value");
        return value;
      }

      (0, _invariant.default)(false);
    }
  } else if (type === _index.FunctionValue) {
    return createEmptyFunction(realm);
  } else if (type === _index.ArrayValue) {
    reportCompileError(realm, "Emitting a concrete model for abstract array value is not supported yet.", val.expressionLocation);
  } else if (val instanceof _index.AbstractObjectValue) {
    if (val.values.isTop()) {
      return new _index.ObjectValue(realm);
    } else {
      let template = val.getTemplate();

      let concreteObj = _singletons.Create.ObjectCreate(realm, template.$GetPrototypeOf());

      let keys = (0, _index2.EnumerableOwnProperties)(realm, template, "key", true);

      for (let P of keys) {
        (0, _invariant.default)(P instanceof _index.StringValue);
        let newElement = (0, _index2.Get)(realm, template, P);

        _singletons.Create.CreateDataProperty(realm, concreteObj, P, concretize(realm, newElement));
      }

      return concreteObj;
    }
  }

  reportCompileError(realm, "Emitting a concrete model for this abstract value is not supported yet.", val.expressionLocation); // Return undefined to make flow happy.

  return new _index.UndefinedValue(realm);
}
//# sourceMappingURL=ConcreteModelConverter.js.map

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebugReproManagerImplementation = void 0;

var _SourceMapManager = __webpack_require__(463);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/**
 * Manager that captures name of all original sourcefiles touched by Prepack.
 * When Prepack exits (regardless of success or failure), the list of all
 * relevant sourcefiles is passed back to the CLI to be included in the reproBundle.
 */
class DebugReproManagerImplementation {
  construct(configArgs) {
    this._sourceMapManager = new _SourceMapManager.SourceMapManager(configArgs.buckRoot, configArgs.sourcemaps);

    if (configArgs.sourcemaps) {
      this._sourceMapNames = [];
      configArgs.sourcemaps.forEach(m => {
        if (m.sourceMapFilename !== undefined) this._sourceMapNames.push(m.sourceMapFilename);
      });
    }

    this._usedSourceFiles = new Set();
    return this;
  } // Manager to translate between relative/absolute paths used by sourceMaps/Filesystem.


  addSourceFile(fileName) {
    if (!fileName.includes("node_modules")) this._usedSourceFiles.add(this._sourceMapManager.relativeToAbsolute(fileName));
  }

  getSourceFilePaths() {
    return Array.from(this._usedSourceFiles).map(absolutePath => {
      return {
        absolute: absolutePath,
        relative: this._sourceMapManager.absoluteToRelative(absolutePath)
      };
    });
  }

  getSourceMapPaths() {
    return this._sourceMapNames;
  }

}

exports.DebugReproManagerImplementation = DebugReproManagerImplementation;
//# sourceMappingURL=DebugReproManager.js.map

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SourceMapManager = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

/**
 * Sourcemap paths can come in one of two formats:
 *     - Relative: The paths include `../` and can be followed from the sourcemap's location
 *         to arrive at the original source's location. In this format, path conversion
 *         requires two different prefixes (MapDifference and CommonPrefix) that must be
 *         discovered from the input paths.
 *     - Common Directory: The paths take the format of an absolute path (`/foo/bar`) and
 *         assume there is a common prefix to the path that, when added, will make the path an
 *         valid absolute path. This prefix is passed in as the `buckRoot` argument.
 *     Example:
 *         In a directory structure with /A/B/map.js and /A/C/original.js,
 *         the sourcemaps would have the following path structures:
 *           - Relative: ../C/original.js, with `CP` = /A and 'MD' = ../
 *           - Common Directory: /C/original.js, with `buckRoot` = /A
 */
class SourceMapManager {
  constructor(buckRoot, sourceMaps) {
    // Use presence of buck root argument to indicate which path format sourcemap prefixes take on.
    if (buckRoot !== undefined) {
      if (sourceMaps === undefined) {
        throw new Error("Invalid input: Can't provide a sourcemap directory root without having sourcemaps present");
      }

      this._buckRoot = buckRoot;

      if (this._buckRoot[this._buckRoot.length - 1] === "/") {
        // Remove trailing slash to prepare for prepending to internal paths.
        this._buckRoot = this._buckRoot.slice(0, -1);
      }
    } else {
      // If sourcemaps don't exist, set prefixes to undefined and break.
      if (sourceMaps && sourceMaps.length > 0) {
        for (let map of sourceMaps) {
          if (map.sourceMapContents === undefined || map.sourceMapContents === "") {
            this._sourcemapCommonPrefix = undefined;
            this._sourcemapMapDifference = undefined;
            return;
          }
        }
      } else {
        this._sourcemapCommonPrefix = undefined;
        this._sourcemapMapDifference = undefined;
        return;
      } // Extract common prefix and map difference


      let originalSourcePaths = [];
      let mapPaths = [];

      for (let map of sourceMaps) {
        (0, _invariant.default)(map.sourceMapContents !== undefined); // Checked above.

        let parsed = JSON.parse(map.sourceMapContents); // Two formats for sourcemaps exist.

        if ("sections" in parsed) {
          for (let section of parsed.sections) {
            for (let source of section.map.sources) {
              originalSourcePaths.push(this._getAbsoluteSourcePath(map.filePath, source));
            }
          }
        } else {
          for (let source of parsed.sources) {
            originalSourcePaths.push(this._getAbsoluteSourcePath(map.filePath, source));
          }
        }

        mapPaths.push(this._stripEmptyStringBookends(map.filePath.split("/")));
      }

      let originalSourceCommonPrefix = this._findCommonPrefix(originalSourcePaths);

      let originalSourceCPElements = this._stripEmptyStringBookends(originalSourceCommonPrefix.split("/"));

      let mapCommonPrefix = this._findCommonPrefix(mapPaths);

      let mapCPElements = this._stripEmptyStringBookends(mapCommonPrefix.split("/"));

      this._sourcemapCommonPrefix = this._findCommonPrefix([originalSourceCPElements, mapCPElements]);
      this._sourcemapMapDifference = this._findMapDifference(this._sourcemapCommonPrefix, mapCommonPrefix);
    }
  } // Prefixes used to translate between relative paths stored in AST nodes and absolute paths given to IDE.


  // For paths relative to directory root. (Used in Buck format)

  /**
   * Assumes that input file and sourcemap are in the same directory.
   * Assumes pathToInput is an absolute path and pathToSource is relative.
   * Uses pathToSource to find absolute path of original source file.
   */
  _getAbsoluteSourcePath(pathToInput, pathToSource) {
    // pathToInput is an absolute path to the file being prepacked.
    let fullPath = this._stripEmptyStringBookends(pathToInput.split("/")); // Remove last entry because it is the filename, while we want the parent directory of the input file.


    fullPath.pop(); // Traverse the path to the source file.

    let steps = pathToSource.split("/");

    for (let step of steps) {
      switch (step) {
        case ".":
          break;

        case "..":
          fullPath.pop();
          break;

        default:
          fullPath.push(step);
          break;
      }
    }

    return fullPath;
  }
  /**
   * Finds the longest possible prefix common to all input paths.
   * Input paths must be absolute.
   * Input is nested array because each path must be separated into elements.
   */


  _findCommonPrefix(paths) {
    // Find the point at which the paths diverge.
    let divergenceIndex = 0;
    let allPathsMatch = true;
    let maxDivergenceIndex = Math.max(...paths.map(path => path.length));

    while (allPathsMatch && divergenceIndex < maxDivergenceIndex) {
      let entry = paths[0][divergenceIndex]; // Arbitrary choice of 0th path, since we're checking if all entires match.

      for (let path of paths) {
        if (path[divergenceIndex] !== entry) {
          allPathsMatch = false;
          break;
        }
      }

      if (allPathsMatch) divergenceIndex += 1;
    } // Edge case: if there's only one path, it will match itself, including the filename at the end.
    // For 2+ paths, even if they all share a prefix, the filenames will not match, so this is not needed.


    if (paths.length === 1) divergenceIndex -= 1; // Concatenate prefix into string that's bookended by slashes for use as an absolute path prefix.

    return `/${paths[0].slice(0, divergenceIndex).join("/")}/`;
  }
  /**
   * Finds the path that must be followed to arrive at the directory of the
   * common prefix from the sourcemap.
   */


  _findMapDifference(commonPrefix, mapPrefix) {
    // Find difference in path between the map's location and the common prefix.
    let mapPrefixUniqueElements = this._stripEmptyStringBookends(mapPrefix.replace(commonPrefix, "").split("/"));

    let mapDifference = "";

    for (let i = 0; i < mapPrefixUniqueElements.length; i++) {
      mapDifference = mapDifference.concat("../");
    }

    return mapDifference;
  }
  /**
   *  Takes in ["", "foo", "bar", ""] and returns ["foo", "bar"]
   */


  _stripEmptyStringBookends(path) {
    if (path[0] === "") path.shift();
    if (path[path.length - 1] === "") path.pop();
    return path;
  }
  /**
   * Used by DebugAdapter to convert relative paths (used internally in debugging/Prepack engine)
   * into absolute paths (used by debugging UI/IDE).
   */


  relativeToAbsolute(path) {
    let absolute;

    if (this._buckRoot !== undefined) {
      let dirRoot = this._buckRoot;

      if ( // If the "relative" path is actually absolute, then don't prepend anything.
      this._stripEmptyStringBookends(path.split("/"))[0] === this._stripEmptyStringBookends(this._buckRoot.split("/"))[0]) {
        absolute = path;
      } else {
        let separator = path[0] === "/" ? "" : "/";
        absolute = dirRoot + separator + path;
      }
    } else {
      if (this._sourcemapCommonPrefix !== undefined && this._sourcemapMapDifference !== undefined) {
        absolute = path.replace(this._sourcemapMapDifference, "");
        (0, _invariant.default)(this._sourcemapCommonPrefix !== undefined);
        absolute = this._sourcemapCommonPrefix + absolute;
      } else {
        absolute = path;
      }
    }

    return absolute;
  }
  /**
   * Used by DebugAdapter to convert absolute paths (used by debugging UI/IDE)
   * into relative paths (used internally in debugging/Prepack engine).
   */


  absoluteToRelative(path) {
    let relative;

    if (this._buckRoot !== undefined) {
      relative = path.replace(this._buckRoot, "");
    } else {
      if (this._sourcemapCommonPrefix !== undefined && this._sourcemapMapDifference !== undefined) {
        relative = path.replace(this._sourcemapCommonPrefix, "");
        (0, _invariant.default)(this._sourcemapMapDifference !== undefined);
        relative = this._sourcemapMapDifference + relative;
      } else {
        relative = path;
      }
    }

    return relative;
  }

}

exports.SourceMapManager = SourceMapManager;
//# sourceMappingURL=SourceMapManager.js.map

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialize = initialize;

var _index = __webpack_require__(15);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _Object = _interopRequireDefault(__webpack_require__(465));

var _ObjectPrototype = _interopRequireDefault(__webpack_require__(466));

var _Error = _interopRequireDefault(__webpack_require__(424));

var _ErrorPrototype = _interopRequireDefault(__webpack_require__(467));

var _TypeError = _interopRequireDefault(__webpack_require__(468));

var _TypeErrorPrototype = _interopRequireDefault(__webpack_require__(469));

var _RangeError = _interopRequireDefault(__webpack_require__(470));

var _RangeErrorPrototype = _interopRequireDefault(__webpack_require__(471));

var _ReferenceError = _interopRequireDefault(__webpack_require__(472));

var _ReferenceErrorPrototype = _interopRequireDefault(__webpack_require__(473));

var _SyntaxError = _interopRequireDefault(__webpack_require__(474));

var _SyntaxErrorPrototype = _interopRequireDefault(__webpack_require__(475));

var _URIError = _interopRequireDefault(__webpack_require__(476));

var _URIErrorPrototype = _interopRequireDefault(__webpack_require__(477));

var _EvalError = _interopRequireDefault(__webpack_require__(478));

var _EvalErrorPrototype = _interopRequireDefault(__webpack_require__(479));

var _Function = _interopRequireDefault(__webpack_require__(480));

var _FunctionPrototype = _interopRequireDefault(__webpack_require__(481));

var _Generator = _interopRequireDefault(__webpack_require__(482));

var _GeneratorFunction = _interopRequireDefault(__webpack_require__(483));

var _GeneratorPrototype = _interopRequireDefault(__webpack_require__(484));

var _Array = _interopRequireDefault(__webpack_require__(485));

var _ArrayPrototype = _interopRequireDefault(__webpack_require__(486));

var _Date = _interopRequireDefault(__webpack_require__(487));

var _DatePrototype = _interopRequireDefault(__webpack_require__(488));

var _RegExp = _interopRequireDefault(__webpack_require__(489));

var _RegExpPrototype = _interopRequireDefault(__webpack_require__(490));

var _Symbol = _interopRequireDefault(__webpack_require__(491));

var _SymbolPrototype = _interopRequireDefault(__webpack_require__(492));

var _String = _interopRequireDefault(__webpack_require__(493));

var _StringPrototype = _interopRequireDefault(__webpack_require__(494));

var _Number = _interopRequireDefault(__webpack_require__(495));

var _NumberPrototype = _interopRequireDefault(__webpack_require__(496));

var _Boolean = _interopRequireDefault(__webpack_require__(497));

var _BooleanPrototype = _interopRequireDefault(__webpack_require__(498));

var _DataView = _interopRequireDefault(__webpack_require__(499));

var _DataViewPrototype = _interopRequireDefault(__webpack_require__(500));

var _TypedArray = _interopRequireDefault(__webpack_require__(501));

var _TypedArrayPrototype = _interopRequireDefault(__webpack_require__(502));

var _Float32Array = _interopRequireDefault(__webpack_require__(503));

var _Float32ArrayPrototype = _interopRequireDefault(__webpack_require__(504));

var _Float64Array = _interopRequireDefault(__webpack_require__(505));

var _Float64ArrayPrototype = _interopRequireDefault(__webpack_require__(506));

var _Int8Array = _interopRequireDefault(__webpack_require__(507));

var _Int8ArrayPrototype = _interopRequireDefault(__webpack_require__(508));

var _Int16Array = _interopRequireDefault(__webpack_require__(509));

var _Int16ArrayPrototype = _interopRequireDefault(__webpack_require__(510));

var _Int32Array = _interopRequireDefault(__webpack_require__(511));

var _Int32ArrayPrototype = _interopRequireDefault(__webpack_require__(512));

var _Map = _interopRequireDefault(__webpack_require__(513));

var _MapPrototype = _interopRequireDefault(__webpack_require__(514));

var _WeakMap = _interopRequireDefault(__webpack_require__(515));

var _WeakMapPrototype = _interopRequireDefault(__webpack_require__(516));

var _Set = _interopRequireDefault(__webpack_require__(517));

var _SetPrototype = _interopRequireDefault(__webpack_require__(518));

var _Promise = _interopRequireDefault(__webpack_require__(519));

var _PromisePrototype = _interopRequireDefault(__webpack_require__(520));

var _Uint8Array = _interopRequireDefault(__webpack_require__(521));

var _Uint8ArrayPrototype = _interopRequireDefault(__webpack_require__(522));

var _Uint8ClampedArray = _interopRequireDefault(__webpack_require__(523));

var _Uint8ClampedArrayPrototype = _interopRequireDefault(__webpack_require__(524));

var _Uint16Array = _interopRequireDefault(__webpack_require__(525));

var _Uint16ArrayPrototype = _interopRequireDefault(__webpack_require__(526));

var _Uint32Array = _interopRequireDefault(__webpack_require__(527));

var _Uint32ArrayPrototype = _interopRequireDefault(__webpack_require__(528));

var _WeakSet = _interopRequireDefault(__webpack_require__(529));

var _WeakSetPrototype = _interopRequireDefault(__webpack_require__(530));

var _ArrayBuffer = _interopRequireDefault(__webpack_require__(531));

var _ArrayBufferPrototype = _interopRequireDefault(__webpack_require__(532));

var _JSON = _interopRequireDefault(__webpack_require__(533));

var _Reflect = _interopRequireDefault(__webpack_require__(536));

var _Math = _interopRequireDefault(__webpack_require__(537));

var _Proxy = _interopRequireDefault(__webpack_require__(538));

var _parseInt = _interopRequireDefault(__webpack_require__(540));

var _parseFloat = _interopRequireDefault(__webpack_require__(541));

var _isFinite = _interopRequireDefault(__webpack_require__(542));

var _decodeURI = _interopRequireDefault(__webpack_require__(543));

var _decodeURIComponent = _interopRequireDefault(__webpack_require__(544));

var _encodeURI = _interopRequireDefault(__webpack_require__(545));

var _encodeURIComponent = _interopRequireDefault(__webpack_require__(546));

var _eval = _interopRequireDefault(__webpack_require__(547));

var _isNaN = _interopRequireDefault(__webpack_require__(548));

var _ArrayIteratorPrototype = _interopRequireDefault(__webpack_require__(549));

var _StringIteratorPrototype = _interopRequireDefault(__webpack_require__(550));

var _MapIteratorPrototype = _interopRequireDefault(__webpack_require__(551));

var _SetIteratorPrototype = _interopRequireDefault(__webpack_require__(552));

var _IteratorPrototype = _interopRequireDefault(__webpack_require__(553));

var _ArrayProto_values = _interopRequireDefault(__webpack_require__(554));

var _ArrayProto_toString = _interopRequireDefault(__webpack_require__(555));

var _ObjectProto_toString = _interopRequireDefault(__webpack_require__(556));

var _TypedArrayProto_values = _interopRequireDefault(__webpack_require__(557));

var _ThrowTypeError = _interopRequireDefault(__webpack_require__(558));

var _IntrospectionError = _interopRequireDefault(__webpack_require__(559));

var _IntrospectionErrorPrototype = _interopRequireDefault(__webpack_require__(560));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function initialize(i, realm) {
  i.undefined = new _index2.UndefinedValue(realm);
  i.empty = new _index2.EmptyValue(realm);
  i.null = new _index2.NullValue(realm);
  i.false = new _index2.BooleanValue(realm, false);
  i.true = new _index2.BooleanValue(realm, true);
  i.NaN = new _index2.NumberValue(realm, NaN);
  i.negativeInfinity = new _index2.NumberValue(realm, -Infinity);
  i.Infinity = new _index2.NumberValue(realm, +Infinity);
  i.negativeZero = new _index2.NumberValue(realm, -0);
  i.zero = new _index2.NumberValue(realm, +0);
  i.emptyString = new _index2.StringValue(realm, ""); //

  i.ObjectPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Object.prototype");
  i.FunctionPrototype = i.ObjectPrototype;
  i.FunctionPrototype = new _index2.NativeFunctionValue(realm, "Function.prototype", "", 0, context => i.undefined, false);
  i.parseFloat = (0, _parseFloat.default)(realm);
  i.parseInt = (0, _parseInt.default)(realm);
  i.SymbolPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Symbol.prototype"); // initialize common symbols

  i.SymbolIsConcatSpreadable = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.isConcatSpreadable"), "Symbol.isConcatSpreadable");
  i.SymbolSpecies = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.species"), "Symbol.species");
  i.SymbolReplace = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.replace"), "Symbol.replace");
  i.SymbolIterator = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.iterator"), "Symbol.iterator");
  i.SymbolHasInstance = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.hasInstance"), "Symbol.hasInstance");
  i.SymbolToPrimitive = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.toPrimitive"), "Symbol.toPrimitive");
  i.SymbolToStringTag = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.toStringTag"), "Symbol.toStringTag");
  i.SymbolMatch = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.match"), "Symbol.match");
  i.SymbolSplit = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.split"), "Symbol.split");
  i.SymbolSearch = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.search"), "Symbol.search");
  i.SymbolUnscopables = new _index2.SymbolValue(realm, new _index2.StringValue(realm, "Symbol.unscopables"), "Symbol.unscopables"); //

  i.ArrayProto_values = (0, _ArrayProto_values.default)(realm);
  i.ArrayProto_toString = (0, _ArrayProto_toString.default)(realm); //

  i.ObjectProto_toString = (0, _ObjectProto_toString.default)(realm); //

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) i.TypedArrayProto_values = (0, _TypedArrayProto_values.default)(realm); //

  i.ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Array.prototype");
  i.RegExpPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "RegExp.prototype");
  i.DatePrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Date.prototype");
  i.StringPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "String.prototype");
  i.BooleanPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Boolean.prototype");
  i.NumberPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Number.prototype");
  i.DataViewPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "DataView.prototype");
  i.PromisePrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Promise.prototype");
  i.ArrayBufferPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "ArrayBuffer.prototype"); // error prototypes

  i.ErrorPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Error.prototype");
  i.RangeErrorPrototype = new _index2.ObjectValue(realm, i.ErrorPrototype, "RangeError.prototype");
  i.TypeErrorPrototype = new _index2.ObjectValue(realm, i.ErrorPrototype, "TypeError.prototype");
  i.ReferenceErrorPrototype = new _index2.ObjectValue(realm, i.ErrorPrototype, "ReferenceError.prototype");
  i.URIErrorPrototype = new _index2.ObjectValue(realm, i.ErrorPrototype, "URIError.prototype");
  i.EvalErrorPrototype = new _index2.ObjectValue(realm, i.ErrorPrototype, "EvalError.prototype");
  i.SyntaxErrorPrototype = new _index2.ObjectValue(realm, i.ErrorPrototype, "SyntaxError.prototype");
  i.__IntrospectionErrorPrototype = new _index2.ObjectValue(realm, i.ErrorPrototype, "__IntrospectionError.prototype"); // collection prototypes

  i.MapPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Map.prototype");
  i.SetPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Set.prototype");
  i.WeakMapPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "WeakMap.prototype");

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    i.WeakSetPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "WeakSet.prototype");
  } // typed array prototypes


  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) i.TypedArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "TypedArray.prototype",
  /* refuseSerialization */
  true);
  i.Float32ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Float32Array.prototype");
  i.Float64ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Float64Array.prototype");
  i.Int8ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Int8Array.prototype");
  i.Int16ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Int16Array.prototype");
  i.Int32ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Int32Array.prototype");
  i.Uint8ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Uint8Array.prototype");
  i.Uint8ClampedArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Uint8ClampedArray.prototype");
  i.Uint16ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Uint16Array.prototype");
  i.Uint32ArrayPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "Uint32Array.prototype"); // iterator prototypes

  i.IteratorPrototype = new _index2.ObjectValue(realm, i.ObjectPrototype, "([][Symbol.iterator]().__proto__.__proto__)");
  i.MapIteratorPrototype = new _index2.ObjectValue(realm, i.IteratorPrototype, "(new Map()[Symbol.iterator]().__proto__)");
  i.SetIteratorPrototype = new _index2.ObjectValue(realm, i.IteratorPrototype, "(new Set()[Symbol.iterator]().__proto__)");
  i.ArrayIteratorPrototype = new _index2.ObjectValue(realm, i.IteratorPrototype, "([][Symbol.iterator]().__proto__)");
  i.StringIteratorPrototype = new _index2.ObjectValue(realm, i.IteratorPrototype, '(""[Symbol.iterator]().__proto__)'); //

  (0, _ObjectPrototype.default)(realm, i.ObjectPrototype);
  (0, _FunctionPrototype.default)(realm, i.FunctionPrototype);
  (0, _ArrayPrototype.default)(realm, i.ArrayPrototype);
  (0, _DatePrototype.default)(realm, i.DatePrototype);
  (0, _RegExpPrototype.default)(realm, i.RegExpPrototype);
  (0, _StringPrototype.default)(realm, i.StringPrototype);
  (0, _BooleanPrototype.default)(realm, i.BooleanPrototype);
  (0, _NumberPrototype.default)(realm, i.NumberPrototype);
  (0, _SymbolPrototype.default)(realm, i.SymbolPrototype);
  (0, _ErrorPrototype.default)(realm, i.ErrorPrototype);
  (0, _TypeErrorPrototype.default)(realm, i.TypeErrorPrototype);
  (0, _RangeErrorPrototype.default)(realm, i.RangeErrorPrototype);
  (0, _ReferenceErrorPrototype.default)(realm, i.ReferenceErrorPrototype);
  (0, _URIErrorPrototype.default)(realm, i.URIErrorPrototype);
  (0, _EvalErrorPrototype.default)(realm, i.EvalErrorPrototype);
  (0, _SyntaxErrorPrototype.default)(realm, i.SyntaxErrorPrototype);
  (0, _IntrospectionErrorPrototype.default)(realm, i.__IntrospectionErrorPrototype);
  (0, _DataViewPrototype.default)(realm, i.DataViewPrototype);
  (0, _WeakMapPrototype.default)(realm, i.WeakMapPrototype);

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    (0, _TypedArrayPrototype.default)(realm, i.TypedArrayPrototype);
    (0, _WeakSetPrototype.default)(realm, i.WeakSetPrototype);
  }

  (0, _Float32ArrayPrototype.default)(realm, i.Float32ArrayPrototype);
  (0, _Float64ArrayPrototype.default)(realm, i.Float64ArrayPrototype);
  (0, _Int8ArrayPrototype.default)(realm, i.Int8ArrayPrototype);
  (0, _Int16ArrayPrototype.default)(realm, i.Int16ArrayPrototype);
  (0, _Int32ArrayPrototype.default)(realm, i.Int32ArrayPrototype);
  (0, _MapPrototype.default)(realm, i.MapPrototype);
  (0, _SetPrototype.default)(realm, i.SetPrototype);
  (0, _PromisePrototype.default)(realm, i.PromisePrototype);
  (0, _Uint8ArrayPrototype.default)(realm, i.Uint8ArrayPrototype);
  (0, _Uint8ClampedArrayPrototype.default)(realm, i.Uint8ClampedArrayPrototype);
  (0, _Uint16ArrayPrototype.default)(realm, i.Uint16ArrayPrototype);
  (0, _Uint32ArrayPrototype.default)(realm, i.Uint32ArrayPrototype);
  (0, _ArrayBufferPrototype.default)(realm, i.ArrayBufferPrototype); // iterator prototypes

  (0, _IteratorPrototype.default)(realm, i.IteratorPrototype);
  (0, _ArrayIteratorPrototype.default)(realm, i.ArrayIteratorPrototype);
  (0, _StringIteratorPrototype.default)(realm, i.StringIteratorPrototype);
  (0, _MapIteratorPrototype.default)(realm, i.MapIteratorPrototype);
  (0, _SetIteratorPrototype.default)(realm, i.SetIteratorPrototype); //

  i.Object = (0, _Object.default)(realm);
  i.Function = (0, _Function.default)(realm);
  i.Array = (0, _Array.default)(realm);
  i.RegExp = (0, _RegExp.default)(realm);
  i.Date = (0, _Date.default)(realm);
  i.String = (0, _String.default)(realm);
  i.Math = (0, _Math.default)(realm);
  i.Boolean = (0, _Boolean.default)(realm);
  i.Number = (0, _Number.default)(realm);
  i.Symbol = (0, _Symbol.default)(realm);
  i.JSON = (0, _JSON.default)(realm);
  i.Proxy = (0, _Proxy.default)(realm);
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) i.Reflect = (0, _Reflect.default)(realm);
  i.Promise = (0, _Promise.default)(realm);
  i.DataView = (0, _DataView.default)(realm); // collections

  i.Set = (0, _Set.default)(realm);
  i.Map = (0, _Map.default)(realm);
  i.WeakMap = (0, _WeakMap.default)(realm);

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    i.WeakSet = (0, _WeakSet.default)(realm);
  }

  i.ArrayBuffer = (0, _ArrayBuffer.default)(realm); // typed arrays

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) i.TypedArray = (0, _TypedArray.default)(realm);
  i.Float32Array = (0, _Float32Array.default)(realm);
  i.Float64Array = (0, _Float64Array.default)(realm);
  i.Int8Array = (0, _Int8Array.default)(realm);
  i.Int16Array = (0, _Int16Array.default)(realm);
  i.Int32Array = (0, _Int32Array.default)(realm);
  i.Uint8Array = (0, _Uint8Array.default)(realm);
  i.Uint8ClampedArray = (0, _Uint8ClampedArray.default)(realm);
  i.Uint16Array = (0, _Uint16Array.default)(realm);
  i.Uint32Array = (0, _Uint32Array.default)(realm); //

  i.Error = (0, _Error.default)(realm);
  i.TypeError = (0, _TypeError.default)(realm);
  i.RangeError = (0, _RangeError.default)(realm);
  i.ReferenceError = (0, _ReferenceError.default)(realm);
  i.URIError = (0, _URIError.default)(realm);
  i.EvalError = (0, _EvalError.default)(realm);
  i.SyntaxError = (0, _SyntaxError.default)(realm);
  i.__IntrospectionError = (0, _IntrospectionError.default)(realm); //

  let builtins = ["Object", "Function", "Symbol", "String", "Array", "Boolean", "RegExp", "Date", "Error", "Number", "TypeError", "RangeError", "ReferenceError", "SyntaxError", "URIError", "EvalError", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Map", "Set", "WeakMap", "Promise", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "ArrayBuffer"];

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    builtins = builtins.concat(["WeakSet", "TypedArray"]);
  }

  for (let name of builtins) {
    let fn = i[name];
    let proto = i[`${name}Prototype`];
    proto.$DefineOwnProperty("constructor", new _descriptors.PropertyDescriptor({
      value: fn,
      writable: true,
      enumerable: false,
      configurable: true
    }));
    fn.$DefineOwnProperty("prototype", new _descriptors.PropertyDescriptor({
      value: proto,
      writable: false,
      enumerable: false,
      configurable: false
    }));
    fn.$DefineOwnProperty("constructor", new _descriptors.PropertyDescriptor({
      value: i.Function,
      writable: true,
      enumerable: false,
      configurable: true
    }));
  } //


  i.GeneratorPrototype = new _index2.ObjectValue(realm, i.FunctionPrototype, "Generator.prototype");
  (0, _GeneratorPrototype.default)(realm, i.GeneratorPrototype);
  i.Generator = new _index2.ObjectValue(realm, i.FunctionPrototype, "Generator");
  (0, _Generator.default)(realm, i.Generator);
  i.GeneratorFunction = (0, _GeneratorFunction.default)(realm);
  i.Generator.$DefineOwnProperty("prototype", new _descriptors.PropertyDescriptor({
    value: i.GeneratorPrototype,
    writable: false,
    enumerable: false,
    configurable: true
  }));
  i.GeneratorPrototype.$DefineOwnProperty("constructor", new _descriptors.PropertyDescriptor({
    value: i.Generator,
    writable: false,
    enumerable: false,
    configurable: true
  }));
  i.GeneratorFunction.$DefineOwnProperty("prototype", new _descriptors.PropertyDescriptor({
    value: i.Generator,
    writable: false,
    enumerable: false,
    configurable: false
  }));
  i.Generator.$DefineOwnProperty("constructor", new _descriptors.PropertyDescriptor({
    value: i.GeneratorFunction,
    writable: false,
    enumerable: false,
    configurable: true
  })); //

  i.isNaN = (0, _isNaN.default)(realm);
  i.isFinite = (0, _isFinite.default)(realm);
  i.decodeURI = (0, _decodeURI.default)(realm);
  i.decodeURIComponent = (0, _decodeURIComponent.default)(realm);
  i.encodeURI = (0, _encodeURI.default)(realm);
  i.encodeURIComponent = (0, _encodeURIComponent.default)(realm);
  i.ThrowTypeError = (0, _ThrowTypeError.default)(realm);
  i.eval = (0, _eval.default)(realm); // 8.2.2, step 12

  _singletons.Functions.AddRestrictedFunctionProperties(i.FunctionPrototype, realm); //


  if (realm.useAbstractInterpretation) {
    _index.TypesDomain.topVal = new _index.TypesDomain(undefined);
    _index.ValuesDomain.topVal = new _index.ValuesDomain(undefined);
    i.__topValue = new _index2.AbstractValue(realm, _index.TypesDomain.topVal, _index.ValuesDomain.topVal, Number.MAX_SAFE_INTEGER, []);
    _index.TypesDomain.bottomVal = new _index.TypesDomain(_index2.EmptyValue);
    _index.ValuesDomain.bottomVal = new _index.ValuesDomain(new Set());
    i.__bottomValue = new _index2.AbstractValue(realm, _index.TypesDomain.bottomVal, _index.ValuesDomain.bottomVal, Number.MIN_SAFE_INTEGER, []);
  }

  return i;
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(15);

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _index2 = __webpack_require__(10);

var _index3 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _generator = __webpack_require__(237);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
//import { AbruptCompletion } from "../../completions.js";
function snapshotToObjectAndRemoveProperties(to, delayedSources) {
  // If to has properties, we better remove them because after the temporal call to Object.assign we don't know their values anymore
  if (to.hasStringOrSymbolProperties()) {
    // Preserve them in a snapshot and add the snapshot to the sources
    delayedSources.push(to.getSnapshot({
      removeProperties: true
    }));
  }
}

function handleObjectAssignSnapshot(to, frm, frm_was_partial, delayedSources) {
  if (to instanceof _index2.AbstractObjectValue && to.values.isTop()) {
    // We don't know which objects to make partial and making all objects partial is failure in itself
    _index2.AbstractValue.reportIntrospectionError(to);

    throw new _errors.FatalError();
  } else {
    if (frm instanceof _index2.ObjectValue && frm.mightBeLeakedObject()) {
      // "frm" is leaked, so it might contain properties that potentially overwrite
      // properties already on the "to" object.
      snapshotToObjectAndRemoveProperties(to, delayedSources); // it's not safe to trust any of its values

      delayedSources.push(frm);
    } else if (frm_was_partial) {
      // "frm" is partial, so it might contain properties that potentially overwrite
      // properties already on the "to" object.
      snapshotToObjectAndRemoveProperties(to, delayedSources);

      if (frm instanceof _index2.AbstractObjectValue && frm.kind === "explicit conversion to object") {
        // Make it implicit again since it is getting delayed into an Object.assign call.
        delayedSources.push(frm.args[0]);
      } else {
        let frmSnapshot = frm.getSnapshot();
        frm.temporalAlias = frmSnapshot;
        frm.makePartial();
        delayedSources.push(frmSnapshot);
      }
    } else {
      return false;
    }
  }

  return true;
}

function copyKeys(realm, keys, from, to) {
  // c. Repeat for each element nextKey of keys in List order,
  for (let nextKey of keys) {
    // i. Let desc be ? from.[[GetOwnProperty]](nextKey).
    let desc = from.$GetOwnProperty(nextKey); // ii. If desc is not undefined and desc.[[Enumerable]] is true, then

    if (desc && desc.throwIfNotConcrete(realm).enumerable) {
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc); // 1. Let propValue be ? Get(from, nextKey).


      let propValue = (0, _index3.Get)(realm, from, nextKey); // 2. Perform ? Set(to, nextKey, propValue, true).

      _singletons.Properties.Set(realm, to, nextKey, propValue, true);
    }
  }
}

function applyObjectAssignSource(realm, nextSource, to, delayedSources, to_must_be_partial) {
  let keys, frm; // a. If nextSource is undefined or null, let keys be a new empty List.

  if ((0, _index3.HasSomeCompatibleType)(nextSource, _index2.NullValue, _index2.UndefinedValue)) {
    return to_must_be_partial;
  } // b. Else,
  // i. Let from be ToObject(nextSource).


  frm = _singletons.To.ToObject(realm, nextSource); // ii. Let keys be ? from.[[OwnPropertyKeys]]().

  let frm_was_partial = frm.isPartialObject();

  if (frm_was_partial) {
    if (!to.isSimpleObject() || !frm.isSimpleObject()) {
      // If an object is not a simple object, it may have getters on it that can
      // mutate any state as a result. We don't yet support this.
      _index2.AbstractValue.reportIntrospectionError(nextSource);

      throw new _errors.FatalError();
    }

    to_must_be_partial = true;
  }

  keys = frm.$OwnPropertyKeys(true);

  if (to_must_be_partial) {
    handleObjectAssignSnapshot(to, frm, frm_was_partial, delayedSources);
  } // c. Repeat for each element nextKey of keys in List order,


  (0, _invariant.default)(frm, "from required");
  (0, _invariant.default)(keys, "keys required");
  copyKeys(realm, keys, frm, to);
  return to_must_be_partial;
}

function tryAndApplySourceOrRecover(realm, nextSource, to, delayedSources, to_must_be_partial) {
  (0, _invariant.default)(!realm.instantRender.enabled);
  let effects;
  let savedSuppressDiagnostics = realm.suppressDiagnostics;

  try {
    realm.suppressDiagnostics = true;
    effects = realm.evaluateForEffects(() => {
      to_must_be_partial = applyObjectAssignSource(realm, nextSource, to, delayedSources, to_must_be_partial);
      return realm.intrinsics.undefined;
    }, undefined, "tryAndApplySourceOrRecover");
  } catch (e) {
    (0, _invariant.default)(nextSource !== realm.intrinsics.null && nextSource !== realm.intrinsics.undefined);

    let frm = _singletons.To.ToObject(realm, nextSource);

    if (e instanceof _errors.FatalError && to.isSimpleObject()) {
      to_must_be_partial = true;
      let frm_was_partial = frm.isPartialObject();
      let didSnapshot = handleObjectAssignSnapshot(to, frm, frm_was_partial, delayedSources);

      if (!didSnapshot) {
        delayedSources.push(frm);
      } // Leak the frm value because it can have getters on it


      _singletons.Leak.value(realm, frm);

      return to_must_be_partial;
    }

    throw e;
  } finally {
    realm.suppressDiagnostics = savedSuppressDiagnostics;
  }

  realm.applyEffects(effects);
  realm.returnOrThrowCompletion(effects.result);
  return to_must_be_partial;
}

function _default(realm) {
  // ECMA262 19.1.1.1
  let func = new _index2.NativeFunctionValue(realm, "Object", "Object", 1, (context, [value], argCount, NewTarget) => {
    // 1. If NewTarget is neither undefined nor the active function, then
    if (NewTarget && NewTarget !== func) {
      // a. Return ? OrdinaryCreateFromConstructor(NewTarget, "%ObjectPrototype%").
      return _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "ObjectPrototype");
    } // 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).


    if ((0, _index3.HasSomeCompatibleType)(value, _index2.NullValue, _index2.UndefinedValue)) {
      return _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);
    } // 3. Return ToObject(value).


    return _singletons.To.ToObject(realm, value);
  });

  function performConditionalObjectAssign(condValue, consequentVal, alternateVal, to, prefixSources, suffixSources) {
    // After applying a Object.assign on one path of the conditional value,
    // that path may have had snapshotting applied to the "to" value. If
    // that is the case and the other path has not had snapshotting applied
    // then we need to make sure we materialize out the properties of the object.
    let conditionallySnapshotted = false;

    const evaluateForEffects = (val, materializeIfSnapshottingIsConditional) => realm.evaluateForEffects(() => {
      let wasSnapshotedBeforehand = to instanceof _index2.ObjectValue && to.temporalAlias !== undefined;
      performObjectAssign(to, [...prefixSources, val, ...suffixSources]); // Check if snapshotting occured

      if (to instanceof _index2.ObjectValue) {
        if (materializeIfSnapshottingIsConditional && to.temporalAlias === undefined && conditionallySnapshotted) {
          // We don't really want to leak, but rather materialize the object
          // so we assign its bindings correctly.
          _singletons.Materialize.materializeObject(realm, to);
        } else if (!wasSnapshotedBeforehand && to.temporalAlias !== undefined && !conditionallySnapshotted) {
          conditionallySnapshotted = true;
        }
      }

      return realm.intrinsics.undefined;
    }, null, "performConditionalObjectAssign consequent"); // First evaluate both sides to see if snapshotting occurs on either side


    evaluateForEffects(consequentVal, false);
    evaluateForEffects(alternateVal, false); // Now evaluate both sides again, but this time materialize if snapshotting is
    // being used conditionally.

    realm.evaluateWithAbstractConditional(condValue, () => evaluateForEffects(consequentVal, true), () => evaluateForEffects(alternateVal, true));
  }

  function performObjectAssign(target, sources) {
    // 1. Let to be ? ToObject(target).
    let to = _singletons.To.ToObject(realm, target);

    let to_must_be_partial = false; // 2. If only one argument was passed, return to.

    if (!sources.length) return to; // Check if any sources are conditionals and if so, fork the work
    // into many subsequent objectAssign calls for each branch of the conditional

    for (let i = 0; i < sources.length; i++) {
      let nextSource = sources[i];

      if (nextSource instanceof _index2.AbstractValue) {
        if (nextSource.kind === "conditional") {
          let [condValue, consequentVal, alternateVal] = nextSource.args;
          (0, _invariant.default)(condValue instanceof _index2.AbstractValue);
          let prefixSources = sources.slice(0, i);
          let suffixSources = sources.slice(i + 1);
          performConditionalObjectAssign(condValue, consequentVal, alternateVal, to, prefixSources, suffixSources);
          return to;
        } else if (nextSource.kind === "||") {
          let [leftValue, rightValue] = nextSource.args;
          (0, _invariant.default)(leftValue instanceof _index2.AbstractValue);
          let prefixSources = sources.slice(0, i);
          let suffixSources = sources.slice(i + 1);
          performConditionalObjectAssign(leftValue, leftValue, rightValue, to, prefixSources, suffixSources);
          return to;
        } else if (nextSource.kind === "&&") {
          let [leftValue, rightValue] = nextSource.args;
          (0, _invariant.default)(leftValue instanceof _index2.AbstractValue);
          let prefixSources = sources.slice(0, i);
          let suffixSources = sources.slice(i + 1);
          performConditionalObjectAssign(leftValue, rightValue, leftValue, to, prefixSources, suffixSources);
          return to;
        }
      }
    } // 3. Let sources be the List of argument values starting with the second argument.


    sources;
    let delayedSources = []; // 4. For each element nextSource of sources, in ascending index order,

    for (let nextSource of sources) {
      if (realm.isInPureScope() && !realm.instantRender.enabled) {
        realm.evaluateWithPossibleThrowCompletion(() => {
          to_must_be_partial = tryAndApplySourceOrRecover(realm, nextSource, to, delayedSources, to_must_be_partial);
          return realm.intrinsics.undefined;
        }, _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
      } else {
        to_must_be_partial = applyObjectAssignSource(realm, nextSource, to, delayedSources, to_must_be_partial);
      }
    } // 5. Return to.


    if (to_must_be_partial) {
      // if to has properties, we copy and delay them (at this stage we do not need to remove them)
      if (to.hasStringOrSymbolProperties()) {
        let toSnapshot = to.getSnapshot();
        delayedSources.push(toSnapshot);
      }

      to.makePartial(); // We already established above that to is simple,
      // but now that it is partial we need to set the _isSimple flag.

      to.makeSimple();

      _index2.AbstractValue.createTemporalObjectAssign(realm, to, delayedSources);
    }

    return to;
  } // ECMA262 19.1.2.1


  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) {
    func.defineNativeMethod("assign", 2, (context, [target, ...sources]) => performObjectAssign(target, sources));
  } // ECMA262 19.1.2.2


  func.defineNativeMethod("create", 2, (context, [O, Properties]) => {
    // 1. If Type(O) is neither Object nor Null, throw a TypeError exception.
    if (!(0, _index3.HasSomeCompatibleType)(O, _index2.ObjectValue, _index2.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let obj be ObjectCreate(O).


    let obj = _singletons.Create.ObjectCreate(realm, O.throwIfNotConcrete()); // 3. If Properties is not undefined, then


    if (!Properties.mightBeUndefined()) {
      // a. Return ? ObjectDefineProperties(obj, Properties).
      return _singletons.Properties.ObjectDefineProperties(realm, obj, Properties);
    }

    Properties.throwIfNotConcrete(); // 4. Return obj.

    return obj;
  }); // ECMA262 19.1.2.3

  func.defineNativeMethod("defineProperties", 2, (context, [O, Properties]) => {
    // 1. Return ? ObjectDefineProperties(O, Properties).
    return _singletons.Properties.ObjectDefineProperties(realm, O, Properties);
  }); // ECMA262 19.1.2.4

  func.defineNativeMethod("defineProperty", 3, (context, [O, P, Attributes]) => {
    // 1. If Type(O) is not Object, throw a TypeError exception.
    if (!O.mightBeObject()) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    O = O.throwIfNotObject(); // 2. Let key be ? ToPropertyKey(P).

    let key = _singletons.To.ToPropertyKey(realm, P.throwIfNotConcrete()); // 3. Let desc be ? ToPropertyDescriptor(Attributes).


    let desc = _singletons.To.ToPropertyDescriptor(realm, Attributes); // 4. Perform ? DefinePropertyOrThrow(O, key, desc).


    _singletons.Properties.DefinePropertyOrThrow(realm, O, key, desc); // 4. Return O.


    return O;
  }); // ECMA262 19.1.2.5

  func.defineNativeMethod("freeze", 1, (context, [O]) => {
    // 1. If Type(O) is not Object, return O.
    if (!O.mightBeObject()) return O; // 2. Let status be ? SetIntegrityLevel(O, "frozen").

    O = O.throwIfNotConcreteObject();
    let status = (0, _index3.SetIntegrityLevel)(realm, O, "frozen"); // 3. If status is false, throw a TypeError exception.

    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Return O.


    return O;
  }); // ECMA262 19.1.2.6

  let getOwnPropertyDescriptor = func.defineNativeMethod("getOwnPropertyDescriptor", 2, (context, [O, P]) => {
    // 1. Let obj be ? ToObject(O).
    let obj = _singletons.To.ToObject(realm, O); // 2. Let key be ? ToPropertyKey(P).


    let key = _singletons.To.ToPropertyKey(realm, P.throwIfNotConcrete()); // 3. Let desc be ? obj.[[GetOwnProperty]](key).


    let desc = obj.$GetOwnProperty(key); // If we are returning a descriptor with a NativeFunctionValue
    // and it has no intrinsic name, then we create a temporal as this
    // can only be done at runtime

    if (desc instanceof _descriptors.PropertyDescriptor) {
      let getterFunc = desc.get;

      if (getterFunc instanceof _index2.NativeFunctionValue && getterFunc.intrinsicName === undefined && realm.useAbstractInterpretation) {
        (0, _invariant.default)(P instanceof _index2.Value); // this will create a property descriptor at runtime

        let result = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.ObjectValue, [getOwnPropertyDescriptor, obj, P], (0, _generator.createOperationDescriptor)("OBJECT_PROTO_GET_OWN_PROPERTY_DESCRIPTOR"));

        (0, _invariant.default)(result instanceof _index2.AbstractObjectValue);
        result.makeSimple();
        let get = (0, _index3.Get)(realm, result, "get");
        let set = (0, _index3.Get)(realm, result, "set");
        (0, _invariant.default)(get instanceof _index2.AbstractValue);
        (0, _invariant.default)(set instanceof _index2.AbstractValue);
        desc = new _descriptors.PropertyDescriptor({
          get,
          set,
          enumerable: false,
          configurable: true
        });
      }
    } // 4. Return FromPropertyDescriptor(desc).


    let propDesc = _singletons.Properties.FromPropertyDescriptor(realm, desc);

    return propDesc;
  }); // ECMA262 19.1.2.7

  func.defineNativeMethod("getOwnPropertyNames", 1, (context, [O]) => {
    // 1. Return ? GetOwnPropertyKeys(O, String).
    return (0, _index3.GetOwnPropertyKeys)(realm, O, _index2.StringValue);
  }); // ECMA262 19.1.2.8

  func.defineNativeMethod("getOwnPropertyDescriptors", 1, (context, [O]) => {
    // 1. Let obj be ? ToObject(O).
    let obj = _singletons.To.ToObject(realm, O); // 2. Let ownKeys be ? obj.[[OwnPropertyKeys]]().


    let ownKeys = obj.$OwnPropertyKeys(); // 3. Let descriptors be ! ObjectCreate(%ObjectPrototype%).

    let descriptors = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 4. Repeat, for each element key of ownKeys in List order,


    for (let key of ownKeys) {
      // a. Let desc be ? obj.[[GetOwnProperty]](key).
      let desc = obj.$GetOwnProperty(key);
      if (desc !== undefined) _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc); // b. Let descriptor be ! FromPropertyDescriptor(desc).

      let descriptor = _singletons.Properties.FromPropertyDescriptor(realm, desc); // c. If descriptor is not undefined, perform ! CreateDataProperty(descriptors, key, descriptor).


      if (!(descriptor instanceof _index2.UndefinedValue)) _singletons.Create.CreateDataProperty(realm, descriptors, key, descriptor);
    } // 5. Return descriptors.


    return descriptors;
  }); // ECMA262 19.1.2.9

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    let getOwnPropertySymbols = func.defineNativeMethod("getOwnPropertySymbols", 1, (context, [O]) => {
      if (O instanceof _index2.AbstractValue && realm.isInPureScope()) {
        let obj = O instanceof _index2.AbstractObjectValue ? O : _singletons.To.ToObject(realm, O);
        realm.callReportObjectGetOwnProperties(obj);
        return _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [getOwnPropertySymbols, obj], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));
      } else if (_index2.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O)) {
        realm.callReportObjectGetOwnProperties(O);
        return _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [getOwnPropertySymbols, O], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));
      } // Return ? GetOwnPropertyKeys(O, Symbol).


      return (0, _index3.GetOwnPropertyKeys)(realm, O, _index2.SymbolValue);
    });
  } // ECMA262 19.1.2.10


  func.defineNativeMethod("getPrototypeOf", 1, (context, [O]) => {
    // 1. Let obj be ? ToObject(O).
    let obj = _singletons.To.ToObject(realm, O); // 2. Return ? obj.[[GetPrototypeOf]]().


    return obj.$GetPrototypeOf();
  }); // ECMA262 19.1.2.11

  func.defineNativeMethod("is", 2, (context, [value1, value2]) => {
    // 1. Return SameValue(value1, value2).
    return new _index2.BooleanValue(realm, (0, _index3.SameValuePartial)(realm, value1, value2));
  }); // ECMA262 19.1.2.12

  func.defineNativeMethod("isExtensible", 1, (context, [O]) => {
    // 1. If Type(O) is not Object, return false.
    if (!O.mightBeObject()) return realm.intrinsics.false;
    O = O.throwIfNotObject(); // 2. Return ? IsExtensible(O).

    return new _index2.BooleanValue(realm, (0, _index3.IsExtensible)(realm, O));
  }); // ECMA262 19.1.2.13

  func.defineNativeMethod("isFrozen", 1, (context, [O]) => {
    // 1. If Type(O) is not Object, return true.
    if (!O.mightBeObject()) return realm.intrinsics.true; // 2. Return ? TestIntegrityLevel(O, "frozen").

    O = O.throwIfNotConcreteObject();
    return new _index2.BooleanValue(realm, (0, _index3.TestIntegrityLevel)(realm, O, "frozen"));
  }); // ECMA262 19.1.2.14

  func.defineNativeMethod("isSealed", 1, (context, [O]) => {
    // 1. If Type(O) is not Object, return true.
    if (!O.mightBeObject()) return realm.intrinsics.true; // 2. Return ? TestIntegrityLevel(O, "sealed").

    O = O.throwIfNotConcreteObject();
    return new _index2.BooleanValue(realm, (0, _index3.TestIntegrityLevel)(realm, O, "sealed"));
  }); // ECMA262 19.1.2.15

  let objectKeys = func.defineNativeMethod("keys", 1, (context, [O]) => {
    // 1. Let obj be ? ToObject(O).
    let obj = _singletons.To.ToObject(realm, O); // If we're in pure scope and the items are completely abstract,
    // then create an abstract temporal with an array kind


    if (realm.isInPureScope() && obj instanceof _index2.AbstractObjectValue) {
      let array = _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [objectKeys, obj], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));

      return array;
    } else if (_index2.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(obj)) {
      return _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [objectKeys, obj], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));
    } // 2. Let nameList be ? EnumerableOwnProperties(obj, "key").


    let nameList = (0, _index3.EnumerableOwnProperties)(realm, obj.throwIfNotConcreteObject(), "key"); // 3. Return CreateArrayFromList(nameList).

    return _singletons.Create.CreateArrayFromList(realm, nameList);
  }); // ECMA262 9.1.2.16

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    let objectValues = func.defineNativeMethod("values", 1, (context, [O]) => {
      // 1. Let obj be ? ToObject(O).
      let obj = _singletons.To.ToObject(realm, O);

      if (realm.isInPureScope()) {
        // If we're in pure scope and the items are completely abstract,
        // then create an abstract temporal with an array kind
        if (obj instanceof _index2.AbstractObjectValue) {
          let array = _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [objectValues, obj], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));

          return array;
        } else if (_index2.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(obj)) {
          return _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [objectValues, obj], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));
        }
      } // 2. Let nameList be ? EnumerableOwnProperties(obj, "value").


      let nameList = (0, _index3.EnumerableOwnProperties)(realm, obj.throwIfNotConcreteObject(), "value"); // 3. Return CreateArrayFromList(nameList).

      return _singletons.Create.CreateArrayFromList(realm, nameList);
    });
  } // ECMA262 19.1.2.17


  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    let objectEntries = func.defineNativeMethod("entries", 1, (context, [O]) => {
      // 1. Let obj be ? ToObject(O).
      let obj = _singletons.To.ToObject(realm, O); // If we're in pure scope and the items are completely abstract,
      // then create an abstract temporal with an array kind


      if (realm.isInPureScope() && obj instanceof _index2.AbstractObjectValue) {
        let array = _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [objectEntries, obj], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));

        return array;
      } else if (_index2.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(obj)) {
        return _index2.ArrayValue.createTemporalWithWidenedNumericProperty(realm, [objectEntries, obj], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"));
      } // 2. Let nameList be ? EnumerableOwnProperties(obj, "key+value").


      let nameList = (0, _index3.EnumerableOwnProperties)(realm, obj.throwIfNotConcreteObject(), "key+value"); // 3. Return CreateArrayFromList(nameList).

      return _singletons.Create.CreateArrayFromList(realm, nameList);
    });
  } // ECMA262 19.1.2.18


  func.defineNativeMethod("preventExtensions", 1, (context, [O]) => {
    // 1. If Type(O) is not Object, return O.
    if (!O.mightBeObject()) return O; // 2. Let status be ? O.[[PreventExtensions]]().

    O = O.throwIfNotConcreteObject();
    let status = O.$PreventExtensions(); // 3. If status is false, throw a TypeError exception.

    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Return O.


    return O;
  }); // ECMA262 19.1.2.19

  func.defineNativeMethod("seal", 1, (context, [O]) => {
    // 1. If Type(O) is not Object, return O.
    if (!O.mightBeObject()) return O; // 2. Let status be ? SetIntegrityLevel(O, "sealed").

    O = O.throwIfNotConcreteObject();
    let status = (0, _index3.SetIntegrityLevel)(realm, O, "sealed"); // 3. If status is false, throw a TypeError exception.

    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Return O.


    return O;
  }); // ECMA262 19.1.2.20

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("setPrototypeOf", 2, (context, [O, proto]) => {
    // 1. Let O be ? RequireObjectCoercible(O).
    O = (0, _index3.RequireObjectCoercible)(realm, O); // 2. If Type(proto) is neither Object nor Null, throw a TypeError exception.

    if (!(0, _index3.HasSomeCompatibleType)(proto, _index2.ObjectValue, _index2.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If Type(O) is not Object, return O.


    O = O.throwIfNotConcrete();
    if (!(O instanceof _index2.ObjectValue)) return O; // 4. Let status be ? O.[[SetPrototypeOf]](proto).

    let status = O.$SetPrototypeOf(proto); // 5. If status is false, throw a TypeError exception.

    if (status === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 6. Return O.


    return O;
  });
  return func;
}
//# sourceMappingURL=Object.js.map

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _abstract = __webpack_require__(233);

var _has = __webpack_require__(269);

var _call = __webpack_require__(234);

var _singletons = __webpack_require__(236);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index2 = __webpack_require__(15);

var _generator = __webpack_require__(237);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm, obj) {
  // ECMA262 19.1.3.2
  const ObjectPrototypeHasOwnPrototype = obj.defineNativeMethod("hasOwnProperty", 1, (context, [V]) => {
    // 1. Let P be ? ToPropertyKey(V).
    let P = _singletons.To.ToPropertyKey(realm, V.throwIfNotConcrete()); // The pure parts are wrapped with a recovery mode.


    try {
      // 2. Let O be ? ToObject(this value).
      let O = _singletons.To.ToObject(realm, context); // 3. Return ? HasOwnProperty(O, P).


      return new _index.BooleanValue(realm, (0, _has.HasOwnProperty)(realm, O, P));
    } catch (x) {
      if (realm.isInPureScope() && x instanceof _errors.FatalError) {
        // If we're in pure scope we can try to recover from any fatals by
        // leaving the call in place which we do by default, but we don't
        // have to leak the state of any arguments since this function is pure.
        // This also lets us define the return type properly.
        const key = typeof P === "string" ? new _index.StringValue(realm, P) : P;
        return realm.evaluateWithPossibleThrowCompletion(() => _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, [ObjectPrototypeHasOwnPrototype, context, key], (0, _generator.createOperationDescriptor)("OBJECT_PROTO_HAS_OWN_PROPERTY")), _index2.TypesDomain.topVal, _index2.ValuesDomain.topVal);
      }

      throw x;
    }
  }); // ECMA262 19.1.3.3

  obj.defineNativeMethod("isPrototypeOf", 1, (context, [V]) => {
    // 1. If Type(V) is not Object, return false.
    if (!V.mightBeObject()) return realm.intrinsics.false;
    V = V.throwIfNotConcreteObject(); // 2. Let O be ? ToObject(this value).

    let O = _singletons.To.ToObject(realm, context); // 3. Repeat


    while (true) {
      // a. Let V be ? V.[[GetPrototypeOf]]().
      V = V.$GetPrototypeOf(); // b. If V is null, return false.

      if (V instanceof _index.NullValue) return realm.intrinsics.false; // c. If SameValue(O, V) is true, return true.

      if ((0, _abstract.SameValuePartial)(realm, O, V) === true) return realm.intrinsics.true;
    }

    (0, _invariant.default)(false);
  }); // ECMA262 19.1.3.4

  obj.defineNativeMethod("propertyIsEnumerable", 1, (context, [V]) => {
    // 1. Let P be ? ToPropertyKey(V).
    let P = _singletons.To.ToPropertyKey(realm, V.throwIfNotConcrete()); // 2. Let O be ? ToObject(this value).


    let O = _singletons.To.ToObject(realm, context); // 3. Let desc be ? O.[[GetOwnProperty]](P).


    let desc = O.$GetOwnProperty(P); // 4. If desc is undefined, return false.

    if (!desc) return realm.intrinsics.false;

    _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc);

    desc = desc.throwIfNotConcrete(realm); // 5. Return the value of desc.[[Enumerable]].

    return desc.enumerable === undefined ? realm.intrinsics.undefined : new _index.BooleanValue(realm, desc.enumerable);
  }); // ECMA262 19.1.3.5

  obj.defineNativeMethod("toLocaleString", 0, context => {
    // 1. Let O be the this value.
    let O = context; // 2. Return ? Invoke(O, "toString").

    return (0, _call.Invoke)(realm, O, "toString");
  }); // ECMA262 19.1.3.6

  obj.defineNativeProperty("toString", realm.intrinsics.ObjectProto_toString); // ECMA262 19.1.3.7

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Return ? ToObject(this value).
    return _singletons.To.ToObject(realm, context);
  });
  obj.$DefineOwnProperty("__proto__", new _descriptors.PropertyDescriptor({
    // B.2.2.1.1
    get: new _index.NativeFunctionValue(realm, undefined, "get __proto__", 0, context => {
      // 1. Let O be ? ToObject(this value).
      let O = _singletons.To.ToObject(realm, context); // 2. Return ? O.[[GetPrototypeOf]]().


      return O.$GetPrototypeOf();
    }),
    // B.2.2.1.2
    set: new _index.NativeFunctionValue(realm, undefined, "set __proto__", 1, (context, [proto]) => {
      // 1. Let O be ? RequireObjectCoercible(this value).
      let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. If Type(proto) is neither Object nor Null, return undefined.

      if (!(0, _has.HasSomeCompatibleType)(proto, _index.ObjectValue, _index.NullValue)) return realm.intrinsics.undefined; // 3. If Type(O) is not Object, return undefined.

      if (!O.mightBeObject()) return realm.intrinsics.undefined;
      O = O.throwIfNotConcreteObject(); // 4. Let status be ? O.[[SetPrototypeOf]](proto).

      let status = O.$SetPrototypeOf(proto.throwIfNotConcrete()); // 5. If status is false, throw a TypeError exception.

      if (!status) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "couldn't set proto");
      } // 6. Return undefined.


      return realm.intrinsics.undefined;
    })
  }));
}
//# sourceMappingURL=ObjectPrototype.js.map

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.build = build;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  return build("Error", realm, obj);
}

function build(name, realm, obj) {
  // ECMA262 19.5.3.2
  obj.defineNativeProperty("message", realm.intrinsics.emptyString); // ECMA262 19.5.3.3

  obj.defineNativeProperty("name", new _index.StringValue(realm, name)); // ECMA262 19.5.3.4

  obj.defineNativeMethod("toString", 0, context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Let name be ? Get(O, "name").


    let nameValue = (0, _index2.Get)(realm, O, "name"); // 4. If name is undefined, let name be "Error"; otherwise let name be ? ToString(name).

    let nameString = nameValue instanceof _index.UndefinedValue ? "Error" : _singletons.To.ToStringPartial(realm, nameValue); // 5. Let msg be ? Get(O, "message").

    let msg = (0, _index2.Get)(realm, O, "message"); // 6. If msg is undefined, let msg be the empty String; otherwise let msg be ? ToString(msg).

    msg = msg instanceof _index.UndefinedValue ? "" : _singletons.To.ToStringPartial(realm, msg); // Note that in ES5, both name and msg are checked for emptiness in step 7,
    // which however is later dropped in ES6.
    // 7. If name is the empty String, return msg.

    if (nameString === "") return new _index.StringValue(realm, msg); // 8. If msg is the empty String, return name.

    if (msg === "") return new _index.StringValue(realm, nameString); // 9. Return the result of concatenating name, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and msg.

    return new _index.StringValue(realm, `${nameString}: ${msg}`);
  });
}
//# sourceMappingURL=ErrorPrototype.js.map

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _Error = __webpack_require__(424);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _Error.build)("TypeError", realm);
}
//# sourceMappingURL=TypeError.js.map

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  obj.defineNativeProperty("name", new _index.StringValue(realm, "TypeError"));
  obj.defineNativeProperty("message", realm.intrinsics.emptyString);
}
//# sourceMappingURL=TypeErrorPrototype.js.map

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _Error = __webpack_require__(424);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _Error.build)("RangeError", realm);
}
//# sourceMappingURL=RangeError.js.map

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  obj.defineNativeProperty("name", new _index.StringValue(realm, "RangeError"));
  obj.defineNativeProperty("message", realm.intrinsics.emptyString);
}
//# sourceMappingURL=RangeErrorPrototype.js.map

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _Error = __webpack_require__(424);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _Error.build)("ReferenceError", realm);
}
//# sourceMappingURL=ReferenceError.js.map

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  obj.defineNativeProperty("name", new _index.StringValue(realm, "ReferenceError"));
  obj.defineNativeProperty("message", realm.intrinsics.emptyString);
}
//# sourceMappingURL=ReferenceErrorPrototype.js.map

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _Error = __webpack_require__(424);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _Error.build)("SyntaxError", realm);
}
//# sourceMappingURL=SyntaxError.js.map

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  obj.defineNativeProperty("name", new _index.StringValue(realm, "SyntaxError"));
  obj.defineNativeProperty("message", realm.intrinsics.emptyString);
}
//# sourceMappingURL=SyntaxErrorPrototype.js.map

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _Error = __webpack_require__(424);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _Error.build)("URIError", realm);
}
//# sourceMappingURL=URIError.js.map

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  obj.defineNativeProperty("name", new _index.StringValue(realm, "URIError"));
  obj.defineNativeProperty("message", realm.intrinsics.emptyString);
}
//# sourceMappingURL=URIErrorPrototype.js.map

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _Error = __webpack_require__(424);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _Error.build)("EvalError", realm);
}
//# sourceMappingURL=EvalError.js.map

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  obj.defineNativeProperty("name", new _index.StringValue(realm, "EvalError"));
  obj.defineNativeProperty("message", realm.intrinsics.emptyString);
}
//# sourceMappingURL=EvalErrorPrototype.js.map

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 19.2.1
  let func = new _index.NativeFunctionValue(realm, "Function", "Function", 1, (context, _args, argCount, NewTarget) => {
    let args = _args; // 1. Let C be the active function object.

    let C = func; // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].

    args = argCount > 0 ? args : []; // 3. Return ? CreateDynamicFunction(C, NewTarget, "normal", args).

    return _singletons.Create.CreateDynamicFunction(realm, C, NewTarget, "normal", args);
  });
  return func;
}
//# sourceMappingURL=Function.js.map

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

var _index = __webpack_require__(10);

var _call = __webpack_require__(234);

var _get = __webpack_require__(230);

var _is = __webpack_require__(229);

var _has = __webpack_require__(269);

var _abstract = __webpack_require__(233);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 19.2.3
  obj.$Call = (thisArgument, argsList) => {
    return realm.intrinsics.undefined;
  }; // ECMA262 19.2.3


  obj.defineNativeProperty("length", realm.intrinsics.zero, {
    writable: false
  }); // ECMA262 19.2.3

  obj.defineNativeProperty("name", realm.intrinsics.emptyString, {
    writable: false
  }); // ECMA262 19.2.3.3

  obj.defineNativeMethod("call", 1, (func, [thisArg, ...argList]) => {
    // 1. If IsCallable(func) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, func) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable");
    } // 2. Let argList be a new empty List.
    // 3. If this method was called with more than one argument, then in left to right order,
    //    starting with the second argument, append each argument as the last element of argList.


    argList; // TODO #1008 4. Perform PrepareForTailCall().
    // 5. Return ? Call(func, thisArg, argList).

    return (0, _call.Call)(realm, func, thisArg, argList);
  });

  function conditionalFunctionApply(func, thisArg, condValue, consequentVal, alternateVal) {
    return realm.evaluateWithAbstractConditional(condValue, () => {
      return realm.evaluateForEffects(() => functionApply(func, thisArg, consequentVal), null, "conditionalFunctionApply consequent");
    }, () => {
      return realm.evaluateForEffects(() => functionApply(func, thisArg, alternateVal), null, "conditionalFunctionApply alternate");
    });
  }

  function functionApply(func, thisArg, argArray) {
    // 1. If IsCallable(func) is false, throw a TypeError exception.
    if ((0, _is.IsCallable)(realm, func) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not callable");
    } // 2. If argArray is null or undefined, then


    if ((0, _has.HasSomeCompatibleType)(argArray, _index.NullValue, _index.UndefinedValue)) {
      // TODO #1008 a. Perform PrepareForTailCall().
      // b. Return ? Call(func, thisArg).
      return (0, _call.Call)(realm, func, thisArg);
    }

    if (argArray instanceof _index.AbstractValue) {
      if (argArray.kind === "conditional") {
        let [condValue, consequentVal, alternateVal] = argArray.args;
        (0, _invariant.default)(condValue instanceof _index.AbstractValue);
        return conditionalFunctionApply(func, thisArg, condValue, consequentVal, alternateVal);
      } else if (argArray.kind === "||") {
        let [leftValue, rightValue] = argArray.args;
        (0, _invariant.default)(leftValue instanceof _index.AbstractValue);
        return conditionalFunctionApply(func, thisArg, leftValue, leftValue, rightValue);
      } else if (argArray.kind === "&&") {
        let [leftValue, rightValue] = argArray.args;
        (0, _invariant.default)(leftValue instanceof _index.AbstractValue);
        return conditionalFunctionApply(func, thisArg, leftValue, rightValue, leftValue);
      }
    } // 3. Let argList be ? CreateListFromArrayLike(argArray).


    let argList = _singletons.Create.CreateListFromArrayLike(realm, argArray); // TODO #1008 4. Perform PrepareForTailCall().
    // 5. Return ? Call(func, thisArg, argList).


    return (0, _call.Call)(realm, func, thisArg, argList);
  } // ECMA262 19.2.3.1


  obj.defineNativeMethod("apply", 2, (func, [thisArg, argArray]) => functionApply(func, thisArg, argArray)); // ECMA262 19.2.3.2

  obj.defineNativeMethod("bind", 1, (context, [thisArg, ...args]) => {
    // 1. Let Target be the realm value.
    let Target = context; // 2. If IsCallable(Target) is false, throw a TypeError exception.

    if ((0, _is.IsCallable)(realm, Target) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    (0, _invariant.default)(Target instanceof _index.ObjectValue); // 3. Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in order.

    args; // 4. Let F be ? BoundFunctionCreate(Target, thisArg, args).

    let F = _singletons.Functions.BoundFunctionCreate(realm, Target, thisArg, args); // 5. Let targetHasLength be ? HasOwnProperty(Target, "length").


    let targetHasLength = (0, _has.HasOwnProperty)(realm, Target, new _index.StringValue(realm, "length"));
    let L; // 6. If targetHasLength is true, then

    if (targetHasLength === true) {
      // a. Let targetLen be ? Get(Target, "length").
      let targetLen = (0, _get.Get)(realm, Target, new _index.StringValue(realm, "length")); // b. If Type(targetLen) is not Number, let L be 0.

      if (!targetLen.mightBeNumber()) {
        L = 0;
      } else {
        // c. Else,
        targetLen = targetLen.throwIfNotConcreteNumber(); // i. Let targetLen be ToInteger(targetLen).

        targetLen = _singletons.To.ToInteger(realm, targetLen); // ii. Let L be the larger of 0 and the result of targetLen minus the number of elements of args.

        L = Math.max(0, targetLen - args.length);
      }
    } else {
      // 7. Else let L be 0.
      L = 0;
    } // 8. Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor {[[Value]]: L, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).


    _singletons.Properties.DefinePropertyOrThrow(realm, F, "length", new _descriptors.PropertyDescriptor({
      value: new _index.NumberValue(realm, L),
      writable: false,
      enumerable: false,
      configurable: true
    })); // 9. Let targetName be ? Get(Target, "name").


    let targetName = (0, _get.Get)(realm, Target, new _index.StringValue(realm, "name")); // 10. If Type(targetName) is not String, let targetName be the empty string.

    if (!(targetName instanceof _index.StringValue)) targetName = realm.intrinsics.emptyString; // 11. Perform SetFunctionName(F, targetName, "bound").

    _singletons.Functions.SetFunctionName(realm, F, targetName, "bound"); // 12. Return F.


    return F;
  }); // ECMA262 19.2.3.6

  obj.defineNativeMethod(realm.intrinsics.SymbolHasInstance, 1, (context, [V]) => {
    // 1. Let F be the this value.
    let F = context; // 2. Return ? OrdinaryHasInstance(F, V).

    return new _index.BooleanValue(realm, (0, _abstract.OrdinaryHasInstance)(realm, F, V));
  }, {
    writable: false,
    configurable: false
  }); // ECMA262 19.2.3.5

  obj.defineNativeMethod("toString", 0, _context => {
    let context = _context.throwIfNotConcrete();

    if (context instanceof _index.NativeFunctionValue) {
      let name = context.name;

      if (name instanceof _index.AbstractValue) {
        return new _index.StringValue(realm, `function () {[native code]}`);
      } else {
        (0, _invariant.default)(typeof name === "string");
        return new _index.StringValue(realm, `function ${name}() { [native code] }`);
      }
    } else if (context instanceof _index.FunctionValue) {
      // TODO #1009: provide function source code
      return new _index.StringValue(realm, "function () { }");
    } else {
      // 3. Throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, new _index.StringValue(realm, "Function.prototype.toString is not generic"));
    }
  });
}
//# sourceMappingURL=FunctionPrototype.js.map

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 25.3.1.5
  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "GeneratorFunction"), {
    writable: false
  });
}
//# sourceMappingURL=Generator.js.map

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 25.2.1
  let func = new _index.NativeFunctionValue(realm, "GeneratorFunction", "GeneratorFunction", 1, (context, _args, argCount, NewTarget) => {
    let args = _args; // 1. Let C be the active function object.

    let C = func; // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].

    args = argCount > 0 ? args : []; // 3. Return ? CreateDynamicFunction(C, NewTarget, "generator", args).

    return _singletons.Create.CreateDynamicFunction(realm, C, NewTarget, "generator", args);
  });
  return func;
}
//# sourceMappingURL=GeneratorFunction.js.map

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _generator = __webpack_require__(235);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 25.3.1.2
  obj.defineNativeMethod("next", 1, (context, [value]) => {
    // 1. Let g be the this value.
    let g = context; // 2. Return ? GeneratorResume(g, value).

    return (0, _generator.GeneratorResume)(realm, g, value);
  }); // ECMA262 25.3.1.3

  obj.defineNativeMethod("return", 1, (context, [value]) => {
    // 1. Let g be the this value.
    let g = context; // 2. Let C be Completion{[[Type]]: return, [[Value]]: value, [[Target]]: empty}.

    let C = new _completions.ReturnCompletion(value, realm.currentLocation); // 3. Return ? GeneratorResumeAbrupt(g, C).

    return (0, _generator.GeneratorResumeAbrupt)(realm, g, C);
  }); // ECMA262 25.3.1.4

  obj.defineNativeMethod("throw", 1, (context, [exception]) => {
    // 1. Let g be the this value.
    let g = context; // 2. Let C be Completion{[[Type]]: throw, [[Value]]: exception, [[Target]]: empty}.

    let C = new _completions.ReturnCompletion(exception, realm.currentLocation); // 3. Return ? GeneratorResumeAbrupt(g, C).

    return (0, _generator.GeneratorResumeAbrupt)(realm, g, C);
  }); // ECMA262 25.3.1.5

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Generator"), {
    writable: false
  });
}
//# sourceMappingURL=GeneratorPrototype.js.map

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _iterator = __webpack_require__(272);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm) {
  let func = new _index.NativeFunctionValue(realm, "Array", "Array", 1, (context, [...items], argCount, NewTarget) => {
    if (argCount === 0) {
      // 1. Let numberOfArgs be the number of arguments passed to this function call.
      let numberOfArgs = argCount; // 2. Assert: numberOfArgs = 0.

      (0, _invariant.default)(numberOfArgs === 0, "numberOfArgs = 0"); // 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.

      let newTarget = NewTarget === undefined ? func : NewTarget; // 4. Let proto be ? GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%").

      let proto = (0, _index2.GetPrototypeFromConstructor)(realm, newTarget, "ArrayPrototype"); // 5. Return ArrayCreate(0, proto).

      return _singletons.Create.ArrayCreate(realm, 0, proto);
    } else if (argCount === 1) {
      // 1. Let numberOfArgs be the number of arguments passed to this function call.
      let numberOfArgs = argCount; // 2. Assert: numberOfArgs = 1.

      (0, _invariant.default)(numberOfArgs === 1, "numberOfArgs = 1"); // 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.

      let newTarget = NewTarget === undefined ? func : NewTarget; // 4. Let proto be ? GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%").

      let proto = (0, _index2.GetPrototypeFromConstructor)(realm, newTarget, "ArrayPrototype"); // 5. Let array be ArrayCreate(0, proto).

      let array = _singletons.Create.ArrayCreate(realm, 0, proto); // 6. If Type(len) is not Number, then


      let len = items[0];
      (0, _invariant.default)(len !== undefined);
      let intLen;

      if (!len.mightBeNumber()) {
        // a. Let defineStatus be CreateDataProperty(array, "0", len).
        let defineStatus = _singletons.Create.CreateDataProperty(realm, array, "0", len); // b. Assert: defineStatus is true.


        (0, _invariant.default)(defineStatus, "defineStatus is true"); // c. Let intLen be 1.

        intLen = 1;
      } else {
        // 7. Else,
        // a. Let intLen be ToUint32(len).
        intLen = _singletons.To.ToUint32(realm, len.throwIfNotConcreteNumber());
        (0, _invariant.default)(len instanceof _index.NumberValue); // b If intLen  len, throw a RangeError exception.

        if (intLen !== len.value) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "intLen  len");
        }
      } // 8. Perform ! Set(array, "length", intLen, true).


      _singletons.Properties.Set(realm, array, "length", new _index.NumberValue(realm, intLen), true); // 9. Return array.


      return array;
    } else {
      // 1. Let numberOfArgs be the number of arguments passed to this function call.
      let numberOfArgs = argCount; // 2. Assert: numberOfArgs  2.

      (0, _invariant.default)(numberOfArgs >= 2, "numberOfArgs >= 2"); // 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.

      let newTarget = NewTarget === undefined ? func : NewTarget; // 4. Let proto be ? GetPrototypeFromConstructor(newTarget, "%ArrayPrototype%").

      let proto = (0, _index2.GetPrototypeFromConstructor)(realm, newTarget, "ArrayPrototype"); // 5. Let array be ? ArrayCreate(numberOfArgs, proto).

      let array = _singletons.Create.ArrayCreate(realm, numberOfArgs, proto); // 6. Let k be 0.


      let k = 0; // 7. Let items be a zero-origined List containing the argument items in order.

      items; // 8. Repeat, while k < numberOfArgs

      while (k < numberOfArgs) {
        // a. Let Pk be ! ToString(k).
        let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let itemK be items[k].


        let itemK = items[k];
        (0, _invariant.default)(itemK !== undefined); // c. Let defineStatus be CreateDataProperty(array, Pk, itemK).

        let defineStatus = _singletons.Create.CreateDataProperty(realm, array, Pk, itemK); // d. Assert: defineStatus is true.


        (0, _invariant.default)(defineStatus, "defineStatus is true"); // e. Increase k by 1.

        k += 1;
      } // 9. Assert: the value of array's length property is numberOfArgs.


      let length = (0, _index2.Get)(realm, array, "length").throwIfNotConcrete();
      (0, _invariant.default)(length instanceof _index.NumberValue);
      (0, _invariant.default)(length.value === numberOfArgs, "the value of array's length property is numberOfArgs"); // 10. Return array.

      return array;
    }
  }); // ECMA262 22.1.2.2

  func.defineNativeMethod("isArray", 1, (context, [arg]) => {
    // 1. Return ? IsArray(arg).
    return new _index.BooleanValue(realm, (0, _index2.IsArray)(realm, arg));
  }); // ECMA262 22.1.2.3

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("of", 0, (context, [...items], argCount) => {
    // 1. Let len be the actual number of arguments passed to this function.
    let len = argCount; // 2. Let items be the List of arguments passed to this function.

    items; // 3. Let C be the this value.

    let C = context; // 4. If IsConstructor(C) is true, then

    let A;

    if ((0, _index2.IsConstructor)(realm, C)) {
      (0, _invariant.default)(C instanceof _index.ObjectValue); // a. Let A be ? Construct(C,  len ).

      A = (0, _index2.Construct)(realm, C, [new _index.NumberValue(realm, len)]);
    } else {
      // 5. Else,
      // a. Let A be ? ArrayCreate(len).
      A = _singletons.Create.ArrayCreate(realm, len);
    } // 6. Let k be 0.


    let k = 0; // 7. Repeat, while k < len

    while (k < len) {
      // a. Let kValue be items[k].
      let kValue = items[k]; // b. Let Pk be ! To.ToString(k).

      let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // c. Perform ? CreateDataPropertyOrThrow(A, Pk, kValue).


      _singletons.Create.CreateDataPropertyOrThrow(realm, A, Pk, kValue); // d. Increase k by 1.


      k += 1;
    } // 8. Perform ? Set(A, "length", len, true).


    _singletons.Properties.Set(realm, A, "length", new _index.NumberValue(realm, len), true); // 9. Return A.


    return A;
  }); // ECMA262 22.1.2.1

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) {
    let arrayFrom = func.defineNativeMethod("from", 1, (context, [items, mapfn, thisArg], argCount) => {
      // 1. Let C be the this value.
      let C = context;
      let mapping, T; // 2. If mapfn is undefined, let mapping be false.

      if (!mapfn || mapfn instanceof _index.UndefinedValue) {
        mapping = false;
      } else if (mapfn.mightBeUndefined()) {
        (0, _invariant.default)(mapfn instanceof _index.AbstractValue);
        mapfn.throwIfNotConcrete();
      } else {
        // 3. Else,
        // a. If IsCallable(mapfn) is false, throw a TypeError exception.
        if ((0, _index2.IsCallable)(realm, mapfn) === false) {
          mapfn.throwIfNotConcrete();
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(mapfn) is false");
        } // b. If thisArg was supplied, let T be thisArg; else let T be undefined.


        T = thisArg !== undefined ? thisArg : realm.intrinsics.undefined; // c. Let mapping be true.

        mapping = true;
      } // If we're in pure scope and the items are completely abstract,
      // then create an abstract temporal with an array kind


      if (realm.isInPureScope() && items instanceof _index.AbstractValue && items.values.isTop()) {
        let args = [arrayFrom, items];
        let possibleNestedOptimizedFunctions;

        if (mapfn) {
          args.push(mapfn);

          if (thisArg) {
            args.push(thisArg);
          }

          possibleNestedOptimizedFunctions = [{
            func: mapfn,
            thisValue: thisArg || realm.intrinsics.undefined,
            kind: "map"
          }];
        }

        _singletons.Leak.value(realm, items);

        return _index.ArrayValue.createTemporalWithWidenedNumericProperty(realm, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_CALL"), possibleNestedOptimizedFunctions);
      } // 4. Let usingIterator be ? GetMethod(items, @@iterator).


      let usingIterator = (0, _index2.GetMethod)(realm, items, realm.intrinsics.SymbolIterator); // 5. If usingIterator is not undefined, then

      if (!usingIterator.mightBeUndefined()) {
        let A; // a. If IsConstructor(C) is true, then

        if ((0, _index2.IsConstructor)(realm, C)) {
          (0, _invariant.default)(C instanceof _index.ObjectValue); // i. Let A be ? Construct(C).

          A = (0, _index2.Construct)(realm, C);
        } else {
          // b. Else,
          // i. Let A be ArrayCreate(0).
          A = _singletons.Create.ArrayCreate(realm, 0);
        } // c. Let iterator be ? GetIterator(items, usingIterator).


        let iterator = (0, _iterator.GetIterator)(realm, items, usingIterator); // d. Let k be 0.

        let k = 0; // e. Repeat

        while (true) {
          // i. If k  2^53-1, then
          if (k >= Math.pow(2, 53) - 1) {
            // 1. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.
            let error = realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "k >= 2^53 - 1"); // 2. Return ? IteratorClose(iterator, error).

            throw (0, _iterator.IteratorClose)(realm, iterator, error);
          } // ii. Let Pk be ! ToString(k).


          let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // iii. Let next be ? IteratorStep(iterator).


          let next = (0, _iterator.IteratorStep)(realm, iterator); // iv. If next is false, then

          if (next === false) {
            // 1. Perform ? Set(A, "length", k, true).
            _singletons.Properties.Set(realm, A, "length", new _index.NumberValue(realm, k), true); // 2. Return A.


            return A;
          } // v. Let nextValue be ? IteratorValue(next).


          let nextValue = (0, _iterator.IteratorValue)(realm, next);
          let mappedValue; // vi. If mapping is true, then

          if (mapping === true) {
            // 1. Let mappedValue be Call(mapfn, T,  nextValue, k ).
            try {
              (0, _invariant.default)(T !== undefined);
              mappedValue = (0, _index2.Call)(realm, mapfn, T, [nextValue, new _index.NumberValue(realm, k)]);
            } catch (mappedValueCompletion) {
              if (mappedValueCompletion instanceof _completions.AbruptCompletion) {
                // 2. If mappedValue is an abrupt completion, return ? IteratorClose(iterator, mappedValue).
                throw (0, _iterator.IteratorClose)(realm, iterator, mappedValueCompletion);
              } else {
                throw mappedValueCompletion;
              }
            } // 3. Let mappedValue be mappedValue.[[Value]].

          } else {
            // vii. Else, let mappedValue be nextValue.
            mappedValue = nextValue;
          } // viii. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).


          try {
            _singletons.Create.CreateDataPropertyOrThrow(realm, A, Pk, mappedValue);
          } catch (completion) {
            if (completion instanceof _completions.AbruptCompletion) {
              // ix. If defineStatus is an abrupt completion, return ? IteratorClose(iterator, defineStatus).
              throw (0, _iterator.IteratorClose)(realm, iterator, completion);
            } else throw completion;
          } // x. Increase k by 1.


          k = k + 1;
        }
      } else {
        usingIterator.throwIfNotConcrete();
      } // 6. NOTE: items is not an Iterable so assume it is an array-like object.


      items = items.throwIfNotConcrete();
      (0, _invariant.default)(items instanceof _index.ObjectValue); // 7. Let arrayLike be ! ToObject(items).

      let arrayLike = _singletons.To.ToObject(realm, items); // 8. Let len be ? ToLength(? Get(arrayLike, "length")).


      let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, arrayLike, "length"));

      let A; // 9. If IsConstructor(C) is true, then

      if ((0, _index2.IsConstructor)(realm, C)) {
        (0, _invariant.default)(C instanceof _index.ObjectValue); // a. Let A be ? Construct(C,  len ).

        A = (0, _index2.Construct)(realm, C, [new _index.NumberValue(realm, len)]);
      } else {
        // 10. Else,
        // a. Let A be ? ArrayCreate(len).
        A = _singletons.Create.ArrayCreate(realm, len);
      } // 11. Let k be 0.


      let k = 0; // 12. Repeat, while k < len

      while (k < len) {
        // a. Let Pk be ! ToString(k).
        let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let kValue be ? Get(arrayLike, Pk).


        let kValue = (0, _index2.Get)(realm, arrayLike, Pk);
        let mappedValue; // c. If mapping is true, then

        if (mapping === true) {
          // i. Let mappedValue be ? Call(mapfn, T,  kValue, k ).
          (0, _invariant.default)(T !== undefined);
          mappedValue = (0, _index2.Call)(realm, mapfn, T, [kValue, new _index.NumberValue(realm, k)]);
        } else {
          // d. Else, let mappedValue be kValue.
          mappedValue = kValue;
        } // e. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).


        _singletons.Create.CreateDataPropertyOrThrow(realm, A, new _index.StringValue(realm, Pk), mappedValue); // f. Increase k by 1.


        k = k + 1;
      } // 13. Perform ? Set(A, "length", len, true).


      _singletons.Properties.Set(realm, A, "length", new _index.NumberValue(realm, len), true); // 14. Return A.


      return A;
    });
  } // ECMA262 22.1.2.5


  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });
  return func;
}
//# sourceMappingURL=Array.js.map

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _abstract = __webpack_require__(233);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm, obj) {
  // ECMA262 22.1.3.31
  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.ArrayProto_values); // ECMA262 22.1.3

  obj.defineNativeProperty("length", realm.intrinsics.zero); // ECMA262 22.1.3.1

  obj.defineNativeMethod("concat", 1, (context, args, argCount) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context);

    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("concat") === undefined) {
      let newArgs = [O, new _index.StringValue(realm, "concat"), ...args];
      return _index.ArrayValue.createTemporalWithWidenedNumericProperty(realm, newArgs, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let A be ? ArraySpeciesCreate(O, 0).


    let A = _singletons.Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), 0); // 3. Let n be 0.


    let n = 0; // 4. Let items be a List whose first element is O and whose subsequent elements are, in left to right
    //    order, the arguments that were passed to this function invocation.

    let items = argCount === 0 ? [O] : [O, ...args]; // 5. Repeat, while items is not empty

    while (items.length) {
      // a. Remove the first element from items and let E be the value of the element.
      let E = items.shift(); // b. Let spreadable be ? IsConcatSpreadable(E).

      let spreadable = (0, _index2.IsConcatSpreadable)(realm, E); // c. If spreadable is true, then

      if (spreadable) {
        E = E.throwIfNotConcreteObject(); // i. Let k be 0.

        let k = 0; // ii. Let len be ? ToLength(? Get(E, "length")).

        let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, E, "length")); // ii. If n + len > 2^53-1, throw a TypeError exception.


        if (n + len > Math.pow(2, 53) - 1) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "too damn high");
        } // iv. Repeat, while k < len


        while (k < len) {
          // 1. Let P be ! ToString(k).
          let P = new _index.StringValue(realm, k + ""); // 2. Let exists be ? HasProperty(E, P).

          let exists = (0, _index2.HasProperty)(realm, E, P); // 3. If exists is true, then

          if (exists) {
            // a. Let subElement be ? Get(E, P).
            let subElement = (0, _index2.Get)(realm, E, P); // b. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), subElement).

            _singletons.Create.CreateDataPropertyOrThrow(realm, A, new _index.StringValue(realm, n + ""), subElement);
          } // 4. Increase n by 1.


          n++; // 5. Increase k by 1.

          k++;
        }
      } else {
        // d. Else E is added as a single item rather than spread,
        // i. If n2^53-1, throw a TypeError exception.
        if (n > Math.pow(2, 53) - 1) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "too damn high");
        } // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), E).


        _singletons.Create.CreateDataPropertyOrThrow(realm, A, new _index.StringValue(realm, n + ""), E); // iii. Increase n by 1.


        n++;
      }
    } // 6. Perform ? Set(A, "length", n, true).


    _singletons.Properties.Set(realm, A, "length", new _index.NumberValue(realm, n), true); // 7. Return A.


    return A;
  }); // ECMA262 22.1.3.3

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("copyWithin", 2, (context, [target, start, end]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("copyWithin") === undefined) {
      let args = [O, new _index.StringValue(realm, "copyWithin"), target];

      if (start) {
        args.push(start);
      }

      if (end) {
        args.push(end);
      }

      _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));

      return O;
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. Let relativeTarget be ? ToInteger(target).


    let relativeTarget = _singletons.To.ToInteger(realm, target); // 4. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).


    let to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len); // 5. Let relativeStart be ? ToInteger(start).

    let relativeStart = _singletons.To.ToInteger(realm, start); // 6. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).


    let from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // 7. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 8. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).

    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // 9. Let count be min(final-from, len-to).

    let count = Math.min(final - from, len - to);
    let direction; // 10. If from<to and to<from+count, then

    if (from < to && to < from + count) {
      // a. Let direction be -1.
      direction = -1; // b. Let from be from + count - 1.

      from = from + count - 1; // c. Let to be to + count - 1.

      to = to + count - 1;
    } else {
      // 11. Else,
      // a. Let direction be 1.
      direction = 1;
    } // 12. Repeat, while count > 0


    while (count > 0) {
      // a. Let fromKey be ! ToString(from).
      let fromKey = _singletons.To.ToString(realm, new _index.NumberValue(realm, from)); // b. Let toKey be ! ToString(to).


      let toKey = _singletons.To.ToString(realm, new _index.NumberValue(realm, to)); // c. Let fromPresent be ? HasProperty(O, fromKey).


      let fromPresent = (0, _index2.HasProperty)(realm, O, fromKey); // d. If fromPresent is true, then

      if (fromPresent === true) {
        // i. Let fromVal be ? Get(O, fromKey).
        let fromVal = (0, _index2.Get)(realm, O, fromKey); // ii. Perform ? Set(O, toKey, fromVal, true).

        _singletons.Properties.Set(realm, O, toKey, fromVal, true);
      } else {
        // e. Else fromPresent is false,
        // i. Perform ? DeletePropertyOrThrow(O, toKey).
        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), toKey);
      } // f. Let from be from + direction.


      from = from + direction; // g. Let to be to + direction.

      to = to + direction; // h. Let count be count - 1.

      count = count - 1;
    } // 13. Return O.


    return O;
  }); // ECMA262 22.1.3.4

  obj.defineNativeMethod("entries", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("entries") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O, new _index.StringValue(realm, "entries")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Return CreateArrayIterator(O, "key+value").


    return _singletons.Create.CreateArrayIterator(realm, O.throwIfNotConcreteObject(), "key+value");
  }); // ECMA262 22.1.3.5

  obj.defineNativeMethod("every", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("every") === undefined) {
      let args = [O, new _index.StringValue(realm, "every"), callbackfn];

      if (thisArg) {
        args.push(thisArg);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 5. Let k be 0.

    let k = 0; // 6. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Let testResult be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).

        let testResult = _singletons.To.ToBooleanPartial(realm, (0, _index2.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O])); // iii. If testResult is false, return false.


        if (!testResult) return realm.intrinsics.false;
      } // d. Increase k by 1.


      k++;
    } // 7. Return true.


    return realm.intrinsics.true;
  }); // ECMA262 22.1.3.6

  obj.defineNativeMethod("fill", 1, (context, [value, start, end]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("fill") === undefined) {
      let args = [O, new _index.StringValue(realm, "fill"), value];

      if (start) {
        args.push(start);
      }

      if (end) {
        args.push(end);
      }

      _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));

      return O;
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. Let relativeStart be ? ToInteger(start).


    let relativeStart = _singletons.To.ToInteger(realm, start || realm.intrinsics.undefined); // 4. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).


    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // 5. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 6. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).

    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // 7. Repeat, while k < final

    while (k < final) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Perform ? Set(O, Pk, value, true).

      _singletons.Properties.Set(realm, O, Pk, value, true); // c. Increase k by 1.


      k++;
    } // 8. Return O.


    return O;
  }); // ECMA262 22.1.3.7

  obj.defineNativeMethod("filter", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context);

    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("filter") === undefined) {
      let args = [O, new _index.StringValue(realm, "filter"), callbackfn];

      if (thisArg) {
        args.push(thisArg);
      }

      return _index.ArrayValue.createTemporalWithWidenedNumericProperty(realm, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 5. Let A be ? ArraySpeciesCreate(O, 0).

    let A = _singletons.Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), 0); // 6. Let k be 0.


    let k = 0; // 7. Let to be 0.

    let to = 0; // 8. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Let selected be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).

        let selected = _singletons.To.ToBooleanPartial(realm, (0, _index2.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O])); // iii. If selected is true, then


        if (selected) {
          // 1. Perform ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue).
          _singletons.Create.CreateDataPropertyOrThrow(realm, A, _singletons.To.ToString(realm, new _index.NumberValue(realm, to)), kValue); // 2. Increase to by 1.


          to++;
        }
      } // d. Increase k by 1.


      k++;
    } // 9. Return A.


    return A;
  }); // ECMA262 22.1.3.8

  obj.defineNativeMethod("find", 1, (context, [predicate, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("find") === undefined) {
      let args = [O, new _index.StringValue(realm, "find"), predicate];

      if (thisArg) {
        args.push(thisArg);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(predicate) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, predicate)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 5. Let k be 0.

    let k = 0; // 6. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kValue be ? Get(O, Pk).

      let kValue = (0, _index2.Get)(realm, O, Pk); // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).

      let testResult = _singletons.To.ToBooleanPartial(realm, (0, _index2.Call)(realm, predicate, T, [kValue, new _index.NumberValue(realm, k), O])); // d. If testResult is true, return kValue.


      if (testResult) return kValue; // e. Increase k by 1.

      k++;
    } // 7. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 22.1.3.9

  obj.defineNativeMethod("findIndex", 1, (context, [predicate, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("findIndex") === undefined) {
      let args = [O, new _index.StringValue(realm, "findIndex"), predicate];

      if (thisArg) {
        args.push(thisArg);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.NumberValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(predicate) is false, throw a TypeError exception.


    if ((0, _index2.IsCallable)(realm, predicate) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg ? thisArg : realm.intrinsics.undefined; // 5. Let k be 0.

    let k = 0; // 6. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let kValue be ? Get(O, Pk).


      let kValue = (0, _index2.Get)(realm, O, new _index.StringValue(realm, Pk)); // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).

      let testResult = _singletons.To.ToBooleanPartial(realm, (0, _index2.Call)(realm, predicate, T, [kValue, new _index.NumberValue(realm, k), O])); // d. If testResult is true, return k.


      if (testResult === true) return new _index.NumberValue(realm, k); // e. Increase k by 1.

      k = k + 1;
    } // 7. Return -1.


    return new _index.NumberValue(realm, -1);
  }); // ECMA262 22.1.3.10

  obj.defineNativeMethod("forEach", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("forEach") === undefined) {
      let args = [O, new _index.StringValue(realm, "forEach"), callbackfn];

      if (thisArg) {
        args.push(thisArg);
      }

      _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));

      return realm.intrinsics.undefined;
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 5. Let k be 0.

    let k = 0; // 6. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! To.ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Perform ? Call(callbackfn, T,  kValue, k, O ).

        (0, _index2.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]);
      } // d. Increase k by 1.


      k++;
    } // 7. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 22.1.3.11

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("includes", 1, (context, [searchElement, fromIndex]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("includes") === undefined) {
      let args = [O, new _index.StringValue(realm, "includes"), searchElement];

      if (fromIndex) {
        args.push(fromIndex);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If len is 0, return false.


    if (len === 0) return realm.intrinsics.false; // 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)

    let n = _singletons.To.ToInteger(realm, fromIndex || realm.intrinsics.undefined);

    let k; // 5. If n  0, then

    if (n >= 0) {
      // a. Let k be n.
      k = n;
    } else {
      // 6. Else n < 0,
      // a. Let k be len + n.
      k = len + n; // b. If k < 0, let k be 0.

      if (k < 0) k = 0;
    } // 7. Repeat, while k < len


    while (k < len) {
      // a. Let elementK be the result of ? Get(O, ! ToString(k)).
      let elementK = (0, _index2.Get)(realm, O, _singletons.To.ToString(realm, new _index.NumberValue(realm, k))); // b. If SameValueZero(searchElement, elementK) is true, return true.

      if ((0, _abstract.SameValueZeroPartial)(realm, searchElement, elementK) === true) return realm.intrinsics.true; // c. Increase k by 1.

      k = k + 1;
    } // 8. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 22.1.3.12

  obj.defineNativeMethod("indexOf", 1, (context, [searchElement, fromIndex]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("indexOf") === undefined) {
      let args = [O, new _index.StringValue(realm, "indexOf"), searchElement];

      if (fromIndex) {
        args.push(fromIndex);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.NumberValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If len is 0, return -1.


    if (len === 0) return new _index.NumberValue(realm, -1); // 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)

    let n = fromIndex ? _singletons.To.ToInteger(realm, fromIndex) : 0; // 5. If n  len, return -1.

    if (n >= len) return new _index.NumberValue(realm, -1); // 6. If n  0, then

    let k;

    if (n >= 0) {
      // a. If n is -0, let k be +0; else let k be n.
      k = Object.is(n, -0) ? +0 : n;
    } else {
      // 7. Else n < 0,
      // a. Let k be len + n.
      k = len + n; // b. If k < 0, let k be 0.

      if (k < 0) k = 0;
    } // 8. Repeat, while k < len


    while (k < len) {
      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).
      let kPresent = (0, _index2.HasProperty)(realm, O, k + ""); // b. If kPresent is true, then

      if (kPresent === true) {
        // i. Let elementK be ? Get(O, ! ToString(k)).
        let elementK = (0, _index2.Get)(realm, O, k + ""); // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.

        let same = (0, _index2.StrictEqualityComparisonPartial)(realm, searchElement, elementK); // iii. If same is true, return k.

        if (same) return new _index.NumberValue(realm, k);
      } // c. Increase k by 1.


      k++;
    } // 9. Return -1.


    return new _index.NumberValue(realm, -1);
  }); // ECMA262 22.1.3.13

  obj.defineNativeMethod("join", 1, (context, [separator]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("join") === undefined) {
      let args = [O, new _index.StringValue(realm, "join")];

      if (separator) {
        args.push(separator);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.StringValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If separator is undefined, let separator be the single-element String ",".


    if (!separator || separator instanceof _index.UndefinedValue) separator = new _index.StringValue(realm, ","); // 4. Let sep be ? ToString(separator).

    let sep = _singletons.To.ToStringPartial(realm, separator); // 5. If len is zero, return the empty String.


    if (len === 0) return realm.intrinsics.emptyString; // 6. Let element0 be Get(O, "0").

    let element0 = (0, _index2.Get)(realm, O, "0"); // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).

    let R;

    if ((0, _index2.HasSomeCompatibleType)(element0, _index.UndefinedValue, _index.NullValue)) {
      R = "";
    } else {
      R = _singletons.To.ToStringPartial(realm, element0);
    } // 8. Let k be 1.


    let k = 1; // 9. Repeat, while k < len

    while (k < len) {
      // a. Let S be the String value produced by concatenating R and sep.
      let S = R + sep; // b. Let element be ? Get(O, ! To.ToString(k)).

      let element = (0, _index2.Get)(realm, O, new _index.StringValue(realm, k + "")); // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).

      let next;

      if ((0, _index2.HasSomeCompatibleType)(element, _index.UndefinedValue, _index.NullValue)) {
        next = "";
      } else {
        next = _singletons.To.ToStringPartial(realm, element);
      } // d. Let R be a String value produced by concatenating S and next.


      R = S + next; // e. Increase k by 1.

      k++;
    } // 10. Return R.


    return new _index.StringValue(realm, R + "");
  }); // ECMA262 22.1.3.14

  obj.defineNativeMethod("keys", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("keys") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O, new _index.StringValue(realm, "keys")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Return CreateArrayIterator(O, "key").


    return _singletons.Create.CreateArrayIterator(realm, O.throwIfNotConcreteObject(), "key");
  }); // ECMA262 22.1.3.15

  obj.defineNativeMethod("lastIndexOf", 1, (context, [searchElement, fromIndex]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("lastIndexOf") === undefined) {
      let args = [O, new _index.StringValue(realm, "lastIndexOf"), searchElement];

      if (fromIndex) {
        args.push(fromIndex);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.NumberValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If len is 0, return -1.


    if (len === 0) return new _index.NumberValue(realm, -1); // 4. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.

    let n = fromIndex ? _singletons.To.ToInteger(realm, fromIndex) : len - 1; // 5. If n  0, then

    let k;

    if (n >= 0) {
      // a. If n is -0, let k be +0; else let k be min(n, len - 1).
      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);
    } else {
      // 6. Else n < 0,
      // a. Let k be len + n.
      k = len + n;
    } // 7. Repeat, while k  0


    while (k >= 0) {
      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).
      let kPresent = (0, _index2.HasProperty)(realm, O, new _index.StringValue(realm, k + "")); // b. If kPresent is true, then

      if (kPresent) {
        // i. Let elementK be ? Get(O, ! ToString(k)).
        let elementK = (0, _index2.Get)(realm, O, new _index.StringValue(realm, k + "")); // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.

        let same = (0, _index2.StrictEqualityComparisonPartial)(realm, searchElement, elementK); // iii. If same is true, return k.

        if (same) return new _index.NumberValue(realm, k);
      } // c. Decrease k by 1.


      k--;
    } // 8. Return -1.


    return new _index.NumberValue(realm, -1);
  }); // ECMA262 22.1.3.16

  obj.defineNativeMethod("map", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context);

    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("map") === undefined) {
      let args = [O, new _index.StringValue(realm, "map"), callbackfn];

      if (thisArg) {
        args.push(thisArg);
      }

      (0, _invariant.default)(callbackfn instanceof _index.ECMAScriptSourceFunctionValue || callbackfn instanceof _index.BoundFunctionValue);
      let possibleNestedOptimizedFunctions = [{
        func: callbackfn,
        thisValue: thisArg || realm.intrinsics.undefined,
        kind: "map"
      }];
      return _index.ArrayValue.createTemporalWithWidenedNumericProperty(realm, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"), possibleNestedOptimizedFunctions);
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let lenVal = (0, _index2.Get)(realm, O, "length");

    if (lenVal instanceof _index.AbstractValue && !lenVal.mightNotBeNumber() && !lenVal.values.isTop()) {
      let values = lenVal.values.getElements();
      let n = values.size;

      if (n > 1 && n < 10) {
        let a = _singletons.Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), 0);

        return _singletons.Join.mapAndJoin(realm, values, v => _index.AbstractValue.createFromBinaryOp(realm, "===", v, lenVal, lenVal.expressionLocation), v => doMap(v, a));
      }
    }

    return doMap(lenVal.throwIfNotConcrete());

    function doMap(val, resultArray) {
      let len = _singletons.To.ToLength(realm, val); // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.


      if (!(0, _index2.IsCallable)(realm, callbackfn)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
      } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


      let T = thisArg || realm.intrinsics.undefined; // 5. Let A be ? ArraySpeciesCreate(O, len).

      let A;
      if (resultArray === undefined) A = _singletons.Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), len);else {
        A = resultArray;

        _singletons.Properties.Set(realm, A, "length", val, true);
      } // 6. Let k be 0.

      let k = 0; // 7. Repeat, while k < len

      while (k < len) {
        // a. Let Pk be ! To.ToString(k).
        let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

        let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

        if (kPresent) {
          // i. Let kValue be ? Get(O, Pk).
          let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Let mappedValue be ? Call(callbackfn, T,  kValue, k, O ).

          let mappedValue = (0, _index2.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]); // iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).

          _singletons.Create.CreateDataPropertyOrThrow(realm, A, Pk, mappedValue);
        } // d. Increase k by 1.


        k++;
      } // 8. Return A.


      return A;
    }
  }); // ECMA262 22.1.3.17

  obj.defineNativeMethod("pop", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("pop") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O, new _index.StringValue(realm, "pop")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If len is zero, then


    if (len === 0) {
      // a. Perform ? Set(O, "length", 0, true).
      _singletons.Properties.Set(realm, O, "length", realm.intrinsics.zero, true); // b. Return undefined.


      return realm.intrinsics.undefined;
    } else {
      // 4. Else len > 0,
      // a. Let newLen be len-1.
      let newLen = len - 1; // b. Let indx be ! ToString(newLen).

      let indx = new _index.StringValue(realm, newLen + ""); // c. Let element be ? Get(O, indx).

      let element = (0, _index2.Get)(realm, O, indx); // d. Perform ? DeletePropertyOrThrow(O, indx).

      _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), indx); // e. Perform ? Set(O, "length", newLen, true).


      _singletons.Properties.Set(realm, O, "length", new _index.NumberValue(realm, newLen), true); // f. Return element.


      return element;
    }
  }); // ECMA262 22.1.3.18

  obj.defineNativeMethod("push", 1, (context, args, argCount) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("push") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.NumberValue, [O, new _index.StringValue(realm, "push"), ...args], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, new _index.StringValue(realm, "length"))); // 3. Let items be a List whose elements are, in left to right order, the arguments that were passed to realm function invocation.


    let items = argCount > 0 ? args : []; // 4. Let argCount be the number of elements in items.

    argCount; // 5. If len + argCount > 2^53-1, throw a TypeError exception.

    if (len + argCount > Math.pow(2, 53) - 1) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
    } // 6. Repeat, while items is not empty


    while (items.length) {
      // a. Remove the first element from items and let E be the value of the element.
      let E = items.shift(); // b. Perform ? Set(O, ! ToString(len), E, true).

      _singletons.Properties.Set(realm, O, new _index.StringValue(realm, len + ""), E, true); // c. Let len be len+1.


      len++;
    } // 7. Perform ? Set(O, "length", len, true).


    _singletons.Properties.Set(realm, O, new _index.StringValue(realm, "length"), new _index.NumberValue(realm, len), true); // 8. Return len.


    return new _index.NumberValue(realm, len);
  }); // ECMA262 22.1.3.19

  obj.defineNativeMethod("reduce", 1, (context, [callbackfn, initialValue]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("reduce") === undefined) {
      let args = [O, new _index.StringValue(realm, "reduce"), callbackfn];

      if (initialValue) {
        args.push(initialValue);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 4. If len is 0 and initialValue is not present, throw a TypeError exception.


    if (len === 0 && !initialValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
    } // 5. Let k be 0.


    let k = 0; // 6. If initialValue is present, then

    let accumulator;

    if (initialValue) {
      // a. Set accumulator to initialValue.
      accumulator = initialValue;
    } else {
      // 7. Else initialValue is not present,
      // a. Let kPresent be false.
      let kPresent = false; // b. Repeat, while kPresent is false and k < len

      while (kPresent === false && k < len) {
        // i. Let Pk be ! ToString(k).
        let Pk = new _index.StringValue(realm, k + ""); // ii. Let kPresent be ? HasProperty(O, Pk).

        kPresent = (0, _index2.HasProperty)(realm, O, Pk); // iv. If kPresent is true, then

        if (kPresent) {
          // 1. Let accumulator be ? Get(O, Pk).
          accumulator = (0, _index2.Get)(realm, O, Pk);
        } // v. Increase k by 1.


        k++;
      } // c. If kPresent is false, throw a TypeError exception.


      if (!kPresent) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "kPresent is false");
      }

      (0, _invariant.default)(accumulator);
    } // 8. Repeat, while k < len


    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Let accumulator be ? Call(callbackfn, undefined,  accumulator, kValue, k, O ).

        accumulator = (0, _index2.Call)(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new _index.NumberValue(realm, k), O]);
      } // d. Increase k by 1.


      k++;
    } // 9. Return accumulator.


    return accumulator;
  }); // ECMA262 22.1.3.20

  obj.defineNativeMethod("reduceRight", 1, (context, [callbackfn, initialValue]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("reduceRight") === undefined) {
      let args = [O, new _index.StringValue(realm, "reduceRight"), callbackfn];

      if (initialValue) {
        args.push(initialValue);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 4. If len is 0 and initialValue is not present, throw a TypeError exception.


    if (len === 0 && !initialValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
    } // 5. Let k be len-1.


    let k = len - 1; // 6. If initialValue is present, then

    let accumulator;

    if (initialValue) {
      // 1. Set accumulator to initialValue.
      accumulator = initialValue;
    } else {
      // 7. Else initialValue is not present,
      // a. Let kPresent be false.
      let kPresent = false; // b. Repeat, while kPresent is false and k  0

      while (!kPresent && k >= 0) {
        // i. Let Pk be ! ToString(k).
        let Pk = new _index.StringValue(realm, k + ""); // ii. Let kPresent be ? HasProperty(O, Pk).

        kPresent = (0, _index2.HasProperty)(realm, O, Pk); // iii. If kPresent is true, then

        if (kPresent) {
          // 1. Let accumulator be ? Get(O, Pk).
          accumulator = (0, _index2.Get)(realm, O, Pk);
        } // iv. Decrease k by 1.


        k--;
      } // c. If kPresent is false, throw a TypeError exception.


      if (!kPresent || !accumulator) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
      }
    } // 8. Repeat, while k  0


    while (k >= 0) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Let accumulator be ? Call(callbackfn, undefined,  accumulator, kValue, k, O ).

        accumulator = (0, _index2.Call)(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new _index.NumberValue(realm, k), O]);
      } // d. Decrease k by 1.


      k--;
    } // 9. Return accumulator.


    return accumulator;
  }); // ECMA262 22.1.3.21

  obj.defineNativeMethod("reverse", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("reverse") === undefined) {
      _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.ArrayValue, [O, new _index.StringValue(realm, "reverse")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));

      return O;
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. Let middle be floor(len/2).


    let middle = Math.floor(len / 2); // 4. Let lower be 0.

    let lower = 0; // 5. Repeat, while lower  middle

    while (lower !== middle) {
      // a. Let upper be len - lower - 1.
      let upper = len - lower - 1; // b. Let upperP be ! ToString(upper).

      let upperP = new _index.StringValue(realm, upper + ""); // c. Let lowerP be ! ToString(lower).

      let lowerP = new _index.StringValue(realm, lower + ""); // d. Let lowerExists be ? HasProperty(O, lowerP).

      let lowerExists = (0, _index2.HasProperty)(realm, O, lowerP); // e. If lowerExists is true, then

      let lowerValue;

      if (lowerExists) {
        // i. Let lowerValue be ? Get(O, lowerP).
        lowerValue = (0, _index2.Get)(realm, O, lowerP);
      } // f. Let upperExists be ? HasProperty(O, upperP).


      let upperExists = (0, _index2.HasProperty)(realm, O, upperP); // g. If upperExists is true, then

      let upperValue;

      if (upperExists) {
        // i. Let upperValue be ? Get(O, upperP).
        upperValue = (0, _index2.Get)(realm, O, upperP);
      } // h. If lowerExists is true and upperExists is true, then


      if (lowerExists && upperExists) {
        (0, _invariant.default)(lowerValue, "expected lower value to exist");
        (0, _invariant.default)(upperValue, "expected upper value to exist"); // i. Perform ? Set(O, lowerP, upperValue, true).

        _singletons.Properties.Set(realm, O, lowerP, upperValue, true); // ii. Perform ? Set(O, upperP, lowerValue, true).


        _singletons.Properties.Set(realm, O, upperP, lowerValue, true);
      } else if (!lowerExists && upperExists) {
        // i. Else if lowerExists is false and upperExists is true, then
        (0, _invariant.default)(upperValue, "expected upper value to exist"); // i. Perform ? Set(O, lowerP, upperValue, true).

        _singletons.Properties.Set(realm, O, lowerP, upperValue, true); // ii. Perform ? DeletePropertyOrThrow(O, upperP).


        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), upperP);
      } else if (lowerExists && !upperExists) {
        // j. Else if lowerExists is true and upperExists is false, then
        (0, _invariant.default)(lowerValue, "expected lower value to exist"); // i. Perform ? DeletePropertyOrThrow(O, lowerP).

        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), lowerP); // ii. Perform ? Set(O, upperP, lowerValue, true).


        _singletons.Properties.Set(realm, O, upperP, lowerValue, true);
      } else {} // k. Else both lowerExists and upperExists are false,
      // i. No action is required.
      // l. Increase lower by 1.


      lower++;
    } // 6. Return O.


    return O;
  }); // ECMA262 22.1.3.22

  obj.defineNativeMethod("shift", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("shift") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O, new _index.StringValue(realm, "shift")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If len is zero, then


    if (len === 0) {
      // a. Perform ? Set(O, "length", 0, true).
      _singletons.Properties.Set(realm, O, "length", realm.intrinsics.zero, true); // b. Return undefined.


      return realm.intrinsics.undefined;
    } // 4. Let first be ? Get(O, "0").


    let first = (0, _index2.Get)(realm, O, "0"); // 5. Let k be 1.

    let k = 0; // 6. Repeat, while k < len

    while (k < len) {
      // a. Let from be ! ToString(k).
      let frm = new _index.StringValue(realm, k + ""); // b. Let to be ! ToString(k-1).

      let to = new _index.StringValue(realm, k - 1 + ""); // c. Let fromPresent be ? HasProperty(O, from).

      let fromPresent = (0, _index2.HasProperty)(realm, O, frm); // d. If fromPresent is true, then

      if (fromPresent) {
        // i. Let fromVal be ? Get(O, from).
        let fromVal = (0, _index2.Get)(realm, O, frm); // ii. Perform ? Set(O, to, fromVal, true).

        _singletons.Properties.Set(realm, O, to, fromVal, true);
      } else {
        // d. Else fromPresent is false,
        // i. Perform ? DeletePropertyOrThrow(O, to).
        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);
      } // e. Increase k by 1.


      k++;
    } // 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len-1)).


    _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), new _index.StringValue(realm, len - 1 + "")); // 8. Perform ? Set(O, "length", len-1, true).


    _singletons.Properties.Set(realm, O, "length", new _index.NumberValue(realm, len - 1), true); // 9. Return first.


    return first;
  }); // ECMA262 22.1.3.23

  obj.defineNativeMethod("slice", 2, (context, [start, end]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context);

    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("slice") === undefined) {
      let newArgs = [O, new _index.StringValue(realm, "slice"), start, end];
      return _index.ArrayValue.createTemporalWithWidenedNumericProperty(realm, newArgs, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. Let relativeStart be ? ToInteger(start).


    let relativeStart = _singletons.To.ToInteger(realm, start); // 4. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).


    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // 5. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 6. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).

    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // 7. Let count be max(final - k, 0).

    let count = Math.max(final - k, 0); // 8. Let A be ? ArraySpeciesCreate(O, count).

    let A = _singletons.Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), count); // 9. Let n be 0.


    let n = 0; // 10. Repeat, while k < final

    while (k < final) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), kValue).

        _singletons.Create.CreateDataPropertyOrThrow(realm, A, new _index.StringValue(realm, n + ""), kValue);
      } // d. Increase k by 1.


      k++; // e. Increase n by 1.

      n++;
    } // 11. Perform ? Set(A, "length", n, true).


    _singletons.Properties.Set(realm, A, "length", new _index.NumberValue(realm, n), true); // 12. Return A.


    return A;
  }); // ECMA262 22.1.3.24

  obj.defineNativeMethod("some", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("some") === undefined) {
      let args = [O, new _index.StringValue(realm, "some"), callbackfn];

      if (thisArg) {
        args.push(thisArg);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "callback passed to Array.prototype.some isn't callable");
    } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 5. Let k be 0.

    let k = 0; // 6. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _index2.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _index2.Get)(realm, O, Pk); // ii. Let testResult be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).

        let testResult = _singletons.To.ToBooleanPartial(realm, (0, _index2.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O])); // iii. If testResult is true, return true.


        if (testResult) return realm.intrinsics.true;
      } // d. Increase k by 1.


      k++;
    } // 7. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 22.1.3.25

  obj.defineNativeMethod("sort", 1, (context, [comparefn]) => {
    // 1. Let obj be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("sort") === undefined) {
      let args = [O, new _index.StringValue(realm, "sort"), comparefn];

      _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL")); // context is returned instead of O at the end of this method
      // so we do the same here


      return context;
    } // 2. Let len be ? ToLength(? Get(obj, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // Within this specification of the sort method, an object, obj, is said to be sparse if the following algorithm returns true:


    let isSparse = () => {
      // 1.For each integer i in the range 0i< len
      for (let i = 0; i < len; i++) {
        // a.Let elem be obj.[[GetOwnProperty]](! ToString(i)).
        let elem = O.$GetOwnProperty(i.toString()); // b.If elem is undefined, return true.

        if (elem === undefined) return true;

        _singletons.Properties.ThrowIfMightHaveBeenDeleted(elem);
      } // 2.Return false.


      return false;
    };

    let sparse = isSparse(); // Let proto be obj.[[GetPrototypeOf]]().

    let proto = O.$GetPrototypeOf(); // If proto is not null

    if (!(proto instanceof _index.NullValue)) {
      // and there exists an integer j such that all of the conditions below are satisfied then the sort order is implementation-defined:
      for (let j = 0; j < len; j++) {
        // HasProperty(proto, ToString(j)) is true.
        if ((0, _index2.HasProperty)(realm, proto, j.toString()) && // obj is sparse
        sparse) // We abord when the result of the sort is implementation defined.
          throw Error("Implentation defined behavior detected");
      }
    } // The sort order is also implementation defined if obj is sparse and any of the following conditions are true:


    if (sparse) {
      // IsExtensible(obj) is false.
      if (!(0, _index2.IsExtensible)(realm, O)) throw Error("Implementation defined behavior, Array is both sparse and extensible"); // Any integer index property of obj whose name is a nonnegative integer less than len

      for (let j = 0; j < len; j++) {
        // is a data property whose [[Configurable]] attribute is false.
        let prop = O.$GetOwnProperty(j.toString());

        if (prop !== undefined && !prop.throwIfNotConcrete(realm).configurable) {
          _singletons.Properties.ThrowIfMightHaveBeenDeleted(prop);

          throw Error("Implementation defined behavior :  Array is sparse and it's prototype has some numbered properties");
        }
      }
    } // Any integer index property of obj whose name is a nonnegative integer less than len


    for (let j = 0; j < len; j++) {
      //is a data property whose [[writable]] attribute is false.
      let prop = O.$GetOwnProperty(j.toString());

      if (prop !== undefined && !prop.throwIfNotConcrete(realm).writable) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(prop);

        throw Error("Implementation defined behavior : property " + j.toString() + "is non writable : ");
      }
    } // The SortCompare abstract operation is called with two arguments x and y. It also has access to the comparefn
    // argument passed to the current invocation of the sort method. The following steps are taken:
    // 22.1.3.25.1 Runtime Semantics: SortCompare( x, y )#


    let SortCompare = (x, y) => {
      x = x.throwIfNotConcrete();
      y = y.throwIfNotConcrete(); // 1. If x and y are both undefined, return +0.

      if (x instanceof _index.UndefinedValue && y instanceof _index.UndefinedValue) {
        return realm.intrinsics.zero;
      } // 2. If x is undefined, return 1.


      if (x instanceof _index.UndefinedValue) {
        return new _index.NumberValue(realm, 1);
      } // 3. If y is undefined, return -1.


      if (y instanceof _index.UndefinedValue) {
        return new _index.NumberValue(realm, -1);
      } // 4. If the argument comparefn is not undefined, then


      if (!comparefn.mightBeUndefined()) {
        // a. Let v be ? ToNumber(? Call(comparefn, undefined,  x, y )).
        let v = _singletons.To.ToNumber(realm, (0, _index2.Call)(realm, comparefn, new _index.UndefinedValue(realm), [x, y])); // b. If v is NaN, return +0.


        if (isNaN(v)) return new _index.NumberValue(realm, +0); // c. Return v.

        return new _index.NumberValue(realm, v);
      } else {
        comparefn.throwIfNotConcrete();
      } // 5. Let xString be ? ToString(x).


      let xString = new _index.StringValue(realm, _singletons.To.ToString(realm, x)); // 6. Let yString be ? ToString(y).

      let yString = new _index.StringValue(realm, _singletons.To.ToString(realm, y)); // 7. Let xSmaller be the result of performing Abstract Relational Comparison xString < yString.

      let xSmaller = (0, _abstract.AbstractRelationalComparison)(realm, xString, yString, true, "<"); // 8. If xSmaller is true, return -1.

      if (xSmaller.value) return new _index.NumberValue(realm, -1); // 9. Let ySmaller be the result of performing Abstract Relational Comparison yString < xString.

      let ySmaller = (0, _abstract.AbstractRelationalComparison)(realm, yString, xString, true, "<"); // 10. If ySmaller is true, return 1.

      if (ySmaller.value) return new _index.NumberValue(realm, 1); // 11. Return +0.

      return realm.intrinsics.zero;
    }; //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:
    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.
    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and
    // transfering back the value inside the our array.


    let arr = []; // We need to adapt the comparefn function to match the expected types

    let comparefn_ = (x, y) => {
      (0, _invariant.default)(x instanceof _index.Value, "Unexpected type");
      (0, _invariant.default)(y instanceof _index.Value, "Unexpected type");
      let result_ = SortCompare(x, y);

      let numb = _singletons.To.ToNumber(realm, result_);

      return numb;
    };

    for (let j = 0; j < len; j++) {
      // The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.
      if (!(0, _index2.HasOwnProperty)(realm, O, j.toString())) continue; // The arguments for calls to SortCompare are values returned by a previous call to the [[Get]] internal method,
      // unless the properties accessed by those previous calls did not exist according to HasOwnProperty.
      // -- Important : We rely on the fact that the underlying sort implementation respect the standard for the following 3 properties
      // If both perspective arguments to SortCompare correspond to non-existent properties,
      // use +0 instead of calling SortCompare. If only the first perspective argument is non-existent use +1.
      // If only the second perspective argument is non-existent use -1.

      let val = O.$Get(j.toString(), O);
      arr[j] = val;
    }

    arr.sort(comparefn_); //Apply the permutation back to the original array.

    for (let j = 0; j < len; j++) {
      if (arr.hasOwnProperty(j.toString())) {
        let ok = O.$Set(j.toString(), arr[j], O); // If any [[Set]] call returns false a TypeError exception is thrown.

        if (!ok) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "[[Set]] returned false");
      } else {
        // If obj is not sparse then DeletePropertyOrThrow must not be called.
        (0, _invariant.default)(sparse);

        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), j.toString());
      }
    } // If an abrupt completion is returned from any of these operations, it is immediately returned as the value of this function.
    // 2. Return obj;


    return context;
  }); // ECMA262 22.1.3.26

  obj.defineNativeMethod("splice", 2, (context, [start, deleteCount, ...items], argLength) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("splice") === undefined) {
      let args = [O, new _index.StringValue(realm, "splice"), start];

      if (deleteCount) {
        args.push(deleteCount);
      }

      if (items && items.length > 0) {
        args.push(...items);
      }

      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.ArrayValue, args, (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. Let relativeStart be ? ToInteger(start).


    let relativeStart = _singletons.To.ToInteger(realm, start); // 4. If relativeStart < 0, let actualStart be max((len + relativeStart), 0); else let actualStart be min(relativeStart, len).


    let actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
    let insertCount;
    let actualDeleteCount; // 5. If the number of actual arguments is 0, then

    if (argLength === 0) {
      // a. Let insertCount be 0.
      insertCount = 0; // b. Let actualDeleteCount be 0.

      actualDeleteCount = 0;
    } else if (argLength === 1) {
      // 6. Else if the number of actual arguments is 1, then
      // a. Let insertCount be 0.
      insertCount = 0; // b. Let actualDeleteCount be len - actualStart.

      actualDeleteCount = len - actualStart;
    } else {
      // 7. Else,
      // a. Let insertCount be the number of actual arguments minus 2.
      insertCount = argLength - 2; // b. Let dc be ? ToInteger(deleteCount).

      let dc = _singletons.To.ToInteger(realm, deleteCount); // c. Let actualDeleteCount be min(max(dc, 0), len - actualStart).


      actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
    } // 8. If len+insertCount-actualDeleteCount > 2^53-1, throw a TypeError exception.


    if (len + insertCount - actualDeleteCount > Math.pow(2, 53) - 1) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "the item count is too damn high");
    } // 9. Let A be ? ArraySpeciesCreate(O, actualDeleteCount).


    let A = _singletons.Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), actualDeleteCount); // 10. Let k be 0.


    let k = 0; // 11. Repeat, while k < actualDeleteCount

    while (k < actualDeleteCount) {
      // a. Let from be ! ToString(actualStart+k).
      let frm = new _index.StringValue(realm, actualStart + k + ""); // b. Let fromPresent be ? HasProperty(O, from).

      let fromPresent = (0, _index2.HasProperty)(realm, O, frm); // c. If fromPresent is true, then

      if (fromPresent) {
        // i. Let fromValue be ? Get(O, from).
        let fromValue = (0, _index2.Get)(realm, O, frm); // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue).

        _singletons.Create.CreateDataPropertyOrThrow(realm, A, new _index.StringValue(realm, k + ""), fromValue);
      } // d. Increment k by 1.


      k++;
    } // 12. Perform ? Set(A, "length", actualDeleteCount, true).


    _singletons.Properties.Set(realm, A, "length", new _index.NumberValue(realm, actualDeleteCount), true); // 13. Let items be a List whose elements are, in left to right order, the portion of the actual argument
    //     list starting with the third argument. The list is empty if fewer than three arguments were passed.


    items; // 14. Let itemCount be the number of elements in items.

    let itemCount = items.length; // 15. If itemCount < actualDeleteCount, then

    if (itemCount < actualDeleteCount) {
      // a. Let k be actualStart.
      k = actualStart; // b. Repeat, while k < (len - actualDeleteCount)

      while (k < len - actualDeleteCount) {
        // i. Let from be ! ToString(k+actualDeleteCount).
        let frm = new _index.StringValue(realm, k + actualDeleteCount + ""); // ii. Let to be ! ToString(k+itemCount).

        let to = new _index.StringValue(realm, k + itemCount + ""); // iii. Let fromPresent be ? HasProperty(O, from).

        let fromPresent = (0, _index2.HasProperty)(realm, O, frm); // iv. If fromPresent is true, then

        if (fromPresent) {
          // 1. Let fromValue be ? Get(O, from).
          let fromValue = (0, _index2.Get)(realm, O, frm); // 2. Perform ? Set(O, to, fromValue, true).

          _singletons.Properties.Set(realm, O, to, fromValue, true);
        } else {
          // v. Else fromPresent is false,
          // 1. Perform ? DeletePropertyOrThrow(O, to).
          _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);
        } // vi. Increase k by 1.


        k++;
      } // c. Let k be len.


      k = len; // d. Repeat, while k > (len - actualDeleteCount + itemCount)

      while (k > len - actualDeleteCount + itemCount) {
        // i. Perform ? DeletePropertyOrThrow(O, ! ToString(k-1)).
        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), new _index.StringValue(realm, k - 1 + "")); // ii. Decrease k by 1.


        k--;
      }
    } else if (itemCount > actualDeleteCount) {
      // 16. Else if itemCount > actualDeleteCount, then
      // a. Let k be (len - actualDeleteCount).
      k = len - actualDeleteCount; // b. Repeat, while k > actualStart

      while (k > actualStart) {
        // i. Let from be ! ToString(k + actualDeleteCount - 1).
        let frm = new _index.StringValue(realm, k + actualDeleteCount - 1 + ""); // ii. Let to be ! ToString(k + itemCount - 1).

        let to = new _index.StringValue(realm, k + itemCount - 1 + ""); // iii. Let fromPresent be ? HasProperty(O, from).

        let fromPresent = (0, _index2.HasProperty)(realm, O, frm); // iv. If fromPresent is true, then

        if (fromPresent) {
          // 1. Let fromValue be ? Get(O, from).
          let fromValue = (0, _index2.Get)(realm, O, frm); // 2. Perform ? Set(O, to, fromValue, true).

          _singletons.Properties.Set(realm, O, to, fromValue, true);
        } else {
          // v. Else fromPresent is false,
          // 1. Perform ? DeletePropertyOrThrow(O, to).
          _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);
        } // vi. Decrease k by 1.


        k--;
      }
    } // 17. Let k be actualStart.


    k = actualStart; // 18. Repeat, while items is not empty

    while (items.length) {
      // a. Remove the first element from items and let E be the value of that element.
      let E = items.shift(); // b. Perform ? Set(O, ! ToString(k), E, true).

      _singletons.Properties.Set(realm, O, new _index.StringValue(realm, k + ""), E, true); // c. Increase k by 1.


      k++;
    } // 19. Perform ? Set(O, "length", len - actualDeleteCount + itemCount, true).


    _singletons.Properties.Set(realm, O, "length", new _index.NumberValue(realm, len - actualDeleteCount + itemCount), true); // 20. Return A.


    return A;
  }); // ECMA262 22.1.3.27

  obj.defineNativeMethod("toLocaleString", 0, context => {
    // 1. Let array be ? ToObject(this value).
    let array = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(array) && realm.isInPureScope() && array.$GetOwnProperty("toLocaleString") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.StringValue, [array, new _index.StringValue(realm, "toLocaleString")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(array, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, array, "length")); // 3. Let separator be the String value for the list-separator String appropriate for the host environment's
    //    current locale (this is derived in an implementation-defined way).


    let separator = ","; // 4. If len is zero, return the empty String.

    if (len === 0) return realm.intrinsics.emptyString; // 5. Let firstElement be ? Get(array, "0").

    let firstElement = (0, _index2.Get)(realm, array, "0"); // 6. If firstElement is undefined or null, then

    let R;

    if ((0, _index2.HasSomeCompatibleType)(firstElement, _index.UndefinedValue, _index.NullValue)) {
      // a. Let R be the empty String.
      R = "";
    } else {
      // 7. Else,
      // a. Let R be ? ToString(? Invoke(firstElement, "toLocaleString")).
      R = _singletons.To.ToStringPartial(realm, (0, _index2.Invoke)(realm, firstElement, "toLocaleString"));
    } // 8. Let k be 1.


    let k = 1; // 9. Repeat, while k < len

    while (k < len) {
      // a. Let S be a String value produced by concatenating R and separator.
      let S = R + separator; // b. Let nextElement be ? Get(array, ! ToString(k)).

      let nextElement = (0, _index2.Get)(realm, array, new _index.StringValue(realm, k + "")).throwIfNotConcrete(); // c. If nextElement is undefined or null, then

      if ((0, _index2.HasSomeCompatibleType)(nextElement, _index.UndefinedValue, _index.NullValue)) {
        // i. Let R be the empty String.
        R = "";
      } else {
        // d. Else,
        // i. Let R be ? ToString(? Invoke(nextElement, "toLocaleString")).
        R = _singletons.To.ToStringPartial(realm, (0, _index2.Invoke)(realm, nextElement, "toLocaleString"));
      } // e. Let R be a String value produced by concatenating S and R.


      R = S + R; // f. Increase k by 1.

      k++;
    } // 10. Return R.


    return new _index.StringValue(realm, R);
  }); // ECMA262 22.1.3.28

  obj.defineNativeProperty("toString", realm.intrinsics.ArrayProto_toString); // ECMA262 22.1.3.29

  obj.defineNativeMethod("unshift", 1, (context, items, argCount) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("unshift") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.NumberValue, [O, new _index.StringValue(realm, "unshift")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let len be ? ToLength(? Get(O, "length")).


    let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, O, "length")); // 3. Let argCount be the number of actual arguments.


    argCount; // 4. If argCount > 0, then

    if (argCount > 0) {
      // a. If len+argCount > 2^53-1, throw a TypeError exception.
      if (len + argCount > Math.pow(2, 53) - 1) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "too damn high");
      } // b. Let k be len.


      let k = len; // c. Repeat, while k > 0,

      while (k > 0) {
        // i. Let from be ! ToString(k-1).
        let frm = new _index.StringValue(realm, k - 1 + ""); // ii. Let to be ! ToString(k+argCount-1).

        let to = new _index.StringValue(realm, k + argCount - 1 + ""); // iv. Let fromPresent be ? HasProperty(O, from).

        let fromPresent = (0, _index2.HasProperty)(realm, O, frm); // v. If fromPresent is true, then

        if (fromPresent) {
          // 1. Let fromValue be ? Get(O, from).
          let fromValue = (0, _index2.Get)(realm, O, frm); // 2. Perform ? Set(O, to, fromValue, true).

          _singletons.Properties.Set(realm, O, to, fromValue, true);
        } else {
          // vi. Else fromPresent is false,
          // 1. Perform ? DeletePropertyOrThrow(O, to).
          _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);
        } // vii. Decrease k by 1.


        k--;
      } // e. Let j be 0.


      let j = 0; // f. Let items be a List whose elements are, in left to right order, the arguments that were passed to
      //    this function invocation.

      items; // g. Repeat, while items is not empty

      while (items.length) {
        // i. Remove the first element from items and let E be the value of that element.
        let E = items.shift(); // ii. Perform ? Set(O, ! ToString(j), E, true).

        _singletons.Properties.Set(realm, O, new _index.StringValue(realm, j + ""), E, true); // iii. Increase j by 1.


        j++;
      }
    } // 5. Perform ? Set(O, "length", len+argCount, true).


    _singletons.Properties.Set(realm, O, "length", new _index.NumberValue(realm, len + argCount), true); // 6. Return len+argCount.


    return new _index.NumberValue(realm, len + argCount);
  }); // ECMA262 22.1.3.30

  obj.defineNativeProperty("values", realm.intrinsics.ArrayProto_values); // ECMA262 22.1.3.32

  {
    // 1. Let unscopableList be ObjectCreate(null).
    let unscopableList = _singletons.Create.ObjectCreate(realm, realm.intrinsics.null); // 2. Perform CreateDataProperty(unscopableList, "copyWithin", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "copyWithin", realm.intrinsics.true); // 3. Perform CreateDataProperty(unscopableList, "entries", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "entries", realm.intrinsics.true); // 4. Perform CreateDataProperty(unscopableList, "fill", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "fill", realm.intrinsics.true); // 5. Perform CreateDataProperty(unscopableList, "find", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "find", realm.intrinsics.true); // 6. Perform CreateDataProperty(unscopableList, "findIndex", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "findIndex", realm.intrinsics.true); // 7. Perform CreateDataProperty(unscopableList, "includes", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "includes", realm.intrinsics.true); // 8. Perform CreateDataProperty(unscopableList, "keys", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "keys", realm.intrinsics.true); // 9. Perform CreateDataProperty(unscopableList, "values", true).


    _singletons.Create.CreateDataProperty(realm, unscopableList, "values", realm.intrinsics.true); // 10. Assert: Each of the above calls will return true.
    // 11. Return unscopableList.


    obj.defineNativeProperty(realm.intrinsics.SymbolUnscopables, unscopableList, {
      writable: false
    });
  }
}
//# sourceMappingURL=ArrayPrototype.js.map

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _date = __webpack_require__(270);

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _seedrandom = _interopRequireDefault(__webpack_require__(396));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
const buildDateNowSrc = "global.Date.now()";

function _default(realm) {
  let lastNow;
  let offsetGenerator;

  function getCurrentTime() {
    if (realm.useAbstractInterpretation) {
      return _index.AbstractValue.createTemporalFromTemplate(realm, buildDateNowSrc, _index.NumberValue, [], {
        isPure: true,
        skipInvariant: true
      });
    } else {
      let newNow = Date.now();

      if (realm.strictlyMonotonicDateNow && lastNow >= newNow) {
        if (!offsetGenerator) offsetGenerator = (0, _seedrandom.default)(0); // certain behaviors in the test262 test suite can only be (reliably) triggered if Date.now() is strictly monotonically increasing
        // TODO #1004: Set the strictlyMonotonicDateNow option on the realm in the test262 test runner, fix the issues that will come up in the tests, and remove this comment.

        newNow = lastNow + 1 + Math.floor(offsetGenerator() * 500);
      }

      lastNow = newNow;
      return new _index.NumberValue(realm, newNow);
    }
  } // ECMA262 20.3.2


  let func = new _index.NativeFunctionValue(realm, "Date", "Date", 7, (context, args, argCount, NewTarget) => {
    if (argCount >= 2) {
      // ECMA262 20.3.2.1
      let [year, month, date, hours, minutes, seconds, ms] = args; // 1. Let numberOfArgs be the number of arguments passed to this function call.

      let numberOfArgs = argCount; // 2. Assert: numberOfArgs  2.

      (0, _invariant.default)(numberOfArgs >= 2, "expected two or more arguments"); // 3. If NewTarget is not undefined, then

      if (NewTarget) {
        // a. Let y be ? ToNumber(year).
        let y = _singletons.To.ToNumber(realm, year); // b. Let m be ? ToNumber(month).


        let m = _singletons.To.ToNumber(realm, month); // c. If date is supplied, let dt be ? ToNumber(date); else let dt be 1.


        let dt = argCount >= 3 ? _singletons.To.ToNumber(realm, date) : 1; // d. If hours is supplied, let h be ? ToNumber(hours); else let h be 0.

        let h = argCount >= 4 ? _singletons.To.ToNumber(realm, hours) : 0; // e. If minutes is supplied, let min be ? ToNumber(minutes); else let min be 0.

        let min = argCount >= 5 ? _singletons.To.ToNumber(realm, minutes) : 0; // f. If seconds is supplied, let s be ? ToNumber(seconds); else let s be 0.

        let s = argCount >= 6 ? _singletons.To.ToNumber(realm, seconds) : 0; // g. If ms is supplied, let milli be ? ToNumber(ms); else let milli be 0.

        let milli = argCount >= 7 ? _singletons.To.ToNumber(realm, ms) : 0; // h. If y is not NaN and 0  ToInteger(y)  99, let yr be 1900+ToInteger(y); otherwise, let yr be y.

        let yr;

        if (!isNaN(y) && _singletons.To.ToInteger(realm, y) >= 0 && _singletons.To.ToInteger(realm, y) <= 99) {
          yr = 1900 + _singletons.To.ToInteger(realm, new _index.NumberValue(realm, y));
        } else {
          yr = y;
        } // i. Let finalDate be MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)).


        let finalDate = (0, _date.MakeDate)(realm, (0, _date.MakeDay)(realm, yr, m, dt), (0, _date.MakeTime)(realm, h, min, s, milli)); // j. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DatePrototype%",  [[DateValue]] ).

        let O = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "DatePrototype", {
          $DateValue: undefined
        }); // k. Set the [[DateValue]] internal slot of O to TimeClip(UTC(finalDate)).


        O.$DateValue = (0, _date.TimeClip)(realm, (0, _date.UTC)(realm, finalDate)); // l. Return O.

        return O;
      } else {
        // 4. Else,
        // a. Let now be the Number that is the time value (UTC) identifying the current time.
        let now = getCurrentTime().throwIfNotConcreteNumber().value; // b. Return ToDateString(now).

        return new _index.StringValue(realm, (0, _date.ToDateString)(realm, now));
      }
    } else if (argCount === 1) {
      // ECMA262 20.3.2.2
      let [value_] = args;
      let value = value_.throwIfNotConcrete(); // 1. Let numberOfArgs be the number of arguments passed to this function call.

      let numberOfArgs = argCount; // 2. Assert: numberOfArgs = 1.

      (0, _invariant.default)(numberOfArgs === 1, "expected number of arguments to equal 1"); // 3. If NewTarget is not undefined, then

      if (NewTarget) {
        let tv; // a. If Type(value) is Object and value has a [[DateValue]] internal slot, then

        if (value instanceof _index.ObjectValue && value.$DateValue !== undefined) {
          // i. Let tv be thisTimeValue(value).
          tv = (0, _date.thisTimeValue)(realm, value);
        } else {
          // b. Else,
          // i. Let v be ? ToPrimitive(value)
          let v = _singletons.To.ToPrimitive(realm, value); // ii. If Type(v) is String, then


          if (v instanceof _index.StringValue) {
            // 1. Let tv be the result of parsing v as a date, in exactly the same manner as for the parse
            //    method (20.3.3.2). If the parse resulted in an abrupt completion, tv is the Completion Record.
            tv = new _index.NumberValue(realm, new Date(v.value).getTime()); // 2. ReturnIfAbrupt(tv).
          } else {
            // iii. Else,
            // 1. Let tv be ? ToNumber(v).
            tv = new _index.NumberValue(realm, _singletons.To.ToNumber(realm, v));
          }
        } // c. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DatePrototype%",  [[DateValue]] ).


        let O = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "DatePrototype", {
          $DateValue: undefined
        }); // d. Set the [[DateValue]] internal slot of O to TimeClip(tv).


        O.$DateValue = (0, _date.TimeClip)(realm, tv); // e. Return O.

        return O;
      } else {
        // 4. Else,
        // a. Let now be the Number that is the time value (UTC) identifying the current time.
        let now = getCurrentTime().throwIfNotConcreteNumber().value; // b. Return ToDateString(now).

        return new _index.StringValue(realm, (0, _date.ToDateString)(realm, now));
      }
    } else {
      // ECMA262 20.3.2.3
      // 1. Let numberOfArgs be the number of arguments passed to this function call.
      let numberOfArgs = argCount; // 2. Assert: numberOfArgs = 0.

      (0, _invariant.default)(numberOfArgs === 0, "expected zero arguments"); // 3. If NewTarget is not undefined, then

      if (NewTarget) {
        // a. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DatePrototype%",  [[DateValue]] ).
        let O = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "DatePrototype", {
          $DateValue: undefined
        }); // b. Set the [[DateValue]] internal slot of O to the time value (UTC) identifying the current time.


        O.$DateValue = getCurrentTime(); // c. Return O.

        return O;
      } else {
        // 4. Else,
        // a. Let now be the Number that is the time value (UTC) identifying the current time.
        let now = getCurrentTime().throwIfNotConcreteNumber().value; // b. Return ToDateString(now).

        return new _index.StringValue(realm, (0, _date.ToDateString)(realm, now));
      }
    }
  }); // ECMA262 20.3.3.1

  func.defineNativeMethod("now", 0, context => {
    return getCurrentTime();
  }); // ECMA262 20.3.3.2

  func.defineNativeMethod("parse", 1, (context, [string]) => {
    if (realm.useAbstractInterpretation) {
      _index.AbstractValue.reportIntrospectionError(string);

      throw new _errors.FatalError();
    } else {
      const parsedDate = Date.parse(string.value);
      return new _index.NumberValue(realm, parsedDate);
    }
  }); // ECMA262 20.3.3.4

  func.defineNativeMethod("UTC", 7, (context, [year, month, date, hours, minutes, seconds, ms], argCount) => {
    // 1. Let y be ? ToNumber(year).
    let y = _singletons.To.ToNumber(realm, year); // 2. Let m be ? ToNumber(month).


    let m = argCount >= 2 ? _singletons.To.ToNumber(realm, month) : 0; // 3. If date is supplied, let dt be ? ToNumber(date); else let dt be 1.

    let dt = argCount >= 3 ? _singletons.To.ToNumber(realm, date) : 1; // 4. If hours is supplied, let h be ? ToNumber(hours); else let h be 0.

    let h = argCount >= 4 ? _singletons.To.ToNumber(realm, hours) : 0; // 5. If minutes is supplied, let min be ? ToNumber(minutes); else let min be 0.

    let min = argCount >= 5 ? _singletons.To.ToNumber(realm, minutes) : 0; // 6. If seconds is supplied, let s be ? ToNumber(seconds); else let s be 0.

    let s = argCount >= 6 ? _singletons.To.ToNumber(realm, seconds) : 0; // 7. If ms is supplied, let milli be ? ToNumber(ms); else let milli be 0.

    let milli = argCount >= 7 ? _singletons.To.ToNumber(realm, ms) : 0; // 8. If y is not NaN and 0  ToInteger(y)  99, let yr be 1900+ToInteger(y); otherwise, let yr be y.

    let yr = !isNaN(y) && _singletons.To.ToInteger(realm, y) >= 0 && _singletons.To.ToInteger(realm, y) <= 99 ? 1900 + _singletons.To.ToInteger(realm, y) : y; // 9. Return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))).

    return (0, _date.TimeClip)(realm, (0, _date.MakeDate)(realm, (0, _date.MakeDay)(realm, yr, m, dt), (0, _date.MakeTime)(realm, h, min, s, milli)));
  });
  return func;
}
//# sourceMappingURL=Date.js.map

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 20.3.4.2
  obj.defineNativeMethod("getDate", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return DateFromTime(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.DateFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.3

  obj.defineNativeMethod("getDay", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return WeekDay(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.WeekDay)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.4

  obj.defineNativeMethod("getFullYear", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return YearFromTime(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.YearFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.5

  obj.defineNativeMethod("getHours", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return HourFromTime(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.HourFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.6

  obj.defineNativeMethod("getMilliseconds", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return msFromTime(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.msFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.7

  obj.defineNativeMethod("getMinutes", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return MinFromTime(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.MinFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.8

  obj.defineNativeMethod("getMonth", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return MonthFromTime(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.MonthFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.9

  obj.defineNativeMethod("getSeconds", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return SecFromTime(LocalTime(t)).

    return new _index.NumberValue(realm, (0, _index2.SecFromTime)(realm, (0, _index2.LocalTime)(realm, t)));
  }); // ECMA262 20.3.4.10

  obj.defineNativeMethod("getTime", 0, context => {
    // 1. Return ? thisTimeValue(this value).
    return (0, _index2.thisTimeValue)(realm, context);
  }); // ECMA262 20.3.4.11

  obj.defineNativeMethod("getTimezoneOffset", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return (t - LocalTime(t)) / msPerMinute.

    return new _index.NumberValue(realm, (t - (0, _index2.LocalTime)(realm, t)) / _index2.msPerMinute);
  }); // ECMA262 20.3.4.12

  obj.defineNativeMethod("getUTCDate", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return DateFromTime(t).

    return new _index.NumberValue(realm, (0, _index2.DateFromTime)(realm, t));
  }); // ECMA262 20.3.4.13

  obj.defineNativeMethod("getUTCDay", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return WeekDay(t).

    return new _index.NumberValue(realm, (0, _index2.WeekDay)(realm, t));
  }); // ECMA262 20.3.4.14

  obj.defineNativeMethod("getUTCFullYear", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return YearFromTime(t).

    return new _index.NumberValue(realm, (0, _index2.YearFromTime)(realm, t));
  }); // ECMA262 20.3.4.15

  obj.defineNativeMethod("getUTCHours", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return HourFromTime(t).

    return new _index.NumberValue(realm, (0, _index2.HourFromTime)(realm, t));
  }); // ECMA262 20.3.4.16

  obj.defineNativeMethod("getUTCMilliseconds", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return msFromTime(t).

    return new _index.NumberValue(realm, (0, _index2.msFromTime)(realm, t));
  }); // ECMA262 20.3.4.17

  obj.defineNativeMethod("getUTCMinutes", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return MinFromTime(t).

    return new _index.NumberValue(realm, (0, _index2.MinFromTime)(realm, t));
  }); // ECMA262 20.3.4.18

  obj.defineNativeMethod("getUTCMonth", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return MonthFromTime(t).

    return new _index.NumberValue(realm, (0, _index2.MonthFromTime)(realm, t));
  }); // ECMA262 20.3.4.19

  obj.defineNativeMethod("getUTCSeconds", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return SecFromTime(t).

    return new _index.NumberValue(realm, (0, _index2.SecFromTime)(realm, t));
  }); // ECMA262 20.3.4.20

  obj.defineNativeMethod("setDate", 1, (context, [date]) => {
    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    let t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let dt be ? ToNumber(date).

    let dt = _singletons.To.ToNumber(realm, date); // 3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).


    let newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), (0, _index2.MonthFromTime)(realm, t), dt), (0, _index2.TimeWithinDay)(realm, t)); // 4. Let u be TimeClip(UTC(newDate)).

    let u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, newDate)); // 5. Set the [[DateValue]] internal slot of this Date object to u.

    context.$DateValue = u; // 6. Return u.

    return u;
  }); // ECMA262 20.3.4.21

  obj.defineNativeMethod("setFullYear", 3, (context, [year, month, date], argCount) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. If t is NaN, let t be +0; otherwise, let t be LocalTime(t).

    t = isNaN(t) ? +0 : (0, _index2.LocalTime)(realm, t); // 3. Let y be ? ToNumber(year).

    let y = _singletons.To.ToNumber(realm, year); // 4. If month is not specified, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).


    let m = argCount >= 2 ? _singletons.To.ToNumber(realm, month) : (0, _index2.MonthFromTime)(realm, t); // 5. If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).

    let dt = argCount >= 3 ? _singletons.To.ToNumber(realm, date) : (0, _index2.DateFromTime)(realm, t); // 6. Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).

    let newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, y, m, dt), (0, _index2.TimeWithinDay)(realm, t)); // 7. Let u be TimeClip(UTC(newDate)).

    let u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, newDate)); // 8. Set the [[DateValue]] internal slot of this Date object to u.

    context.$DateValue = u; // 9. Return u.

    return u;
  }); // ECMA262 20.3.4.22

  obj.defineNativeMethod("setHours", 4, (context, [hour, min, sec, ms], argCount) => {
    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    let t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let h be ? ToNumber(hour).

    let h = _singletons.To.ToNumber(realm, hour); // 3. If min is not specified, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).


    let m = argCount >= 2 ? _singletons.To.ToNumber(realm, min) : (0, _index2.MinFromTime)(realm, t); // 4. If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).

    let s = argCount >= 3 ? _singletons.To.ToNumber(realm, sec) : (0, _index2.SecFromTime)(realm, t); // 5. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).

    let milli = argCount >= 4 ? _singletons.To.ToNumber(realm, ms) : (0, _index2.msFromTime)(realm, t); // 6. Let date be MakeDate(Day(t), MakeTime(h, m, s, milli)).

    let date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, h, m, s, milli)); // 7. Let u be TimeClip(UTC(date)).

    let u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, date)); // 8. Set the [[DateValue]] internal slot of this Date object to u.

    context.$DateValue = u; // 9. Return u.

    return u;
  }); // ECMA262 20.3.4.23

  obj.defineNativeMethod("setMilliseconds", 1, (context, [_ms]) => {
    let ms = _ms; // 1. Let t be LocalTime(? thisTimeValue(this value)).

    let t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let ms be ? ToNumber(ms).

    ms = _singletons.To.ToNumber(realm, ms); // 3. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ms).

    let time = (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), (0, _index2.SecFromTime)(realm, t), ms); // 4. Let u be TimeClip(UTC(MakeDate(Day(t), time))).

    let u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), time))); // 5. Set the [[DateValue]] internal slot of this Date object to u.

    context.$DateValue = u; // 6. Return u.

    return u;
  }); // ECMA262 20.3.4.24

  obj.defineNativeMethod("setMinutes", 3, (context, [min, sec, ms], argCount) => {
    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    let t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let m be ? ToNumber(min).

    let m = _singletons.To.ToNumber(realm, min); // 3. If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).


    let s = argCount >= 2 ? _singletons.To.ToNumber(realm, sec) : (0, _index2.SecFromTime)(realm, t); // 4. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).

    let milli = argCount >= 3 ? _singletons.To.ToNumber(realm, ms) : (0, _index2.msFromTime)(realm, t); // 5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).

    let date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), m, s, milli)); // 6. Let u be TimeClip(UTC(date)).

    let u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, date)); // 7. Set the [[DateValue]] internal slot of this Date object to u.

    context.$DateValue = u; // 8. Return u.

    return u;
  }); // ECMA262 20.3.4.25

  obj.defineNativeMethod("setMonth", 2, (context, [month, date], argCount) => {
    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    let t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let m be ? ToNumber(month).

    let m = _singletons.To.ToNumber(realm, month); // 3. If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).


    let dt = argCount >= 2 ? _singletons.To.ToNumber(realm, date) : (0, _index2.DateFromTime)(realm, t); // 4. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).

    let newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), m, dt), (0, _index2.TimeWithinDay)(realm, t)); // 5. Let u be TimeClip(UTC(newDate)).

    let u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, newDate)); // 6. Set the [[DateValue]] internal slot of this Date object to u.

    context.$DateValue = u; // 7. Return u.

    return u;
  }); // ECMA262 20.3.4.26

  obj.defineNativeMethod("setSeconds", 2, (context, [sec, ms], argCount) => {
    // 1. Let t be LocalTime(? thisTimeValue(this value)).
    let t = (0, _index2.LocalTime)(realm, (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value);
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let s be ? ToNumber(sec).

    let s = _singletons.To.ToNumber(realm, sec); // 3. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).


    let milli = argCount >= 2 ? _singletons.To.ToNumber(realm, ms) : (0, _index2.msFromTime)(realm, t); // 4. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).

    let date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), s, milli)); // 5. Let u be TimeClip(UTC(date)).

    let u = (0, _index2.TimeClip)(realm, (0, _index2.UTC)(realm, date)); // 6. Set the [[DateValue]] internal slot of this Date object to u.

    context.$DateValue = u; // 7. Return u.

    return u;
  }); // ECMA262 20.3.4.27

  obj.defineNativeMethod("setTime", 1, (context, [time]) => {
    // 1. Perform ? thisTimeValue(this value).
    (0, _index2.thisTimeValue)(realm, context);
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let t be ? ToNumber(time).

    let t = _singletons.To.ToNumber(realm, time); // 3. Let v be TimeClip(t).


    let v = (0, _index2.TimeClip)(realm, t); // 4. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 5. Return v.

    return v;
  }); // ECMA262 20.3.4.28

  obj.defineNativeMethod("setUTCDate", 1, (context, [date]) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let dt be ? ToNumber(date).

    let dt = _singletons.To.ToNumber(realm, date); // 3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)).


    let newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), (0, _index2.MonthFromTime)(realm, t), dt), (0, _index2.TimeWithinDay)(realm, t)); // 4. Let v be TimeClip(newDate).

    let v = (0, _index2.TimeClip)(realm, newDate); // 5. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 6. Return v.

    return v;
  }); // ECMA262 20.3.4.29

  obj.defineNativeMethod("setUTCFullYear", 3, (context, [year, month, date], argCount) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. If t is NaN, let t be +0.

    if (isNaN(t)) t = +0; // 3. Let y be ? ToNumber(year).

    let y = _singletons.To.ToNumber(realm, year); // 4. If month is not specified, let m be MonthFromTime(t); otherwise, let m be ? ToNumber(month).


    let m = argCount >= 2 ? _singletons.To.ToNumber(realm, month) : (0, _index2.MonthFromTime)(realm, t); // 5. If date is not specified, let dt be DateFromTime(t); otherwise, let dt be ? ToNumber(date).

    let dt = argCount >= 3 ? _singletons.To.ToNumber(realm, date) : (0, _index2.DateFromTime)(realm, t); // 6. Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)).

    let newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, y, m, dt), (0, _index2.TimeWithinDay)(realm, t)); // 7. Let v be TimeClip(newDate).

    let v = (0, _index2.TimeClip)(realm, newDate); // 8. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 9. Return v.

    return v;
  }); // ECMA262 20.3.4.30

  obj.defineNativeMethod("setUTCHours", 4, (context, [hour, min, sec, ms], argCount) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let h be ? ToNumber(hour).

    let h = _singletons.To.ToNumber(realm, hour); // 3. If min is not specified, let m be MinFromTime(t); otherwise, let m be ? ToNumber(min).


    let m = argCount >= 2 ? _singletons.To.ToNumber(realm, min) : (0, _index2.MinFromTime)(realm, t); // 4. If sec is not specified, let s be SecFromTime(t); otherwise, let s be ? ToNumber(sec).

    let s = argCount >= 3 ? _singletons.To.ToNumber(realm, sec) : (0, _index2.SecFromTime)(realm, t); // 5. If ms is not specified, let milli be msFromTime(t); otherwise, let milli be ? ToNumber(ms).

    let milli = argCount >= 4 ? _singletons.To.ToNumber(realm, ms) : (0, _index2.msFromTime)(realm, t); // 6. Let newDate be MakeDate(Day(t), MakeTime(h, m, s, milli)).

    let newDate = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, h, m, s, milli)); // 7. Let v be TimeClip(newDate).

    let v = (0, _index2.TimeClip)(realm, newDate); // 8. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 9. Return v.

    return v;
  }); // ECMA262 20.3.4.31

  obj.defineNativeMethod("setUTCMilliseconds", 1, (context, [ms]) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let milli be ? ToNumber(ms).

    let milli = _singletons.To.ToNumber(realm, ms); // 3. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), milli).


    let time = (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), (0, _index2.SecFromTime)(realm, t), milli); // 4. Let v be TimeClip(MakeDate(Day(t), time)).

    let v = (0, _index2.TimeClip)(realm, (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), time)); // 5. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 6. Return v.

    return v;
  }); // ECMA262 20.3.4.32

  obj.defineNativeMethod("setUTCMinutes", 3, (context, [min, sec, ms], argCount) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let m be ? ToNumber(min).

    let m = _singletons.To.ToNumber(realm, min); // 3. If sec is not specified, let s be SecFromTime(t).


    let s;

    if (argCount < 2) {
      s = (0, _index2.SecFromTime)(realm, t);
    } else {
      // 4. Else,
      // a. Let s be ? ToNumber(sec).
      s = _singletons.To.ToNumber(realm, sec);
    } // 5. If ms is not specified, let milli be msFromTime(t).


    let milli;

    if (argCount < 3) {
      milli = (0, _index2.msFromTime)(realm, t);
    } else {
      // 6. Else,
      // a. Let milli be ? ToNumber(ms).
      milli = _singletons.To.ToNumber(realm, ms);
    } // 7. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)).


    let date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), m, s, milli)); // 8. Let v be TimeClip(date).

    let v = (0, _index2.TimeClip)(realm, date); // 9. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 10. Return v.

    return v;
  }); // ECMA262 20.3.4.33

  obj.defineNativeMethod("setUTCMonth", 2, (context, [month, date], argCount) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let m be ? ToNumber(month).

    let m = _singletons.To.ToNumber(realm, month); // 3. If date is not specified, let dt be DateFromTime(t).


    let dt;

    if (argCount < 2) {
      dt = (0, _index2.DateFromTime)(realm, t);
    } else {
      // 4. Else,
      // a. Let dt be ? ToNumber(date).
      dt = _singletons.To.ToNumber(realm, date);
    } // 5. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)).


    let newDate = (0, _index2.MakeDate)(realm, (0, _index2.MakeDay)(realm, (0, _index2.YearFromTime)(realm, t), m, dt), (0, _index2.TimeWithinDay)(realm, t)); // 6. Let v be TimeClip(newDate).

    let v = (0, _index2.TimeClip)(realm, newDate); // 7. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 8. Return v.

    return v;
  }); // ECMA262 20.3.4.34

  obj.defineNativeMethod("setUTCSeconds", 2, (context, [sec, ms], argCount) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. Let s be ? ToNumber(sec).

    let s = _singletons.To.ToNumber(realm, sec); // 3. If ms is not specified, let milli be msFromTime(t).


    let milli;

    if (argCount < 2) {
      milli = (0, _index2.msFromTime)(realm, t);
    } else {
      // 4. Else,
      // a. Let milli be ? ToNumber(ms).
      milli = _singletons.To.ToNumber(realm, ms);
    } // 5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)).


    let date = (0, _index2.MakeDate)(realm, (0, _index2.Day)(realm, t), (0, _index2.MakeTime)(realm, (0, _index2.HourFromTime)(realm, t), (0, _index2.MinFromTime)(realm, t), s, milli)); // 6. Let v be TimeClip(date).

    let v = (0, _index2.TimeClip)(realm, date); // 7. Set the [[DateValue]] internal slot of this Date object to v.

    context.$DateValue = v; // 8. Return v.

    return v;
  }); // ECMA262 20.3.4.35

  obj.defineNativeMethod("toDateString", 0, context => {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toDateString");
  }); // ECMA262 20.3.4.36

  obj.defineNativeMethod("toISOString", 0, context => {
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;

    if (!isFinite(t)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    }

    return new _index.StringValue(realm, new Date(t).toISOString());
  }); // ECMA262 20.3.4.37

  obj.defineNativeMethod("toJSON", 1, (context, [key]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Let tv be ? ToPrimitive(O, hint Number).


    let tv = _singletons.To.ToPrimitive(realm, O.throwIfNotConcreteObject(), "number"); // 3. If Type(tv) is Number and tv is not finite, return null.


    if (tv instanceof _index.NumberValue && !isFinite(tv.value)) {
      return realm.intrinsics.null;
    } // 4. Return ? Invoke(O, "toISOString").


    return (0, _index2.Invoke)(realm, O, "toISOString");
  }); // ECMA262 20.3.4.38

  obj.defineNativeMethod("toLocaleDateString", 0, context => {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toLocaleDateString");
  }); // ECMA262 20.3.4.39

  obj.defineNativeMethod("toLocaleString", 0, context => {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toLocaleString");
  }); // ECMA262 20.3.4.40

  obj.defineNativeMethod("toLocaleTimeString", 0, context => {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toLocaleTimeString");
  }); // ECMA262 20.3.4.41

  obj.defineNativeMethod("toString", 0, context => {
    // 1. Let O be this Date object.
    let O = context; // 2. If O does not have a [[DateValue]] internal slot, then

    let tv;

    if (O.$DateValue === undefined) {
      // a. Let tv be NaN.
      tv = NaN;
    } else {
      // 3. Else,
      // a. Let tv be thisTimeValue(O).
      tv = (0, _index2.thisTimeValue)(realm, O).throwIfNotConcreteNumber().value;
    } // 4. Return ToDateString(tv).


    return new _index.StringValue(realm, (0, _index2.ToDateString)(realm, tv));
  }); // ECMA262 20.3.4.42

  obj.defineNativeMethod("toTimeString", 0, context => {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toTimeString");
  }); // ECMA262 20.3.4.43

  obj.defineNativeMethod("toUTCString", 0, context => {
    throw new _errors.FatalError("TODO #1005: implement Date.prototype.toUTCString");
  }); // ECMA262 20.3.4.44

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Return ? thisTimeValue(this value).
    return (0, _index2.thisTimeValue)(realm, context);
  }); // ECMA262 20.3.4.45

  obj.defineNativeMethod(realm.intrinsics.SymbolToPrimitive, 1, (context, [_hint]) => {
    let hint = _hint; // 1. Let O be the this value.

    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    }

    let tryFirst;
    hint = hint.throwIfNotConcrete(); // 3. If hint is the String value "string" or the String value "default", then

    if (hint instanceof _index.StringValue && (hint.value === "string" || hint.value === "default")) {
      // a. Let tryFirst be "string".
      tryFirst = "string";
    } else if (hint instanceof _index.StringValue && hint.value === "number") {
      // 4. Else if hint is the String value "number", then
      // a. Let tryFirst be "number".
      tryFirst = "number";
    } else {
      // 5. Else, throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 6. Return ? OrdinaryToPrimitive(O, tryFirst).


    return _singletons.To.OrdinaryToPrimitive(realm, O, tryFirst);
  }, {
    writable: false
  }); // B.2.4.1

  obj.defineNativeMethod("getYear", 0, context => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value; // 2. If t is NaN, return NaN.

    if (isNaN(t)) return realm.intrinsics.NaN; // 3. Return YearFromTime(LocalTime(t)) - 1900.

    return new _index.NumberValue(realm, (0, _index2.YearFromTime)(realm, (0, _index2.LocalTime)(realm, t)) - 1900);
  }); // B.2.4.2

  obj.defineNativeMethod("setYear", 1, (context, [year]) => {
    // 1. Let t be ? thisTimeValue(this value).
    let t = (0, _index2.thisTimeValue)(realm, context).throwIfNotConcreteNumber().value;
    (0, _invariant.default)(context instanceof _index.ObjectValue); // 2. If t is NaN, let t be +0; otherwise, let t be LocalTime(t).

    t = isNaN(t) ? +0 : (0, _index2.LocalTime)(realm, t); // 3. Let y be ? ToNumber(year).

    let y = _singletons.To.ToNumber(realm, year); // 4. If y is NaN, set the [[DateValue]] internal slot of this Date object to NaN and return NaN.


    if (isNaN(y)) {
      context.$DateValue = realm.intrinsics.NaN;
      return realm.intrinsics.NaN;
    } // 5. If y is not NaN and 0  To.ToInteger(y)  99, let yyyy be To.ToInteger(y) + 1900.


    let yyyy;

    if (_singletons.To.ToInteger(realm, y) < 99) {
      yyyy = _singletons.To.ToInteger(realm, y) + 1900;
    } else {
      // 6. Else, let yyyy be y.
      yyyy = y;
    } // 7. Let d be MakeDay(yyyy, MonthFromTime(t), DateFromTime(t)).


    let d = (0, _index2.MakeDay)(realm, yyyy, (0, _index2.MonthFromTime)(realm, t), (0, _index2.DateFromTime)(realm, t)); // 8. Let date be UTC(MakeDate(d, TimeWithinDay(t))).

    let date = (0, _index2.UTC)(realm, (0, _index2.MakeDate)(realm, d, (0, _index2.TimeWithinDay)(realm, t))); // 9. Set the [[DateValue]] internal slot of this Date object to TimeClip(date).

    let dateValue = (0, _index2.TimeClip)(realm, date);
    context.$DateValue = dateValue; // 10. Return the value of the [[DateValue]] internal slot of this Date object.

    return dateValue;
  }); // B.2.4.3

  obj.defineNativeProperty("toGMTString", obj.$Get("toUTCString", obj));
}
//# sourceMappingURL=DatePrototype.js.map

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _get = __webpack_require__(230);

var _abstract = __webpack_require__(233);

var _regexp = __webpack_require__(276);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let func = new _index.NativeFunctionValue(realm, "RegExp", "RegExp", 2, (context, [pattern, flags], argCount, NewTarget) => {
    // 1. Let patternIsRegExp be ? IsRegExp(pattern).
    let patternIsRegExp = (0, _is.IsRegExp)(realm, pattern);
    let newTarget; // 2. If NewTarget is not undefined, let newTarget be NewTarget.

    if (NewTarget) {
      newTarget = NewTarget;
    } else {
      // 3. Else,
      // a. Let newTarget be the active function object.
      newTarget = func; // b. If patternIsRegExp is true and flags is undefined, then

      if (patternIsRegExp && flags instanceof _index.UndefinedValue) {
        (0, _invariant.default)(pattern instanceof _index.ObjectValue); // i. Let patternConstructor be ? Get(pattern, "constructor").

        let patternConstructor = (0, _get.Get)(realm, pattern, "constructor"); // ii. If SameValue(newTarget, patternConstructor) is true, return pattern.

        if ((0, _abstract.SameValuePartial)(realm, newTarget, patternConstructor)) {
          return pattern;
        }
      }
    }

    let P, F; // 4. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then

    if (pattern instanceof _index.ObjectValue && pattern.$RegExpMatcher) {
      // a. Let P be the value of pattern's [[OriginalSource]] internal slot.
      (0, _invariant.default)(typeof pattern.$OriginalSource === "string");
      P = new _index.StringValue(realm, pattern.$OriginalSource); // b. If flags is undefined, let F be the value of pattern's [[OriginalFlags]] internal slot.

      if (flags instanceof _index.UndefinedValue) {
        (0, _invariant.default)(typeof pattern.$OriginalFlags === "string");
        F = new _index.StringValue(realm, pattern.$OriginalFlags);
      } else {
        // c. Else, let F be flags.
        F = flags.throwIfNotConcrete();
      }
    } else if (patternIsRegExp) {
      // 5. Else if patternIsRegExp is true, then
      (0, _invariant.default)(pattern instanceof _index.ObjectValue); // a. Let P be ? Get(pattern, "source").

      P = (0, _get.Get)(realm, pattern, "source"); // b. If flags is undefined, then

      if (flags instanceof _index.UndefinedValue) {
        // i. Let F be ? Get(pattern, "flags").
        F = (0, _get.Get)(realm, pattern, "flags");
      } else {
        // c. Else, let F be flags.
        F = flags.throwIfNotConcrete();
      }
    } else {
      // 6. Else,
      // a. Let P be pattern.
      P = pattern.throwIfNotConcrete(); // b. Let F be flags.

      F = flags.throwIfNotConcrete();
    } // 7. Let O be ? RegExpAlloc(newTarget).


    let O = (0, _regexp.RegExpAlloc)(realm, newTarget); // 8. Return ? RegExpInitialize(O, P, F).

    return (0, _regexp.RegExpInitialize)(realm, O, P, F);
  }); // ECMA262 21.2.4.2

  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });
  return func;
}
//# sourceMappingURL=RegExp.js.map

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index = __webpack_require__(10);

var _abstract = __webpack_require__(233);

var _call = __webpack_require__(234);

var _construct = __webpack_require__(228);

var _get = __webpack_require__(230);

var _singletons = __webpack_require__(236);

var _is = __webpack_require__(229);

var _regexp = __webpack_require__(276);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function InternalHasFlag(realm, context, flag) {
  // 1. Let R be the this value.
  let R = context.throwIfNotConcrete(); // 2. If Type(R) is not Object, throw a TypeError exception.

  if (!(R instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
  } // 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception.


  if (typeof R.$OriginalFlags !== "string") {
    // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
    if ((0, _abstract.SameValue)(realm, R, realm.intrinsics.RegExpPrototype)) {
      return realm.intrinsics.undefined;
    } else {
      // b. Otherwise, throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "R does not have an [[OriginalFlags]] internal slot");
    }
  } // 4. Let flags be the value of R's [[OriginalFlags]] internal slot.


  let flags = R.$OriginalFlags; // 5. If flags contains the code unit "g", return true.

  if (flags.indexOf(flag) >= 0) {
    return realm.intrinsics.true;
  } // 6. Return false.


  return realm.intrinsics.false;
}

function _default(realm, obj) {
  // ECMA262 21.2.5.2
  obj.defineNativeMethod("exec", 1, (context, [string]) => {
    // 1. Let R be the this value.
    let R = context.throwIfNotConcrete(); // 2. If Type(R) is not Object, throw a TypeError exception.

    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.


    if (R.$RegExpMatcher === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "R does not have a [[RegExpMatcher]] internal slot");
    } // 4. Let S be ? ToString(string).


    let S = _singletons.To.ToStringPartial(realm, string); // 5. Return ? RegExpBuiltinExec(R, S).


    return (0, _regexp.RegExpBuiltinExec)(realm, R, S);
  }); // ECMA262 21.2.5.3

  obj.defineNativeGetter("flags", context => {
    // 1. Let R be the this value.
    let R = context.throwIfNotConcrete(); // 2. If Type(R) is not Object, throw a TypeError exception.

    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. Let result be the empty String.


    let result = ""; // 4. Let global be ToBoolean(? Get(R, "global")).

    let global = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, R, "global")); // 5. If global is true, append "g" as the last code unit of result.


    if (global) result += "g"; // 6. Let ignoreCase be ToBoolean(? Get(R, "ignoreCase")).

    let ignoreCase = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, R, "ignoreCase")); // 7. If ignoreCase is true, append "i" as the last code unit of result.


    if (ignoreCase) result += "i"; // 8. Let multiline be ToBoolean(? Get(R, "multiline")).

    let multiline = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, R, "multiline")); // 9. If multiline is true, append "m" as the last code unit of result.


    if (multiline) result += "m"; // 10. Let unicode be ToBoolean(? Get(R, "unicode")).

    let unicode = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, R, "unicode")); // 11. If unicode is true, append "u" as the last code unit of result.


    if (unicode) result += "u"; // 12. Let sticky be ToBoolean(? Get(R, "sticky")).

    let sticky = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, R, "sticky")); // 13. If sticky is true, append "y" as the last code unit of result.


    if (sticky) result += "y"; // 14. Return result.

    return new _index.StringValue(realm, result);
  }); // ECMA262 21.2.5.4

  obj.defineNativeGetter("global", context => {
    return InternalHasFlag(realm, context, "g");
  }); // ECMA262 21.2.5.5

  obj.defineNativeGetter("ignoreCase", context => {
    return InternalHasFlag(realm, context, "i");
  }); // ECMA262 21.2.5.6

  obj.defineNativeMethod(realm.intrinsics.SymbolMatch, 1, (context, [string]) => {
    // 1. Let rx be the this value.
    let rx = context.throwIfNotConcrete(); // 2. If Type(rx) is not Object, throw a TypeError exception.

    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. Let S be ? ToString(string).


    let S = _singletons.To.ToStringPartial(realm, string); // 4. Let global be ToBoolean(? Get(rx, "global")).


    let global = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, rx, "global")); // 5. If global is false, then


    if (global === false) {
      // a. Return ? RegExpExec(rx, S).
      return (0, _regexp.RegExpExec)(realm, rx, S);
    } else {
      // 6. Else global is true,
      // a. Let fullUnicode be ToBoolean(? Get(rx, "unicode")).
      let fullUnicode = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, rx, "unicode")); // b. Perform ? Set(rx, "lastIndex", 0, true).


      _singletons.Properties.Set(realm, rx, "lastIndex", realm.intrinsics.zero, true); // c. Let A be ArrayCreate(0).


      let A = _singletons.Create.ArrayCreate(realm, 0); // d. Let n be 0.


      let n = 0; // e. Repeat,

      while (true) {
        // i. Let result be ? RegExpExec(rx, S).
        let result = (0, _regexp.RegExpExec)(realm, rx, S); // ii. If result is null, then

        if (result instanceof _index.NullValue) {
          // 1. If n=0, return null.
          if (n === 0) {
            return realm.intrinsics.null;
          } else {
            // 2. Else, return A.
            return A;
          }
        } else {
          // iii. Else result is not null,
          // 1. Let matchStr be ? ToString(? Get(result, "0")).
          let matchStr = _singletons.To.ToStringPartial(realm, (0, _get.Get)(realm, result, "0")); // 2. Let status be CreateDataProperty(A, ! ToString(n), matchStr).


          let status = _singletons.Create.CreateDataProperty(realm, A, _singletons.To.ToString(realm, new _index.NumberValue(realm, n)), new _index.StringValue(realm, matchStr)); // 3. Assert: status is true.


          (0, _invariant.default)(status === true, "status is true"); // 4. If matchStr is the empty String, then

          if (matchStr === "") {
            // a. Let thisIndex be ? ToLength(? Get(rx, "lastIndex")).
            let thisIndex = _singletons.To.ToLength(realm, (0, _get.Get)(realm, rx, "lastIndex")); // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).


            let nextIndex = (0, _regexp.AdvanceStringIndex)(realm, S, thisIndex, fullUnicode); // c .Perform ? Set(rx, "lastIndex", nextIndex, true).

            _singletons.Properties.Set(realm, rx, "lastIndex", new _index.NumberValue(realm, nextIndex), true);
          } // 5. Increment n.


          n += 1;
        }
      }

      (0, _invariant.default)(false);
    }
  }); // ECMA262 21.2.5.7

  obj.defineNativeGetter("multiline", context => {
    return InternalHasFlag(realm, context, "m");
  }); // ECMA262 21.2.5.8

  obj.defineNativeMethod(realm.intrinsics.SymbolReplace, 2, (context, [string, _replaceValue]) => {
    let replaceValue = _replaceValue; // 1. Let rx be the this value.

    let rx = context.throwIfNotConcrete(); // 2. If Type(rx) is not Object, throw a TypeError exception.

    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. Let S be ? ToString(string).


    let S = _singletons.To.ToStringPartial(realm, string); // 4. Let lengthS be the number of code unit elements in S.


    let lengthS = S.length; // 5. Let functionalReplace be IsCallable(replaceValue).

    let functionalReplace = (0, _is.IsCallable)(realm, replaceValue); // 6. If functionalReplace is false, then

    if (functionalReplace === false) {
      // a. Let replaceValue be ? ToString(replaceValue).
      replaceValue = new _index.StringValue(realm, _singletons.To.ToStringPartial(realm, replaceValue));
    } // 7. Let global be ToBoolean(? Get(rx, "global")).


    let global = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, rx, "global"));

    let fullUnicode; // 8. If global is true, then

    if (global === true) {
      // a. Let fullUnicode be ToBoolean(? Get(rx, "unicode")).
      fullUnicode = _singletons.To.ToBooleanPartial(realm, (0, _get.Get)(realm, rx, "unicode")); // b. Perform ? Set(rx, "lastIndex", 0, true).

      _singletons.Properties.Set(realm, rx, "lastIndex", realm.intrinsics.zero, true);
    } // 9. Let results be a new empty List.


    let results = []; // 10. Let done be false.

    let done = false; // 11. Repeat, while done is false

    while (done === false) {
      // a. Let result be ? RegExpExec(rx, S).
      let result = (0, _regexp.RegExpExec)(realm, rx, S); // b. If result is null, set done to true.

      if (result instanceof _index.NullValue) {
        done = true;
      } else {
        // c. Else result is not null,
        // i. Append result to the end of results.
        results.push(result); // ii. If global is false, set done to true.

        if (global === false) {
          done = true;
        } else {
          // iii. Else,
          (0, _invariant.default)(fullUnicode !== undefined); // 1. Let matchStr be ? ToString(? Get(result, "0")).

          let matchStr = _singletons.To.ToStringPartial(realm, (0, _get.Get)(realm, result, "0")); // 2. If matchStr is the empty String, then


          if (matchStr === "") {
            // a. Let thisIndex be ? ToLength(? Get(rx, "lastIndex")).
            let thisIndex = _singletons.To.ToLength(realm, (0, _get.Get)(realm, rx, "lastIndex")); // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).


            let nextIndex = (0, _regexp.AdvanceStringIndex)(realm, S, thisIndex, fullUnicode); // c. Perform ? Set(rx, "lastIndex", nextIndex, true).

            _singletons.Properties.Set(realm, rx, "lastIndex", new _index.NumberValue(realm, nextIndex), true);
          }
        }
      }
    } // 12. Let accumulatedResult be the empty String value.


    let accumulatedResult = ""; // 13. Let nextSourcePosition be 0.

    let nextSourcePosition = 0; // 14. Repeat, for each result in results,

    for (let result of results) {
      // a. Let nCaptures be ? ToLength(? Get(result, "length")).
      let nCaptures = _singletons.To.ToLength(realm, (0, _get.Get)(realm, result, "length")); // b. Let nCaptures be max(nCaptures - 1, 0).


      nCaptures = Math.max(nCaptures - 1, 0); // c. Let matched be ? ToString(? Get(result, "0")).

      let matched = _singletons.To.ToStringPartial(realm, (0, _get.Get)(realm, result, "0")); // d. Let matchLength be the number of code units in matched.


      let matchLength = matched.length; // e. Let position be ? ToInteger(? Get(result, "index")).

      let position = _singletons.To.ToInteger(realm, (0, _get.Get)(realm, result, "index")); // f. Let position be max(min(position, lengthS), 0).


      position = Math.max(Math.min(position, lengthS), 0); // g. Let n be 1.

      let n = 1; // h. Let captures be a new empty List.

      let captures = []; // i. Repeat while n  nCaptures

      while (n <= nCaptures) {
        // i. Let capN be ? Get(result, ! ToString(n)).
        let capN = (0, _get.Get)(realm, result, _singletons.To.ToString(realm, new _index.NumberValue(realm, n))); // ii. If capN is not undefined, then

        if (!capN.mightBeUndefined()) {
          // 1. Let capN be ? ToString(capN).
          capN = _singletons.To.ToStringPartial(realm, capN);
        } else {
          capN.throwIfNotConcrete();
          capN = undefined;
        } // iii. Append capN as the last element of captures.


        captures.push(capN); // iv. Let n be n+1.

        n = n + 1;
      }

      let replacement; // j. If functionalReplace is true, then

      if (functionalReplace) {
        // i. Let replacerArgs be  matched .
        let replacerArgs = [new _index.StringValue(realm, matched)]; // ii. Append in list order the elements of captures to the end of the List replacerArgs.

        for (let capture of captures) {
          replacerArgs.push(capture === undefined ? realm.intrinsics.undefined : new _index.StringValue(realm, capture));
        } // iii. Append position and S as the last two elements of replacerArgs.


        replacerArgs = replacerArgs.concat([new _index.NumberValue(realm, position), new _index.StringValue(realm, S)]); // iv. Let replValue be ? Call(replaceValue, undefined, replacerArgs).

        let replValue = (0, _call.Call)(realm, replaceValue, realm.intrinsics.undefined, replacerArgs); // v. Let replacement be ? ToString(replValue).

        replacement = _singletons.To.ToStringPartial(realm, replValue);
      } else {
        // k. Else,
        (0, _invariant.default)(replaceValue instanceof _index.StringValue); // i. Let replacement be GetSubstitution(matched, S, position, captures, replaceValue).

        replacement = (0, _get.GetSubstitution)(realm, matched, S, position, captures, replaceValue.value);
      } // l. If position  nextSourcePosition, then


      if (position >= nextSourcePosition) {
        // i. NOTE position should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx. In such cases, the corresponding substitution is ignored.
        // ii. Let accumulatedResult be the String formed by concatenating the code units of the current value of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to position (exclusive) and with the code units of replacement.
        accumulatedResult = accumulatedResult + S.substr(nextSourcePosition, position - nextSourcePosition) + replacement; // iii. Let nextSourcePosition be position + matchLength.

        nextSourcePosition = position + matchLength;
      }
    } // 15. If nextSourcePosition  lengthS, return accumulatedResult.


    if (nextSourcePosition >= lengthS) return new _index.StringValue(realm, accumulatedResult); // 16. Return the String formed by concatenating the code units of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive).

    return new _index.StringValue(realm, accumulatedResult + S.substr(nextSourcePosition));
  }); // ECMA262 21.2.5.9

  obj.defineNativeMethod(realm.intrinsics.SymbolSearch, 1, (context, [string]) => {
    // 1. Let rx be the this value.
    let rx = context.throwIfNotConcrete(); // 2. If Type(rx) is not Object, throw a TypeError exception.

    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. Let S be ? ToString(string).


    let S = _singletons.To.ToStringPartial(realm, string); // 4. Let previousLastIndex be ? Get(rx, "lastIndex").


    let previousLastIndex = (0, _get.Get)(realm, rx, "lastIndex"); // 5. Perform ? Set(rx, "lastIndex", 0, true).

    _singletons.Properties.Set(realm, rx, "lastIndex", realm.intrinsics.zero, true); // 6. Let result be ? RegExpExec(rx, S).


    let result = (0, _regexp.RegExpExec)(realm, rx, S); // 7. Perform ? Set(rx, "lastIndex", previousLastIndex, true).

    _singletons.Properties.Set(realm, rx, "lastIndex", previousLastIndex, true); // 8. If result is null, return -1.


    if (result instanceof _index.NullValue) return new _index.NumberValue(realm, -1); // 9. Return ? Get(result, "index").

    return (0, _get.Get)(realm, result, "index");
  }); // ECMA262 21.2.5.10

  obj.defineNativeGetter("source", context => {
    // 1. Let R be the this value.
    let R = context.throwIfNotConcrete(); // 2. If Type(R) is not Object, throw a TypeError exception.

    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. If R does not have an [[OriginalSource]] internal slot, throw a TypeError exception.


    if (typeof R.$OriginalSource !== "string") {
      // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.
      if ((0, _abstract.SameValue)(realm, R, realm.intrinsics.RegExpPrototype)) {
        return new _index.StringValue(realm, "(?:)");
      } else {
        // b. Otherwise, throw a TypeError exception.
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "R does not have an [[OriginalSource]] internal slot");
      }
    } // 4. Assert: R has an [[OriginalFlags]] internal slot.


    (0, _invariant.default)(R.$OriginalFlags !== undefined, "R has an [[OriginalFlags]] internal slot"); // 5. Let src be R.[[OriginalSource]].

    let src = R.$OriginalSource;
    (0, _invariant.default)(typeof src === "string"); // 6. Let flags be R.[[OriginalFlags]].

    let flags = R.$OriginalFlags;
    (0, _invariant.default)(typeof flags === "string"); // 7. Return EscapeRegExpPattern(src, flags).

    return new _index.StringValue(realm, (0, _regexp.EscapeRegExpPattern)(realm, src, flags));
  }); // ECMA262 21.2.5.11

  obj.defineNativeMethod(realm.intrinsics.SymbolSplit, 2, (context, [string, limit]) => {
    // 1. Let rx be the this value.
    let rx = context.throwIfNotConcrete(); // 2. If Type(rx) is not Object, throw a TypeError exception.

    if (!(rx instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(rx) is not an object");
    } // 3. Let S be ? ToString(string).


    let S = _singletons.To.ToStringPartial(realm, string); // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).


    let C = (0, _construct.SpeciesConstructor)(realm, rx, realm.intrinsics.RegExp); // 5. Let flags be ? ToString(? Get(rx, "flags")).

    let flags = _singletons.To.ToStringPartial(realm, (0, _get.Get)(realm, rx, "flags"));

    let unicodeMatching; // 6. If flags contains "u", let unicodeMatching be true.

    if (flags.indexOf("u") >= 0) {
      unicodeMatching = true;
    } else {
      // 7. Else, let unicodeMatching be false.
      unicodeMatching = false;
    }

    let newFlags; // 8. If flags contains "y", let newFlags be flags.

    if (flags.indexOf("y") >= 0) {
      newFlags = flags;
    } else {
      // 9. Else, let newFlags be the string that is the concatenation of flags and "y".
      newFlags = flags + "y";
    } // 10. Let splitter be ? Construct(C,  rx, newFlags ).


    let splitter = (0, _construct.Construct)(realm, C, [rx, new _index.StringValue(realm, newFlags)]).throwIfNotConcreteObject(); // 11. Let A be ArrayCreate(0).

    let A = _singletons.Create.ArrayCreate(realm, 0); // 12. Let lengthA be 0.


    let lengthA = 0; // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).

    let lim = limit instanceof _index.UndefinedValue ? Math.pow(2, 32) - 1 : _singletons.To.ToUint32(realm, limit.throwIfNotConcrete()); // 14. Let size be the number of elements in S.

    let size = S.length; // 15. Let p be 0.

    let p = 0; // 16. If lim = 0, return A.

    if (lim === 0) return A; // 17. If size = 0, then

    if (size === 0) {
      // a. Let z be ? RegExpExec(splitter, S).
      let z = (0, _regexp.RegExpExec)(realm, splitter, S); // b. If z is not null, return A.

      if (!(z instanceof _index.NullValue)) return A; // c. Perform ! CreateDataProperty(A, "0", S).

      _singletons.Create.CreateDataProperty(realm, A, "0", new _index.StringValue(realm, S)); // d Return A.


      return A;
    } // 18. Let q be p.


    let q = p; // 19. Repeat, while q < size

    while (q < size) {
      // a. Perform ? Set(splitter, "lastIndex", q, true).
      _singletons.Properties.Set(realm, splitter, "lastIndex", new _index.NumberValue(realm, q), true); // b. Let z be ? RegExpExec(splitter, S).


      let z = (0, _regexp.RegExpExec)(realm, splitter, S); // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).

      if (z instanceof _index.NullValue) {
        q = (0, _regexp.AdvanceStringIndex)(realm, S, q, unicodeMatching);
      } else {
        // d. Else z is not null,
        // i. Let e be ? ToLength(? Get(splitter, "lastIndex")).
        let e = _singletons.To.ToLength(realm, (0, _get.Get)(realm, splitter, "lastIndex")); // ii. Let e be min(e, size).


        e = Math.min(e, size); // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).

        if (e === p) {
          q = (0, _regexp.AdvanceStringIndex)(realm, S, q, unicodeMatching);
        } else {
          // iv. Else e  p,
          // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
          let T = S.substr(p, q - p); // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).

          _singletons.Create.CreateDataProperty(realm, A, _singletons.To.ToString(realm, new _index.NumberValue(realm, lengthA)), new _index.StringValue(realm, T)); // 3. Let lengthA be lengthA + 1.


          lengthA = lengthA + 1; // 4. If lengthA = lim, return A.

          if (lengthA === lim) return A; // 5. Let p be e.

          p = e; // 6. Let numberOfCaptures be ? ToLength(? Get(z, "length")).

          let numberOfCaptures = _singletons.To.ToLength(realm, (0, _get.Get)(realm, z, "length")); // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).


          numberOfCaptures = Math.max(numberOfCaptures - 1, 0); // 8. Let i be 1.

          let i = 1; // 9. Repeat, while i  numberOfCaptures,

          while (i <= numberOfCaptures) {
            // a. Let nextCapture be ? Get(z, ! ToString(i)).
            let nextCapture = (0, _get.Get)(realm, z, _singletons.To.ToString(realm, new _index.NumberValue(realm, i))); // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).

            _singletons.Create.CreateDataProperty(realm, A, _singletons.To.ToString(realm, new _index.NumberValue(realm, lengthA)), nextCapture); // c. Let i be i + 1.


            i = i + 1; // d. Let lengthA be lengthA + 1.

            lengthA = lengthA + 1; // e. If lengthA = lim, return A.

            if (lengthA === lim) return A;
          } // 10. Let q be p.


          q = p;
        }
      }
    } // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).


    let T = S.substr(p, size - p); // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).

    _singletons.Create.CreateDataProperty(realm, A, _singletons.To.ToString(realm, new _index.NumberValue(realm, lengthA)), new _index.StringValue(realm, T)); // 22. Return A.


    return A;
  }); // ECMA262 21.2.5.12

  obj.defineNativeGetter("sticky", context => {
    return InternalHasFlag(realm, context, "y");
  }); // ECMA262 21.2.5.13

  obj.defineNativeMethod("test", 1, (context, [S]) => {
    // 1. Let R be the this value.
    let R = context.throwIfNotConcrete(); // 2. If Type(R) is not Object, throw a TypeError exception.

    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. Let string be ? ToString(S).


    let string = _singletons.To.ToStringPartial(realm, S); // 4. Let match be ? RegExpExec(R, string).


    let match = (0, _regexp.RegExpExec)(realm, R, string); // 5. If match is not null, return true; else return false.

    return new _index.BooleanValue(realm, !(match instanceof _index.NullValue) ? true : false);
  }); // ECMA262 21.2.5.14

  obj.defineNativeMethod("toString", 0, context => {
    // 1. Let R be the this value.
    let R = context.throwIfNotConcrete(); // 2. If Type(R) is not Object, throw a TypeError exception.

    if (!(R instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(R) is not an object");
    } // 3. Let pattern be ? ToString(? Get(R, "source")).


    let pattern = _singletons.To.ToStringPartial(realm, (0, _get.Get)(realm, R, "source")); // 4. Let flags be ? ToString(? Get(R, "flags")).


    let flags = _singletons.To.ToStringPartial(realm, (0, _get.Get)(realm, R, "flags")); // 5. Let result be the String value formed by concatenating "/", pattern, "/", and flags.


    let result = "/" + pattern + "/" + flags; // 6. Return result.

    return new _index.StringValue(realm, result);
  }); // ECMA262 21.2.5.15

  obj.defineNativeGetter("unicode", context => {
    return InternalHasFlag(realm, context, "u");
  });
}
//# sourceMappingURL=RegExpPrototype.js.map

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _abstract = __webpack_require__(233);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 19.4.1.1
  let func = new _index.NativeFunctionValue(realm, "Symbol", "Symbol", 0, (context, [description], argCount, NewTarget) => {
    // 1. If NewTarget is not undefined, throw a TypeError exception.
    if (NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. If description is undefined, let descString be undefined.


    let descString;

    if (!description || description instanceof _index.UndefinedValue) {
      descString = undefined;
    } else if (description instanceof _index.AbstractValue) {
      descString = description;
    } else {
      // 3. Else, let descString be ? ToString(description).
      descString = _singletons.To.ToStringPartial(realm, description);
      descString = new _index.StringValue(realm, descString);
    } // 4. Return a new unique Symbol value whose [[Description]] value is descString.


    return new _index.SymbolValue(realm, descString);
  }); // ECMA262 19.4.2.1

  func.defineNativeMethod("for", 1, (context, [key]) => {
    // 1. Let stringKey be ? ToString(key).
    let stringKey = _singletons.To.ToStringPartial(realm, key);

    stringKey = new _index.StringValue(realm, stringKey); // 2. For each element e of the GlobalSymbolRegistry List,

    for (let e of realm.globalSymbolRegistry) {
      // a. If SameValue(e.[[Key]], stringKey) is true, return e.[[Symbol]].
      if (e.$Key === stringKey.value) {
        return e.$Symbol;
      }
    } // 3. Assert: GlobalSymbolRegistry does not currently contain an entry for stringKey.
    // 4. Let newSymbol be a new unique Symbol value whose [[Description]] value is stringKey.


    let newSymbol = new _index.SymbolValue(realm, stringKey); // 5. Append the Record { [[Key]]: stringKey, [[Symbol]]: newSymbol } to the GlobalSymbolRegistry List.

    realm.globalSymbolRegistry.push({
      $Key: stringKey.value,
      $Symbol: newSymbol
    }); // 6. Return newSymbol.

    return newSymbol;
  }); // ECMA262 19.4.2.2

  func.defineNativeMethod("keyFor", 1, (context, [sym]) => {
    // 1. If Type(sym) is not Symbol, throw a TypeError exception.
    if (!(sym instanceof _index.SymbolValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(sym) is not Symbol");
    } // 2. For each element e of the GlobalSymbolRegistry List (see 19.4.2.1),


    for (let e of realm.globalSymbolRegistry) {
      // a. If SameValue(e.[[Symbol]], sym) is true, return e.[[Key]].
      if ((0, _abstract.SameValue)(realm, e.$Symbol, sym) === true) {
        return new _index.StringValue(realm, e.$Key);
      }
    } // 3. Assert: GlobalSymbolRegistry does not currently contain an entry for sym.
    // 4. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 19.4.2.3

  func.defineNativeConstant("isConcatSpreadable", realm.intrinsics.SymbolIsConcatSpreadable); // ECMA262 19.4.2.10

  func.defineNativeConstant("species", realm.intrinsics.SymbolSpecies); // ECMA262 19.4.2.8

  func.defineNativeConstant("replace", realm.intrinsics.SymbolReplace); // ECMA262 19.4.2.4

  func.defineNativeConstant("iterator", realm.intrinsics.SymbolIterator); // ECMA262 19.4.2.2

  func.defineNativeConstant("hasInstance", realm.intrinsics.SymbolHasInstance); // ECMA262 19.4.2.12

  func.defineNativeConstant("toPrimitive", realm.intrinsics.SymbolToPrimitive); // ECMA262 19.4.2.13

  func.defineNativeConstant("toStringTag", realm.intrinsics.SymbolToStringTag); // ECMA262 19.4.2.14

  func.defineNativeConstant("unscopables", realm.intrinsics.SymbolUnscopables); // ECMA262 19.4.2.6

  func.defineNativeConstant("match", realm.intrinsics.SymbolMatch); // ECMA262 19.4.2.11

  func.defineNativeConstant("split", realm.intrinsics.SymbolSplit); // ECMA262 19.4.2.9

  func.defineNativeConstant("search", realm.intrinsics.SymbolSearch);
  return func;
}
//# sourceMappingURL=Symbol.js.map

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  const tsTemplateSrc = "('' + A)"; // ECMA262 19.4.3.2

  obj.defineNativeMethod("toString", 0, context => {
    const target = context instanceof _index.ObjectValue ? context.$SymbolData : context;

    if (target instanceof _index.AbstractValue && target.getType() === _index.SymbolValue) {
      return _index.AbstractValue.createFromTemplate(realm, tsTemplateSrc, _index.StringValue, [target]);
    } // 1. Let s be the this value.


    let s = context.throwIfNotConcrete(); // 2. If Type(s) is Symbol, let sym be s.

    let sym;

    if (s instanceof _index.SymbolValue) {
      sym = s;
    } else {
      // 3. Else,
      // a. If Type(s) is not Object, throw a TypeError exception.
      if (!(s instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // b. If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.


      if (!s.$SymbolData) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // c. Let sym be the value of s's [[SymbolData]] internal slot.


      sym = s.$SymbolData;
    }

    sym.throwIfNotConcreteSymbol();
    (0, _invariant.default)(sym instanceof _index.SymbolValue, "expected symbol data internal slot to be a symbol value"); // 4. Return SymbolDescriptiveString(sym).

    return new _index.StringValue(realm, (0, _index2.SymbolDescriptiveString)(realm, sym));
  }); // ECMA262 19.4.3.3

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Let s be the this value.
    let s = context.throwIfNotConcrete(); // 2. If Type(s) is Symbol, return s.

    if (s instanceof _index.SymbolValue) return s; // 3. If Type(s) is not Object, throw a TypeError exception.

    if (!(s instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.


    if (!s.$SymbolData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 5. Return the value of s's [[SymbolData]] internal slot.


    return s.$SymbolData;
  }); // ECMA262 19.4.3.4

  obj.defineNativeMethod(realm.intrinsics.SymbolToPrimitive, 1, (context, [hint]) => {
    // 1. Let s be the this value.
    let s = context.throwIfNotConcrete(); // 2. If Type(s) is Symbol, return s.

    if (s instanceof _index.SymbolValue) return s; // 3. If Type(s) is not Object, throw a TypeError exception.

    if (!(s instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.


    if (!s.$SymbolData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 5. Return s.[[SymbolData]].


    return s.$SymbolData;
  }, {
    writable: false
  }); // ECMA262 19.4.3.5

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Symbol"), {
    writable: false
  });
}
//# sourceMappingURL=SymbolPrototype.js.map

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 21.1.1
  let func = new _index.NativeFunctionValue(realm, "String", "String", 1, (context, [value], argCount, NewTarget) => {
    let s; // 1. If no arguments were passed to this function invocation, let s be "".

    if (argCount === 0) {
      s = realm.intrinsics.emptyString;
    } else {
      // 2. Else,
      // a. If NewTarget is undefined and Type(value) is Symbol, return SymbolDescriptiveString(value).
      if (!NewTarget && value instanceof _index.SymbolValue) {
        return new _index.StringValue(realm, (0, _index2.SymbolDescriptiveString)(realm, value));
      } // b. Let s be ? ToString(value).


      s = _singletons.To.ToStringValue(realm, value);
    } // 3. If NewTarget is undefined, return s.


    if (!NewTarget) return s; // 4. Return ? StringCreate(s, ? GetPrototypeFromConstructor(NewTarget, "%StringPrototype%")).

    s = s.throwIfNotConcreteString();
    return _singletons.Create.StringCreate(realm, s, (0, _index2.GetPrototypeFromConstructor)(realm, NewTarget, "StringPrototype"));
  }); // ECMA262 21.1.2.1 ( ..._codeUnits_ )

  func.defineNativeMethod("fromCharCode", 1, (context, codeUnits, argCount) => {
    // 1. Let codeUnits be a List containing the arguments passed to this function.
    codeUnits; // 2. Let length be the number of elements in codeUnits.

    let length = argCount; // 3. Let elements be a new empty List.

    let elements = []; // 4. Let nextIndex be 0.

    let nextIndex = 0; // 5. Repeat while nextIndex < length

    while (nextIndex < length) {
      // a. Let next be codeUnits[nextIndex].
      let next = codeUnits[nextIndex]; // b. Let nextCU be ? ToUint16(next).

      let nextCU = _singletons.To.ToUint16(realm, next); // c. Append nextCU to the end of elements.


      elements.push(nextCU); // d. Let nextIndex be nextIndex + 1.

      nextIndex++;
    } // 6. Return the String value whose elements are, in order, the elements in the List elements. If length
    //    is 0, the empty string is returned.


    return new _index.StringValue(realm, String.fromCharCode.apply(null, elements));
  }); // ECMA262 21.1.2.2 ( ..._codePoints_ )

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("fromCodePoint", 1, (context, codePoints, argCount) => {
    // 1. Let codePoints be a List containing the arguments passed to this function.
    codePoints; // 2. Let length be the number of elements in codePoints.

    let length = argCount; // 3. Let elements be a new empty List.

    let elements = []; // 4. Let nextIndex be 0.

    let nextIndex = 0; // 5. Repeat while nextIndex < length

    while (nextIndex < length) {
      // a. Let next be codePoints[nextIndex].
      let next = codePoints[nextIndex]; // b. Let nextCP be ? ToNumber(next).

      let nextCP = _singletons.To.ToNumber(realm, next); // c. If SameValue(nextCP, ToInteger(nextCP)) is false, throw a RangeError exception.


      if (nextCP !== _singletons.To.ToInteger(realm, nextCP)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "SameValue(nextCP, To.ToInteger(nextCP)) is false");
      } // d. If nextCP < 0 or nextCP > 0x10FFFF, throw a RangeError exception.


      if (nextCP < 0 || nextCP > 0x10ffff) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "SameValue(nextCP, To.ToInteger(nextCP)) is false");
      } // e. Append the elements of the UTF16Encoding of nextCP to the end of elements.


      elements.push(String.fromCodePoint(nextCP)); // f. Let nextIndex be nextIndex + 1.

      nextIndex++;
    } // 6. Return the String value whose elements are, in order, the elements in the List elements. If length
    //    is 0, the empty string is returned.


    return new _index.StringValue(realm, elements.join(""));
  }); // ECMA262 21.1.2.4

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("raw", 1, (context, [template, ..._substitutions], argCount) => {
    let substitutions = _substitutions; // 1. Let substitutions be a List consisting of all of the arguments passed to this function, starting with the second argument. If fewer than two arguments were passed, the List is empty.

    substitutions = argCount < 2 ? [] : substitutions; // 2. Let numberOfSubstitutions be the number of elements in substitutions.

    let numberOfSubstitutions = substitutions.length; // 3. Let cooked be ? ToObject(template).

    let cooked = _singletons.To.ToObject(realm, template); // 4. Let raw be ? ToObject(? Get(cooked, "raw")).


    let raw = _singletons.To.ToObject(realm, (0, _index2.Get)(realm, cooked, "raw")); // 5. Let literalSegments be ? ToLength(? Get(raw, "length")).


    let literalSegments = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, raw, "length")); // 6. If literalSegments  0, return the empty string.


    if (literalSegments <= 0) return realm.intrinsics.emptyString; // 7. Let stringElements be a new empty List.

    let stringElements = ""; // 8. Let nextIndex be 0.

    let nextIndex = 0; // 9. Repeat

    while (true) {
      // a. Let nextKey be ! ToString(nextIndex).
      let nextKey = _singletons.To.ToString(realm, new _index.NumberValue(realm, nextIndex)); // b. Let nextSeg be ? ToString(? Get(raw, nextKey)).


      let nextSeg = _singletons.To.ToStringPartial(realm, (0, _index2.Get)(realm, raw, nextKey)); // c. Append in order the code unit elements of nextSeg to the end of stringElements.


      stringElements = stringElements + nextSeg; // d. If nextIndex + 1 = literalSegments, then

      if (nextIndex + 1 === literalSegments) {
        // i. Return the String value whose code units are, in order, the elements in the List stringElements. If stringElements has no elements, the empty string is returned.
        return new _index.StringValue(realm, stringElements);
      }

      let next; // e. If nextIndex < numberOfSubstitutions, let next be substitutions[nextIndex].

      if (nextIndex < numberOfSubstitutions) next = substitutions[nextIndex];else {
        // f. Else, let next be the empty String.
        next = realm.intrinsics.emptyString;
      } // g. Let nextSub be ? ToString(next).

      let nextSub = _singletons.To.ToStringPartial(realm, next); // h. Append in order the code unit elements of nextSub to the end of stringElements.


      stringElements = stringElements + nextSub; // i. Let nextIndex be nextIndex + 1.

      nextIndex = nextIndex + 1;
    }

    (0, _invariant.default)(false);
  });
  return func;
}
//# sourceMappingURL=String.js.map

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _realm = __webpack_require__(7);

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _get = __webpack_require__(230);

var _call = __webpack_require__(234);

var _singletons = __webpack_require__(236);

var _regexp = __webpack_require__(276);

var _abstract = __webpack_require__(233);

var _has = __webpack_require__(269);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const sliceTemplateSrc = "(A).slice(B,C)";
const splitTemplateSrc = "(A).split(B,C)";

function _default(realm, obj) {
  // ECMA262 21.1.3
  obj.$StringData = realm.intrinsics.emptyString; // ECMA262 21.1.3

  obj.defineNativeProperty("length", realm.intrinsics.zero); // ECMA262 21.1.3.1

  obj.defineNativeMethod("charAt", 1, (context, [pos]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let position be ? ToInteger(pos).


    let position = _singletons.To.ToInteger(realm, pos); // 4. Let size be the number of elements in S.


    let size = S.length; // 5. If position < 0 or position  size, return the empty String.

    if (position < 0 || position >= size) return realm.intrinsics.emptyString; // 6. Return a String of length 1, containing one code unit from S, namely the code unit at index position.

    return new _index.StringValue(realm, S.charAt(position));
  }); // ECMA262 21.1.3.2

  obj.defineNativeMethod("charCodeAt", 1, (context, [pos]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let position be ? ToInteger(pos).


    let position = _singletons.To.ToInteger(realm, pos); // 4. Let size be the number of elements in S.


    let size = S.length; // 5. If position < 0 or position  size, return NaN.

    if (position < 0 || position >= size) return realm.intrinsics.NaN; // 6. Return a value of Number type, whose value is the code unit value of the element at index position
    //    in the String S.

    return new _index.NumberValue(realm, S.charCodeAt(position));
  }); // ECMA262 21.1.3.3

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("codePointAt", 1, (context, [pos]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let position be ? ToInteger(pos).


    let position = _singletons.To.ToInteger(realm, pos); // 4. Let size be the number of elements in S.


    let size = S.length; // 5. If position < 0 or position  size, return undefined.

    if (position < 0 || position >= size) return realm.intrinsics.undefined; // 6. Let first be the code unit value of the element at index position in the String S.
    // 7. If first < 0xD800 or first > 0xDBFF or position+1 = size, return first.
    // 8. Let second be the code unit value of the element at index position+1 in the String S.
    // 9. If second < 0xDC00 or second > 0xDFFF, return first.
    // 10. Return UTF16Decode(first, second).

    return new _index.NumberValue(realm, S.codePointAt(position));
  }); // ECMA262 21.1.3.4

  obj.defineNativeMethod("concat", 1, (context, args, argCount) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let args be a List whose elements are the arguments passed to this function.


    args = argCount === 0 ? [] : args; // 4. Let R be S.

    let R = S; // 5. Repeat, while args is not empty

    while (args.length) {
      // a. Remove the first element from args and let next be the value of that element.
      let next = args.shift(); // b. Let nextString be ? ToString(next).

      let nextString = _singletons.To.ToStringPartial(realm, next); // c. Let R be the String value consisting of the code units of the previous value of R followed by the code units of nextString.


      R = R + nextString;
    } // 6. Return R.


    return new _index.StringValue(realm, R);
  }); // ECMA262 21.1.3.6

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("endsWith", 1, (context, [searchString, endPosition]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let isRegExp be ? IsRegExp(searchString).


    let isRegExp = (0, _is.IsRegExp)(realm, searchString); // 4. If isRegExp is true, throw a TypeError exception.

    if (isRegExp) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "String.prototype");
    } // 5. Let searchStr be ? ToString(searchString).


    let searchStr = _singletons.To.ToStringPartial(realm, searchString); // 6. Let len be the number of elements in S.


    let len = S.length; // 7. If endPosition is undefined, let pos be len, else let pos be ? ToInteger(endPosition).)

    let pos;

    if (!endPosition || endPosition instanceof _index.UndefinedValue) {
      pos = len;
    } else {
      pos = _singletons.To.ToInteger(realm, endPosition.throwIfNotConcrete());
    } // 8. Let end be min(max(pos, 0), len).


    let end = Math.min(Math.max(pos, 0), len); // 9. Let searchLength be the number of elements in searchStr.

    let searchLength = searchStr.length; // 10. Let start be end - searchLength.

    let start = end - searchLength; // 11. If start is less than 0, return false.

    if (start < 0) return realm.intrinsics.false; // 12. If the sequence of elements of S starting at start of length searchLength is the same as the full
    //     element sequence of searchStr, return true.

    if (S.substr(start, searchLength) === searchStr) return realm.intrinsics.true; // 13. Otherwise, return false.

    return realm.intrinsics.false;
  }); // ECMA262 21.1.3.7

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("includes", 1, (context, [searchString, position]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let isRegExp be ? IsRegExp(searchString).


    let isRegExp = (0, _is.IsRegExp)(realm, searchString); // 4. If isRegExp is true, throw a TypeError exception.

    if (isRegExp) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "String.prototype");
    } // 5. Let searchStr be ? ToString(searchString).


    let searchStr = _singletons.To.ToStringPartial(realm, searchString); // 6. Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)


    let pos = _singletons.To.ToInteger(realm, position || realm.intrinsics.undefined); // 7. Let len be the number of elements in S.


    let len = S.length; // 8. Let start be min(max(pos, 0), len).

    let start = Math.min(Math.max(pos, 0), len); // 9. Let searchLen be the number of elements in searchStr.

    let searchLen = searchStr.length; // 10. If there exists any integer k not smaller than start such that k + searchLen is not greater than
    //     len, and for all nonnegative integers j less than searchLen, the code unit at index k+j of S is the
    //     same as the code unit at index j of searchStr, return true; but if there is no such integer k,
    //     return false.

    if (searchLen === 0) {
      return realm.intrinsics.true;
    } else {
      for (let k = start; k + searchLen <= len; ++k) {
        let found = true;

        for (let j = 0; j < searchLen; ++j) {
          if (S.charCodeAt(k + j) !== searchStr.charCodeAt(j)) {
            found = false;
          }
        }

        if (found) return realm.intrinsics.true;
      }

      return realm.intrinsics.false;
    }
  }); // ECMA262 21.1.3.8

  obj.defineNativeMethod("indexOf", 1, (context, [searchString, position]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let searchStr be ? ToString(searchString).


    let searchStr = _singletons.To.ToStringPartial(realm, searchString); // 4. Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)


    let pos = position ? _singletons.To.ToInteger(realm, position) : 0; // 5. Let len be the number of elements in S.
    // 6. Let start be min(max(pos, 0), len).
    // 7. Let searchLen be the number of elements in searchStr.
    // 8. Return the smallest possible integer k not smaller than start such that k+searchLen is not greater
    //    than len, and for all nonnegative integers j less than searchLen, the code unit at index k+j of S is
    //    the same as the code unit at index j of searchStr; but if there is no such integer k, return the
    //    value -1.

    return new _index.NumberValue(realm, S.indexOf(searchStr, pos));
  }); // ECMA262 21.1.3.9

  obj.defineNativeMethod("lastIndexOf", 1, (context, [searchString, position]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let searchStr be ? ToString(searchString).


    let searchStr = _singletons.To.ToStringPartial(realm, searchString); // 4. Let numPos be ? ToNumber(position). (If position is undefined, this step produces the value NaN.)


    let numPos = _singletons.To.ToNumber(realm, position || realm.intrinsics.undefined); // 5. If numPos is NaN, let pos be +; otherwise, let pos be ToInteger(numPos).


    let pos;

    if (isNaN(numPos)) {
      pos = Infinity;
    } else {
      pos = _singletons.To.ToInteger(realm, numPos);
    } // 6. Let len be the number of elements in S.
    // 7. Let start be min(max(pos, 0), len).
    // 8. Let searchLen be the number of elements in searchStr.
    // 9. Return the largest possible nonnegative integer k not larger than start such that k+searchLen is not
    //    greater than len, and for all nonnegative integers j less than searchLen, the code unit at index k+j
    //    of S is the same as the code unit at index j of searchStr; but if there is no such integer k, return
    //    the value -1.


    return new _index.NumberValue(realm, S.lastIndexOf(searchStr, pos));
  }); // ECMA262 21.1.3.10

  obj.defineNativeMethod("localeCompare", 1, (context, [that]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let That be ? ToString(that).


    let That = _singletons.To.ToStringPartial(realm, that);

    return new _index.NumberValue(realm, S.localeCompare(That));
  }); // ECMA262 21.1.3.11

  obj.defineNativeMethod("match", 1, (context, [regexp]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. If regexp is neither undefined nor null, then

    if (!(0, _has.HasSomeCompatibleType)(regexp, _index.UndefinedValue, _index.NullValue)) {
      // a. Let matcher be ? GetMethod(regexp, @@match).
      let matcher = (0, _get.GetMethod)(realm, regexp, realm.intrinsics.SymbolMatch); // b. If matcher is not undefined, then

      if (!matcher.mightBeUndefined()) {
        // i. Return ? Call(matcher, regexp,  O ).
        return (0, _call.Call)(realm, matcher, regexp, [O]);
      }

      matcher.throwIfNotConcrete();
    } // 3. Let S be ? ToString(O).


    let S = new _index.StringValue(realm, _singletons.To.ToStringPartial(realm, O)); // 4. Let rx be ? RegExpCreate(regexp, undefined).

    let rx = (0, _regexp.RegExpCreate)(realm, regexp, undefined); // 5. Return ? Invoke(rx, @@match,  S ).

    return (0, _call.Invoke)(realm, rx, realm.intrinsics.SymbolMatch, [S]);
  }); // ECMA262 21.1.3.12

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("normalize", 0, (context, [form]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. If form is not provided or form is undefined, let form be "NFC".


    if (!form || form instanceof _index.UndefinedValue) form = new _index.StringValue(realm, "NFC"); // 4. Let f be ? ToString(form).

    let f = _singletons.To.ToStringPartial(realm, form); // 5. If f is not one of "NFC", "NFD", "NFKC", or "NFKD", throw a RangeError exception.


    if (f !== "NFC" && f !== "NFD" && f !== "NFKC" && f !== "NFKD") {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    } // 6. Let ns be the String value that is the result of normalizing S into the normalization form named by
    //    f as specified in http://www.unicode.org/reports/tr15/tr15-29.html.
    // 7. Return ns.


    return new _index.StringValue(realm, S.normalize(f));
  }); // ECMA262 21.1.3.13

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("padEnd", 1, (context, [maxLength, fillString]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let intMaxLength be ? ToLength(maxLength).


    let intMaxLength = _singletons.To.ToLength(realm, maxLength); // 4. Let stringLength be the number of elements in S.


    let stringLength = S.length; // 5. If intMaxLength is not greater than stringLength, return S.

    if (intMaxLength <= stringLength) return new _index.StringValue(realm, S);
    let filler; // 6. If fillString is undefined, let filler be a String consisting solely of the code unit 0x0020 (SPACE).

    if (!fillString || fillString instanceof _index.UndefinedValue) filler = " ";else {
      // 7. Else, let filler be ? ToString(fillString).
      filler = _singletons.To.ToStringPartial(realm, fillString);
    } // 8. If filler is the empty String, return S.

    if (filler === "") return new _index.StringValue(realm, S); // 9. Let fillLen be intMaxLength - stringLength.

    let fillLen = intMaxLength - stringLength; // 10. Let truncatedStringFiller be a new String value consisting of repeated concatenations of filler truncated to length fillLen.

    let truncatedStringFiller = filler.repeat(Math.ceil(fillLen / filler.length)).substr(0, fillLen); // 11. Return a new String value computed by the concatenation of S and truncatedStringFiller.

    return new _index.StringValue(realm, S + truncatedStringFiller);
  }); // ECMA262 21.1.3.14

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("padStart", 1, (context, [maxLength, fillString]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let intMaxLength be ? ToLength(maxLength).


    let intMaxLength = _singletons.To.ToLength(realm, maxLength); // 4. Let stringLength be the number of elements in S.


    let stringLength = S.length; // 5. If intMaxLength is not greater than stringLength, return S.

    if (intMaxLength <= stringLength) return new _index.StringValue(realm, S);
    let filler; // 6. If fillString is undefined, let filler be a String consisting solely of the code unit 0x0020 (SPACE).

    if (!fillString || fillString instanceof _index.UndefinedValue) filler = " ";else {
      // 7. Else, let filler be ? ToString(fillString).
      filler = _singletons.To.ToStringPartial(realm, fillString);
    } // 8. If filler is the empty String, return S.

    if (filler === "") return new _index.StringValue(realm, S); // 9. Let fillLen be intMaxLength - stringLength.

    let fillLen = intMaxLength - stringLength; // 10. Let truncatedStringFiller be a new String value consisting of repeated concatenations of filler truncated to length fillLen.

    let truncatedStringFiller = filler.repeat(Math.ceil(fillLen / filler.length)).substr(0, fillLen); // 11. Return a new String value computed by the concatenation of truncatedStringFiller and S.

    return new _index.StringValue(realm, truncatedStringFiller + S);
  }); // ECMA262 21.1.3.13

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("repeat", 1, (context, [count]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let n be ? ToInteger(count).


    let n = _singletons.To.ToInteger(realm, count); // 4. If n < 0, throw a RangeError exception.


    if (n < 0) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    } // 5. If n is +, throw a RangeError exception.


    if (!isFinite(n)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    } // 6. Let T be a String value that is made from n copies of S appended together. If n is 0, T is the empty String.


    let T = "";
    if (S) while (n--) T += S; // 7. Return T.

    return new _index.StringValue(realm, T);
  }); // ECMA262 21.1.3.14

  obj.defineNativeMethod("replace", 2, (context, [searchValue, replaceValue]) => {
    let replStr; // 1. Let O be ? RequireObjectCoercible(this value).

    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. If searchValue is neither undefined nor null, then

    if (!(0, _has.HasSomeCompatibleType)(searchValue, _index.NullValue, _index.UndefinedValue)) {
      // a. Let replacer be ? GetMethod(searchValue, @@replace).
      let replacer = (0, _get.GetMethod)(realm, searchValue, realm.intrinsics.SymbolReplace); // b. If replacer is not undefined, then

      if (!(replacer instanceof _index.UndefinedValue)) {
        // i. Return ? Call(replacer, searchValue,  O, replaceValue ).
        return (0, _call.Call)(realm, replacer, searchValue, [O, replaceValue]);
      }
    } // 3. Let string be ? ToString(O).


    let string = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 4. Let searchString be ? ToString(searchValue).


    let searchString = _singletons.To.ToStringPartial(realm, searchValue); // 5. Let functionalReplace be IsCallable(replaceValue).


    let functionalReplace = (0, _is.IsCallable)(realm, replaceValue);
    let replaceValueString; // 6. If functionalReplace is false, then

    if (functionalReplace === false) {
      // a. Let replaceValue be ? ToString(replaceValue).
      replaceValueString = _singletons.To.ToStringPartial(realm, replaceValue);
    } // 7. Search string for the first occurrence of searchString and
    //    let pos be the index within string of the first code unit of the matched substring and


    let pos = string.indexOf(searchString); //    let matched be searchString.

    let matched = searchString; //    If no occurrences of searchString were found, return string.

    if (pos < 0) return new _index.StringValue(realm, string); // 8. If functionalReplace is true, then

    if (functionalReplace === true) {
      // a. Let replValue be ? Call(replaceValue, undefined,  matched, pos, string ).
      let replValue = (0, _call.Call)(realm, replaceValue, realm.intrinsics.undefined, [new _index.StringValue(realm, matched), new _index.NumberValue(realm, pos), new _index.StringValue(realm, string)]); // b. Let replStr be ? ToString(replValue).

      replStr = _singletons.To.ToStringPartial(realm, replValue);
    } else {
      // 9. Else,
      // a. Let captures be an empty List.
      let captures = []; // b. Let replStr be GetSubstitution(matched, string, pos, captures, replaceValue).

      (0, _invariant.default)(typeof replaceValueString === "string");
      replStr = _singletons.To.ToString(realm, (0, _get.GetSubstitution)(realm, matched, string, pos, captures, replaceValueString));
    } // 10. Let tailPos be pos + the number of code units in matched.


    let tailPos = pos + matched.length; // 11. Let newString be the String formed by concatenating the first pos code units of string,
    //     replStr, and the trailing substring of string starting at index tailPos. If pos is 0,
    //     the first element of the concatenation will be the empty String.

    let newString = string.substr(0, pos) + replStr + string.substr(tailPos); // 12. Return newString.

    return new _index.StringValue(realm, newString);
  }); // ECMA262 21.1.3.15

  obj.defineNativeMethod("search", 1, (context, [regexp]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. If regexp is neither undefined nor null, then

    if (!(0, _has.HasSomeCompatibleType)(regexp, _index.UndefinedValue, _index.NullValue)) {
      // a. Let searcher be ? GetMethod(regexp, @@search).
      let searcher = (0, _get.GetMethod)(realm, regexp, realm.intrinsics.SymbolSearch); // b. If searcher is not undefined, then

      if (!(searcher instanceof _index.UndefinedValue)) {
        // i. Return ? Call(searcher, regexp,  O ).
        return (0, _call.Call)(realm, searcher, regexp, [O]);
      }
    } // 3. Let string be ? ToString(O).


    let string = _singletons.To.ToStringPartial(realm, O); // 4. Let rx be ? RegExpCreate(regexp, undefined).


    let rx = (0, _regexp.RegExpCreate)(realm, regexp, undefined); // 5. Return ? Invoke(rx, @@search,  string ).

    return (0, _call.Invoke)(realm, rx, realm.intrinsics.SymbolSearch, [new _index.StringValue(realm, string)]);
  }); // ECMA262 21.1.3.16

  obj.defineNativeMethod("slice", 2, (context, [start, end]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context);

    if (O instanceof _index.AbstractValue && O.getType() === _index.StringValue) {
      // This operation is a conditional atemporal
      // See #2327
      let absVal = _index.AbstractValue.createFromTemplate(realm, sliceTemplateSrc, _index.StringValue, [O, start, end]);

      return _index.AbstractValue.convertToTemporalIfArgsAreTemporal(realm, absVal, [O]);
    } // 2. Let S be ? ToString(O).


    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let len be the number of elements in S.


    let len = S.length; // 4. Let intStart be ? ToInteger(start).

    let intStart = _singletons.To.ToInteger(realm, start); // 5. If end is undefined, let intEnd be len; else let intEnd be ? ToInteger(end).


    let intEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 6. If intStart < 0, let from be max(len + intStart, 0); otherwise let from be min(intStart, len).

    let from = intStart < 0 ? Math.max(len + intStart, 0) : Math.min(intStart, len); // 7. If intEnd < 0, let to be max(len + intEnd, 0); otherwise let to be min(intEnd, len).

    let to = intEnd < 0 ? Math.max(len + intEnd, 0) : Math.min(intEnd, len); // 8. Let span be max(to - from, 0).

    let span = Math.max(to - from, 0); // 9. Return a String value containing span consecutive elements from S beginning with the element at index from.

    return new _index.StringValue(realm, S.substr(from, span));
  }); // ECMA262 21.1.3.17

  obj.defineNativeMethod("split", 2, (context, [separator, limit]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context);

    if (O instanceof _index.AbstractValue && O.getType() === _index.StringValue) {
      // This operation is a conditional atemporal
      // See #2327
      let absVal = _index.AbstractValue.createFromTemplate(realm, splitTemplateSrc, _index.ObjectValue, [O, separator, limit]);

      return _index.AbstractValue.convertToTemporalIfArgsAreTemporal(realm, absVal, [O]);
    } // 2. If separator is neither undefined nor null, then


    if (!(0, _has.HasSomeCompatibleType)(separator, _index.UndefinedValue, _index.NullValue)) {
      // a. Let splitter be ? GetMethod(separator, @@split).
      let splitter = (0, _get.GetMethod)(realm, separator, realm.intrinsics.SymbolSplit); // b. If splitter is not undefined, then

      if (!(splitter instanceof _index.UndefinedValue)) {
        // i. Return ? Call(splitter, separator,  O, limit ).
        return (0, _call.Call)(realm, splitter, separator, [O, limit]);
      }
    } // 3. Let S be ? ToString(O).


    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 4. Let A be ArrayCreate(0).


    let A = _singletons.Create.ArrayCreate(realm, 0); // 5. Let lengthA be 0.


    let lengthA = 0; // 6. If limit is undefined, let lim be 232-1; else let lim be ? ToUint32(limit).

    let lim = !limit || limit instanceof _index.UndefinedValue ? Math.pow(2, 32) - 1 : _singletons.To.ToUint32(realm, limit.throwIfNotConcrete()); // 7. Let s be the number of elements in S.

    let s = S.length; // 8. Let p be 0.

    let p = 0; // 9. Let R be ? ToString(separator).

    let R = _singletons.To.ToStringPartial(realm, separator); // 10. If lim = 0, return A.


    if (lim === 0) return A; // 11. If separator is undefined, then

    if (!separator || separator instanceof _index.UndefinedValue) {
      // a. Perform ! CreateDataProperty(A, "0", S).
      _singletons.Create.CreateDataProperty(realm, A, "0", new _index.StringValue(realm, S)); // b. Return A.


      return A;
    } // 12. If s = 0, then


    if (s === 0) {
      // a. Let z be SplitMatch(S, 0, R).
      let z = (0, _abstract.SplitMatch)(realm, S, 0, R); // b. If z is not false, return A.

      if (z !== false) return A; // c. Perform ! CreateDataProperty(A, "0", S).

      _singletons.Create.CreateDataProperty(realm, A, "0", new _index.StringValue(realm, S)); // d. Return A.


      return A;
    } // 13. Let q be p.


    let q = p; // 14. Repeat, while q  s

    while (q !== s) {
      // a. Let e be SplitMatch(S, q, R).
      let e = (0, _abstract.SplitMatch)(realm, S, q, R); // b. If e is false, let q be q+1.

      if (e === false) {
        q++;
      } else {
        // c. Else e is an integer index  s,
        // i. If e = p, let q be q+1.
        if (e === p) {
          q++;
        } else {
          // ii. Else e  p,
          // 1. Let T be a String value equal to the substring of S consisting of the code units at indices p (inclusive) through q (exclusive).
          let T = S.substring(p, q); // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).

          _singletons.Create.CreateDataProperty(realm, A, new _index.StringValue(realm, lengthA + ""), new _index.StringValue(realm, T)); // 3. Increment lengthA by 1.


          lengthA++; // 4. If lengthA = lim, return A.

          if (lengthA === lim) return A; // 5. Let p be e.

          p = e; // 6. Let q be p.

          q = p;
        }
      }
    } // 15. Let T be a String value equal to the substring of S consisting of the code units at indices p (inclusive) through s (exclusive).


    let T = S.substring(p, s); // 16. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).

    _singletons.Create.CreateDataProperty(realm, A, new _index.StringValue(realm, lengthA + ""), new _index.StringValue(realm, T)); // 17. Return A.


    return A;
  }); // ECMA262 21.1.3.18

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) obj.defineNativeMethod("startsWith", 1, (context, [searchString, position]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let isRegExp be ? IsRegExp(searchString).


    let isRegExp = (0, _is.IsRegExp)(realm, searchString); // 4. If isRegExp is true, throw a TypeError exception.

    if (isRegExp) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "String.prototype");
    } // 5. Let searchStr be ? ToString(searchString).


    let searchStr = _singletons.To.ToStringPartial(realm, searchString); // 6. Let pos be ? ToInteger(position). (If position is undefined, this step produces the value 0.)


    let pos = _singletons.To.ToInteger(realm, position || realm.intrinsics.undefined); // 7. Let len be the number of elements in S.


    let len = S.length; // 8. Let start be min(max(pos, 0), len).

    let start = Math.min(Math.max(pos, 0), len); // 9. Let searchLength be the number of elements in searchStr.

    let searchLength = searchStr.length; // 10. If searchLength+start is greater than len, return false.

    if (searchLength + start > len) return realm.intrinsics.false; // 11. If the sequence of elements of S starting at start of length searchLength is the same as the full element sequence of searchStr, return true.

    if (S.substr(start, searchLength) === searchStr) return realm.intrinsics.true; // 12. Otherwise, return false.

    return realm.intrinsics.false;
  }); // ECMA262 21.1.3.19

  obj.defineNativeMethod("substring", 2, (context, [start, end]) => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let len be the number of elements in S.


    let len = S.length; // 4. Let intStart be ? ToInteger(start).

    let intStart = _singletons.To.ToInteger(realm, start); // 5. If end is undefined, let intEnd be len; else let intEnd be ? ToInteger(end).


    let intEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 6. Let finalStart be min(max(intStart, 0), len).

    let finalStart = Math.min(Math.max(intStart, 0), len); // 7. Let finalEnd be min(max(intEnd, 0), len).

    let finalEnd = Math.min(Math.max(intEnd, 0), len); // 8. Let from be min(finalStart, finalEnd).

    let frm = Math.min(finalStart, finalEnd); // 9. Let to be max(finalStart, finalEnd).

    let to = Math.max(finalStart, finalEnd); // 10. Return a String whose length is to - from, containing code units from S, namely the code units with indices from through to - 1, in ascending order.

    return new _index.StringValue(realm, S.slice(frm, to));
  });

  function toCase(type, context, locales) {
    // 1. Let O be RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ToString(O)

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete());

    if (realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) || realm.isCompatibleWith("mobile")) {
      locales = undefined;
    } else {
      // TODO #1013 filter locales for only serialisable values
      if (locales) locales = locales.serialize();
    }

    if (realm.useAbstractInterpretation && (type === "LocaleUpper" || type === "LocaleLower")) {
      // The locale is environment-dependent
      _index.AbstractValue.reportIntrospectionError(O);

      throw new _errors.FatalError();
    } // Omit the rest of the arguments. Just use the native impl.


    return new _index.StringValue(realm, S[`to${type}Case`](locales));
  } // ECMA-262 21.1.3.20
  // ECMA-402 13.1.2


  obj.defineNativeMethod("toLocaleLowerCase", 0, (context, [locales]) => {
    return toCase("LocaleLower", context, locales);
  }); // ECMA-262 21.1.3.21
  // ECMA-402 13.1.3

  obj.defineNativeMethod("toLocaleUpperCase", 0, (context, [locales]) => {
    return toCase("LocaleUpper", context, locales);
  }); // ECMA262 21.1.3.22

  obj.defineNativeMethod("toLowerCase", 0, context => {
    return toCase("Lower", context);
  }); // ECMA262 21.1.3.23

  obj.defineNativeMethod("toString", 0, context => {
    const target = context instanceof _index.ObjectValue ? context.$StringData : context;

    if (target instanceof _index.AbstractValue && target.getType() === _index.StringValue) {
      return target;
    } // 1. Return ? thisStringValue(this value).


    return _singletons.To.thisStringValue(realm, context);
  }); // ECMA262 21.1.3.24

  obj.defineNativeMethod("toUpperCase", 0, context => {
    return toCase("Upper", context);
  }); // ECMA262 21.1.3.25

  obj.defineNativeMethod("trim", 0, context => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Let T be a String value that is a copy of S with both leading and trailing white space removed. The definition of white space is the union of WhiteSpace and LineTerminator. When determining whether a Unicode code point is in Unicode general category Zs, code unit sequences are interpreted as UTF-16 encoded code point sequences as specified in 6.1.4.


    let T = S.trim(); // 4. Return T.

    return new _index.StringValue(realm, T);
  }); // ECMA262 21.1.3.26

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Return ? thisStringValue(this value).
    return _singletons.To.thisStringValue(realm, context);
  }); // ECMA262 21.1.3.27

  obj.defineNativeMethod(realm.intrinsics.SymbolIterator, 0, context => {
    // 1. Let O be ? RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ? ToString(O).

    let S = _singletons.To.ToString(realm, O.throwIfNotConcrete()); // 3. Return CreateStringIterator(S).


    return _singletons.Create.CreateStringIterator(realm, new _index.StringValue(realm, S));
  }); // B.2.3.1

  obj.defineNativeMethod("substr", 2, (context, [start, length]) => {
    // 1. Let O be RequireObjectCoercible(this value).
    let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. Let S be ToString(O).

    let S = _singletons.To.ToStringPartial(realm, O); // 3. ReturnIfAbrupt(S).
    // 4. Let intStart be ToInteger(start).


    let intStart = _singletons.To.ToInteger(realm, start); // 5. ReturnIfAbrupt(intStart).
    // 6. If length is undefined, let end be +; otherwise let end be ToInteger(length).


    let end;

    if (!length || length instanceof _index.UndefinedValue) {
      end = Infinity;
    } else {
      end = _singletons.To.ToInteger(realm, length.throwIfNotConcrete());
    } // 7. ReturnIfAbrupt(end).
    // 8. Let size be the number of code units in S.


    let size = S.length; // 9. If intStart < 0, let intStart be max(size + intStart,0).

    if (intStart < 0) intStart = Math.max(size + intStart, 0); // 10. Let resultLength be min(max(end,0), size  intStart).

    let resultLength = Math.min(Math.max(end, 0), size - intStart); // 11. If resultLength  0, return the empty String "".

    if (resultLength <= 0) return realm.intrinsics.emptyString; // 12. Return a String containing resultLength consecutive code units from S beginning with the code unit at index intStart.

    return new _index.StringValue(realm, S.slice(intStart, intStart + resultLength));
  }); // B.2.3.2

  obj.defineNativeMethod("anchor", 1, (context, [name]) => {
    // 1. Let S be the this value.
    let S = context; // 2. // 2. Return ? CreateHTML(S, "a", "name", name).

    return _singletons.Create.CreateHTML(realm, S, "a", "name", name);
  }); // B.2.3.3

  obj.defineNativeMethod("big", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "big", "", "").

    return _singletons.Create.CreateHTML(realm, S, "big", "", "");
  }); // B.2.3.4

  obj.defineNativeMethod("blink", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "blink", "", "").

    return _singletons.Create.CreateHTML(realm, S, "blink", "", "");
  }); // B.2.3.5

  obj.defineNativeMethod("bold", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "b", "", "").

    return _singletons.Create.CreateHTML(realm, S, "b", "", "");
  }); // B.2.3.6

  obj.defineNativeMethod("fixed", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "tt", "", "").

    return _singletons.Create.CreateHTML(realm, S, "tt", "", "");
  }); // B.2.3.7

  obj.defineNativeMethod("fontcolor", 1, (context, [color]) => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "font", "color", color).

    return _singletons.Create.CreateHTML(realm, S, "font", "color", color);
  }); // B.2.3.8

  obj.defineNativeMethod("fontsize", 1, (context, [size]) => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "font", "size", size).

    return _singletons.Create.CreateHTML(realm, S, "font", "size", size);
  }); // B.2.3.9

  obj.defineNativeMethod("italics", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "i", "", "").

    return _singletons.Create.CreateHTML(realm, S, "i", "", "");
  }); // B.2.3.10

  obj.defineNativeMethod("link", 1, (context, [url]) => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "a", "href", url).

    return _singletons.Create.CreateHTML(realm, S, "a", "href", url);
  }); // B.2.3.11

  obj.defineNativeMethod("small", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "small", "", "").

    return _singletons.Create.CreateHTML(realm, S, "small", "", "");
  }); // B.2.3.12

  obj.defineNativeMethod("strike", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "strike", "", "").

    return _singletons.Create.CreateHTML(realm, S, "strike", "", "");
  }); // B.2.3.13

  obj.defineNativeMethod("sub", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "sub", "", "").

    return _singletons.Create.CreateHTML(realm, S, "sub", "", "");
  }); // B.2.3.14

  obj.defineNativeMethod("sup", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateHTML(S, "sup", "", "").

    return _singletons.Create.CreateHTML(realm, S, "sup", "", "");
  });
  return obj;
}
//# sourceMappingURL=StringPrototype.js.map

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 20.1.1
  let func = new _index.NativeFunctionValue(realm, "Number", "Number", 1, (context, [value], argCount, NewTarget) => {
    let n; // 1. If no arguments were passed to this function invocation, let n be +0.

    if (argCount === 0) {
      n = realm.intrinsics.zero;
    } else {
      // 2. Else, let n be ? ToNumber(value).
      n = new _index.NumberValue(realm, _singletons.To.ToNumber(realm, value));
    } // 3. If NewTarget is undefined, return n.


    if (!NewTarget) return n; // 4. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%NumberPrototype%",  [[NumberData]] ).

    let O = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "NumberPrototype", {
      $NumberData: undefined
    }); // 5. Set the value of O's [[NumberData]] internal slot to n.


    O.$NumberData = n; // 6. Return O.

    return O;
  }); // ECMA262 20.1.2.1

  func.defineNativeConstant("EPSILON", new _index.NumberValue(realm, 2.220446049250313e-16)); // ECMA262 20.1.2.2

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("isFinite", 1, (context, [_number]) => {
    let number = _number; // 1. If Type(number) is not Number, return false.

    if (!number.mightBeNumber()) return realm.intrinsics.false; // 2. If number is NaN, +, or -, return false.

    number = number.throwIfNotConcreteNumber();
    if (isNaN(number.value) || number.value === +Infinity || number.value === -Infinity) return realm.intrinsics.false; // 3. Otherwise, return true.

    return realm.intrinsics.true;
  }); // ECMA262 20.1.2.3

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("isInteger", 1, (context, [_number]) => {
    let number = _number; // 1. If Type(number) is not Number, return false.

    if (!number.mightBeNumber()) return realm.intrinsics.false; // 2. If number is NaN, +, or -, return false.

    number = number.throwIfNotConcreteNumber();
    if (isNaN(number.value) || number.value === +Infinity || number.value === -Infinity) return realm.intrinsics.false; // 3. Let integer be ToInteger(number).

    let integer = _singletons.To.ToInteger(realm, number); // 4. If integer is not equal to number, return false.


    if (integer !== number.value) return realm.intrinsics.false; // 5. Otherwise, return true.

    return realm.intrinsics.true;
  }); // ECMA262 20.1.2.4

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("isNaN", 1, (context, [_number]) => {
    let number = _number; // 1. If Type(number) is not Number, return false.

    if (!number.mightBeNumber()) return realm.intrinsics.false; // 2. If number is NaN, return true.

    number = number.throwIfNotConcreteNumber();
    if (isNaN(number.value)) return realm.intrinsics.true; // 3. Otherwise, return false.

    return realm.intrinsics.false;
  }); // ECMA262 20.1.2.5

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeMethod("isSafeInteger", 1, (context, [_number]) => {
    let number = _number; // 1. If Type(number) is not Number, return false.

    if (!number.mightBeNumber()) return realm.intrinsics.false; // 2. If number is NaN, +, or -, return false.

    number = number.throwIfNotConcreteNumber();
    if (isNaN(number.value) || number.value === +Infinity || number.value === -Infinity) return realm.intrinsics.false; // 3. Let integer be ToInteger(number).

    let integer = _singletons.To.ToInteger(realm, number); // 4. If integer is not equal to number, return false.


    if (integer !== number.value) return realm.intrinsics.false; // 5. If abs(integer)  2^53-1, return true.

    if (Math.abs(integer) <= Math.pow(2, 53) - 1) return realm.intrinsics.true; // 6. Otherwise, return false.

    return realm.intrinsics.false;
  }); // ECMA262 20.1.2.6

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeConstant("MAX_SAFE_INTEGER", new _index.NumberValue(realm, 9007199254740991)); // ECMA262 20.1.2.7

  func.defineNativeConstant("MAX_VALUE", new _index.NumberValue(realm, 1.7976931348623157e308)); // ECMA262 20.1.2.8

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) func.defineNativeConstant("MIN_SAFE_INTEGER", new _index.NumberValue(realm, -9007199254740991)); // ECMA262 20.1.2.9

  func.defineNativeConstant("MIN_VALUE", new _index.NumberValue(realm, 5e-324)); // ECMA262 20.1.2.10

  func.defineNativeConstant("NaN", realm.intrinsics.NaN); // ECMA262 20.1.2.11

  func.defineNativeConstant("NEGATIVE_INFINITY", realm.intrinsics.negativeInfinity); // ECMA262 20.1.2.12

  func.defineNativeProperty("parseFloat", realm.intrinsics.parseFloat); // ECMA262 20.1.2.13

  func.defineNativeProperty("parseInt", realm.intrinsics.parseInt); // ECMA262 20.1.2.14

  func.defineNativeConstant("POSITIVE_INFINITY", realm.intrinsics.Infinity);
  return func;
}
//# sourceMappingURL=Number.js.map

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 20.1.3
  obj.$NumberData = realm.intrinsics.zero; // ECMA262 20.1.3.2

  obj.defineNativeMethod("toExponential", 1, (context, [_fractionDigits]) => {
    let fractionDigits = _fractionDigits; // 1. Let x be ? thisNumberValue(this value).

    let x = _singletons.To.thisNumberValue(realm, context).value; // 2. Let f be ? ToInteger(fractionDigits).


    fractionDigits = fractionDigits.throwIfNotConcrete();

    let f = _singletons.To.ToInteger(realm, fractionDigits); // 3. Assert: f is 0, when fractionDigits is undefined.


    (0, _invariant.default)(f === 0 || !(fractionDigits instanceof _index.UndefinedValue)); // 4. If x is NaN, return the String "NaN".

    if (isNaN(x)) return new _index.StringValue(realm, "NaN"); // 5. Let s be the empty String.

    let s = ""; // 6. If x < 0, then

    if (x < 0) {
      // 6a. Let s be "-".
      s = "-"; // 6b. Let x be -x.

      x = -x;
    } // 7. If x = +, then


    if (x === +Infinity) {
      // 7a. Return the concatenation of the Strings s and "Infinity".
      return new _index.StringValue(realm, s + "Infinity");
    } // 8. If f < 0 or f > 20, throw a RangeError exception. However, an implementation is permitted to extend the behaviour of toExponential for values of f less than 0 or greater than 20. In this case toExponential would not necessarily throw RangeError for such values.


    if (f < 0 || f > 20) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "f < 0 || f > 20");
    }

    let positiveResultString = x.toExponential(fractionDigits instanceof _index.UndefinedValue ? undefined : f);
    return new _index.StringValue(realm, s + positiveResultString);
  }); // ECMA262 20.1.3.3

  obj.defineNativeMethod("toFixed", 1, (context, [fractionDigits]) => {
    // 1. Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0).
    let f = _singletons.To.ToInteger(realm, fractionDigits); // 2. If f < 0 or f > 20, throw a RangeError exception.


    if (f < 0 || f > 20) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "f < 0 || f > 20");
    } // 3. Let x be this Number value.


    let x = _singletons.To.thisNumberValue(realm, context).value; // 4. If x is NaN, return the String "NaN".


    if (isNaN(x)) return new _index.StringValue(realm, "NaN");
    return new _index.StringValue(realm, x.toFixed(f));
  });
  let toLocaleStringSrc = "(A).toLocaleString()"; // ECMA262 20.1.3.4

  obj.defineNativeMethod("toLocaleString", 0, context => {
    let x = _singletons.To.thisNumberValue(realm, context);

    if (realm.useAbstractInterpretation) {
      // The locale is environment-dependent and may also be time-dependent
      // so do this at runtime and at this point in time
      return _index.AbstractValue.createTemporalFromTemplate(realm, toLocaleStringSrc, _index.StringValue, [x]);
    } else {
      return new _index.StringValue(realm, x.toLocaleString());
    }
  }); // ECMA262 20.1.3.5

  obj.defineNativeMethod("toPrecision", 1, (context, [precision]) => {
    // 1. Let x be ? thisNumberValue(this value).
    // 2. If precision is undefined, return ! ToString(x).
    let num = _singletons.To.thisNumberValue(realm, context);

    if (precision instanceof _index.UndefinedValue) {
      return new _index.StringValue(realm, _singletons.To.ToString(realm, num));
    } // 3. Let p be ? ToInteger(precision).


    let p = _singletons.To.ToInteger(realm, precision.throwIfNotConcrete()); // 4. If x is NaN, return the String "NaN".


    let x = num.value;

    if (isNaN(x)) {
      return new _index.StringValue(realm, "NaN");
    } // 5. Let s be the empty String.


    let s = ""; // 6. If x < 0, then

    if (x < 0) {
      // a. Let s be code unit 0x002D (HYPHEN-MINUS).
      s = "-"; // b. Let x be -x.

      x = -x;
    } // 7. If x = +, then


    if (x === +Infinity) {
      // a. Return the String that is the concatenation of s and "Infinity".
      return new _index.StringValue(realm, s + "Infinity");
    } // 8. If p < 1 or p > 21, throw a RangeError exception.
    // However, an implementation is permitted to extend the behaviour of
    // toPrecision for values of p less than 1 or greater than 21.
    // In this case toPrecision would not necessarily throw RangeError for such
    // values.


    if (p < 1 || p > 21) {
      // for simplicity, throw the error
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "p should be in between 1 and 21 inclusive");
    }

    return new _index.StringValue(realm, s + x.toPrecision(p));
  });
  const tsTemplateSrc = "('' + A)"; // ECMA262 20.1.3.6

  obj.defineNativeMethod("toString", 1, (context, [radix]) => {
    if (radix instanceof _index.UndefinedValue) {
      const target = context instanceof _index.ObjectValue ? context.$NumberData : context;

      if (target instanceof _index.AbstractValue && (target.getType() === _index.NumberValue || target.getType() === _index.IntegralValue)) {
        return _index.AbstractValue.createFromTemplate(realm, tsTemplateSrc, _index.StringValue, [target]);
      }
    } // 1. Let x be ? thisNumberValue(this value).


    let x = _singletons.To.thisNumberValue(realm, context); // 2. If radix is not present, let radixNumber be 10.
    // 3. Else if radix is undefined, let radixNumber be 10.


    let radixNumber;

    if (!radix || radix instanceof _index.UndefinedValue) {
      radixNumber = 10;
    } else {
      // 4. Else let radixNumber be ? ToInteger(radix).
      radixNumber = _singletons.To.ToInteger(realm, radix.throwIfNotConcrete());
    } // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.


    if (radixNumber < 2 || radixNumber > 36) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 6. If radixNumber = 10, return ! ToString(x).


    if (radixNumber === 10) return new _index.StringValue(realm, _singletons.To.ToString(realm, x)); // 7. Return the String representation of this Number value using the radix specified by radixNumber.
    //    Letters a-z are used for digits with values 10 through 35. The precise algorithm is
    //    implementation-dependent, however the algorithm should be a generalization of that specified in
    //    7.1.12.1.

    return new _index.StringValue(realm, x.value.toString(radixNumber));
  }); // ECMA262 20.1.3.7

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Return ? thisNumberValue(this value).
    return _singletons.To.thisNumberValue(realm, context);
  });
}
//# sourceMappingURL=NumberPrototype.js.map

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 19.3.1.1
  let func = new _index.NativeFunctionValue(realm, "Boolean", "Boolean", 1, (context, [value], argCount, NewTarget) => {
    // 1. Let b be ToBoolean(value).
    let b = new _index.BooleanValue(realm, _singletons.To.ToBooleanPartial(realm, value)); // 2. If NewTarget is undefined, return b.

    if (!NewTarget) return b; // 3. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%BooleanPrototype%",  [[BooleanData]] ).

    let O = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "BooleanPrototype", {
      $BooleanData: undefined
    }); // 4. Set the value of O's [[BooleanData]] internal slot to b.


    O.$BooleanData = b; // 5. Return O.

    return O;
  });
  return func;
}
//# sourceMappingURL=Boolean.js.map

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 19.3.1
  obj.$BooleanData = realm.intrinsics.false;
  const tsTemplateSrc = "('' + A)"; // ECMA262 19.3.3.3

  obj.defineNativeMethod("toString", 0, context => {
    const target = context instanceof _index.ObjectValue ? context.$BooleanData : context;

    if (target instanceof _index.AbstractValue && target.getType() === _index.BooleanValue) {
      return _index.AbstractValue.createFromTemplate(realm, tsTemplateSrc, _index.StringValue, [target]);
    } // 1. Let b be ? thisBooleanValue(this value).


    let b = _singletons.To.thisBooleanValue(realm, context); // 2. If b is true, return "true"; else return "false".


    return new _index.StringValue(realm, b.value ? "true" : "false");
  }); // ECMA262 19.3.3.4

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Return ? thisBooleanValue(this value).
    return _singletons.To.thisBooleanValue(realm, context);
  });
}
//# sourceMappingURL=BooleanPrototype.js.map

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 24.2.2.1
  let func = new _index2.NativeFunctionValue(realm, "DataView", "DataView", 3, (context, [_buffer, byteOffset, byteLength], argCount, NewTarget) => {
    let buffer = _buffer; // 1. If NewTarget is undefined, throw a TypeError exception.

    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    buffer = buffer.throwIfNotConcrete(); // 2. If Type(buffer) is not Object, throw a TypeError exception.

    if (!(buffer instanceof _index2.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If buffer does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.


    if (!("$ArrayBufferData" in buffer)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let offset be ? ToIndex(byteOffset).


    let offset = _singletons.To.ToIndexPartial(realm, byteOffset); // 5. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.


    if ((0, _index.IsDetachedBuffer)(realm, buffer)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 6. Let bufferByteLength be the value of buffer's [[ArrayBufferByteLength]] internal slot.


    let bufferByteLength = buffer.$ArrayBufferByteLength;
    (0, _invariant.default)(typeof bufferByteLength === "number"); // 7. If offset > bufferByteLength, throw a RangeError exception.

    if (offset > bufferByteLength) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
    } // 8. If byteLength is undefined, then


    let viewByteLength;

    if (!byteLength || byteLength instanceof _index2.UndefinedValue) {
      // a. Let viewByteLength be bufferByteLength - offset.
      viewByteLength = bufferByteLength - offset;
    } else {
      // 9. Else,
      // a. Let viewByteLength be ? ToIndex(byteLength).
      viewByteLength = _singletons.To.ToIndexPartial(realm, byteLength); // b. If offset+viewByteLength > bufferByteLength, throw a RangeError exception.

      if (offset + viewByteLength > bufferByteLength) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError);
      }
    } // 10. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%DataViewPrototype%",  [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] ).


    let O = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "DataViewPrototype", {
      $DataView: undefined,
      $ViewedArrayBuffer: undefined,
      $ByteLength: undefined,
      $ByteOffset: undefined
    }); // 11. Set O's [[DataView]] internal slot to true.


    O.$DataView = true; // 12. Set O's [[ViewedArrayBuffer]] internal slot to buffer.

    O.$ViewedArrayBuffer = buffer; // 13. Set O's [[ByteLength]] internal slot to viewByteLength.

    O.$ByteLength = viewByteLength; // 14. Set O's [[ByteOffset]] internal slot to offset.

    O.$ByteOffset = offset; // 15. Return O.

    return O;
  });
  return func;
}
//# sourceMappingURL=DataView.js.map

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _arraybuffer = __webpack_require__(278);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 24.2.4.1
  obj.defineNativeGetter("buffer", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[DataView]] internal slot, throw a TypeError exception.


    if (!("$DataView" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[DataView]] internal slot");
    } // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.


    (0, _invariant.default)(O.$ViewedArrayBuffer); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer; // 6. Return buffer.

    return buffer;
  }); // ECMA262 24.2.4.2

  obj.defineNativeGetter("byteLength", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[DataView]] internal slot, throw a TypeError exception.


    if (!("$DataView" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[DataView]] internal slot");
    } // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.


    (0, _invariant.default)(O.$ViewedArrayBuffer); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer; // 6. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
    } // 7. Let size be O.[[ByteLength]].


    let size = O.$ByteLength;
    (0, _invariant.default)(typeof size === "number"); // 8. Return size.

    return new _index.NumberValue(realm, size);
  }); // ECMA262 24.2.4.3

  obj.defineNativeGetter("byteOffset", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[DataView]] internal slot, throw a TypeError exception.


    if (!("$DataView" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[DataView]] internal slot");
    } // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.


    (0, _invariant.default)(O.$ViewedArrayBuffer); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer; // 6. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
    } // 7. Let offset be O.[[ByteOffset]].


    let offset = O.$ByteOffset;
    (0, _invariant.default)(typeof offset === "number"); // 8. Return offset.

    return new _index.NumberValue(realm, offset);
  }); // ECMA262 24.2.4.5

  obj.defineNativeMethod("getFloat32", 1, (context, [byteOffset, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Float32").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Float32");
  }); // ECMA262 24.2.4.6

  obj.defineNativeMethod("getFloat64", 1, (context, [byteOffset, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Float64").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Float64");
  }); // ECMA262 24.2.4.7

  obj.defineNativeMethod("getInt8", 1, (context, [byteOffset]) => {
    // 1. Let v be the this value.
    let v = context; // 2. Return ? GetViewValue(v, byteOffset, true, "Int8").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Int8");
  }); // ECMA262 24.2.4.8

  obj.defineNativeMethod("getInt16", 1, (context, [byteOffset, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Int16").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Int16");
  }); // ECMA262 24.2.4.9

  obj.defineNativeMethod("getInt32", 1, (context, [byteOffset, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Int32").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Int32");
  }); // ECMA262 24.2.4.10

  obj.defineNativeMethod("getUint8", 1, (context, [byteOffset]) => {
    // 1. Let v be the this value.
    let v = context; // 2. Return ? GetViewValue(v, byteOffset, true, "Uint8").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Uint8");
  }); // ECMA262 24.2.4.11

  obj.defineNativeMethod("getUint16", 1, (context, [byteOffset, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Uint16").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Uint16");
  }); // ECMA262 24.2.4.12

  obj.defineNativeMethod("getUint32", 1, (context, [byteOffset, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? GetViewValue(v, byteOffset, littleEndian, "Uint32").

    return (0, _arraybuffer.GetViewValue)(realm, v, byteOffset, littleEndian, "Uint32");
  }); // ECMA262 24.2.4.13

  obj.defineNativeMethod("setFloat32", 2, (context, [byteOffset, value, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Float32", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Float32", value);
  }); // ECMA262 24.2.4.14

  obj.defineNativeMethod("setFloat64", 2, (context, [byteOffset, value, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Float64", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Float64", value);
  }); // ECMA262 24.2.4.15

  obj.defineNativeMethod("setInt8", 2, (context, [byteOffset, value]) => {
    // 1. Let v be the this value.
    let v = context; // 2. Return ? SetViewValue(v, byteOffset, true, "Int8", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Int8", value);
  }); // ECMA262 24.2.4.16

  obj.defineNativeMethod("setInt16", 2, (context, [byteOffset, value, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Int16", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Int16", value);
  }); // ECMA262 24.2.4.17

  obj.defineNativeMethod("setInt32", 2, (context, [byteOffset, value, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Int32", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Int32", value);
  }); // ECMA262 24.2.4.18

  obj.defineNativeMethod("setUint8", 2, (context, [byteOffset, value]) => {
    // 1. Let v be the this value.
    let v = context; // 2. Return ? SetViewValue(v, byteOffset, true, "Uint8", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, realm.intrinsics.true, "Uint8", value);
  }); // ECMA262 24.2.4.19

  obj.defineNativeMethod("setUint16", 2, (context, [byteOffset, value, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Uint16", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Uint16", value);
  }); // ECMA262 24.2.4.20

  obj.defineNativeMethod("setUint32", 2, (context, [byteOffset, value, _littleEndian]) => {
    let littleEndian = _littleEndian; // 1. Let v be the this value.

    let v = context; // 2. If littleEndian is not present, let littleEndian be false.

    if (!littleEndian) littleEndian = realm.intrinsics.false; // 3. Return ? SetViewValue(v, byteOffset, littleEndian, "Uint32", value).

    return (0, _arraybuffer.SetViewValue)(realm, v, byteOffset, littleEndian, "Uint32", value);
  }); // ECMA26224.2.4.21

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "DataView"), {
    writable: false
  });
}
//# sourceMappingURL=DataViewPrototype.js.map

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.build = build;

var _types = __webpack_require__(19);

var _index = __webpack_require__(10);

var _typedarray = __webpack_require__(390);

var _construct = __webpack_require__(228);

var _get = __webpack_require__(230);

var _singletons = __webpack_require__(236);

var _iterator = __webpack_require__(272);

var _is = __webpack_require__(229);

var _call = __webpack_require__(234);

var _arraybuffer = __webpack_require__(278);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let func = new _index.NativeFunctionValue(realm, "TypedArray", "TypedArray", 0, context => {
    // 1. Throw a TypeError exception.
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "TypedArray");
  }); // ECMA262 22.2.2.1

  func.defineNativeMethod("from", 1, (context, [source, mapfn, thisArg]) => {
    // 1. Let C be the this value.
    let C = context; // 2. If IsConstructor(C) is false, throw a TypeError exception.

    if ((0, _is.IsConstructor)(realm, C) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsConstructor(C) is false");
    }

    (0, _invariant.default)(C instanceof _index.ObjectValue);
    let mapping; // 3. If mapfn was supplied and mapfn is not undefined, then

    if (mapfn !== undefined && !mapfn.mightBeUndefined()) {
      // a. If IsCallable(mapfn) is false, throw a TypeError exception.
      if ((0, _is.IsCallable)(realm, mapfn) === false) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsConstructor(C) is false");
      } // b. Let mapping be true.


      mapping = true;
    } else {
      // 4. Else, let mapping be false.
      mapfn === undefined || mapfn.throwIfNotConcrete();
      mapping = false;
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg !== undefined ? thisArg : realm.intrinsics.undefined; // 6. Let usingIterator be ? GetMethod(source, @@iterator).

    let usingIterator = (0, _get.GetMethod)(realm, source, realm.intrinsics.SymbolIterator); // 7. If usingIterator is not undefined, then

    if (!(usingIterator instanceof _index.UndefinedValue)) {
      // a. Let values be ? IterableToList(source, usingIterator).
      let values = (0, _iterator.IterableToList)(realm, source, usingIterator); // b. Let len be the number of elements in values.

      let len = values.length; // c. Let targetObj be ? TypedArrayCreate(C, len).

      let targetObj = (0, _typedarray.TypedArrayCreate)(realm, C, [new _index.NumberValue(realm, len)]); // d. Let k be 0.

      let k = 0; // e. Repeat, while k < len

      while (k < len) {
        // i. Let Pk be ! ToString(k).
        let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // ii. Let kValue be the first element of values and remove that element from values.


        let kValue = values.shift();
        let mappedValue; // iii. If mapping is true, then

        if (mapping === true) {
          // 1. Let mappedValue be ? Call(mapfn, T,  kValue, k ).
          mappedValue = (0, _call.Call)(realm, mapfn, T, [kValue, new _index.NumberValue(realm, k)]);
        } else {
          // iv. Else, let mappedValue be kValue.
          mappedValue = kValue;
        } // v. Perform ? Set(targetObj, Pk, mappedValue, true).


        _singletons.Properties.Set(realm, targetObj, Pk, mappedValue, true); // vi. Increase k by 1.


        k = k + 1;
      } // f. Assert: values is now an empty List.


      (0, _invariant.default)(values.length === 0, "values is not an empty List"); // g. Return targetObj.

      return targetObj;
    } // 8. NOTE: source is not an Iterable so assume it is already an array-like object.
    // 9. Let arrayLike be ! ToObject(source).


    let arrayLike = _singletons.To.ToObject(realm, source); // 10. Let len be ? ToLength(? Get(arrayLike, "length")).


    let len = _singletons.To.ToLength(realm, (0, _get.Get)(realm, arrayLike, "length")); // 11. Let targetObj be ? TypedArrayCreate(C,  len ).


    let targetObj = (0, _typedarray.TypedArrayCreate)(realm, C, [new _index.NumberValue(realm, len)]); // 12. Let k be 0.

    let k = 0; // 13. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let kValue be ? Get(arrayLike, Pk).


      let kValue = (0, _get.Get)(realm, arrayLike, Pk);
      let mappedValue; // c. If mapping is true, then

      if (mapping === true) {
        // i. Let mappedValue be ? Call(mapfn, T,  kValue, k ).
        mappedValue = (0, _call.Call)(realm, mapfn, T, [kValue, new _index.NumberValue(realm, k)]);
      } else {
        // d. Else, let mappedValue be kValue.
        mappedValue = kValue;
      } // e. Perform ? Set(targetObj, Pk, mappedValue, true).


      _singletons.Properties.Set(realm, targetObj, Pk, mappedValue, true); // f. Increase k by 1.


      k = k + 1;
    } // 14. Return targetObj.


    return targetObj;
  }); // ECMA262 22.2.2.2

  func.defineNativeMethod("of", 0, (context, items, argCount) => {
    // 1. Let len be the actual number of arguments passed to this function.
    let len = argCount; // 2. Let items be the List of arguments passed to this function.

    items; // 3. Let C be the this value.

    let C = context; // 4. If IsConstructor(C) is false, throw a TypeError exception.

    if ((0, _is.IsConstructor)(realm, C) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsConstructor(C) is false");
    }

    (0, _invariant.default)(C instanceof _index.ObjectValue); // 5. Let newObj be ? TypedArrayCreate(C,  len ).

    let newObj = (0, _typedarray.TypedArrayCreate)(realm, C, [new _index.NumberValue(realm, len)]); // 6. Let k be 0.

    let k = 0; // 7. Repeat, while k < len

    while (k < len) {
      // a. Let kValue be items[k].
      let kValue = items[k]; // b. Let Pk be ! ToString(k).

      let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // c. Perform ? Set(newObj, Pk, kValue, true).


      _singletons.Properties.Set(realm, newObj, Pk, kValue, true); // d. Increase k by 1.


      k = k + 1;
    } // 8. Return newObj.


    return newObj;
  }); // ECMA262 22.2.2.4

  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });
  return func;
} // ECMA262 22.2 Table 50


function getConstructorName(type) {
  switch (type) {
    case "Float32":
      return "Float32Array";

    case "Float64":
      return "Float64Array";

    case "Int8":
      return "Int8Array";

    case "Int16":
      return "Int16Array";

    case "Int32":
      return "Int32Array";

    case "Uint8":
      return "Uint8Array";

    case "Uint16":
      return "Uint16Array";

    case "Uint32":
      return "Uint32Array";

    case "Uint8Clamped":
      return "Uint8ClampedArray";

    default:
      (0, _invariant.default)(false);
  }
}

function build(realm, type) {
  let func = new _index.NativeFunctionValue(realm, `${type}Array`, `${type}Array`, 3, (context, args, argCount, NewTarget) => {
    if (argCount === 0) {
      // ECMA262 22.2.4.1
      // 1. If NewTarget is undefined, throw a TypeError exception.
      if (!NewTarget) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "NewTarget is undefined");
      } // 2. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.


      let constructorName = getConstructorName(type); // 3. Return ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%", 0).

      return (0, _typedarray.AllocateTypedArray)(realm, constructorName, NewTarget, `${type}ArrayPrototype`, 0);
    } else if (!(args[0] instanceof _index.ObjectValue)) {
      // ECMA262 22.2.4.2
      let length = args[0].throwIfNotConcrete(); // 1. Assert: Type(length) is not Object.

      (0, _invariant.default)(!(length instanceof _index.ObjectValue), "Type(length) is not Object"); // 2. If NewTarget is undefined, throw a TypeError exception.

      if (!NewTarget) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "NewTarget is undefined");
      } // 3. Let elementLength be ? ToIndex(length).


      let elementLength = _singletons.To.ToIndexPartial(realm, length); // 4. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.


      let constructorName = getConstructorName(type); // 5. Return ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%", elementLength).

      return (0, _typedarray.AllocateTypedArray)(realm, constructorName, NewTarget, `${type}ArrayPrototype`, elementLength);
    } else if ("$TypedArrayName" in args[0]) {
      // ECMA262 22.2.4.3
      let typedArray = args[0].throwIfNotConcrete(); // 1. Assert: Type(typedArray) is Object and typedArray has a [[TypedArrayName]] internal slot.

      (0, _invariant.default)(typedArray instanceof _index.ObjectValue && typeof typedArray.$TypedArrayName === "string"); // 2. If NewTarget is undefined, throw a TypeError exception.

      if (!NewTarget) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "NewTarget is undefined");
      } // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.


      let constructorName = getConstructorName(type); // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%").

      let O = (0, _typedarray.AllocateTypedArray)(realm, constructorName, NewTarget, `${type}ArrayPrototype`); // 5. Let srcArray be typedArray.

      let srcArray = typedArray; // 6. Let srcData be srcArray.[[ViewedArrayBuffer]].

      let srcData = srcArray.$ViewedArrayBuffer;
      (0, _invariant.default)(srcData); // 7. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.

      if ((0, _is.IsDetachedBuffer)(realm, srcData) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcData) is true");
      } // 8. Let constructorName be the String value of O.[[TypedArrayName]].


      constructorName = O.$TypedArrayName;
      (0, _invariant.default)(typeof constructorName === "string"); // 9. Let elementType be the String value of the Element Type value in Table 50 for constructorName.

      let elementType = _typedarray.ArrayElementType[constructorName]; // 10. Let elementLength be srcArray.[[ArrayLength]].

      let elementLength = srcArray.$ArrayLength;
      (0, _invariant.default)(typeof elementLength === "number"); // 11. Let srcName be the String value of srcArray.[[TypedArrayName]].

      let srcName = srcArray.$TypedArrayName;
      (0, _invariant.default)(typeof srcName === "string"); // 12. Let srcType be the String value of the Element Type value in Table 50 for srcName.

      let srcType = _typedarray.ArrayElementType[srcName]; // 13. Let srcElementSize be the Element Size value in Table 50 for srcName.

      let srcElementSize = _typedarray.ArrayElementSize[srcName]; // 14. Let srcByteOffset be srcArray.[[ByteOffset]].

      let srcByteOffset = srcArray.$ByteOffset;
      (0, _invariant.default)(typeof srcByteOffset === "number"); // 15. Let elementSize be the Element Size value in Table 50 for constructorName.

      let elementSize = _typedarray.ArrayElementSize[constructorName]; // 16. Let byteLength be elementSize  elementLength.

      let byteLength = elementSize * elementLength;
      let data; // 17. If SameValue(elementType, srcType) is true, then

      if (elementType === srcType) {
        // a. Let data be ? CloneArrayBuffer(srcData, srcByteOffset).
        data = (0, _arraybuffer.CloneArrayBuffer)(realm, srcData, srcByteOffset);
      } else {
        // 18. Else,
        // a. Let bufferConstructor be ? SpeciesConstructor(srcData, %ArrayBuffer%).
        let bufferConstructor = (0, _construct.SpeciesConstructor)(realm, srcData, realm.intrinsics.ArrayBuffer); // b. Let data be ? AllocateArrayBuffer(bufferConstructor, byteLength).

        data = (0, _arraybuffer.AllocateArrayBuffer)(realm, bufferConstructor, byteLength); // c. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.

        if ((0, _is.IsDetachedBuffer)(realm, srcData) === true) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcData) is true");
        } // d. Let srcByteIndex be srcByteOffset.


        let srcByteIndex = srcByteOffset; // e. Let targetByteIndex be 0.

        let targetByteIndex = 0; // f. Let count be elementLength.

        let count = elementLength; // g. Repeat, while count > 0

        while (count > 0) {
          // i. Let value be GetValueFromBuffer(srcData, srcByteIndex, srcType).
          let value = (0, _arraybuffer.GetValueFromBuffer)(realm, srcData, srcByteIndex, srcType); // ii. Perform SetValueInBuffer(data, targetByteIndex, elementType, value).

          (0, _arraybuffer.SetValueInBuffer)(realm, data, targetByteIndex, elementType, value.value); // iii. Set srcByteIndex to srcByteIndex + srcElementSize.

          srcByteIndex = srcByteIndex + srcElementSize; // iv. Set targetByteIndex to targetByteIndex + elementSize.

          targetByteIndex = targetByteIndex + elementSize; // v. Decrement count by 1.

          count -= 1;
        }
      } // 19. Set O.[[ViewedArrayBuffer]] to data.


      O.$ViewedArrayBuffer = data; // 20. Set O.[[ByteLength]] to byteLength.

      O.$ByteLength = byteLength; // 21. Set O.[[ByteOffset]] to 0.

      O.$ByteOffset = 0; // 22. Set O.[[ArrayLength]] to elementLength.

      O.$ArrayLength = elementLength; // 23. Return O.

      return O;
    } else if (!("$ArrayBufferData" in args[0]) && !("$TypedArrayName" in args[0])) {
      // ECMA262 22.2.4.4
      let object = args[0].throwIfNotConcrete(); // 1. Assert: Type(object) is Object and object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.

      (0, _invariant.default)(object instanceof _index.ObjectValue && typeof object.$TypedArrayName && !object.$ArrayBufferData); // 2. If NewTarget is undefined, throw a TypeError exception.

      if (!NewTarget) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "NewTarget is undefined");
      } // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.


      let constructorName = getConstructorName(type); // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%").

      let O = (0, _typedarray.AllocateTypedArray)(realm, constructorName, NewTarget, `${type}ArrayPrototype`); // 5. Let usingIterator be ? GetMethod(object, @@iterator).

      let usingIterator = (0, _get.GetMethod)(realm, object, realm.intrinsics.SymbolIterator); // 6. If usingIterator is not undefined, then

      if (!(usingIterator instanceof _index.UndefinedValue)) {
        // a. Let values be ? IterableToList(object, usingIterator).
        let values = (0, _iterator.IterableToList)(realm, object, usingIterator); // b. Let len be the number of elements in values.

        let len = values.length; // c. Perform ? AllocateTypedArrayBuffer(O, len).

        (0, _typedarray.AllocateTypedArrayBuffer)(realm, O, len); // d. Let k be 0.

        let k = 0; // e. Repeat, while k < len

        while (k < len) {
          // i. Let Pk be ! ToString(k).
          let Pk = new _index.StringValue(realm, _singletons.To.ToString(realm, new _index.NumberValue(realm, k))); // ii. Let kValue be the first element of values and remove that element from values.

          let kValue = values.shift(); // iii. Perform ? Set(O, Pk, kValue, true).

          _singletons.Properties.Set(realm, O, Pk, kValue, true); // iv. Increase k by 1.


          k = k + 1;
        } // f. Assert: values is now an empty List.


        (0, _invariant.default)(values.length === 0); // g. Return O.

        return O;
      } // 7. NOTE: object is not an Iterable so assume it is already an array-like object.
      // 8. Let arrayLike be object.


      let arrayLike = object; // 9. Let len be ? ToLength(? Get(arrayLike, "length")).

      let len = _singletons.To.ToLength(realm, (0, _get.Get)(realm, arrayLike, "length")); // 10. Perform ? AllocateTypedArrayBuffer(O, len).


      (0, _typedarray.AllocateTypedArrayBuffer)(realm, O, len); // 11. Let k be 0.

      let k = 0; // 12. Repeat, while k < len

      while (k < len) {
        // a. Let Pk be ! ToString(k).
        let Pk = new _index.StringValue(realm, _singletons.To.ToString(realm, new _index.NumberValue(realm, k))); // b. Let kValue be ? Get(arrayLike, Pk).

        let kValue = (0, _get.Get)(realm, arrayLike, Pk); // c. Perform ? Set(O, Pk, kValue, true).

        _singletons.Properties.Set(realm, O, Pk, kValue, true); // d. Increase k by 1.


        k += 1;
      } // 13. Return O.


      return O;
    } else {
      // ECMA262 22.2.4.5
      let buffer = args[0].throwIfNotConcrete(),
          byteOffset = args[1],
          length = args[2]; // 1. Assert: Type(buffer) is Object and buffer has an [[ArrayBufferData]] internal slot.

      (0, _invariant.default)(buffer instanceof _index.ObjectValue && "$ArrayBufferData" in buffer); // 2. If NewTarget is undefined, throw a TypeError exception.

      if (!NewTarget) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "NewTarget is undefined");
      } // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.


      let constructorName = getConstructorName(type); // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, "%TypedArrayPrototype%").

      let O = (0, _typedarray.AllocateTypedArray)(realm, constructorName, NewTarget, `${type}ArrayPrototype`); // 5. Let constructorName be the String value of O.[[TypedArrayName]].

      constructorName = O.$TypedArrayName;
      (0, _invariant.default)(constructorName); // 6. Let elementSize be the Number value of the Element Size value in Table 50 for constructorName.

      let elementSize = _typedarray.ArrayElementSize[constructorName]; // 7. Let offset be ? ToIndex(byteOffset).

      let offset = _singletons.To.ToIndexPartial(realm, byteOffset); // 8. If offset modulo elementSize  0, throw a RangeError exception.


      if (offset % elementSize !== 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "offset modulo elementSize  0");
      } // 9. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.


      if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
      } // 10. Let bufferByteLength be buffer.[[ArrayBufferByteLength]].


      let bufferByteLength = buffer.$ArrayBufferByteLength;
      (0, _invariant.default)(typeof bufferByteLength === "number");
      let newByteLength; // 11. If length is either not present or undefined, then

      if (!length || length instanceof _index.UndefinedValue) {
        // a. If bufferByteLength modulo elementSize  0, throw a RangeError exception.
        if (bufferByteLength % elementSize !== 0) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "bufferByteLength modulo elementSize  0");
        } // b. Let newByteLength be bufferByteLength - offset.


        newByteLength = bufferByteLength - offset; // c. If newByteLength < 0, throw a RangeError exception.

        if (newByteLength < 0) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "newByteLength < 0");
        }
      } else {
        // 12. Else,
        // a. Let newLength be ? ToIndex(length).
        let newLength = _singletons.To.ToIndexPartial(realm, length); // b. Let newByteLength be newLength  elementSize.


        newByteLength = newLength * elementSize; // c. If offset+newByteLength > bufferByteLength, throw a RangeError exception.

        if (offset + newByteLength > bufferByteLength) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "offset+newByteLength > bufferByteLength");
        }
      } // 13. Set O.[[ViewedArrayBuffer]] to buffer.


      O.$ViewedArrayBuffer = buffer; // 14. Set O.[[ByteLength]] to newByteLength.

      O.$ByteLength = newByteLength; // 15. Set O.[[ByteOffset]] to offset.

      O.$ByteOffset = offset; // 16. Set O.[[ArrayLength]] to newByteLength / elementSize.

      O.$ArrayLength = newByteLength / elementSize; // 17. Return O.

      return O;
    }
  }); // ECMA262 22.2.5

  func.$Prototype = realm.intrinsics.TypedArray; // ECMA262 22.2.5.1

  func.defineNativeConstant("BYTES_PER_ELEMENT", new _index.NumberValue(realm, _types.ElementSize[type]));
  return func;
}
//# sourceMappingURL=TypedArray.js.map

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.build = build;

var _types = __webpack_require__(19);

var _index = __webpack_require__(10);

var _call = __webpack_require__(234);

var _get = __webpack_require__(230);

var _has = __webpack_require__(269);

var _is = __webpack_require__(229);

var _typedarray = __webpack_require__(390);

var _arraybuffer = __webpack_require__(278);

var _abstract = __webpack_require__(233);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 22.2.3.1
  obj.defineNativeGetter("buffer", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, return undefined.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    } // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.


    (0, _invariant.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]]"); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer; // 6. Return buffer.

    return buffer;
  }); // ECMA262 22.2.3.2

  obj.defineNativeGetter("byteLength", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    } // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.


    (0, _invariant.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot"); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer;
    (0, _invariant.default)(buffer); // 6. If IsDetachedBuffer(buffer) is true, return 0.

    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) return realm.intrinsics.zero; // 7. Let size be O.[[ByteLength]].

    let size = O.$ByteLength;
    (0, _invariant.default)(typeof size === "number"); // 8. Return size.

    return new _index.NumberValue(realm, size);
  }); // ECMA262 22.2.3.3

  obj.defineNativeGetter("byteOffset", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    } // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.


    (0, _invariant.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot"); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer;
    (0, _invariant.default)(buffer); // 6. If IsDetachedBuffer(buffer) is true, return 0.

    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) return realm.intrinsics.zero; // 7. Let offset be O.[[ByteOffset]].

    let offset = O.$ByteOffset;
    (0, _invariant.default)(typeof offset === "number"); // 8. Return offset.

    return new _index.NumberValue(realm, offset);
  }); // ECMA262 22.2.3.5

  obj.defineNativeMethod("copyWithin", 2, (context, [target, start, end]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. Let relativeTarget be ? ToInteger(target).

    let relativeTarget = _singletons.To.ToInteger(realm, target); // 5. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).


    let to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len); // 6. Let relativeStart be ? ToInteger(start).

    let relativeStart = _singletons.To.ToInteger(realm, start); // 7. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).


    let from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).

    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // 10. Let count be min(final-from, len-to).

    let count = Math.min(final - from, len - to);
    let direction; // 11. If from<to and to<from+count, then

    if (from < to && to < from + count) {
      // a. Let direction be -1.
      direction = -1; // b. Let from be from + count - 1.

      from = from + count - 1; // c. Let to be to + count - 1.

      to = to + count - 1;
    } else {
      // 12. Else,
      // a. Let direction be 1.
      direction = 1;
    } // 13. Repeat, while count > 0


    while (count > 0) {
      // a. Let fromKey be ! ToString(from).
      let fromKey = _singletons.To.ToString(realm, new _index.NumberValue(realm, from)); // b. Let toKey be ! ToString(to).


      let toKey = _singletons.To.ToString(realm, new _index.NumberValue(realm, to)); // c. Let fromPresent be ? HasProperty(O, fromKey).


      let fromPresent = (0, _has.HasProperty)(realm, O, fromKey); // d. If fromPresent is true, then

      if (fromPresent === true) {
        // i. Let fromVal be ? Get(O, fromKey).
        let fromVal = (0, _get.Get)(realm, O, fromKey); // ii. Perform ? Set(O, toKey, fromVal, true).

        _singletons.Properties.Set(realm, O, toKey, fromVal, true);
      } else {
        // e. Else fromPresent is false,
        // i. Perform ? DeletePropertyOrThrow(O, toKey).
        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), toKey);
      } // f. Let from be from + direction.


      from = from + direction; // g. Let to be to + direction.

      to = to + direction; // h. Let count be count - 1.

      count = count - 1;
    } // 14. Return O.


    return O;
  }); // ECMA262 22.2.3.6

  obj.defineNativeMethod("entries", 0, context => {
    // 1. Let O be the this value.
    let O = context; // 2. Perform ? ValidateTypedArray(O).

    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant.default)(O instanceof _index.ObjectValue); // 3. Return CreateArrayIterator(O, "key+value").

    return _singletons.Create.CreateArrayIterator(realm, O, "key+value");
  }); // ECMA262 22.2.3.7

  obj.defineNativeMethod("every", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 6. Let k be 0.

    let k = 0; // 7. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _has.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _get.Get)(realm, O, Pk); // ii. Let testResult be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).

        let testResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O])); // iii. If testResult is false, return false.


        if (!testResult) return realm.intrinsics.false;
      } // d. Increase k by 1.


      k++;
    } // 8. Return true.


    return realm.intrinsics.true;
  }); // ECMA262 22.2.3.8

  obj.defineNativeMethod("fill", 1, (context, [value, start, end]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. Let relativeStart be ? ToInteger(start).

    let relativeStart = _singletons.To.ToInteger(realm, start || realm.intrinsics.undefined); // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).


    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).

    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // 8. Repeat, while k < final

    while (k < final) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Perform ? Set(O, Pk, value, true).

      _singletons.Properties.Set(realm, O, Pk, value, true); // c. Increase k by 1.


      k++;
    } // 9. Return O.


    return O;
  }); // ECMA262 22.2.3.9

  obj.defineNativeMethod("filter", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be the this value.
    let O = context; // 2. Perform ? ValidateTypedArray(O).

    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant.default)(O instanceof _index.ObjectValue); // 3. Let len be O.[[ArrayLength]].

    let len = O.$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if ((0, _is.IsCallable)(realm, callbackfn) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(callbackfn) is false");
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg ? thisArg : realm.intrinsics.undefined; // 6. Let kept be a new empty List.

    let kept = []; // 7. Let k be 0.

    let k = 0; // 8. Let captured be 0.

    let captured = 0; // 9. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let kValue be ? Get(O, Pk).


      let kValue = (0, _get.Get)(realm, O, Pk); // c. Let selected be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).

      let selected = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O])); // d. If selected is true, then


      if (selected === true) {
        // i. Append kValue to the end of kept.
        kept.push(kValue); // ii. Increase captured by 1.

        captured += 1;
      } // e. Increase k by 1.


      k += 1;
    } // 10. Let A be ? TypedArraySpeciesCreate(O,  captured ).


    let A = (0, _typedarray.TypedArraySpeciesCreate)(realm, O, [new _index.NumberValue(realm, captured)]); // 11. Let n be 0.

    let n = 0; // 12. For each element e of kept

    for (let e of kept) {
      // a. Perform ! Set(A, ! ToString(n), e, true).
      _singletons.Properties.Set(realm, A, new _index.StringValue(realm, _singletons.To.ToString(realm, new _index.NumberValue(realm, n))), e, true); // b. Increment n by 1.


      n = n + 1;
    } // 13. Return A.


    return A;
  }); // ECMA262 22.2.3.10

  obj.defineNativeMethod("find", 1, (context, [predicate, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(predicate) is false, throw a TypeError exception.

    if (!(0, _is.IsCallable)(realm, predicate)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 6. Let k be 0.

    let k = 0; // 7. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kValue be ? Get(O, Pk).

      let kValue = (0, _get.Get)(realm, O, Pk); // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).

      let testResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, predicate, T, [kValue, new _index.NumberValue(realm, k), O])); // d. If testResult is true, return kValue.


      if (testResult) return kValue; // e. Increase k by 1.

      k++;
    } // 8. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 22.2.3.11

  obj.defineNativeMethod("findIndex", 1, (context, [predicate, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(predicate) is false, throw a TypeError exception.

    if ((0, _is.IsCallable)(realm, predicate) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg ? thisArg : realm.intrinsics.undefined; // 6. Let k be 0.

    let k = 0; // 7. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let kValue be ? Get(O, Pk).


      let kValue = (0, _get.Get)(realm, O, new _index.StringValue(realm, Pk)); // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).

      let testResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, predicate, T, [kValue, new _index.NumberValue(realm, k), O])); // d. If testResult is true, return k.


      if (testResult === true) return new _index.NumberValue(realm, k); // e. Increase k by 1.

      k = k + 1;
    } // 8. Return -1.


    return new _index.NumberValue(realm, -1);
  }); // ECMA262 22.2.3.12

  obj.defineNativeMethod("forEach", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 6. Let k be 0.

    let k = 0; // 7. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _has.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _get.Get)(realm, O, Pk); // ii. Perform ? Call(callbackfn, T,  kValue, k, O ).

        (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]);
      } // d. Increase k by 1.


      k++;
    } // 8. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 22.2.3.14

  obj.defineNativeMethod("includes", 1, (context, [searchElement, fromIndex]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If len is 0, return false.

    if (len === 0) return realm.intrinsics.false; // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)

    let n = _singletons.To.ToInteger(realm, fromIndex || realm.intrinsics.undefined);

    let k; // 6. If n  0, then

    if (n >= 0) {
      // a. Let k be n.
      k = n;
    } else {
      // 7. Else n < 0,
      // a. Let k be len + n.
      k = len + n; // b. If k < 0, let k be 0.

      if (k < 0) k = 0;
    } // 8. Repeat, while k < len


    while (k < len) {
      // a. Let elementK be the result of ? Get(O, ! ToString(k)).
      let elementK = (0, _get.Get)(realm, O, _singletons.To.ToString(realm, new _index.NumberValue(realm, k))); // b. If SameValueZero(searchElement, elementK) is true, return true.

      if ((0, _abstract.SameValueZeroPartial)(realm, searchElement, elementK) === true) return realm.intrinsics.true; // c. Increase k by 1.

      k = k + 1;
    } // 9. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 22.2.3.14

  obj.defineNativeMethod("indexOf", 1, (context, [searchElement, fromIndex]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If len is 0, return -1.

    if (len === 0) return new _index.NumberValue(realm, -1); // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)

    let n = fromIndex ? _singletons.To.ToInteger(realm, fromIndex) : 0; // 6. If n  len, return -1.

    if (n >= len) return new _index.NumberValue(realm, -1); // 7. If n  0, then

    let k;

    if (n >= 0) {
      // a. If n is -0, let k be +0; else let k be n.
      k = Object.is(n, -0) ? +0 : n;
    } else {
      // 8. Else n < 0,
      // a. Let k be len + n.
      k = len + n; // b. If k < 0, let k be 0.

      if (k < 0) k = 0;
    } // 9. Repeat, while k < len


    while (k < len) {
      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).
      let kPresent = (0, _has.HasProperty)(realm, O, k + ""); // b. If kPresent is true, then

      if (kPresent === true) {
        // i. Let elementK be ? Get(O, ! ToString(k)).
        let elementK = (0, _get.Get)(realm, O, k + ""); // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.

        let same = (0, _abstract.StrictEqualityComparisonPartial)(realm, searchElement, elementK); // iii. If same is true, return k.

        if (same) return new _index.NumberValue(realm, k);
      } // c. Increase k by 1.


      k++;
    } // 10. Return -1.


    return new _index.NumberValue(realm, -1);
  }); // ECMA262 22.2.3.15

  obj.defineNativeMethod("join", 1, (context, [_separator]) => {
    let separator = _separator; // 1. Let O be ? ToObject(this value).

    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If separator is undefined, let separator be the single-element String ",".

    if (!separator || separator instanceof _index.UndefinedValue) separator = new _index.StringValue(realm, ","); // 5. Let sep be ? ToString(separator).

    let sep = _singletons.To.ToStringPartial(realm, separator); // 6. If len is zero, return the empty String.


    if (len === 0) return realm.intrinsics.emptyString; // 7. Let element0 be Get(O, "0").

    let element0 = (0, _get.Get)(realm, O, "0"); // 8. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).

    let R;

    if ((0, _has.HasSomeCompatibleType)(element0, _index.UndefinedValue, _index.NullValue)) {
      R = "";
    } else {
      R = _singletons.To.ToStringPartial(realm, element0);
    } // 9. Let k be 1.


    let k = 1; // 10. Repeat, while k < len

    while (k < len) {
      // a. Let S be the String value produced by concatenating R and sep.
      let S = R + sep; // b. Let element be ? Get(O, ! ToString(k)).

      let element = (0, _get.Get)(realm, O, new _index.StringValue(realm, k + "")); // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).

      let next;

      if ((0, _has.HasSomeCompatibleType)(element, _index.UndefinedValue, _index.NullValue)) {
        next = "";
      } else {
        next = _singletons.To.ToStringPartial(realm, element);
      } // d. Let R be a String value produced by concatenating S and next.


      R = S + next; // e. Increase k by 1.

      k++;
    } // 11. Return R.


    return new _index.StringValue(realm, R + "");
  }); // ECMA262 22.2.3.16

  obj.defineNativeMethod("keys", 0, context => {
    // 1. Let O be the this value.
    let O = context; // 2. Perform ? ValidateTypedArray(O).

    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant.default)(O instanceof _index.ObjectValue); // 3. Return CreateArrayIterator(O, "key").

    return _singletons.Create.CreateArrayIterator(realm, O, "key");
  }); // ECMA262 22.2.3.17

  obj.defineNativeMethod("lastIndexOf", 1, (context, [searchElement, fromIndex]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If len is 0, return -1.

    if (len === 0) return new _index.NumberValue(realm, -1); // 5. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.

    let n = fromIndex ? _singletons.To.ToInteger(realm, fromIndex) : len - 1; // 6. If n  0, then

    let k;

    if (n >= 0) {
      // a. If n is -0, let k be +0; else let k be min(n, len - 1).
      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);
    } else {
      // 7. Else n < 0,
      // a. Let k be len + n.
      k = len + n;
    } // 8. Repeat, while k  0


    while (k >= 0) {
      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).
      let kPresent = (0, _has.HasProperty)(realm, O, new _index.StringValue(realm, k + "")); // b. If kPresent is true, then

      if (kPresent) {
        // i. Let elementK be ? Get(O, ! ToString(k)).
        let elementK = (0, _get.Get)(realm, O, new _index.StringValue(realm, k + "")); // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.

        let same = (0, _abstract.StrictEqualityComparisonPartial)(realm, searchElement, elementK); // iii. If same is true, return k.

        if (same) return new _index.NumberValue(realm, k);
      } // c. Decrease k by 1.


      k--;
    } // 9. Return -1.


    return new _index.NumberValue(realm, -1);
  }); // ECMA262 22.2.3.18

  obj.defineNativeGetter("length", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    } // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.


    (0, _invariant.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot"); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer;
    (0, _invariant.default)(buffer); // 6. If IsDetachedBuffer(buffer) is true, return 0.

    if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) return realm.intrinsics.zero; // 7. Let length be O.[[ArrayLength]].

    let length = O.$ArrayLength;
    (0, _invariant.default)(typeof length === "number"); // 8. Return length.

    return new _index.NumberValue(realm, length);
  }); // ECMA262 22.2.3.19

  obj.defineNativeMethod("map", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be the this value.
    let O = context; // 2. Perform ? ValidateTypedArray(O).

    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant.default)(O instanceof _index.ObjectValue); // 3. Let len be O.[[ArrayLength]].

    let len = O.$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if ((0, _is.IsCallable)(realm, callbackfn) === false) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(callbackfn) is false");
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg ? thisArg : realm.intrinsics.undefined; // 6. Let A be ? TypedArraySpeciesCreate(O,  len ).

    let A = (0, _typedarray.TypedArraySpeciesCreate)(realm, O, [new _index.NumberValue(realm, len)]); // 7. Let k be 0.

    let k = 0; // 8. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let kValue be ? Get(O, Pk).


      let kValue = (0, _get.Get)(realm, O, Pk); // c. Let mappedValue be ? Call(callbackfn, T,  kValue, k, O ).

      let mappedValue = (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O]); // d. Perform ? Set(A, Pk, mappedValue, true).

      _singletons.Properties.Set(realm, A, Pk, mappedValue, true); // e. Increase k by 1.


      k = k + 1;
    } // 9. Return A.


    return A;
  }); // ECMA262 22.2.3.20

  obj.defineNativeMethod("reduce", 1, (context, [callbackfn, initialValue]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 5. If len is 0 and initialValue is not present, throw a TypeError exception.


    if (len === 0 && !initialValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
    } // 6. Let k be 0.


    let k = 0; // 7. If initialValue is present, then

    let accumulator;

    if (initialValue) {
      // a. Set accumulator to initialValue.
      accumulator = initialValue;
    } else {
      // 8. Else initialValue is not present,
      // a. Let kPresent be false.
      let kPresent = false; // b. Repeat, while kPresent is false and k < len

      while (kPresent === false && k < len) {
        // i. Let Pk be ! ToString(k).
        let Pk = new _index.StringValue(realm, k + ""); // ii. Let kPresent be ? HasProperty(O, Pk).

        kPresent = (0, _has.HasProperty)(realm, O, Pk); // iv. If kPresent is true, then

        if (kPresent) {
          // 1. Let accumulator be ? Get(O, Pk).
          accumulator = (0, _get.Get)(realm, O, Pk);
        } // v. Increase k by 1.


        k++;
      } // c. If kPresent is false, throw a TypeError exception.


      if (!kPresent) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "kPresent is false");
      }

      (0, _invariant.default)(accumulator);
    } // 9. Repeat, while k < len


    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _has.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _get.Get)(realm, O, Pk); // ii. Let accumulator be ? Call(callbackfn, undefined,  accumulator, kValue, k, O ).

        accumulator = (0, _call.Call)(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new _index.NumberValue(realm, k), O]);
      } // d. Increase k by 1.


      k++;
    } // 10. Return accumulator.


    return accumulator;
  }); // ECMA262 22.2.3.21

  obj.defineNativeMethod("reduceRight", 1, (context, [callbackfn, initialValue]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not a function");
    } // 5. If len is 0 and initialValue is not present, throw a TypeError exception.


    if (len === 0 && !initialValue) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
    } // 6. Let k be len-1.


    let k = len - 1; // 7. If initialValue is present, then

    let accumulator;

    if (initialValue) {
      // 1. Set accumulator to initialValue.
      accumulator = initialValue;
    } else {
      // 8. Else initialValue is not present,
      // a. Let kPresent be false.
      let kPresent = false; // b. Repeat, while kPresent is false and k  0

      while (!kPresent && k >= 0) {
        // i. Let Pk be ! ToString(k).
        let Pk = new _index.StringValue(realm, k + ""); // ii. Let kPresent be ? HasProperty(O, Pk).

        kPresent = (0, _has.HasProperty)(realm, O, Pk); // iii. If kPresent is true, then

        if (kPresent) {
          // 1. Let accumulator be ? Get(O, Pk).
          accumulator = (0, _get.Get)(realm, O, Pk);
        } // iv. Decrease k by 1.


        k--;
      } // c. If kPresent is false, throw a TypeError exception.


      if (!kPresent || !accumulator) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Array.prototype");
      }
    } // 9. Repeat, while k  0


    while (k >= 0) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _has.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _get.Get)(realm, O, Pk); // ii. Let accumulator be ? Call(callbackfn, undefined,  accumulator, kValue, k, O ).

        accumulator = (0, _call.Call)(realm, callbackfn, realm.intrinsics.undefined, [accumulator, kValue, new _index.NumberValue(realm, k), O]);
      } // d. Decrease k by 1.


      k--;
    } // 10. Return accumulator.


    return accumulator;
  }); // ECMA262 22.2.3.21

  obj.defineNativeMethod("reverse", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. Let middle be floor(len/2).

    let middle = Math.floor(len / 2); // 5. Let lower be 0.

    let lower = 0; // 6. Repeat, while lower  middle

    while (lower !== middle) {
      // a. Let upper be len - lower - 1.
      let upper = len - lower - 1; // b. Let upperP be ! ToString(upper).

      let upperP = new _index.StringValue(realm, upper + ""); // c. Let lowerP be ! ToString(lower).

      let lowerP = new _index.StringValue(realm, lower + ""); // d. Let lowerExists be ? HasProperty(O, lowerP).

      let lowerExists = (0, _has.HasProperty)(realm, O, lowerP); // e. If lowerExists is true, then

      let lowerValue;

      if (lowerExists) {
        // i. Let lowerValue be ? Get(O, lowerP).
        lowerValue = (0, _get.Get)(realm, O, lowerP);
      } // f. Let upperExists be ? HasProperty(O, upperP).


      let upperExists = (0, _has.HasProperty)(realm, O, upperP); // g. If upperExists is true, then

      let upperValue;

      if (upperExists) {
        // i. Let upperValue be ? Get(O, upperP).
        upperValue = (0, _get.Get)(realm, O, upperP);
      } // h. If lowerExists is true and upperExists is true, then


      if (lowerExists && upperExists) {
        (0, _invariant.default)(lowerValue, "expected lower value to exist");
        (0, _invariant.default)(upperValue, "expected upper value to exist"); // i. Perform ? Set(O, lowerP, upperValue, true).

        _singletons.Properties.Set(realm, O, lowerP, upperValue, true); // ii. Perform ? Set(O, upperP, lowerValue, true).


        _singletons.Properties.Set(realm, O, upperP, lowerValue, true);
      } else if (!lowerExists && upperExists) {
        // i. Else if lowerExists is false and upperExists is true, then
        (0, _invariant.default)(upperValue, "expected upper value to exist"); // i. Perform ? Set(O, lowerP, upperValue, true).

        _singletons.Properties.Set(realm, O, lowerP, upperValue, true); // ii. Perform ? DeletePropertyOrThrow(O, upperP).


        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), upperP);
      } else if (lowerExists && !upperExists) {
        // j. Else if lowerExists is true and upperExists is false, then
        (0, _invariant.default)(lowerValue, "expected lower value to exist"); // i. Perform ? DeletePropertyOrThrow(O, lowerP).

        _singletons.Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), lowerP); // ii. Perform ? Set(O, upperP, lowerValue, true).


        _singletons.Properties.Set(realm, O, upperP, lowerValue, true);
      } else {} // k. Else both lowerExists and upperExists are false,
      // i. No action is required.
      // l. Increase lower by 1.


      lower++;
    } // 7. Return O.


    return O;
  }); // ECMA262 22.2.3.23

  obj.defineNativeMethod("set", 1, (context, [overloaded, offset]) => {
    if (overloaded.$TypedArrayName === undefined) {
      let array = overloaded; // 1. Assert: array is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.

      (0, _invariant.default)(!(overloaded instanceof _index.ObjectValue && overloaded.$TypedArrayName)); // 2. Let target be the this value.

      let target = context.throwIfNotConcrete(); // 3. If Type(target) is not Object, throw a TypeError exception.

      if (!(target instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(target) is not Object");
      } // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


      if (typeof target.$TypedArrayName !== "string") {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "target does not have a [[TypedArrayName]] internal slot");
      } // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.


      (0, _invariant.default)(target.$ViewedArrayBuffer, "target has a [[ViewedArrayBuffer]] internal slot"); // 6. Let targetOffset be ? ToInteger(offset).

      let targetOffset = _singletons.To.ToInteger(realm, offset || realm.intrinsics.undefined); // 7. If targetOffset < 0, throw a RangeError exception.


      if (targetOffset < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "targetOffset < 0");
      } // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].


      let targetBuffer = target.$ViewedArrayBuffer;
      (0, _invariant.default)(targetBuffer instanceof _index.ObjectValue); // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.

      if ((0, _is.IsDetachedBuffer)(realm, targetBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(targetBuffer) is true");
      } // 10. Let targetLength be target.[[ArrayLength]].


      let targetLength = target.$ArrayLength;
      (0, _invariant.default)(typeof targetLength === "number"); // 11. Let targetName be the String value of target.[[TypedArrayName]].

      let targetName = target.$TypedArrayName;
      (0, _invariant.default)(typeof targetName === "string"); // 12. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.

      let targetElementSize = _typedarray.ArrayElementSize[targetName]; // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.

      let targetType = _typedarray.ArrayElementType[targetName]; // 14. Let targetByteOffset be target.[[ByteOffset]].

      let targetByteOffset = target.$ByteOffset;
      (0, _invariant.default)(typeof targetByteOffset === "number"); // 15. Let src be ? ToObject(array).

      let src = _singletons.To.ToObject(realm, array); // 16. Let srcLength be ? ToLength(? Get(src, "length")).


      let srcLength = _singletons.To.ToLength(realm, (0, _get.Get)(realm, src, "length")); // 17. If srcLength + targetOffset > targetLength, throw a RangeError exception.


      if (srcLength + targetOffset > targetLength) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "srcLength + targetOffset > targetLength");
      } // 18. Let targetByteIndex be targetOffset  targetElementSize + targetByteOffset.


      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset; // 19. Let k be 0.

      let k = 0; // 20. Let limit be targetByteIndex + targetElementSize  srcLength.

      let limit = targetByteIndex + targetElementSize * srcLength; // 21. Repeat, while targetByteIndex < limit

      while (targetByteIndex < limit) {
        // a. Let Pk be ! ToString(k).
        let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // b. Let kNumber be ? ToNumber(? Get(src, Pk)).


        let kNumber = _singletons.To.ToNumber(realm, (0, _get.Get)(realm, src, Pk)); // c. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.


        if ((0, _is.IsDetachedBuffer)(realm, targetBuffer) === true) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(targetBuffer) is true");
        } // d. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber).


        (0, _arraybuffer.SetValueInBuffer)(realm, targetBuffer, targetByteIndex, targetType, kNumber); // e. Set k to k + 1.

        k = k + 1; // f. Set targetByteIndex to targetByteIndex + targetElementSize.

        targetByteIndex = targetByteIndex + targetElementSize;
      } // 22. Return undefined.


      return realm.intrinsics.undefined;
    } else {
      let typedArray = overloaded; // 1. Assert: typedArray has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.

      (0, _invariant.default)(typedArray instanceof _index.ObjectValue && typedArray.$TypedArrayName); // 2. Let target be the this value.

      let target = context.throwIfNotConcrete(); // 3. If Type(target) is not Object, throw a TypeError exception.

      if (!(target instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(target) is not Object");
      } // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


      if (typeof target.$TypedArrayName !== "string") {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "target does not have a [[TypedArrayName]] internal slot");
      } // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.


      (0, _invariant.default)(target.$ViewedArrayBuffer); // 6. Let targetOffset be ? ToInteger(offset).

      let targetOffset = _singletons.To.ToInteger(realm, offset || realm.intrinsics.undefined); // 7. If targetOffset < 0, throw a RangeError exception.


      if (targetOffset < 0) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "targetOffset < 0");
      } // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].


      let targetBuffer = target.$ViewedArrayBuffer;
      (0, _invariant.default)(targetBuffer instanceof _index.ObjectValue); // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.

      if ((0, _is.IsDetachedBuffer)(realm, targetBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(targetBuffer) is true");
      } // 10. Let targetLength be target.[[ArrayLength]].


      let targetLength = target.$ArrayLength;
      (0, _invariant.default)(typeof targetLength === "number"); // 11. Let srcBuffer be typedArray.[[ViewedArrayBuffer]].

      let srcBuffer = typedArray.$ViewedArrayBuffer;
      (0, _invariant.default)(srcBuffer); // 12. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.

      if ((0, _is.IsDetachedBuffer)(realm, srcBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcBuffer) is true");
      } // 13. Let targetName be the String value of target.[[TypedArrayName]].


      let targetName = target.$TypedArrayName;
      (0, _invariant.default)(typeof targetName === "string"); // 14. Let targetType be the String value of the Element Type value in Table 50 for targetName.

      let targetType = _typedarray.ArrayElementType[targetName]; // 15. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.

      let targetElementSize = _typedarray.ArrayElementSize[targetName]; // 16. Let targetByteOffset be target.[[ByteOffset]].

      let targetByteOffset = target.$ByteOffset;
      (0, _invariant.default)(typeof targetByteOffset === "number"); // 17. Let srcName be the String value of typedArray.[[TypedArrayName]].

      let srcName = typedArray.$TypedArrayName;
      (0, _invariant.default)(typeof srcName === "string"); // 18. Let srcType be the String value of the Element Type value in Table 50 for srcName.

      let srcType = _typedarray.ArrayElementType[srcName]; // 19. Let srcElementSize be the Number value of the Element Size value specified in Table 50 for srcName.

      let srcElementSize = _typedarray.ArrayElementSize[srcName]; // 20. Let srcLength be typedArray.[[ArrayLength]].

      let srcLength = typedArray.$ArrayLength;
      (0, _invariant.default)(typeof srcLength === "number"); // 21. Let srcByteOffset be typedArray.[[ByteOffset]].

      let srcByteOffset = typedArray.$ByteOffset;
      (0, _invariant.default)(typeof srcByteOffset === "number"); // 22. If srcLength + targetOffset > targetLength, throw a RangeError exception.

      if (srcLength + targetOffset > targetLength) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, "srcLength + targetOffset > targetLength");
      }

      let srcByteIndex; // 23. If SameValue(srcBuffer, targetBuffer) is true, then

      if ((0, _abstract.SameValue)(realm, srcBuffer, targetBuffer) === true) {
        // a. Let srcBuffer be ? CloneArrayBuffer(targetBuffer, srcByteOffset, %ArrayBuffer%).
        srcBuffer = (0, _arraybuffer.CloneArrayBuffer)(realm, targetBuffer, srcByteOffset, realm.intrinsics.ArrayBuffer); // b. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.
        // c. Let srcByteIndex be 0.

        srcByteIndex = 0;
      } else {
        // 24. Else, let srcByteIndex be srcByteOffset.
        srcByteIndex = srcByteOffset;
      } // 25. Let targetByteIndex be targetOffset  targetElementSize + targetByteOffset.


      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset; // 26. Let limit be targetByteIndex + targetElementSize  srcLength.

      let limit = targetByteIndex + targetElementSize * srcLength; // 27. If SameValue(srcType, targetType) is true, then

      if (srcType === targetType) {
        // a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
        // b. Repeat, while targetByteIndex < limit
        while (targetByteIndex < limit) {
          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, "Uint8").
          let value = (0, _arraybuffer.GetValueFromBuffer)(realm, srcBuffer, srcByteIndex, "Uint8"); // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, "Uint8", value).

          (0, _arraybuffer.SetValueInBuffer)(realm, targetBuffer, targetByteIndex, "Uint8", value.value); // iii. Set srcByteIndex to srcByteIndex + 1.

          srcByteIndex += 1; // iv. Set targetByteIndex to targetByteIndex + 1.

          targetByteIndex += 1;
        }
      } else {
        // 28. Else,
        // a. Repeat, while targetByteIndex < limit
        while (targetByteIndex < limit) {
          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType).
          let value = (0, _arraybuffer.GetValueFromBuffer)(realm, srcBuffer, srcByteIndex, srcType); // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value).

          (0, _arraybuffer.SetValueInBuffer)(realm, targetBuffer, targetByteIndex, targetType, value.value); // iii. Set srcByteIndex to srcByteIndex + srcElementSize.

          srcByteIndex = srcByteIndex + srcElementSize; // iv. Set targetByteIndex to targetByteIndex + targetElementSize.

          targetByteIndex = targetByteIndex + targetElementSize;
        }
      } // 29. Return undefined.


      return realm.intrinsics.undefined;
    }
  }); // ECMA262 22.2.3.24

  obj.defineNativeMethod("slice", 2, (context, [start, end]) => {
    // 1. Let O be the this value.
    let O = context; // 2. Perform ? ValidateTypedArray(O).

    (0, _typedarray.ValidateTypedArray)(realm, O);
    (0, _invariant.default)(O instanceof _index.ObjectValue); // 3. Let len be O.[[ArrayLength]].

    let len = O.$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. Let relativeStart be ? ToInteger(start).

    let relativeStart = _singletons.To.ToInteger(realm, start); // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).


    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).

    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // 8. Let count be max(final - k, 0).

    let count = Math.max(final - k, 0); // 9. Let A be ? TypedArraySpeciesCreate(O,  count ).

    let A = (0, _typedarray.TypedArraySpeciesCreate)(realm, O, [new _index.NumberValue(realm, count)]); // 10. Let srcName be the String value of O.[[TypedArrayName]].

    let srcName = O.$TypedArrayName;
    (0, _invariant.default)(typeof srcName === "string"); // 11. Let srcType be the String value of the Element Type value in Table 50 for srcName.

    let srcType = _typedarray.ArrayElementType[srcName]; // 12. Let targetName be the String value of A.[[TypedArrayName]].

    let targetName = A.$TypedArrayName;
    (0, _invariant.default)(typeof targetName === "string"); // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.

    let targetType = _typedarray.ArrayElementType[targetName]; // 14. If SameValue(srcType, targetType) is false, then

    if (srcType !== targetType) {
      // a. Let n be 0.
      let n = 0; // b. Repeat, while k < final

      while (k < final) {
        // i. Let Pk be ! ToString(k).
        let Pk = _singletons.To.ToString(realm, new _index.NumberValue(realm, k)); // ii. Let kValue be ? Get(O, Pk).


        let kValue = (0, _get.Get)(realm, O, Pk); // iii. Perform ! Set(A, ! ToString(n), kValue).

        _singletons.Properties.Set(realm, A, _singletons.To.ToString(realm, new _index.NumberValue(realm, n)), kValue, true); // iv. Increase k by 1.


        k += 1; // v. Increase n by 1.

        n += 1;
      }
    } else if (count > 0) {
      // 15. Else if count > 0, then
      // a. Let srcBuffer be O.[[ViewedArrayBuffer]].
      let srcBuffer = O.$ViewedArrayBuffer;
      (0, _invariant.default)(srcBuffer); // b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.

      if ((0, _is.IsDetachedBuffer)(realm, srcBuffer) === true) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(srcBuffer) is true");
      } // c. Let targetBuffer be A.[[ViewedArrayBuffer]].


      let targetBuffer = A.$ViewedArrayBuffer;
      (0, _invariant.default)(targetBuffer instanceof _index.ObjectValue); // d. Let elementSize be the Number value of the Element Size value specified in Table 50 for srcType.

      let elementSize = _types.ElementSize[srcType]; // e. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
      // f. Let srcByteOffset be O.[[ByteOffset]].

      let srcByteOffset = O.$ByteOffset;
      (0, _invariant.default)(typeof srcByteOffset === "number"); // g. Let targetByteIndex be A.[[ByteOffset]].

      let targetByteIndex = A.$ByteOffset;
      (0, _invariant.default)(typeof targetByteIndex === "number"); // h. Let srcByteIndex be (k  elementSize) + srcByteOffset.

      let srcByteIndex = k * elementSize + srcByteOffset; // i. Let limit be targetByteIndex + count  elementSize.

      let limit = targetByteIndex + count * elementSize; // j. Repeat, while targetByteIndex < limit

      while (targetByteIndex < limit) {
        // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, "Uint8").
        let value = (0, _arraybuffer.GetValueFromBuffer)(realm, srcBuffer, srcByteIndex, "Uint8"); // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, "Uint8", value).

        (0, _arraybuffer.SetValueInBuffer)(realm, targetBuffer, targetByteIndex, "Uint8", value.value); // iii. Increase srcByteIndex by 1.

        srcByteIndex += 1; // iv. Increase targetByteIndex by 1.

        targetByteIndex += 1;
      }
    } // 16. Return A.


    return A;
  }); // ECMA262 22.2.3.25

  obj.defineNativeMethod("some", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be O.[[ArrayLength]].

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.

    if (!(0, _is.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "callback passed to Array.prototype.some isn't callable");
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 6. Let k be 0.

    let k = 0; // 7. Repeat, while k < len

    while (k < len) {
      // a. Let Pk be ! ToString(k).
      let Pk = new _index.StringValue(realm, k + ""); // b. Let kPresent be ? HasProperty(O, Pk).

      let kPresent = (0, _has.HasProperty)(realm, O, Pk); // c. If kPresent is true, then

      if (kPresent) {
        // i. Let kValue be ? Get(O, Pk).
        let kValue = (0, _get.Get)(realm, O, Pk); // ii. Let testResult be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).

        let testResult = _singletons.To.ToBooleanPartial(realm, (0, _call.Call)(realm, callbackfn, T, [kValue, new _index.NumberValue(realm, k), O])); // iii. If testResult is true, return true.


        if (testResult) return realm.intrinsics.true;
      } // d. Increase k by 1.


      k++;
    } // 8. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 22.2.3.26

  obj.defineNativeMethod("sort", 1, (context, [comparefn]) => {
    // 1. Let obj be the this value.
    let O = _singletons.To.ToObject(realm, context); // 2. Let buffer be ? ValidateTypedArray(obj).


    let buffer = (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Let len be the value of obj's [[ArrayLength]] internal slot.

    let len = O.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 22.2.3.26 Runtime Semantics: SortCompare( x, y )#

    let SortCompare = (x, y) => {
      // 1. Assert: Both Type(x) and Type(y) is Number.
      (0, _invariant.default)(x instanceof _index.NumberValue);
      (0, _invariant.default)(y instanceof _index.NumberValue); // 2. If the argument comparefn is not undefined, then

      if (!comparefn.mightBeUndefined()) {
        // a. Let v be ? Call(comparefn, undefined,  x, y ).
        let v = (0, _call.Call)(realm, comparefn, realm.intrinsics.undefined, [x, y]); // b. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.

        if ((0, _is.IsDetachedBuffer)(realm, buffer) === true) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "array buffer has been detached"); // c. If v is NaN, return +0.

        if (v instanceof _index.NumberValue && isNaN(v.value)) return realm.intrinsics.zero; // d. Return v.

        return v;
      }

      comparefn.throwIfNotConcrete(); // If x and y are both NaN, return +0.
      // If x is NaN, return 1.

      if (isNaN(x.value)) {
        if (isNaN(y.value)) return realm.intrinsics.zero;
        return new _index.NumberValue(realm, 1);
      } // If y is NaN, return -1.


      if (isNaN(y.value)) return new _index.NumberValue(realm, -1); // If x < y, return -1.

      if (x.value < y.value) return new _index.NumberValue(realm, -1); // If x > y, return 1.

      if (x.value > y.value) return new _index.NumberValue(realm, +1); // If x is -0 and y is +0, return -1.

      if (Object.is(x.value, -0) && Object.is(y.value, +0)) return new _index.NumberValue(realm, -1); // If x is +0 and y is -0, return 1.

      if (Object.is(x.value, +0) && Object.is(y.value, -0)) return new _index.NumberValue(realm, 1); // Return +0.

      return realm.intrinsics.zero;
    }; //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:
    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.
    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and
    // transfering back the value inside the our array.
    // We need to adapt the comparefn function to match the expected types


    let comparefn_ = (x, y) => {
      (0, _invariant.default)(x instanceof _index.NumberValue, "Unexpected type");
      (0, _invariant.default)(y instanceof _index.NumberValue, "Unexpected type");
      let result_ = SortCompare(x, y);

      let numb = _singletons.To.ToNumber(realm, result_);

      return numb;
    };

    let arr = [];

    for (let j = 0; j < len; j++) {
      let val = (0, _typedarray.IntegerIndexedElementGet)(realm, O.throwIfNotConcreteObject(), j);
      arr[j] = val;
    }

    arr.sort(comparefn_); //Apply the permutation back to the original array.

    for (let j = 0; j < len; j++) {
      (0, _typedarray.IntegerIndexedElementSet)(realm, O.throwIfNotConcreteObject(), j, arr[j]);
    } // 2. Return obj;


    return context;
  }); // ECMA262 22.2.3.27

  obj.defineNativeMethod("subarray", 2, (context, [begin, end]) => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.


    if (!("$TypedArrayName" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have a [[TypedArrayName]] internal slot");
    } // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.


    (0, _invariant.default)(O.$ViewedArrayBuffer, "O has a [[ViewedArrayBuffer]] internal slot"); // 5. Let buffer be O.[[ViewedArrayBuffer]].

    let buffer = O.$ViewedArrayBuffer;
    (0, _invariant.default)(buffer); // 6. Let srcLength be O.[[ArrayLength]].

    let srcLength = O.$ArrayLength;
    (0, _invariant.default)(typeof srcLength === "number"); // 7. Let relativeBegin be ? ToInteger(begin).

    let relativeBegin = _singletons.To.ToInteger(realm, begin); // 8. If relativeBegin < 0, let beginIndex be max((srcLength + relativeBegin), 0); else let beginIndex be min(relativeBegin, srcLength).


    let beginIndex = relativeBegin < 0 ? Math.max(srcLength + relativeBegin, 0) : Math.min(relativeBegin, srcLength); // 9. If end is undefined, let relativeEnd be srcLength; else, let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? srcLength : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 10. If relativeEnd < 0, let endIndex be max((srcLength + relativeEnd), 0); else let endIndex be min(relativeEnd, srcLength).

    let endIndex = relativeEnd < 0 ? Math.max(srcLength + relativeEnd, 0) : Math.min(relativeEnd, srcLength); // 11. Let newLength be max(endIndex - beginIndex, 0).

    let newLength = Math.max(endIndex - beginIndex, 0); // 12. Let constructorName be the String value of O.[[TypedArrayName]].

    let constructorName = O.$TypedArrayName;
    (0, _invariant.default)(typeof constructorName === "string"); // 13. Let elementSize be the Number value of the Element Size value specified in Table 50 for constructorName.

    let elementSize = _typedarray.ArrayElementSize[constructorName]; // 14. Let srcByteOffset be O.[[ByteOffset]].

    let srcByteOffset = O.$ByteOffset;
    (0, _invariant.default)(typeof srcByteOffset === "number"); // 15. Let beginByteOffset be srcByteOffset + beginIndex  elementSize.

    let beginByteOffset = srcByteOffset + beginIndex * elementSize; // 16. Let argumentsList be  buffer, beginByteOffset, newLength .

    let argumentsList = [buffer, new _index.NumberValue(realm, beginByteOffset), new _index.NumberValue(realm, newLength)]; // 17. Return ? TypedArraySpeciesCreate(O, argumentsList).

    return (0, _typedarray.TypedArraySpeciesCreate)(realm, O, argumentsList);
  }); // ECMA262 22.2.3.28

  obj.defineNativeMethod("toLocaleString", 0, context => {
    // 1. Let array be ? ToObject(this value).
    let array = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(array).


    (0, _typedarray.ValidateTypedArray)(realm, array); // 3. Let len be array.[[ArrayLength]].

    let len = array.throwIfNotConcreteObject().$ArrayLength;
    (0, _invariant.default)(typeof len === "number"); // 4. Let separator be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).

    let separator = ","; // 5. If len is zero, return the empty String.

    if (len === 0) return realm.intrinsics.emptyString; // 6. Let firstElement be ? Get(array, "0").

    let firstElement = (0, _get.Get)(realm, array, "0"); // 7. If firstElement is undefined or null, then

    let R;

    if ((0, _has.HasSomeCompatibleType)(firstElement, _index.UndefinedValue, _index.NullValue)) {
      // a. Let R be the empty String.
      R = "";
    } else {
      // 8. Else,
      // a. Let R be ? ToString(? Invoke(firstElement, "toLocaleString")).
      R = _singletons.To.ToStringPartial(realm, (0, _call.Invoke)(realm, firstElement, "toLocaleString"));
    } // 9. Let k be 1.


    let k = 1; // 10. Repeat, while k < len

    while (k < len) {
      // a. Let S be a String value produced by concatenating R and separator.
      let S = R + separator; // b. Let nextElement be ? Get(array, ! ToString(k)).

      let nextElement = (0, _get.Get)(realm, array, new _index.StringValue(realm, k + "")); // c. If nextElement is undefined or null, then

      if ((0, _has.HasSomeCompatibleType)(nextElement, _index.UndefinedValue, _index.NullValue)) {
        // i. Let R be the empty String.
        R = "";
      } else {
        // d. Else,
        // i. Let R be ? ToString(? Invoke(nextElement, "toLocaleString")).
        R = _singletons.To.ToStringPartial(realm, (0, _call.Invoke)(realm, nextElement, "toLocaleString"));
      } // e. Let R be a String value produced by concatenating S and R.


      R = S + R; // f. Increase k by 1.

      k++;
    } // 11. Return R.


    return new _index.StringValue(realm, R);
  }); // ECMA262 22.2.3.29

  obj.defineNativeProperty("toString", realm.intrinsics.ArrayProto_toString); // ECMA262 22.2.3.30

  obj.defineNativeProperty("values", realm.intrinsics.TypedArrayProto_values); // ECMA262 22.2.3.31

  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.TypedArrayProto_values); // ECMA262 22.2.3.32

  obj.defineNativeGetter(realm.intrinsics.SymbolToStringTag, context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, return undefined.

    if (!(O instanceof _index.ObjectValue)) return realm.intrinsics.undefined; // 3. If O does not have a [[TypedArrayName]] internal slot, return undefined.

    if (!("$TypedArrayName" in O)) return realm.intrinsics.undefined; // 4. Let name be O.[[TypedArrayName]].

    let name = O.$TypedArrayName; // 5. Assert: name is a String value.

    (0, _invariant.default)(typeof name === "string", "name is a String value"); // 6. Return name.

    return new _index.StringValue(realm, name);
  });
}

function build(realm, obj, type) {
  // ECMA262 22.2.6
  obj.$Prototype = realm.intrinsics.TypedArrayPrototype; // ECMA262 22.2.6.1

  obj.defineNativeConstant("BYTES_PER_ELEMENT", new _index.NumberValue(realm, _types.ElementSize[type]));
}
//# sourceMappingURL=TypedArrayPrototype.js.map

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Float32");
}
//# sourceMappingURL=Float32Array.js.map

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Float32");
}
//# sourceMappingURL=Float32ArrayPrototype.js.map

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Float64");
}
//# sourceMappingURL=Float64Array.js.map

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Float64");
}
//# sourceMappingURL=Float64ArrayPrototype.js.map

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Int8");
}
//# sourceMappingURL=Int8Array.js.map

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Int8");
}
//# sourceMappingURL=Int8ArrayPrototype.js.map

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Int16");
}
//# sourceMappingURL=Int16Array.js.map

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Int16");
}
//# sourceMappingURL=Int16ArrayPrototype.js.map

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Int32");
}
//# sourceMappingURL=Int32Array.js.map

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Int32");
}
//# sourceMappingURL=Int32ArrayPrototype.js.map

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let func = new _index.NativeFunctionValue(realm, "Map", "Map", 0, (context, [_iterable], argCount, NewTarget) => {
    let iterable = _iterable; // 1. If NewTarget is undefined, throw a TypeError exception.

    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, "%MapPrototype%",  [[MapData]] ).


    let map = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "MapPrototype", {
      $MapData: undefined
    }); // 3. Set map's [[MapData]] internal slot to a new empty List.


    map.$MapData = []; // 4. If iterable is not present, let iterable be undefined.

    if (iterable && realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "the map constructor doesn't take arguments");
    }

    if (!iterable) iterable = realm.intrinsics.undefined; // 5. If iterable is either undefined or null, let iter be undefined.

    let iter, adder;

    if ((0, _index2.HasSomeCompatibleType)(iterable, _index.NullValue, _index.UndefinedValue)) {
      adder = realm.intrinsics.undefined;
      iter = realm.intrinsics.undefined;
    } else {
      // 6. Else,
      // a. Let adder be ? Get(map, "set").
      adder = (0, _index2.Get)(realm, map, "set"); // b. If IsCallable(adder) is false, throw a TypeError exception.

      if (!(0, _index2.IsCallable)(realm, adder)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // c. Let iter be ? GetIterator(iterable).


      iter = (0, _index2.GetIterator)(realm, iterable);
    } // 7. If iter is undefined, return map.


    if (iter instanceof _index.UndefinedValue) return map; // 8. Repeat

    while (true) {
      // a. Let next be ? IteratorStep(iter).
      let next = (0, _index2.IteratorStep)(realm, iter); // b. If next is false, return map.

      if (!next) return map; // c. Let nextItem be ? IteratorValue(next).

      let nextItem = (0, _index2.IteratorValue)(realm, next); // d. If Type(nextItem) is not Object, then

      if (nextItem.mightNotBeObject()) {
        if (nextItem.mightBeObject()) nextItem.throwIfNotConcrete(); // i. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.

        let error = realm.createErrorThrowCompletion(realm.intrinsics.TypeError); // ii. Return ? IteratorClose(iter, error).

        throw (0, _index2.IteratorClose)(realm, iter, error);
      }

      (0, _invariant.default)(nextItem instanceof _index.ObjectValue || nextItem instanceof _index.AbstractObjectValue); // e. Let k be Get(nextItem, "0").

      let k;

      try {
        k = (0, _index2.Get)(realm, nextItem, "0");
      } catch (kCompletion) {
        if (kCompletion instanceof _completions.AbruptCompletion) {
          // f. If k is an abrupt completion, return ? IteratorClose(iter, k).
          throw (0, _index2.IteratorClose)(realm, iter, kCompletion);
        } else throw kCompletion;
      } // g. Let v be Get(nextItem, "1").


      let v;

      try {
        v = (0, _index2.Get)(realm, nextItem, "1");
      } catch (vCompletion) {
        if (vCompletion instanceof _completions.AbruptCompletion) {
          // h. If v is an abrupt completion, return ? IteratorClose(iter, v).
          throw (0, _index2.IteratorClose)(realm, iter, vCompletion);
        } else throw vCompletion;
      } // i. Let status be Call(adder, map,  k.[[Value]], v.[[Value]] ).


      let status;

      try {
        status = (0, _index2.Call)(realm, adder, map, [k, v]);
      } catch (statusCompletion) {
        if (statusCompletion instanceof _completions.AbruptCompletion) {
          // j. If status is an abrupt completion, return ? IteratorClose(iter, status).
          throw (0, _index2.IteratorClose)(realm, iter, statusCompletion);
        } else throw statusCompletion;
      }

      status;
    }

    (0, _invariant.default)(false);
  }); // ECMA262 23.1.2.2

  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });
  return func;
}
//# sourceMappingURL=Map.js.map

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm, obj) {
  // ECMA262 23.1.3.1
  obj.defineNativeMethod("clear", 0, context => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.


    if (!M.$MapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[MapData]] internal slot.


    realm.recordModifiedProperty(M.$MapData_binding);
    let entries = M.$MapData;
    (0, _invariant.default)(entries !== undefined); // 5. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,

    for (let p of entries) {
      // a. Set p.[[Key]] to empty.
      p.$Key = undefined; // b. Set p.[[Value]] to empty.

      p.$Value = undefined;
    } // 6. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 23.1.3.3

  obj.defineNativeMethod("delete", 1, (context, [key]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.


    if (!M.$MapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[MapData]] internal slot.


    realm.recordModifiedProperty(M.$MapData_binding);
    let entries = M.$MapData;
    (0, _invariant.default)(entries !== undefined); // 5. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,

    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then
      if (p.$Key !== undefined && (0, _index2.SameValueZeroPartial)(realm, p.$Key, key)) {
        // i. Set p.[[Key]] to empty.
        p.$Key = undefined; // ii. Set p.[[Value]] to empty.

        p.$Value = undefined; // iii. Return true.

        return realm.intrinsics.true;
      }
    } // 6. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.1.3.4

  obj.defineNativeMethod("entries", 0, context => {
    // 1. Let M be the this value.
    let M = context; // 2. Return ? CreateMapIterator(M, "key+value").

    return (0, _index2.CreateMapIterator)(realm, M, "key+value");
  }); // ECMA262 23.1.3.5

  obj.defineNativeMethod("forEach", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.


    if (!M.$MapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 6. Let entries be the List that is the value of M's [[MapData]] internal slot.

    let entries = M.$MapData;
    (0, _invariant.default)(entries); // 7. Repeat for each Record {[[Key]], [[Value]]} e that is an element of entries, in original key insertion order

    for (let e of entries) {
      // a. If e.[[Key]] is not empty, then
      if (e.$Key !== undefined) {
        // i. Perform ? Call(callbackfn, T,  e.[[Value]], e.[[Key]], M ).
        (0, _invariant.default)(e.$Value !== undefined);
        (0, _index2.Call)(realm, callbackfn, T, [e.$Value, e.$Key, M]);
      }
    } // 8. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 23.1.3.6

  obj.defineNativeMethod("get", 1, (context, [key]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.


    if (!M.$MapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[MapData]] internal slot.


    let entries = M.$MapData;
    (0, _invariant.default)(entries !== undefined); // 5. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,

    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return p.[[Value]].
      if (p.$Key !== undefined && (0, _index2.SameValueZeroPartial)(realm, p.$Key, key)) {
        (0, _invariant.default)(p.$Value !== undefined);
        return p.$Value;
      }
    } // 6. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 23.1.3.7

  obj.defineNativeMethod("has", 1, (context, [key]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.


    if (!M.$MapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[MapData]] internal slot.


    let entries = M.$MapData;
    (0, _invariant.default)(entries !== undefined); // 5. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,

    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, return true.
      if (p.$Key !== undefined && (0, _index2.SameValueZeroPartial)(realm, p.$Key, key)) {
        return realm.intrinsics.true;
      }
    } // 6. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.1.3.8

  obj.defineNativeMethod("keys", 0, context => {
    // 1. Let M be the this value.
    let M = context; // 2. Return ? CreateMapIterator(M, "key").

    return (0, _index2.CreateMapIterator)(realm, M, "key");
  }); // ECMA262 23.1.3.9

  obj.defineNativeMethod("set", 2, (context, [key, value]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.


    if (!M.$MapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[MapData]] internal slot.


    realm.recordModifiedProperty(M.$MapData_binding);
    let entries = M.$MapData;
    (0, _invariant.default)(entries !== undefined); // 5. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,

    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValueZero(p.[[Key]], key) is true, then
      if (p.$Key !== undefined && (0, _index2.SameValueZeroPartial)(realm, p.$Key, key)) {
        // i. Set p.[[Value]] to value.
        p.$Value = value; // ii. Return M.

        return M;
      }
    } // 6. If key is -0, let key be +0.


    key = key.throwIfNotConcrete();
    if (key instanceof _index.NumberValue && Object.is(key.value, -0)) key = realm.intrinsics.zero; // 7. Let p be the Record {[[Key]]: key, [[Value]]: value}.

    let p = {
      $Key: key,
      $Value: value
    }; // 8. Append p as the last element of entries.

    entries.push(p); // 9. Return M.

    return M;
  }); // ECMA262 23.1.3.10

  obj.$DefineOwnProperty("size", new _descriptors.PropertyDescriptor({
    configurable: true,
    get: new _index.NativeFunctionValue(realm, undefined, "get size", 0, context => {
      // 1. Let M be the this value.
      let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

      if (!(M instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // 3. If M does not have a [[MapData]] internal slot, throw a TypeError exception.


      if (!M.$MapData) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // 4. Let entries be the List that is the value of M's [[MapData]] internal slot.


      let entries = M.$MapData;
      (0, _invariant.default)(entries !== undefined); // 5. Let count be 0.

      let count = 0; // 6. For each Record {[[Key]], [[Value]]} p that is an element of entries

      for (let p of entries) {
        // a. If p.[[Key]] is not empty, set count to count+1.
        if (p.$Key !== undefined) count++;
      } // 7. Return count.


      return new _index.NumberValue(realm, count);
    })
  })); // ECMA262 23.1.3.11

  obj.defineNativeMethod("values", 0, context => {
    // 1. Let M be the this value.
    let M = context; // 2. Return ? CreateMapIterator(M, "value").

    return (0, _index2.CreateMapIterator)(realm, M, "value");
  }); // ECMA262 23.1.3.12

  let entriesPropertyDescriptor = obj.$GetOwnProperty("entries");
  (0, _invariant.default)(entriesPropertyDescriptor instanceof _descriptors.PropertyDescriptor);

  _singletons.Properties.ThrowIfMightHaveBeenDeleted(entriesPropertyDescriptor);

  obj.$DefineOwnProperty(realm.intrinsics.SymbolIterator, entriesPropertyDescriptor); // ECMA262 23.1.3.13

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Map"), {
    writable: false
  });
}
//# sourceMappingURL=MapPrototype.js.map

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm) {
  let func = new _index.NativeFunctionValue(realm, "WeakMap", "WeakMap", 0, (args, [iterable], argCount, NewTarget) => {
    // 1. If NewTarget is undefined, throw a TypeError exception.
    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, "%WeakMapPrototype%",  [[WeakMapData]] ).


    let map = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "WeakMapPrototype", {
      $WeakMapData: undefined
    }); // 3. Set map's [[WeakMapData]] internal slot to a new empty List.


    map.$WeakMapData = []; // 4. If iterable is not present, let iterable be undefined.

    if (iterable && realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "the weak map constructor doesn't take arguments");
    }

    if (!iterable) iterable = realm.intrinsics.undefined; // 5. If iterable is either undefined or null, let iter be undefined.

    let iter, adder;

    if (iterable instanceof _index.UndefinedValue || iterable instanceof _index.NullValue) {
      adder = realm.intrinsics.undefined;
      iter = realm.intrinsics.undefined;
    } else {
      // 6. Else,
      // a. Let adder be ? Get(map, "set").
      adder = (0, _index2.Get)(realm, map, "set"); // b. If IsCallable(adder) is false, throw a TypeError exception.

      if (!(0, _index2.IsCallable)(realm, adder)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // c. Let iter be ? GetIterator(iterable).


      iter = (0, _index2.GetIterator)(realm, iterable);
    } // 7. If iter is undefined, return map.


    if (iter instanceof _index.UndefinedValue) {
      return map;
    } // 8. Repeat


    while (true) {
      // a. Let next be ? IteratorStep(iter).
      let next = (0, _index2.IteratorStep)(realm, iter); // b. If next is false, return map.

      if (!next) return map; // c. Let nextItem be ? IteratorValue(next).

      let nextItem = (0, _index2.IteratorValue)(realm, next).throwIfNotConcrete(); // d. If Type(nextItem) is not Object, then

      if (!(nextItem instanceof _index.ObjectValue)) {
        // i. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.
        let error = realm.createErrorThrowCompletion(realm.intrinsics.TypeError); // ii. Return ? IteratorClose(iter, error).

        throw (0, _index2.IteratorClose)(realm, iter, error);
      } // e. Let k be Get(nextItem, "0").


      let k;

      try {
        k = (0, _index2.Get)(realm, nextItem, "0");
      } catch (kCompletion) {
        if (kCompletion instanceof _completions.AbruptCompletion) {
          // f. If k is an abrupt completion, return ? IteratorClose(iter, k).
          throw (0, _index2.IteratorClose)(realm, iter, kCompletion);
        } else throw kCompletion;
      } // g. Let v be Get(nextItem, "1").


      let v;

      try {
        v = (0, _index2.Get)(realm, nextItem, "1");
      } catch (vCompletion) {
        if (vCompletion instanceof _completions.AbruptCompletion) {
          // h. If v is an abrupt completion, return ? IteratorClose(iter, v).
          throw (0, _index2.IteratorClose)(realm, iter, vCompletion);
        } else throw vCompletion;
      } // i. Let status be Call(adder, map,  k.[[Value]], v.[[Value]] ).


      let status;

      try {
        status = (0, _index2.Call)(realm, adder, map, [k, v]);
      } catch (statusCompletion) {
        if (statusCompletion instanceof _completions.AbruptCompletion) {
          // j. If status is an abrupt completion, return ? IteratorClose(iter, status).
          throw (0, _index2.IteratorClose)(realm, iter, statusCompletion);
        } else throw statusCompletion;
      }

      status;
    }

    (0, _invariant.default)(false);
  });
  return func;
}
//# sourceMappingURL=WeakMap.js.map

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm, obj) {
  // ECMA262 23.3.3.6
  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "WeakMap"), {
    writable: false
  }); // ECMA262 23.3.3.2

  obj.defineNativeMethod("delete", 1, (context, [key]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.


    if (!M.$WeakMapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[WeakMapData]] internal slot.


    let entries = M.$WeakMapData;
    realm.recordModifiedProperty(M.$WeakMapData_binding);
    (0, _invariant.default)(entries !== undefined); // 5. If Type(key) is not Object, return false.

    key = key.throwIfNotConcrete();

    if (!(key instanceof _index.ObjectValue)) {
      return realm.intrinsics.false;
    } // 6. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,


    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then
      if (p.$Key !== undefined && (0, _index2.SameValuePartial)(realm, p.$Key, key)) {
        // i. Set p.[[Key]] to empty.
        p.$Key = undefined; // ii. Set p.[[Value]] to empty.

        p.$Value = undefined; // iii. Return true.

        return realm.intrinsics.true;
      }
    } // 7. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.3.3.3

  obj.defineNativeMethod("get", 1, (context, [key]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.


    if (!M.$WeakMapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[WeakMapData]] internal slot.


    let entries = M.$WeakMapData;
    (0, _invariant.default)(entries !== undefined); // 5. If Type(key) is not Object, return undefined.

    key = key.throwIfNotConcrete();

    if (!(key instanceof _index.ObjectValue)) {
      return realm.intrinsics.undefined;
    } // 6. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,


    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return p.[[Value]].
      if (p.$Key !== undefined && (0, _index2.SameValuePartial)(realm, p.$Key, key)) {
        (0, _invariant.default)(p.$Value !== undefined);
        return p.$Value;
      }
    } // 7. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 23.3.3.4

  obj.defineNativeMethod("has", 1, (context, [key]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.


    if (!M.$WeakMapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[WeakMapData]] internal slot.


    let entries = M.$WeakMapData;
    (0, _invariant.default)(entries !== undefined); // 5. If Type(key) is not Object, return false.

    key = key.throwIfNotConcrete();

    if (!(key instanceof _index.ObjectValue)) {
      return realm.intrinsics.false;
    } // 6. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,


    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, return true.
      if (p.$Key !== undefined && (0, _index2.SameValuePartial)(realm, p.$Key, key)) return realm.intrinsics.true;
    } // 7. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.3.3.5

  obj.defineNativeMethod("set", 2, (context, [key, value]) => {
    // 1. Let M be the this value.
    let M = context.throwIfNotConcrete(); // 2. If Type(M) is not Object, throw a TypeError exception.

    if (!(M instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If M does not have a [[WeakMapData]] internal slot, throw a TypeError exception.


    if (!M.$WeakMapData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of M's [[WeakMapData]] internal slot.


    realm.recordModifiedProperty(M.$WeakMapData_binding);
    let entries = M.$WeakMapData;
    (0, _invariant.default)(entries !== undefined); // 5. If Type(key) is not Object, throw a TypeError exception.

    key = key.throwIfNotConcrete();

    if (!(key instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 6. Repeat for each Record {[[Key]], [[Value]]} p that is an element of entries,


    for (let p of entries) {
      // a. If p.[[Key]] is not empty and SameValue(p.[[Key]], key) is true, then
      if (p.$Key !== undefined && (0, _index2.SameValuePartial)(realm, p.$Key, key)) {
        // i. Set p.[[Value]] to value.
        p.$Value = value; // ii. Return M.

        return M;
      }
    } // 7. Let p be the Record {[[Key]]: key, [[Value]]: value}.


    let p = {
      $Key: key,
      $Value: value
    }; // 8. Append p as the last element of entries.

    entries.push(p); // 9. Return M.

    return M;
  });
}
//# sourceMappingURL=WeakMapPrototype.js.map

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _errors = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 23.2.1.1
  let func = new _index.NativeFunctionValue(realm, "Set", "Set", 0, (context, [_iterable], argCount, NewTarget) => {
    let iterable = _iterable; // 1. If NewTarget is undefined, throw a TypeError exception.

    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let set be ? OrdinaryCreateFromConstructor(NewTarget, "%SetPrototype%",  [[SetData]] ).


    let set = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "SetPrototype", {
      $SetData: undefined
    }); // 3. Set set's [[SetData]] internal slot to a new empty List.


    set.$SetData = []; // 4. If iterable is not present, let iterable be undefined.

    if (iterable && realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) {
      let loc = realm.currentLocation;
      let error = new _errors.CompilerDiagnostic("This version of JSC ignores the argument to Set, require the polyfill before doing this", loc, "PP0001", "RecoverableError");
      realm.handleError(error);
    }

    if (!iterable) iterable = realm.intrinsics.undefined; // 5. If iterable is either undefined or null, let iter be undefined.

    let iter, adder;

    if ((0, _index2.HasSomeCompatibleType)(iterable, _index.UndefinedValue, _index.NullValue)) {
      adder = realm.intrinsics.undefined;
      iter = realm.intrinsics.undefined;
    } else {
      // 6. Else,
      // a. Let adder be ? Get(set, "add").
      adder = (0, _index2.Get)(realm, set, "add"); // b. If IsCallable(adder) is false, throw a TypeError exception.

      if (!(0, _index2.IsCallable)(realm, adder)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // c. Let iter be ? GetIterator(iterable).


      iter = (0, _index2.GetIterator)(realm, iterable);
    } // 7. If iter is undefined, return set.


    if (iter instanceof _index.UndefinedValue) {
      return set;
    } // 8. Repeat


    while (true) {
      // a. Let next be ? IteratorStep(iter).
      let next = (0, _index2.IteratorStep)(realm, iter); // b. If next is false, return set.

      if (!next) return set; // c. Let nextValue be ? IteratorValue(next).

      let nextValue = (0, _index2.IteratorValue)(realm, next); // d. Let status be Call(adder, set,  nextValue.[[Value]] ).

      try {
        (0, _index2.Call)(realm, adder, set, [nextValue]);
      } catch (status) {
        if (status instanceof _completions.AbruptCompletion) {
          // e. If status is an abrupt completion, return ? IteratorClose(iter, status).
          throw (0, _index2.IteratorClose)(realm, iter, status);
        } else throw status;
      }
    }

    (0, _invariant.default)(false);
  }); // ECMA262 23.2.2.2

  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });
  return func;
}
//# sourceMappingURL=Set.js.map

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm, obj) {
  // ECMA262 23.2.3.1
  obj.defineNativeMethod("add", 1, (context, [value]) => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.


    if (!S.$SetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of S's [[SetData]] internal slot.


    realm.recordModifiedProperty(S.$SetData_binding);
    let entries = S.$SetData;
    (0, _invariant.default)(entries !== undefined); // 5. Repeat for each e that is an element of entries,

    for (let e of entries) {
      // a. If e is not empty and SameValueZero(e, value) is true, then
      if (e && (0, _index2.SameValueZeroPartial)(realm, e, value)) {
        // i. Return S.
        return S;
      }
    } // 6. If value is -0, let value be +0.


    value = value.throwIfNotConcrete();

    if (value instanceof _index.NumberValue && Object.is(value.value, -0)) {
      value = realm.intrinsics.zero;
    } // 7. Append value as the last element of entries.


    entries.push(value); // 8. Return S.

    return S;
  }); // ECMA262 23.2.3.2

  obj.defineNativeMethod("clear", 0, context => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.


    if (!S.$SetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // All of these steps can be replace with just reseting [[SetData]]
    // 4. Let entries be the List that is the value of S's [[SetData]] internal slot.
    // 5. Repeat for each e that is an element of entries,
    // 5.a Replace the element of entries whose value is e with an element whose value is empty.


    realm.recordModifiedProperty(S.$SetData_binding);
    S.$SetData = []; // 6. Return undefined.

    return realm.intrinsics.undefined;
  }); // ECMA262 23.2.3.4

  obj.defineNativeMethod("delete", 1, (context, [value]) => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.


    if (!S.$SetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of S's [[SetData]] internal slot.


    realm.recordModifiedProperty(S.$SetData_binding);
    let entries = S.$SetData;
    (0, _invariant.default)(entries !== undefined); // 5. Repeat for each e that is an element of entries,

    for (let i = 0; i < entries.length; i++) {
      let e = entries[i]; // a. If e is not empty and SameValueZero(e, value) is true, then

      if (e !== undefined && (0, _index2.SameValueZeroPartial)(realm, e, value)) {
        // i. Replace the element of entries whose value is e with an element whose value is empty.
        entries[i] = undefined; // ii. Return true.

        return realm.intrinsics.true;
      }
    } // 6. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.2.3.5

  obj.defineNativeMethod("entries", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateSetIterator(S, "key+value").

    return (0, _index2.CreateSetIterator)(realm, S, "key+value");
  }); // ECMA262 23.2.3.6

  obj.defineNativeMethod("forEach", 1, (context, [callbackfn, thisArg]) => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.


    if (!S.$SetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, callbackfn)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.


    let T = thisArg || realm.intrinsics.undefined; // 6. Let entries be the List that is the value of S's [[SetData]] internal slot.

    let entries = S.$SetData;
    (0, _invariant.default)(entries); // 7. Repeat for each e that is an element of entries, in original insertion order

    for (let e of entries) {
      // a. If e is not empty, then
      if (e) {
        // i. Perform ? Call(callbackfn, T,  e, e, S ).
        (0, _index2.Call)(realm, callbackfn, T, [e, e, S]);
      }
    } // 8. Return undefined.


    return realm.intrinsics.undefined;
  }); // ECMA262 23.2.3.7

  obj.defineNativeMethod("has", 1, (context, [value]) => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.


    if (!S.$SetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let entries be the List that is the value of S's [[SetData]] internal slot.


    let entries = S.$SetData; // 5. Repeat for each e that is an element of entries,

    for (let e of entries) {
      // a. If e is not empty and SameValueZero(e, value) is true, return true.
      if (e && (0, _index2.SameValueZeroPartial)(realm, e, value)) return realm.intrinsics.true;
    } // 6. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.2.3.9 get Set.prototype.size

  obj.$DefineOwnProperty("size", new _descriptors.PropertyDescriptor({
    get: new _index.NativeFunctionValue(realm, undefined, "get size", 0, context => {
      // 1. Let S be the this value.
      let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

      if (!(S instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // 3. If S does not have a [[SetData]] internal slot, throw a TypeError exception.


      if (!S.$SetData) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // 4. Let entries be the List that is the value of S's [[SetData]] internal slot.


      let entries = S.$SetData; // 5. Let count be 0.

      let count = 0; // 6. For each e that is an element of entries

      for (let e of entries) {
        // a. If e is not empty, set count to count+1.
        if (e) count++;
      } // 7. Return count.


      return new _index.NumberValue(realm, count);
    }),
    configurable: true
  })); // ECMA262 23.2.3.10

  obj.defineNativeMethod("values", 0, context => {
    // 1. Let S be the this value.
    let S = context; // 2. Return ? CreateSetIterator(S, "value").

    return (0, _index2.CreateSetIterator)(realm, S, "value");
  }); // ECMA262 23.2.3.8

  let valuesPropertyDescriptor = obj.$GetOwnProperty("values");
  (0, _invariant.default)(valuesPropertyDescriptor instanceof _descriptors.PropertyDescriptor);

  _singletons.Properties.ThrowIfMightHaveBeenDeleted(valuesPropertyDescriptor);

  obj.$DefineOwnProperty("keys", valuesPropertyDescriptor); // ECMA262 23.2.3.11

  obj.$DefineOwnProperty(realm.intrinsics.SymbolIterator, valuesPropertyDescriptor); // ECMA262 23.2.3.12 Set.prototype [ @@toStringTag ]

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Set"), {
    writable: false
  });
}
//# sourceMappingURL=SetPrototype.js.map

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _promise = __webpack_require__(277);

var _index2 = __webpack_require__(232);

var _iterator = __webpack_require__(272);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 25.4.3.1
  let func = new _index.NativeFunctionValue(realm, "Promise", "Promise", 1, (context, [executor], argCount, NewTarget) => {
    // 1. If NewTarget is undefined, throw a TypeError exception.
    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. If IsCallable(executor) is false, throw a TypeError exception.


    if (!(0, _index2.IsCallable)(realm, executor)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Let promise be ? OrdinaryCreateFromConstructor(NewTarget, "%PromisePrototype%",  [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] ).


    let promise = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "PromisePrototype", {
      $PromiseState: undefined,
      $PromiseResult: undefined,
      $PromiseFulfillReactions: undefined,
      $PromiseRejectReactions: undefined,
      $PromiseIsHandled: undefined
    }); // 4. Set promise's [[PromiseState]] internal slot to "pending".


    promise.$PromiseState = "pending"; // 5. Set promise's [[PromiseFulfillReactions]] internal slot to a new empty List.

    promise.$PromiseFulfillReactions = []; // 6. Set promise's [[PromiseRejectReactions]] internal slot to a new empty List.

    promise.$PromiseRejectReactions = []; // 7. Set promise's [[PromiseIsHandled]] internal slot to false.

    promise.$PromiseIsHandled = false; // 8. Let resolvingFunctions be CreateResolvingFunctions(promise).

    let resolvingFunctions = (0, _promise.CreateResolvingFunctions)(realm, promise); // 9. Let completion be Call(executor, undefined,  resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] ).

    let completion;

    try {
      completion = (0, _index2.Call)(realm, executor, realm.intrinsics.undefined, [resolvingFunctions.resolve, resolvingFunctions.reject]);
    } catch (err) {
      if (err instanceof _completions.AbruptCompletion) {
        completion = err;
      } else {
        throw err;
      }
    } // 10. If completion is an abrupt completion, then


    if (completion instanceof _completions.AbruptCompletion) {
      // a. Perform ? Call(resolvingFunctions.[[Reject]], undefined,  completion.[[Value]] ).
      (0, _index2.Call)(realm, resolvingFunctions.reject, realm.intrinsics.undefined, [completion.value]);
    } // 11. Return promise.


    return promise;
  }); // ECMA262 25.4.4.1

  func.defineNativeMethod("all", 1, (context, [iterable]) => {
    // 1. Let C be the this value.
    let C = context.throwIfNotConcrete(); // 2. If Type(C) is not Object, throw a TypeError exception.

    if (!(C instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Let promiseCapability be ? NewPromiseCapability(C).


    let promiseCapability = (0, _promise.NewPromiseCapability)(realm, C); // 4. Let iterator be GetIterator(iterable).

    let iterator;

    try {
      iterator = (0, _index2.GetIterator)(realm, iterable);
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) {
        // 5. IfAbruptRejectPromise(iterator, promiseCapability).
        (0, _index2.Call)(realm, promiseCapability.reject, realm.intrinsics.undefined, [e.value]);
        return promiseCapability.promise;
      } else throw e;
    } // 6. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.


    let iteratorRecord = {
      $Iterator: iterator,
      $Done: false
    }; // 7. Let result be PerformPromiseAll(iteratorRecord, C, promiseCapability).

    let result;

    try {
      (0, _invariant.default)(C instanceof _index.FunctionValue);
      result = (0, _promise.PerformPromiseAll)(realm, iteratorRecord, C, promiseCapability);
    } catch (e) {
      // 8. If result is an abrupt completion, then
      if (e instanceof _completions.AbruptCompletion) {
        // a. If iteratorRecord.[[Done]] is false, let result be IteratorClose(iterator, result).
        if (iteratorRecord.$Done === false) {
          try {
            result = (0, _iterator.IteratorClose)(realm, iterator, e).value;
          } catch (resultCompletion) {
            if (resultCompletion instanceof _completions.AbruptCompletion) {
              result = resultCompletion.value;
            } else throw resultCompletion;
          }
        } else {
          result = e.value;
        } // b. IfAbruptRejectPromise(result, promiseCapability).


        (0, _index2.Call)(realm, promiseCapability.reject, realm.intrinsics.undefined, [result]);
        return promiseCapability.promise;
      } else throw e;
    } // 9. Return Completion(result).


    return result;
  }); // ECMA262 25.4.4.3

  func.defineNativeMethod("race", 1, (context, [iterable]) => {
    // 1. Let C be the this value.
    let C = context.throwIfNotConcrete(); // 2. If Type(C) is not Object, throw a TypeError exception.

    if (!(C instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Let promiseCapability be ? NewPromiseCapability(C).


    let promiseCapability = (0, _promise.NewPromiseCapability)(realm, C); // 4. Let iterator be GetIterator(iterable).

    let iterator;

    try {
      iterator = (0, _index2.GetIterator)(realm, iterable);
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) {
        // 5. IfAbruptRejectPromise(iterator, promiseCapability).
        (0, _index2.Call)(realm, promiseCapability.reject, realm.intrinsics.undefined, [e.value]);
        return promiseCapability.promise;
      } else throw e;
    } // 6. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.


    let iteratorRecord = {
      $Iterator: iterator,
      $Done: false
    }; // 7. Let result be PerformPromiseRace(iteratorRecord, promiseCapability, C).

    let result;

    try {
      result = (0, _promise.PerformPromiseRace)(realm, iteratorRecord, promiseCapability, C);
    } catch (e) {
      // 8. If result is an abrupt completion, then
      if (e instanceof _completions.AbruptCompletion) {
        // a. If iteratorRecord.[[Done]] is false, let result be IteratorClose(iterator, result).
        if (iteratorRecord.$Done === false) {
          try {
            result = (0, _iterator.IteratorClose)(realm, iterator, e).value;
          } catch (resultCompletion) {
            if (resultCompletion instanceof _completions.AbruptCompletion) {
              result = resultCompletion.value;
            } else throw resultCompletion;
          }
        } else {
          result = e.value;
        } // b. IfAbruptRejectPromise(result, promiseCapability).


        (0, _index2.Call)(realm, promiseCapability.reject, realm.intrinsics.undefined, [result]);
        return promiseCapability.promise;
      } else throw e;
    } // 9. Return Completion(result).


    return result;
  }); // ECMA262 25.4.4.4

  func.defineNativeMethod("reject", 1, (context, [r]) => {
    // 1. Let C be the this value.
    let C = context.throwIfNotConcrete(); // 2. If Type(C) is not Object, throw a TypeError exception.

    if (!(C instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Let promiseCapability be ? NewPromiseCapability(C).


    let promiseCapability = (0, _promise.NewPromiseCapability)(realm, C); // 4. Perform ? Call(promiseCapability.[[Reject]], undefined,  r ).

    (0, _index2.Call)(realm, promiseCapability.reject, realm.intrinsics.undefined, [r]); // 5. Return promiseCapability.[[Promise]].

    return promiseCapability.promise;
  }); // ECMA262 25.4.4.5

  func.defineNativeMethod("resolve", 1, (context, [x]) => {
    // 1. Let C be the this value.
    let C = context.throwIfNotConcrete(); // 2. If Type(C) is not Object, throw a TypeError exception.

    if (!(C instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. If IsPromise(x) is true, then


    if ((0, _index2.IsPromise)(realm, x)) {
      (0, _invariant.default)(x instanceof _index.ObjectValue); // a. Let xConstructor be ? Get(x, "constructor").

      let xConstructor = (0, _index2.Get)(realm, x, "constructor"); // b. If SameValue(xConstructor, C) is true, return x.

      if ((0, _index2.SameValuePartial)(realm, xConstructor, C)) return x;
    } // 4. Let promiseCapability be ? NewPromiseCapability(C).


    let promiseCapability = (0, _promise.NewPromiseCapability)(realm, C); // 5. Perform ? Call(promiseCapability.[[Resolve]], undefined,  x ).

    (0, _index2.Call)(realm, promiseCapability.resolve, realm.intrinsics.undefined, [x]); // 6. Return promiseCapability.[[Promise]].

    return promiseCapability.promise;
  }); // ECMA262 25.4.4.6

  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });
  return func;
}
//# sourceMappingURL=Promise.js.map

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _promise = __webpack_require__(277);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 25.4.5.1
  obj.defineNativeMethod("catch", 1, (context, [onRejected]) => {
    // 1. Let promise be the this value.
    let promise = context; // 2. Return ? Invoke(promise, "then",  undefined, onRejected ).

    return (0, _index2.Invoke)(realm, promise, "then", [realm.intrinsics.undefined, onRejected]);
  }); // ECMA262 25.4.5.3

  obj.defineNativeMethod("then", 2, (context, [onFulfilled, onRejected]) => {
    // 1. Let promise be the this value.
    let promise = context; // 2. If IsPromise(promise) is false, throw a TypeError exception.

    if (!(0, _index2.IsPromise)(realm, promise)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    (0, _invariant.default)(promise instanceof _index.ObjectValue); // 3. Let C be ? SpeciesConstructor(promise, %Promise%).

    let C = (0, _index2.SpeciesConstructor)(realm, promise, realm.intrinsics.Promise); // 4. Let resultCapability be ? NewPromiseCapability(C).

    let resultCapability = (0, _promise.NewPromiseCapability)(realm, C); // 5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).

    return (0, _promise.PerformPromiseThen)(realm, promise, onFulfilled, onRejected, resultCapability);
  }); // ECMA262 25.4.5.4 Promise.prototype [ @@toStringTag ]

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Promise"), {
    writable: false
  });
}
//# sourceMappingURL=PromisePrototype.js.map

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Uint8");
}
//# sourceMappingURL=Uint8Array.js.map

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Uint8");
}
//# sourceMappingURL=Uint8ArrayPrototype.js.map

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Uint8Clamped");
}
//# sourceMappingURL=Uint8ClampedArray.js.map

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Uint8Clamped");
}
//# sourceMappingURL=Uint8ClampedArrayPrototype.js.map

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Uint16");
}
//# sourceMappingURL=Uint16Array.js.map

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Uint16");
}
//# sourceMappingURL=Uint16ArrayPrototype.js.map

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _TypedArray = __webpack_require__(501);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _TypedArray.build)(realm, "Uint32");
}
//# sourceMappingURL=Uint32Array.js.map

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _TypedArrayPrototype = __webpack_require__(502);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  (0, _TypedArrayPrototype.build)(realm, obj, "Uint32");
}
//# sourceMappingURL=Uint32ArrayPrototype.js.map

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm) {
  // ECMA262 23.4.1.1
  let func = new _index.NativeFunctionValue(realm, "WeakSet", "WeakSet", 0, (args, [iterable], argCount, NewTarget) => {
    // 1. If NewTarget is undefined, throw a TypeError exception.
    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let set be ? OrdinaryCreateFromConstructor(NewTarget, "%WeakSetPrototype%",  [[WeakSetData]] ).


    let set = _singletons.Create.OrdinaryCreateFromConstructor(realm, NewTarget, "WeakSetPrototype", {
      $WeakSetData: undefined
    }); // 3. Set set.[[WeakSetData]] to a new empty List.


    set.$WeakSetData = []; // 4. If iterable is not present, let iterable be undefined.

    if (iterable === undefined) iterable = realm.intrinsics.undefined;
    let iter, adder; // 5. If iterable is either undefined or null, let iter be undefined.

    if (iterable instanceof _index.UndefinedValue || iterable instanceof _index.NullValue) {
      iter = realm.intrinsics.undefined;
      adder = realm.intrinsics.undefined;
    } else {
      // 6. Else,
      // a. Let adder be ? Get(set, "add").
      adder = (0, _index2.Get)(realm, set, "add"); // b. If IsCallable(adder) is false, throw a TypeError exception.

      if (!(0, _index2.IsCallable)(realm, adder)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsCallable(adder) is false");
      } // c. Let iter be ? GetIterator(iterable).


      iter = (0, _index2.GetIterator)(realm, iterable);
    } // 7. If iter is undefined, return set.


    if (iter instanceof _index.UndefinedValue) return set; // 8. Repeat

    while (true) {
      // a. Let next be ? IteratorStep(iter).
      let next = (0, _index2.IteratorStep)(realm, iter); // b. If next is false, return set.

      if (next === false) return set; // c. Let nextValue be ? IteratorValue(next).

      let nextValue = (0, _index2.IteratorValue)(realm, next); // d. Let status be Call(adder, set,  nextValue ).

      try {
        (0, _index2.Call)(realm, adder, set, [nextValue]);
      } catch (statusCompletion) {
        if (!(statusCompletion instanceof _completions.AbruptCompletion)) throw statusCompletion; // e. If status is an abrupt completion, return ? IteratorClose(iter, status).

        throw (0, _index2.IteratorClose)(realm, iter, statusCompletion);
      }
    }

    (0, _invariant.default)(false);
  });
  return func;
}
//# sourceMappingURL=WeakSet.js.map

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm, obj) {
  // ECMA262 23.4.3.1
  obj.defineNativeMethod("add", 1, (context, [value]) => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(S) is not Object");
    } // 3. If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception.


    if (!S.$WeakSetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "S does not have a [[WeakSetData]] internal slot");
    } // 4. If Type(value) is not Object, throw a TypeError exception.


    value = value.throwIfNotConcrete();

    if (!(value instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(value) is not Object");
    } // 5. Let entries be the List that is S.[[WeakSetData]].


    realm.recordModifiedProperty(S.$WeakSetData_binding);
    let entries = S.$WeakSetData;
    (0, _invariant.default)(entries != null); // 6. Repeat for each e that is an element of entries,

    for (let e of entries) {
      // a. If e is not empty and SameValue(e, value) is true, then
      if (e !== undefined && (0, _index2.SameValuePartial)(realm, e, value) === true) {
        // i. Return S.
        return S;
      }
    } // 7. Append value as the last element of entries.


    entries.push(value); // 8. Return S.

    return S;
  }); // ECMA262 23.4.3.3

  obj.defineNativeMethod("delete", 1, (context, [value]) => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(S) is not Object");
    } // 3. If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception.


    if (!S.$WeakSetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "S does not have a [[WeakSetData]] internal slot");
    } // 4. If Type(value) is not Object, throw a TypeError exception.


    value = value.throwIfNotConcrete();
    if (!(value instanceof _index.ObjectValue)) return realm.intrinsics.false; // 5. Let entries be the List that is S.[[WeakSetData]].

    realm.recordModifiedProperty(S.$WeakSetData_binding);
    let entries = S.$WeakSetData;
    (0, _invariant.default)(entries != null); // 6. Repeat for each e that is an element of entries,

    for (let i = 0; i < entries.length; ++i) {
      let e = entries[i]; // a. If e is not empty and SameValue(e, value) is true, then

      if (e !== undefined && (0, _index2.SameValuePartial)(realm, e, value) === true) {
        // i. Replace the element of entries whose value is e with an element whose value is empty.
        entries[i] = undefined; // ii. Return true.

        return realm.intrinsics.true;
      }
    } // 7. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.4.3.3

  obj.defineNativeMethod("has", 1, (context, [value]) => {
    // 1. Let S be the this value.
    let S = context.throwIfNotConcrete(); // 2. If Type(S) is not Object, throw a TypeError exception.

    if (!(S instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(S) is not Object");
    } // 3. If S does not have a [[WeakSetData]] internal slot, throw a TypeError exception.


    if (!S.$WeakSetData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "S does not have a [[WeakSetData]] internal slot");
    } // 4. Let entries be the List that is S.[[WeakSetData]].


    let entries = S.$WeakSetData; // 5. If Type(value) is not Object, return false.

    value = value.throwIfNotConcrete();
    if (!(value instanceof _index.ObjectValue)) return realm.intrinsics.false; // 6. Repeat for each e that is an element of entries,

    for (let e of entries) {
      // a. If e is not empty and SameValue(e, value) is true, return true.
      if (e !== undefined && (0, _index2.SameValuePartial)(realm, e, value) === true) return realm.intrinsics.true;
    } // 7. Return false.


    return realm.intrinsics.false;
  }); // ECMA262 23.4.3.5

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "WeakSet"), {
    writable: false
  });
}
//# sourceMappingURL=WeakSetPrototype.js.map

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _arraybuffer = __webpack_require__(278);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 24.1.2.1
  let func = new _index.NativeFunctionValue(realm, "ArrayBuffer", "ArrayBuffer", 1, (context, [length], argCount, NewTarget) => {
    // 1. If NewTarget is undefined, throw a TypeError exception.
    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let byteLength be ToIndex(numberLength).


    let byteLength = _singletons.To.ToIndexPartial(realm, length); // 3. Return ? AllocateArrayBuffer(NewTarget, byteLength).


    return (0, _arraybuffer.AllocateArrayBuffer)(realm, NewTarget, byteLength);
  }); // ECMA262 24.1.3.1

  func.defineNativeMethod("isView", 1, (context, [_arg]) => {
    let arg = _arg; // 1. If Type(arg) is not Object, return false.

    if (!arg.mightBeObject()) return realm.intrinsics.false; // 2. If arg has a [[ViewedArrayBuffer]] internal slot, return true.

    arg = arg.throwIfNotConcreteObject();
    if ("$ViewedArrayBuffer" in arg) return realm.intrinsics.true; // 3. Return false.

    return realm.intrinsics.false;
  }); // ECMA262 24.1.3.3

  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });
  return func;
}
//# sourceMappingURL=ArrayBuffer.js.map

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 24.1.4.1
  obj.defineNativeGetter("byteLength", context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.


    if (!("$ArrayBufferData" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have an [[ArrayBufferData]] internal slot");
    } // 4. If IsDetachedBuffer(O) is true, throw a TypeError exception.


    if ((0, _index2.IsDetachedBuffer)(realm, O) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(O) is true");
    } // 5. Let length be O.[[ArrayBufferByteLength]].


    let length = O.$ArrayBufferByteLength;
    (0, _invariant.default)(typeof length === "number"); // 6. Return length.

    return new _index.NumberValue(realm, length);
  }); // ECMA262 24.1.4.3

  obj.defineNativeMethod("slice", 2, (context, [start, end]) => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.


    if (!("$ArrayBufferData" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "O does not have an [[ArrayBufferData]] internal slot");
    } // 4. If IsDetachedBuffer(O) is true, throw a TypeError exception.


    if ((0, _index2.IsDetachedBuffer)(realm, O) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(O) is true");
    } // 5. Let len be O.[[ArrayBufferByteLength]].


    let len = O.$ArrayBufferByteLength;
    (0, _invariant.default)(typeof len === "number"); // 6. Let relativeStart be ? ToInteger(start).

    let relativeStart = _singletons.To.ToInteger(realm, start); // 7. If relativeStart < 0, let first be max((len + relativeStart), 0); else let first be min(relativeStart, len).


    let first = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len); // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).

    let relativeEnd = !end || end instanceof _index.UndefinedValue ? len : _singletons.To.ToInteger(realm, end.throwIfNotConcrete()); // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).

    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len); // 10. Let newLen be max(final-first, 0).

    let newLen = Math.max(final - first, 0); // 11. Let ctor be ? SpeciesConstructor(O, %ArrayBuffer%).

    let ctor = (0, _index2.SpeciesConstructor)(realm, O, realm.intrinsics.ArrayBuffer); // 12. Let New be ? Construct(ctor,  newLen ).

    let New = (0, _index2.Construct)(realm, ctor, [new _index.NumberValue(realm, newLen)]).throwIfNotConcreteObject(); // 13. If New does not have an [[ArrayBufferData]] internal slot, throw a TypeError exception.

    if (!("$ArrayBufferData" in New)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "new does not have an [[ArrayBufferData]] internal slot");
    } // 14. If IsDetachedBuffer(New) is true, throw a TypeError exception.


    if ((0, _index2.IsDetachedBuffer)(realm, New) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(new) is true");
    } // 15. If SameValue(New, O) is true, throw a TypeError exception.


    if ((0, _index2.SameValue)(realm, New, O) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "SameValue(new, O) is true");
    } // 16. If new.[[ArrayBufferByteLength]] < newLen, throw a TypeError exception.


    if (typeof New.$ArrayBufferByteLength !== "number" || New.$ArrayBufferByteLength < newLen) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "new.[[ArrayBufferByteLength]] < newLen");
    } // 17. NOTE: Side-effects of the above steps may have detached O.
    // 18. If IsDetachedBuffer(O) is true, throw a TypeError exception.


    if ((0, _index2.IsDetachedBuffer)(realm, O) === true) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "IsDetachedBuffer(O) is true");
    } // 19. Let fromBuf be O.[[ArrayBufferData]].


    let fromBuf = O.$ArrayBufferData;
    (0, _invariant.default)(fromBuf); // 20. Let toBuf be New.[[ArrayBufferData]].

    let toBuf = New.$ArrayBufferData;
    (0, _invariant.default)(toBuf); // 21. Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen).

    (0, _index2.CopyDataBlockBytes)(realm, toBuf, 0, fromBuf, first, newLen); // 22. Return New.

    return New;
  }); // ECMA262 24.1.4.4

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "ArrayBuffer"), {
    writable: false
  });
}
//# sourceMappingURL=ArrayBufferPrototype.js.map

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _json = __webpack_require__(534);

var _index3 = __webpack_require__(15);

var _errors = __webpack_require__(3);

var _singletons = __webpack_require__(236);

var _nativeToInterp = _interopRequireDefault(__webpack_require__(535));

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function SerializeJSONArray(realm, value, context) {
  // 1. If stack contains value, throw a TypeError exception because the structure is cyclical.
  if (context.stack.indexOf(value) >= 0) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "cyclical error");
  } // 2. Append value to stack.


  context.stack.push(value); // 3. Let stepback be indent.

  let stepback = context.indent; // 4. Let indent be the concatenation of indent and gap.

  context.indent += context.gap; // 5. Let partial be a new empty List.

  let partial = []; // 6. Let len be ? ToLength(? Get(value, "length")).

  let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, value, "length")); // 7. Let index be 0.


  let index = 0; // 8. Repeat while index < len

  while (index < len) {
    // a. Let strP be ? SerializeJSONProperty(! ToString(index), value).
    let strP = SerializeJSONProperty(realm, new _index.StringValue(realm, index + ""), value, context); // b. If strP is undefined, then

    if (strP === undefined) {
      // i. Append "null" to partial.
      partial.push("null");
    } else {
      // c. Else,
      // i. Append strP to partial.
      partial.push(strP);
    } // d. Increment index by 1.


    index++;
  } // 9. If partial is empty, then


  let final = "";

  if (!partial.length) {
    // a. Let final be "[]".
    final = "[]";
  } else {
    // 10. Else,
    // a. If gap is the empty String, then
    if (!context.gap) {
      // i. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
      let properties = partial.join(","); // ii. Let final be the result of concatenating "[", properties, and "]".

      final = `[${properties}]`;
    } else {// b. Else,
      // i. Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.
      // ii. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.
      // iii. Let final be the result of concatenating "[", code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and "]".
    }
  } // 11. Remove the last element of stack.


  context.stack.pop(); // 12. Let indent be stepback.

  context.indent = stepback; // 13. Return final.

  return final;
}

function QuoteJSONString(realm, value) {
  return JSON.stringify(value.value);
}

function SerializeJSONObject(realm, value, context) {
  // 1. If stack contains value, throw a TypeError exception because the structure is cyclical.
  if (context.stack.indexOf(value) >= 0) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "cyclical error");
  } // 2. Append value to stack.


  context.stack.push(value); // 3. Let stepback be indent.

  let stepback = context.indent; // 4. Let indent be the concatenation of indent and gap.

  context.indent += context.gap; // 5. If PropertyList is not undefined, then

  let K;

  if (context.PropertyList !== undefined) {
    // a. Let K be PropertyList.
    K = context.PropertyList;
  } else {
    // 6. Else,
    // a. Let K be ? EnumerableOwnProperties(value, "key").
    K = (0, _index2.EnumerableOwnProperties)(realm, value, "key");
  } // 7. Let partial be a new empty List.


  let partial = []; // 8. For each element P of K,

  for (let P of K) {
    (0, _invariant.default)(P instanceof _index.StringValue); // a. Let strP be ? SerializeJSONProperty(P, value).

    let strP = SerializeJSONProperty(realm, P, value, context); // b. If strP is not undefined, then

    if (strP !== undefined) {
      // i. Let member be QuoteJSONString(P).
      let member = QuoteJSONString(realm, P); // ii. Let member be the concatenation of member and the string ":".

      member += ":"; // iii. If gap is not the empty String, then

      if (context.gap) {
        // 1. Let member be the concatenation of member and code unit 0x0020 (SPACE).
        member += " ";
      } // iv. Let member be the concatenation of member and strP.


      member += strP; // v. Append member to partial.

      partial.push(member);
    }
  } // 9. If partial is empty, then


  let final = "";

  if (!partial.length) {
    // a. Let final be "{}".
    final = "{}";
  } else {
    // 10. Else,
    // a. If gap is the empty String, then
    if (!context.gap) {
      // i. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
      let properties = partial.join(","); // ii. Let final be the result of concatenating "{", properties, and "}".

      final = `{${properties}}`;
    } else {// b. Else gap is not the empty String,
      // i. Let separator be the result of concatenating code unit 0x002C (COMMA), code unit 0x000A (LINE FEED), and indent.
      // ii. Let properties be a String formed by concatenating all the element Strings of partial with each adjacent pair of Strings separated with separator. The separator String is not inserted either before the first String or after the last String.
      // iii. Let final be the result of concatenating "{", code unit 0x000A (LINE FEED), indent, properties, code unit 0x000A (LINE FEED), stepback, and "}".
    }
  } // 11. Remove the last element of stack.


  context.stack.pop(); // 12. Let indent be stepback.

  context.indent = stepback; // 13. Return final.

  return final;
}

function SerializeJSONProperty(realm, key, holder, context) {
  // 1. Let value be ? Get(holder, key).
  let value = (0, _index2.Get)(realm, holder, key).throwIfNotConcrete(); // 2. If Type(value) is Object, then

  if (value instanceof _index.ObjectValue) {
    // a. Let toJSON be ? Get(value, "toJSON").
    let toJSON = (0, _index2.Get)(realm, value, "toJSON"); // b. If IsCallable(toJSON) is true, then

    if ((0, _index2.IsCallable)(realm, toJSON)) {
      // i. Let value be ? Call(toJSON, value,  key ).
      value = (0, _index2.Call)(realm, toJSON, value, [key]);
    }
  } // 3. If ReplacerFunction is not undefined, then


  if (context.ReplacerFunction) {
    // a. Let value be ? Call(ReplacerFunction, holder,  key, value ).
    value = (0, _index2.Call)(realm, context.ReplacerFunction, holder, [key, value]);
  } // 4. If Type(value) is Object, then


  if (value instanceof _index.ObjectValue) {
    // a. If value has a [[NumberData]] internal slot, then
    if (value.$NumberData) {
      // b. Let value be ? ToNumber(value).
      value = new _index.NumberValue(realm, _singletons.To.ToNumber(realm, value));
    } else if (value.$StringData) {
      // c. Else if value has a [[StringData]] internal slot, then
      // d. Let value be ? ToString(value).
      value = new _index.StringValue(realm, _singletons.To.ToString(realm, value));
    } else if (value.$BooleanData) {
      // e. Else if value has a [[BooleanData]] internal slot, then
      // f. Let value be the value of the [[BooleanData]] internal slot of value.
      value = value.$BooleanData;
    }
  } // 5. If value is null, return "null".


  if (value instanceof _index.NullValue) return "null"; // 6. If value is true, return "true".

  if (value instanceof _index.BooleanValue && value.value) return "true"; // 7. If value is false, return "false".

  if (value instanceof _index.BooleanValue && !value.value) return "false"; // 8. If Type(value) is String, return QuoteJSONString(value).

  if (value instanceof _index.StringValue) return QuoteJSONString(realm, value); // 9. If Type(value) is Number, then

  if (value instanceof _index.NumberValue) {
    // a. If value is finite, return ! ToString(value).
    if (isFinite(value.value)) {
      return _singletons.To.ToString(realm, value);
    } else {
      // b. Else, return "null".
      return "null";
    }
  } // 10. If Type(value) is Object and IsCallable(value) is false, then


  if (value instanceof _index.ObjectValue && !(0, _index2.IsCallable)(realm, value)) {
    // a. Let isArray be ? IsArray(value).
    let isArray = (0, _index2.IsArray)(realm, value); // b. If isArray is true, return ? SerializeJSONArray(value).

    if (isArray) {
      return SerializeJSONArray(realm, value, context);
    } else {
      // c. Else, return ? SerializeJSONObject(value).
      return SerializeJSONObject(realm, value, context);
    }
  } // 1. Return undefined.


  return undefined;
}

function InternalCloneObject(realm, val) {
  let clone = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);

  for (let [key, binding] of val.properties) {
    if (binding === undefined || binding.descriptor === undefined) continue; // deleted

    let desc = binding.descriptor;
    (0, _invariant.default)(desc !== undefined);

    _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc);

    let value = desc.throwIfNotConcrete(realm).value;

    if (value === undefined) {
      _index.AbstractValue.reportIntrospectionError(val, key); // cannot handle accessors


      throw new _errors.FatalError();
    }

    (0, _invariant.default)(value instanceof _index.Value);

    _singletons.Create.CreateDataProperty(realm, clone, key, InternalJSONClone(realm, value));
  }

  if (val.isPartialObject()) clone.makePartial();
  if (val.isSimpleObject()) clone.makeSimple();
  clone.isScopedTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope

  return clone;
}

const JSONStringifyStr = "global.JSON.stringify(A)";
const JSONParseStr = "global.JSON.parse(A)";

function InternalJSONClone(realm, val) {
  if (val instanceof _index.AbstractValue) {
    if (val instanceof _index.AbstractObjectValue) {
      let strVal = _index.AbstractValue.createFromTemplate(realm, JSONStringifyStr, _index.StringValue, [val]);

      let obVal = _index.AbstractValue.createFromTemplate(realm, JSONParseStr, _index.ObjectValue, [strVal]);

      obVal.values = new _index3.ValuesDomain(new Set([InternalCloneObject(realm, val.getTemplate())]));
      return obVal;
    } // TODO #1010: NaN and Infinity must be mapped to null.


    return val;
  }

  if (val instanceof _index.NumberValue && !isFinite(val.value)) {
    return realm.intrinsics.null;
  }

  if (val instanceof _index.PrimitiveValue) {
    return val;
  }

  if (val instanceof _index.ObjectValue) {
    let clonedObj;
    let isArray = (0, _index2.IsArray)(realm, val);

    if (isArray === true) {
      clonedObj = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ArrayPrototype);
      let I = 0;

      let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, val, "length"));

      while (I < len) {
        let P = _singletons.To.ToString(realm, new _index.NumberValue(realm, I));

        let newElement = (0, _index2.Get)(realm, val, P);

        if (!(newElement instanceof _index.UndefinedValue)) {
          // TODO #1011: An abstract value that ultimately yields undefined should still be skipped
          _singletons.Create.CreateDataProperty(realm, clonedObj, P, InternalJSONClone(realm, newElement));
        }

        I += 1;
      }
    } else {
      clonedObj = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);
      let keys = (0, _index2.EnumerableOwnProperties)(realm, val, "key", true);

      for (let P of keys) {
        (0, _invariant.default)(P instanceof _index.StringValue);
        let newElement = (0, _index2.Get)(realm, val, P);

        if (!(newElement instanceof _index.UndefinedValue)) {
          // TODO #1011: An abstract value that ultimately yields undefined should still be skipped
          _singletons.Create.CreateDataProperty(realm, clonedObj, P, InternalJSONClone(realm, newElement));
        }
      }
    }

    if (val.isPartialObject()) clonedObj.makePartial();
    clonedObj.makeSimple(); // The result of a JSON clone is always simple

    return clonedObj;
  }

  (0, _invariant.default)(false);
}

function _default(realm) {
  let obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "JSON"); // ECMA262 24.3.3

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "JSON"), {
    writable: false
  }); // ECMA262 24.3.2

  obj.defineNativeMethod("stringify", 3, (context, [value, _replacer, _space]) => {
    let replacer = _replacer.throwIfNotConcrete();

    let space = _space.throwIfNotConcrete(); // 1. Let stack be a new empty List.


    let stack = []; // 2. Let indent be the empty String.

    let indent = ""; // 3. Let PropertyList and ReplacerFunction be undefined.

    let PropertyList, ReplacerFunction; // 4. If Type(replacer) is Object, then

    if (replacer instanceof _index.ObjectValue) {
      // a. If IsCallable(replacer) is true, then
      if ((0, _index2.IsCallable)(realm, replacer)) {
        // i. Let ReplacerFunction be replacer.
        ReplacerFunction = replacer;
      } else {
        // b. Else,
        // i. Let isArray be ? IsArray(replacer).
        let isArray = (0, _index2.IsArray)(realm, replacer); // ii. If isArray is true, then

        if (isArray === true) {
          // i. Let PropertyList be a new empty List.
          PropertyList = []; // ii. Let len be ? ToLength(? Get(replacer, "length")).

          let len = _singletons.To.ToLength(realm, (0, _index2.Get)(realm, replacer, "length")); // iii. Let k be 0.


          let k = 0; // iv. Repeat while k<len,

          while (k < len) {
            // 1. Let v be ? Get(replacer, ! ToString(k)).
            let v = (0, _index2.Get)(realm, replacer, new _index.StringValue(realm, k + ""));
            v = v.throwIfNotConcrete(); // 2. Let item be undefined.

            let item; // 3. If Type(v) is String, let item be v.

            if (v instanceof _index.StringValue) {
              item = v;
            } else if (v instanceof _index.NumberValue) {
              // 4. Else if Type(v) is Number, let item be ! ToString(v).
              item = new _index.StringValue(realm, _singletons.To.ToString(realm, v));
            } else if (v instanceof _index.ObjectValue) {
              // 5. Else if Type(v) is Object, then
              // a. If v has a [[StringData]] or [[NumberData]] internal slot, let item be ? ToString(v).
              if (v.$StringData || v.$NumberData) {
                item = new _index.StringValue(realm, _singletons.To.ToString(realm, v));
              }
            } // 6. If item is not undefined and item is not currently an element of PropertyList, then


            if (item !== undefined && PropertyList.find(x => x.value === item.value) === undefined) {
              // a. Append item to the end of PropertyList.
              PropertyList.push(item);
            } // 7. Let k be k+1.


            k++;
          }
        }
      }
    } // 5. If Type(space) is Object, then


    if (space instanceof _index.ObjectValue) {
      // a. If space has a [[NumberData]] internal slot, then
      if (space.$NumberData) {
        // i. Let space be ? ToNumber(space).
        space = new _index.NumberValue(realm, _singletons.To.ToNumber(realm, space));
      } else if (space.$StringData) {
        // b. Else if space has a [[StringData]] internal slot, then
        // i. Let space be ? ToString(space).
        space = new _index.StringValue(realm, _singletons.To.ToString(realm, space));
      }
    }

    let gap; // 6. If Type(space) is Number, then

    if (space instanceof _index.NumberValue) {
      // a. Let space be min(10, ToInteger(space)).
      space = new _index.NumberValue(realm, Math.min(10, _singletons.To.ToInteger(realm, space))); // b. Set gap to a String containing space occurrences of code unit 0x0020 (SPACE). This will be the empty String if space is less than 1.

      gap = Array(Math.max(0, space.value)).join(" ");
    } else if (space instanceof _index.StringValue) {
      // 7. Else if Type(space) is String, then
      // a. If the number of elements in space is 10 or less, set gap to space; otherwise set gap to a String consisting of the first 10 elements of space.
      gap = space.value.length <= 10 ? space.value : space.value.substring(0, 10);
    } else {
      // 8. Else,
      // a. Set gap to the empty String.
      gap = "";
    } // 9. Let wrapper be ObjectCreate(%ObjectPrototype%).


    let wrapper = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);

    let isAbstract = value instanceof _index.AbstractValue; // #2411

    if (isAbstract && value.values.isTop()) {
      _index.AbstractValue.reportIntrospectionError(value);

      throw new _errors.FatalError();
    } // TODO #1012: Make result abstract if any nested element is an abstract value.


    if (isAbstract || value instanceof _index.ObjectValue && value.isPartialObject()) {
      // Return abstract result. This enables cloning via JSON.parse(JSON.stringify(...)).
      let clonedValue = InternalJSONClone(realm, value);

      let result = _index.AbstractValue.createTemporalFromTemplate(realm, JSONStringifyStr, _index.StringValue, [clonedValue], {
        kind: "JSON.stringify(...)"
      });

      return result;
    } // 10. Let status be CreateDataProperty(wrapper, the empty String, value).


    let status = _singletons.Create.CreateDataProperty(realm, wrapper, "", value); // 11. Assert: status is true.


    (0, _invariant.default)(status, "expected to create data property"); // 12. Return ? SerializeJSONProperty(the empty String, wrapper).

    let str = SerializeJSONProperty(realm, realm.intrinsics.emptyString, wrapper, {
      PropertyList,
      ReplacerFunction,
      stack,
      indent,
      gap
    });

    if (str === undefined) {
      return realm.intrinsics.undefined;
    } else {
      return new _index.StringValue(realm, str);
    }
  }); // ECMA262 24.3.1

  obj.defineNativeMethod("parse", 2, (context, [text, reviver]) => {
    let unfiltered;

    if (text instanceof _index.AbstractValue && text.kind === "JSON.stringify(...)") {
      // Enable cloning via JSON.parse(JSON.stringify(...)).
      // text is abstract, so we are doing abstract interpretation
      let temporalOperationEntryArgs = realm.derivedIds.get(text.intrinsicName);
      (0, _invariant.default)(temporalOperationEntryArgs !== undefined);
      let args = temporalOperationEntryArgs.args;
      (0, _invariant.default)(args[0] instanceof _index.Value); // since text.kind === "JSON.stringify(...)"

      let inputClone = args[0]; // A temporal copy of the object that was the argument to stringify
      // Clone it so that every call to parse produces a different instance from stringify's clone

      let parseResult; // A clone of inputClone, because every call to parse produces a new object

      if (inputClone instanceof _index.ObjectValue) {
        parseResult = InternalCloneObject(realm, inputClone);
      } else {
        (0, _invariant.default)(inputClone instanceof _index.AbstractObjectValue);
        parseResult = InternalCloneObject(realm, inputClone.getTemplate());
      }

      (0, _invariant.default)(parseResult.isPartialObject()); // Because stringify ensures it

      parseResult.makeSimple(); // because the result of JSON.parse is always simple
      // Force evaluation of the parse call

      unfiltered = _index.AbstractValue.createTemporalFromTemplate(realm, JSONParseStr, _index.ObjectValue, [text], {
        kind: "JSON.parse(...)"
      });
      unfiltered.values = new _index3.ValuesDomain(new Set([parseResult]));
      (0, _invariant.default)(unfiltered.intrinsicName !== undefined);
      (0, _invariant.default)(realm.generator);
      realm.rebuildNestedProperties(unfiltered, unfiltered.intrinsicName);
    } else {
      // 1. Let JText be ? ToString(text).
      let JText = _singletons.To.ToStringPartial(realm, text); // 2. Parse JText interpreted as UTF-16 encoded Unicode points (6.1.4) as a JSON text as specified in ECMA-404. Throw a SyntaxError exception if JText is not a valid JSON text as defined in that specification.
      // 3. Let scriptText be the result of concatenating "(", JText, and ");".
      // 4. Let completion be the result of parsing and evaluating scriptText as if it was the source text of an ECMAScript Script, but using the alternative definition of DoubleStringCharacter provided below. The extended PropertyDefinitionEvaluation semantics defined in B.3.1 must not be used during the evaluation.
      // 5. Let unfiltered be completion.[[Value]].


      try {
        unfiltered = (0, _nativeToInterp.default)(realm, JSON.parse(JText));
      } catch (err) {
        if (err instanceof SyntaxError) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, err.message);
        } else {
          throw err;
        }
      } // 6. Assert: unfiltered will be either a primitive value or an object that is defined by either an ArrayLiteral or an ObjectLiteral.


      (0, _invariant.default)((0, _index2.HasSomeCompatibleType)(unfiltered, _index.PrimitiveValue, _index.ObjectValue, _index.ArrayValue), "expected primitive, object or array");
    } // 7. If IsCallable(reviver) is true, then


    if ((0, _index2.IsCallable)(realm, reviver)) {
      // a. Let root be ObjectCreate(%ObjectPrototype%).
      let root = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // b. Let rootName be the empty String.


      let rootName = ""; // c. Let status be CreateDataProperty(root, rootName, unfiltered).

      let status = _singletons.Create.CreateDataProperty(realm, root, rootName, unfiltered); // d. Assert: status is true.


      (0, _invariant.default)(status, "expected to create data property"); // e. Return ? InternalizeJSONProperty(root, rootName).

      return (0, _json.InternalizeJSONProperty)(realm, reviver, root, rootName);
    } else {
      // 8. Else,
      // a. Return unfiltered.
      return unfiltered;
    }
  });
  return obj;
}
//# sourceMappingURL=JSON.js.map

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternalizeJSONProperty = InternalizeJSONProperty;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _get = __webpack_require__(230);

var _call = __webpack_require__(234);

var _is = __webpack_require__(229);

var _own = __webpack_require__(273);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 24.3.1.1
function InternalizeJSONProperty(realm, reviver, holder, name) {
  // 1. Let val be ? Get(holder, name).
  let val = (0, _get.Get)(realm, holder, name); // 2. If Type(val) is Object, then

  if (val instanceof _index.ObjectValue) {
    // a. Let isArray be ? IsArray(val).
    let isArray = (0, _is.IsArray)(realm, val); // b. If isArray is true, then

    if (isArray === true) {
      // i. Set I to 0.
      let I = 0; // ii. Let len be ? ToLength(? Get(val, "length")).

      let len = _singletons.To.ToLength(realm, (0, _get.Get)(realm, val, "length")); // iii. Repeat while I < len,


      while (I < len) {
        // 1. Let newElement be ? InternalizeJSONProperty(val, ! ToString(I)).
        let newElement = InternalizeJSONProperty(realm, reviver, val, _singletons.To.ToString(realm, new _index.NumberValue(realm, I))); // 2. If newElement is undefined, then

        if (newElement instanceof _index.UndefinedValue) {
          // a. Perform ? val.[[Delete]](! ToString(I)).
          val.$Delete(_singletons.To.ToString(realm, new _index.NumberValue(realm, I)));
        } else {
          // 3. Else,
          // a. Perform ? CreateDataProperty(val, ! ToString(I), newElement).
          _singletons.Create.CreateDataProperty(realm, val, _singletons.To.ToString(realm, new _index.NumberValue(realm, I)), newElement.throwIfNotConcrete()); // b. NOTE This algorithm intentionally does not throw an exception if CreateDataProperty returns false.

        } // 4. Add 1 to I.


        I += 1;
      }
    } else {
      // c. Else,
      // i. Let keys be ? EnumerableOwnProperties(val, "key").
      let keys = (0, _own.EnumerableOwnProperties)(realm, val, "key"); // ii. For each String P in keys do,

      for (let P of keys) {
        (0, _invariant.default)(P instanceof _index.StringValue); // 1. Let newElement be ? InternalizeJSONProperty(val, P).

        let newElement = InternalizeJSONProperty(realm, reviver, val, P); // 2. If newElement is undefined, then

        if (newElement instanceof _index.UndefinedValue) {
          // a. Perform ? val.[[Delete]](P).
          val.$Delete(P);
        } else {
          // 3. Else,
          // a. Perform ? CreateDataProperty(val, P, newElement).
          _singletons.Create.CreateDataProperty(realm, val, P, newElement); // b. NOTE This algorithm intentionally does not throw an exception if CreateDataProperty returns false.

        }
      }
    }
  } // 3. Return ? Call(reviver, holder,  name, val ).


  return (0, _call.Call)(realm, reviver, holder, [typeof name === "string" ? new _index.StringValue(realm, name) : name, val]);
}
//# sourceMappingURL=json.js.map

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = convert;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _descriptors = __webpack_require__(268);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function convert(realm, val) {
  if (typeof val === "number") {
    return new _index.NumberValue(realm, val);
  } else if (typeof val === "string") {
    return new _index.StringValue(realm, val);
  } else if (val === null) {
    return realm.intrinsics.null;
  } else if (val === undefined) {
    return realm.intrinsics.undefined;
  } else if (val === true) {
    return realm.intrinsics.true;
  } else if (val === false) {
    return realm.intrinsics.false;
  } else if (Array.isArray(val)) {
    return _singletons.Create.CreateArrayFromList(realm, val.map(item => convert(realm, item)));
  } else if (typeof val === "object") {
    let obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);

    for (let key in val) {
      obj.$DefineOwnProperty(key, new _descriptors.PropertyDescriptor({
        enumerable: true,
        writable: true,
        configurable: true,
        value: convert(realm, val[key])
      }));
    }

    return obj;
  } else {
    throw new _errors.FatalError("need to convert value of type " + typeof val);
  }
}
//# sourceMappingURL=native-to-interp.js.map

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "Reflect"); // ECMA262 26.1.1

  obj.defineNativeMethod("apply", 3, (context, [target, thisArgument, argumentsList]) => {
    // 1. If IsCallable(target) is false, throw a TypeError exception.
    if (!(0, _index2.IsCallable)(realm, target)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let args be ? CreateListFromArrayLike(argumentsList).


    let args = _singletons.Create.CreateListFromArrayLike(realm, argumentsList); // TODO #1008 3. Perform PrepareForTailCall().
    // 4. Return ? Call(target, thisArgument, args).


    return (0, _index2.Call)(realm, target, thisArgument, args);
  }); // ECMA262 26.1.2

  obj.defineNativeMethod("construct", 2, (context, [target, argumentsList, _newTarget]) => {
    let newTarget = _newTarget; // 1. If IsConstructor(target) is false, throw a TypeError exception.

    if (!(0, _index2.IsConstructor)(realm, target)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. If newTarget is not present, let newTarget be target.


    if (!newTarget) {
      newTarget = target;
    } else if (!(0, _index2.IsConstructor)(realm, newTarget)) {
      // 3. Else if IsConstructor(newTarget) is false, throw a TypeError exception.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. Let args be ? CreateListFromArrayLike(argumentsList).


    let args = _singletons.Create.CreateListFromArrayLike(realm, argumentsList); // 5. Return ? Construct(target, args, newTarget).


    return (0, _index2.Construct)(realm, target, args, newTarget);
  }); // ECMA262 26.1.3

  obj.defineNativeMethod("defineProperty", 3, (context, [_target, propertyKey, attributes]) => {
    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let key be ? ToPropertyKey(propertyKey).


    let key = _singletons.To.ToPropertyKey(realm, propertyKey); // 3. Let desc be ? ToPropertyDescriptor(attributes).


    let desc = _singletons.To.ToPropertyDescriptor(realm, attributes); // 4. Return ? target.[[DefineOwnProperty]](key, desc).


    return new _index.BooleanValue(realm, target.$DefineOwnProperty(key, desc));
  }); // ECMA262 26.1.4

  obj.defineNativeMethod("deleteProperty", 2, (context, [_target, propertyKey]) => {
    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let key be ? ToPropertyKey(propertyKey).


    let key = _singletons.To.ToPropertyKey(realm, propertyKey); // 3. Return ? target.[[Delete]](key).


    return new _index.BooleanValue(realm, target.$Delete(key));
  }); // ECMA262 26.1.5

  obj.defineNativeMethod("get", 2, (context, [_target, propertyKey, _receiver]) => {
    let receiver = _receiver;

    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let key be ? ToPropertyKey(propertyKey).


    let key = _singletons.To.ToPropertyKey(realm, propertyKey); // 3. If receiver is not present, then


    if (!receiver) {
      // a. Let receiver be target.
      receiver = target;
    } // 4. Return ? target.[[Get]](key, receiver).


    return target.$Get(key, receiver);
  }); // ECMA262 26.1.6

  obj.defineNativeMethod("getOwnPropertyDescriptor", 2, (context, [_target, propertyKey]) => {
    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let key be ? ToPropertyKey(propertyKey).


    let key = _singletons.To.ToPropertyKey(realm, propertyKey); // 3. Let desc be ? target.[[GetOwnProperty]](key).


    let desc = target.$GetOwnProperty(key); // 4. Return FromPropertyDescriptor(desc).

    return _singletons.Properties.FromPropertyDescriptor(realm, desc);
  }); // ECMA262 26.1.7

  obj.defineNativeMethod("getPrototypeOf", 1, (context, [_target]) => {
    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Return ? target.[[GetPrototypeOf]]().


    return target.$GetPrototypeOf();
  }); // ECMA262 26.1.8

  obj.defineNativeMethod("has", 2, (context, [target, propertyKey]) => {
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (target.mightNotBeObject()) {
      if (target.mightBeObject()) target.throwIfNotConcrete();
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let key be ? ToPropertyKey(propertyKey).


    let key = _singletons.To.ToPropertyKey(realm, propertyKey); // 3. Return ? target.[[HasProperty]](key).


    return new _index.BooleanValue(realm, target.$HasProperty(key));
  }); // ECMA262 26.1.9

  obj.defineNativeMethod("isExtensible", 1, (context, [_target]) => {
    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Return ? target.[[IsExtensible]]().


    return new _index.BooleanValue(realm, target.$IsExtensible());
  }); // ECMA262 26.1.10

  obj.defineNativeMethod("ownKeys", 1, (context, [_target]) => {
    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let keys be ? target.[[OwnPropertyKeys]]().


    let keys = target.$OwnPropertyKeys(); // 3. Return CreateArrayFromList(keys).

    return _singletons.Create.CreateArrayFromList(realm, keys);
  }); // ECMA262 26.1.11

  obj.defineNativeMethod("preventExtensions", 1, (context, [_target]) => {
    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Return ? target.[[PreventExtensions]]().


    return new _index.BooleanValue(realm, target.$PreventExtensions());
  }); // ECMA262 26.1.12

  obj.defineNativeMethod("set", 3, (context, [_target, propertyKey, V, _receiver]) => {
    let receiver = _receiver;

    let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Let key be ? ToPropertyKey(propertyKey).


    let key = _singletons.To.ToPropertyKey(realm, propertyKey); // 3. If receiver is not present, then


    if (!receiver) {
      // a. Let receiver be target.
      receiver = target;
    } // 5. Return ? target.[[Set]](key, V, receiver).


    return new _index.BooleanValue(realm, target.$Set(key, V, receiver));
  }); // ECMA262 26.1.13

  obj.defineNativeMethod("setPrototypeOf", 2, (context, [_target, _proto]) => {
    let target = _target.throwIfNotConcrete();

    let proto = _proto.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


    if (!(target instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. If Type(proto) is not Object and proto is not null, throw a TypeError exception.


    if (!(proto instanceof _index.ObjectValue) && !(proto instanceof _index.NullValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 3. Return ? target.[[SetPrototypeOf]](proto).


    return new _index.BooleanValue(realm, target.$SetPrototypeOf(proto));
  });
  return obj;
}
//# sourceMappingURL=Reflect.js.map

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _errors = __webpack_require__(3);

var _PreludeGenerator = __webpack_require__(238);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
let buildMathTemplates = new Map();

function _default(realm) {
  let obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "Math"); // ECMA262 20.2.1.9

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Math"), {
    writable: false
  }); // ECMA262 20.2.1.1

  obj.defineNativeConstant("E", new _index.NumberValue(realm, 2.7182818284590452354)); // ECMA262 20.2.1.2

  obj.defineNativeConstant("LN10", new _index.NumberValue(realm, 2.302585092994046)); // ECMA262 20.2.1.3

  obj.defineNativeConstant("LN2", new _index.NumberValue(realm, 0.6931471805599453)); // ECMA262 20.2.1.4

  obj.defineNativeConstant("LOG10E", new _index.NumberValue(realm, 0.4342944819032518)); // ECMA262 20.2.1.5

  obj.defineNativeConstant("LOG2E", new _index.NumberValue(realm, 1.4426950408889634)); // ECMA262 20.2.1.6

  obj.defineNativeConstant("PI", new _index.NumberValue(realm, 3.1415926535897932)); // ECMA262 20.2.1.7

  obj.defineNativeConstant("SQRT1_2", new _index.NumberValue(realm, 0.7071067811865476)); // ECMA262 20.2.1.8

  obj.defineNativeConstant("SQRT2", new _index.NumberValue(realm, 1.4142135623730951));
  let functions = [// ECMA262 20.2.2.1
  ["abs", 1], // ECMA262 20.2.2.2
  ["acos", 1], // ECMA262 20.2.2.3
  ["acosh", 1], // ECMA262 20.2.2.4
  ["asin", 1], // ECMA262 20.2.2.5
  ["asinh", 1], // ECMA262 20.2.2.6
  ["atan", 1], // ECMA262 20.2.2.7
  ["atanh", 1], // ECMA262 20.2.2.8
  ["atan2", 2], // ECMA262 20.2.2.9
  ["cbrt", 1], // ECMA262 20.2.2.10
  ["ceil", 1], // ECMA262 20.2.2.12
  ["cos", 1], // ECMA262 20.2.2.13
  ["cosh", 1], // ECMA262 20.2.2.14
  ["exp", 1], // ECMA262 20.2.2.15
  ["expm1", 1], // ECMA262 20.2.2.16
  ["floor", 1], // ECMA262 20.2.2.17
  ["fround", 1], // ECMA262 20.2.2.18
  ["hypot", 2], // ECMA262 20.2.2.20
  ["log", 1], // ECMA262 20.2.2.21
  ["log1p", 1], // ECMA262 20.2.2.22
  ["log10", 1], // ECMA262 20.2.2.23
  ["log2", 1], // ECMA262 20.2.2.24 ( _value1_, _value2_, ..._values_ )
  ["max", 2], // ECMA262 20.2.2.25
  ["min", 2], // ECMA262 20.2.2.26
  ["pow", 2], // ECMA262 20.2.2.28
  ["round", 1], // ECMA262 20.2.2.30
  ["sin", 1], // ECMA262 20.2.2.31
  ["sinh", 1], // ECMA262 20.2.2.32
  ["sqrt", 1], // ECMA262 20.2.2.33
  ["tan", 1], // ECMA262 20.2.2.34
  ["tanh", 1], // ECMA262 20.2.2.35
  ["trunc", 1]]; // ECMA262 20.2.2.11

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) functions.push(["clz32", 1]); // ECMA262 20.2.2.29 (_x_)

  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) functions.push(["sign", 1]);

  for (let [name, length] of functions) {
    obj.defineNativeMethod(name, length, (context, args, originalLength) => {
      (0, _invariant.default)(originalLength >= 0);
      args.length = originalLength;

      if (originalLength <= 26 && args.some(arg => arg instanceof _index.AbstractValue) && args.every(arg => _singletons.To.IsToNumberPure(realm, arg))) {
        let templateSource = buildMathTemplates.get(name);

        if (templateSource === undefined) {
          let params = _PreludeGenerator.Placeholders.slice(0, originalLength).join(",");

          templateSource = `global.Math.${name}(${params})`;
          buildMathTemplates.set(name, templateSource);
        }

        return _index.AbstractValue.createFromTemplate(realm, templateSource, _index.NumberValue, args);
      }

      return new _index.NumberValue(realm, Math[name].apply(null, args.map((arg, i) => _singletons.To.ToNumber(realm, arg.throwIfNotConcrete()))));
    });
  }

  const imulTemplateSrc = "global.Math.imul(A, B)"; // ECMA262 20.2.2.19

  obj.defineNativeMethod("imul", 2, (context, [x, y]) => {
    if ((x instanceof _index.AbstractValue || y instanceof _index.AbstractValue) && _singletons.To.IsToNumberPure(realm, x) && _singletons.To.IsToNumberPure(realm, y)) {
      return _index.AbstractValue.createFromTemplate(realm, imulTemplateSrc, _index.NumberValue, [x, y]);
    }

    return new _index.NumberValue(realm, Math.imul(_singletons.To.ToUint32(realm, x.throwIfNotConcrete()), _singletons.To.ToUint32(realm, y.throwIfNotConcrete())));
  });
  const mathRandomTemplateSrc = "global.Math.random()"; // ECMA262 20.2.2.27

  obj.defineNativeMethod("random", 0, context => {
    let mathRandomGenerator = realm.mathRandomGenerator;

    if (mathRandomGenerator !== undefined) {
      let loc = realm.currentLocation;
      let error = new _errors.CompilerDiagnostic("Result of Math.random() is made deterministic via a fixed mathRandomSeed", loc, "PP8000", "Information");
      realm.handleError(error);
      return new _index.NumberValue(realm, mathRandomGenerator());
    } else if (realm.useAbstractInterpretation) {
      return _index.AbstractValue.createTemporalFromTemplate(realm, mathRandomTemplateSrc, _index.NumberValue, [], {
        isPure: true,
        skipInvariant: true
      });
    } else {
      return new _index.NumberValue(realm, Math.random());
    }
  });
  return obj;
}
//# sourceMappingURL=Math.js.map

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _proxy = __webpack_require__(539);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 26.2.1.1
  let func = new _index.NativeFunctionValue(realm, "Proxy", "Proxy", 2, (context, [target, handler], argCount, NewTarget) => {
    // 1. If NewTarget is undefined, throw a TypeError exception.
    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 2. Return ? ProxyCreate(target, handler).


    return (0, _proxy.ProxyCreate)(realm, target, handler);
  }); // ECMA262 26.2.2.1

  func.defineNativeMethod("revocable", 2, (context, [target, handler]) => {
    // 1. Let p be ? ProxyCreate(target, handler).
    let p = (0, _proxy.ProxyCreate)(realm, target, handler); // 2. Let revoker be a new built-in function object as defined in 26.2.2.1.1.

    let revoker = createRevoker(); // 3. Set the [[RevocableProxy]] internal slot of revoker to p.

    revoker.$RevocableProxy = p; // 4. Let result be ObjectCreate(%ObjectPrototype%).

    let result = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype); // 5. Perform CreateDataProperty(result, "proxy", p).


    _singletons.Create.CreateDataProperty(realm, result, "proxy", p); // 6. Perform CreateDataProperty(result, "revoke", revoker).


    _singletons.Create.CreateDataProperty(realm, result, "revoke", revoker); // 7. Return result.


    return result;
  });

  function createRevoker() {
    let F = new _index.NativeFunctionValue(realm, undefined, undefined, 0, (context, [target, handler], argCount, NewTarget) => {
      // 1. Let p be the value of F's [[RevocableProxy]] internal slot.
      let p = F.$RevocableProxy; // 2. If p is null, return undefined.

      if (p instanceof _index.NullValue) return realm.intrinsics.undefined; // 3. Set the value of F's [[RevocableProxy]] internal slot to null.

      F.$RevocableProxy = realm.intrinsics.null; // 4. Assert: p is a Proxy object.

      (0, _invariant.default)(p instanceof _index.ProxyValue, "expected proxy"); // 5. Set the [[ProxyTarget]] internal slot of p to null.

      p.$ProxyTarget = realm.intrinsics.null; // 6. Set the [[ProxyHandler]] internal slot of p to null.

      p.$ProxyHandler = realm.intrinsics.null; // 7. Return undefined.

      return realm.intrinsics.undefined;
    }, false);
    return F;
  }

  return func;
}
//# sourceMappingURL=Proxy.js.map

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProxyCall = ProxyCall;
exports.ProxyConstruct = ProxyConstruct;
exports.ProxyCreate = ProxyCreate;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _get = __webpack_require__(230);

var _construct = __webpack_require__(228);

var _call = __webpack_require__(234);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 9.5.12
function ProxyCall(realm, O, thisArgument, argumentsList) {
  // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
  let handler = O.$ProxyHandler; // 2. If handler is null, throw a TypeError exception.

  if (handler instanceof _index.NullValue) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 3. Assert: Type(handler) is Object.


  (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected an object"); // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.

  let target = O.$ProxyTarget; // 5. Let trap be ? GetMethod(handler, "apply").

  let trap = (0, _get.GetMethod)(realm, handler, "apply"); // 6. If trap is undefined, then

  if (trap instanceof _index.UndefinedValue) {
    // a. Return ? Call(target, thisArgument, argumentsList).
    return (0, _call.Call)(realm, target, thisArgument, argumentsList);
  } // 7. Let argArray be CreateArrayFromList(argumentsList).


  let argArray = _singletons.Create.CreateArrayFromList(realm, argumentsList); // 8. Return ? Call(trap, handler,  target, thisArgument, argArray ).


  return (0, _call.Call)(realm, trap.throwIfNotConcrete(), handler, [target, thisArgument, argArray]);
} // ECMA262 9.5.13


function ProxyConstruct(realm, O, argumentsList, newTarget) {
  // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.
  let handler = O.$ProxyHandler; // 2. If handler is null, throw a TypeError exception.

  if (handler instanceof _index.NullValue) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 3. Assert: Type(handler) is Object.


  (0, _invariant.default)(handler instanceof _index.ObjectValue, "expected an object"); // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.

  let target = O.$ProxyTarget;
  (0, _invariant.default)(target instanceof _index.ObjectValue); // 5. Let trap be ? GetMethod(handler, "construct").

  let trap = (0, _get.GetMethod)(realm, handler, "construct"); // 6. If trap is undefined, then

  if (trap instanceof _index.UndefinedValue) {
    // a. Assert: target has a [[Construct]] internal method.
    (0, _invariant.default)(target.$Construct, "expected construct method"); // b. Return ? Construct(target, argumentsList, newTarget).

    return (0, _construct.Construct)(realm, target, argumentsList, newTarget).throwIfNotConcreteObject();
  } // 7. Let argArray be CreateArrayFromList(argumentsList).


  let argArray = _singletons.Create.CreateArrayFromList(realm, argumentsList); // 8. Let newObj be ? Call(trap, handler,  target, argArray, newTarget ).


  let newObj = (0, _call.Call)(realm, trap.throwIfNotConcrete(), handler, [target, argArray, newTarget]).throwIfNotConcrete(); // 9. If Type(newObj) is not Object, throw a TypeError exception.

  if (!(newObj instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 10. Return newObj.


  return newObj;
} // ECMA262 9.5.14


function ProxyCreate(realm, _target, _handler) {
  let handler = _handler;

  let target = _target.throwIfNotConcrete(); // 1. If Type(target) is not Object, throw a TypeError exception.


  if (!(target instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 2. If target is a Proxy exotic object and the value of the [[ProxyHandler]] internal slot of target is null, throw a TypeError exception.


  if (target instanceof _index.ProxyValue && (!target.$ProxyHandler || target.$ProxyHandler instanceof _index.NullValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  handler = handler.throwIfNotConcrete(); // 3. If Type(handler) is not Object, throw a TypeError exception.

  if (!(handler instanceof _index.ObjectValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 4. If handler is a Proxy exotic object and the value of the [[ProxyHandler]] internal slot of handler is null, throw a TypeError exception.


  if (handler instanceof _index.ProxyValue && (!handler.$ProxyHandler || handler.$ProxyHandler instanceof _index.NullValue)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  } // 5. Let P be a newly created object.
  // 6. Set P's essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in 9.5.


  let P = new _index.ProxyValue(realm); // 7. If IsCallable(target) is true, then

  if ((0, _is.IsCallable)(realm, target)) {
    // a. Set the [[Call]] internal method of P as specified in 9.5.12.
    P.$Call = (thisArgument, argsList) => {
      return ProxyCall(realm, P, thisArgument, argsList);
    }; // b. If target has a [[Construct]] internal method, then


    if (target.$Construct) {
      // i. Set the [[Construct]] internal method of P as specified in 9.5.13.
      P.$Construct = (argumentsList, newTarget) => {
        return ProxyConstruct(realm, P, argumentsList, newTarget);
      };
    }
  } // 8. Set the [[ProxyTarget]] internal slot of P to target.


  P.$ProxyTarget = target; // 9. Set the [[ProxyHandler]] internal slot of P to handler.

  P.$ProxyHandler = handler; // 10. Return P.

  return P;
}
//# sourceMappingURL=proxy.js.map

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function ToDigit(ch) {
  if (ch >= "0" && ch <= "9") {
    return ch.charCodeAt(0) - "0".charCodeAt(0);
  } else if (ch >= "A" && ch <= "Z") {
    return 10 + ch.charCodeAt(0) - "A".charCodeAt(0);
  } else if (ch >= "a" && ch <= "z") {
    return 10 + ch.charCodeAt(0) - "a".charCodeAt(0);
  }

  return undefined;
}

function _default(realm) {
  return new _index.NativeFunctionValue(realm, "parseInt", "parseInt", 2, (context, [string, radix]) => {
    // 1. Let inputString be ? ToString(string).
    let inputString = _singletons.To.ToStringPartial(realm, string); // 2. Let S be a newly created substring of inputString consisting of the first code unit that is not a StrWhiteSpaceChar and all code units following that code unit. (In other words, remove leading white space.) If inputString does not contain any such code unit, let S be the empty string.


    let S = inputString.trim(); // 3. Let sign be 1.

    let sign = 1; // 4. If S is not empty and the first code unit of S is 0x002D (HYPHEN-MINUS), let sign be -1.

    if (S !== "" && S.charAt(0) === "-") sign = -1; // 5. If S is not empty and the first code unit of S is 0x002B (PLUS SIGN) or 0x002D (HYPHEN-MINUS), remove the first code unit from S.

    if (S !== "" && (S.charAt(0) === "-" || S.charAt(0) === "+")) S = S.substr(1); // 6. Let R be ? ToInt32(radix).

    let R = _singletons.To.ToInt32(realm, radix); // 7. Let stripPrefix be true.


    let stripPrefix = true; // 8. If R  0, then

    if (R !== 0) {
      // a. If R < 2 or R > 36, return NaN.
      if (R < 2 || R > 36) return realm.intrinsics.NaN; // b .If R  16, let stripPrefix be false.

      if (R !== 16) stripPrefix = false;
    } else {
      // 9. Else R = 0,
      // a. Let R be 10.
      R = 10;
    } // 10. If stripPrefix is true, then


    if (stripPrefix === true) {
      // a. If the length of S is at least 2 and the first two code units of S are either "0x" or "0X", remove the first two code units from S and let R be 16.
      if (S.length >= 2 && S.charAt(0) === "0" && (S.charAt(1) === "x" || S.charAt(1) === "X")) {
        S = S.substr(2);
        R = 16;
      }
    } // 11. If S contains a code unit that is not a radix-R digit, let Z be the substring of S consisting of all code units before the first such code unit; otherwise, let Z be S.


    let Z = "";

    for (let i = 0; i < S.length; ++i) {
      let digit = ToDigit(S.charAt(i));

      if (digit === undefined || digit >= R) {
        break;
      }

      Z = Z + S.charAt(i);
    } // 12. If Z is empty, return NaN.


    if (Z === "") return realm.intrinsics.NaN; // 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent approximation to the mathematical integer value that is represented by Z in radix-R notation.)

    let mathInt = 0;

    for (let i = 0; i < Z.length; ++i) {
      mathInt = mathInt * R + (ToDigit(Z.charAt(i)) || 0);
    } // 14. If mathInt = 0, then


    if (mathInt === 0) {
      // a. If sign = -1, return -0.
      if (sign === -1) return realm.intrinsics.negativeZero; // b. Return +0.

      return realm.intrinsics.zero;
    } // 15. Let number be the Number value for mathInt.


    let number = Number(mathInt); // 5. Return sign  number.

    return new _index.NumberValue(realm, sign * number);
  }, false);
}
//# sourceMappingURL=parseInt.js.map

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.4
  return new _index.NativeFunctionValue(realm, "parseFloat", "parseFloat", 1, (context, [string]) => {
    if (!string) return realm.intrinsics.NaN; // 1. Let inputString be ? ToString(string).

    let inputString = _singletons.To.ToStringPartial(realm, string);

    return new _index.NumberValue(realm, parseFloat(inputString));
  }, false);
}
//# sourceMappingURL=parseFloat.js.map

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.2
  return new _index.NativeFunctionValue(realm, "isFinite", "isFinite", 1, (context, [number]) => {
    // 1. Let num be ? ToNumber(number).
    let num = _singletons.To.ToNumber(realm, number); // 2. If num is NaN, +, or -, return false.


    if (isNaN(num) || num === +Infinity || num === -Infinity) return realm.intrinsics.false; // 3. Otherwise, return true.

    return realm.intrinsics.true;
  }, false);
}
//# sourceMappingURL=isFinite.js.map

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.6.2
  let name = "decodeURI";
  return new _index.NativeFunctionValue(realm, name, name, 1, (context, [_encodedURI], argCount, NewTarget) => {
    let encodedURI = _encodedURI;
    if (NewTarget) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, `${name} is not a constructor`);
    encodedURI = encodedURI.throwIfNotConcrete(); // 1. Let uriString be ? ToString(encodedURI).

    let uriString = _singletons.To.ToString(realm, encodedURI); // 2. Let reservedURISet be a String containing one instance of each code unit valid in uriReserved plus "#".
    // 3. Return ? Decode(uriString, reservedURISet).


    try {
      return new _index.StringValue(realm, decodeURI(uriString));
    } catch (e) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.URIError, e.message);
    }
  });
}
//# sourceMappingURL=decodeURI.js.map

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.6.3
  let name = "decodeURIComponent";
  return new _index.NativeFunctionValue(realm, name, name, 1, (context, [_encodedURIComponent], argCount, NewTarget) => {
    let encodedURIComponent = _encodedURIComponent;
    if (NewTarget) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, `${name} is not a constructor`);
    encodedURIComponent = encodedURIComponent.throwIfNotConcrete(); // 1. Let componentString be ? ToString(uri).

    let componentString = _singletons.To.ToString(realm, encodedURIComponent); // 2. Let reservedURIComponentSet be the empty String.
    // 3. Return ? Encode(componentString, unescapedURIComponentSet).


    try {
      return new _index.StringValue(realm, decodeURIComponent(componentString));
    } catch (e) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.URIError, e.message);
    }
  });
}
//# sourceMappingURL=decodeURIComponent.js.map

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.6.4
  let name = "encodeURI";
  return new _index.NativeFunctionValue(realm, name, name, 1, (context, [_uri], argCount, NewTarget) => {
    let uri = _uri;
    if (NewTarget) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, `${name} is not a constructor`);
    uri = uri.throwIfNotConcrete(); // 1. Let uriString be ? ToString(uri).

    let uriString = _singletons.To.ToString(realm, uri); // 2. Let unescapedURISet be a String containing one instance of each code unit valid in uriReserved and uriUnescaped plus "#".
    // 3. Return ? Encode(uriString, unescapedURISet).


    try {
      return new _index.StringValue(realm, encodeURI(uriString));
    } catch (e) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.URIError, e.message);
    }
  });
}
//# sourceMappingURL=encodeURI.js.map

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.6.5
  let name = "encodeURIComponent";
  return new _index.NativeFunctionValue(realm, name, name, 1, (context, [_uriComponent], argCount, NewTarget) => {
    let uriComponent = _uriComponent;
    if (NewTarget) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, `${name} is not a constructor`);
    uriComponent = uriComponent.throwIfNotConcrete(); // 1. Let componentString be ? ToString(uri).

    let componentString = _singletons.To.ToString(realm, uriComponent); // 2. Let unescapedURIComponentSet be a String containing one instance of each code unit valid in uriUnescaped.
    // 3. Return ? Encode(componentString, unescapedURIComponentSet).


    try {
      return new _index.StringValue(realm, encodeURIComponent(componentString));
    } catch (e) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.URIError, e.message);
    }
  });
}
//# sourceMappingURL=encodeURIComponent.js.map

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.1
  return new _index.NativeFunctionValue(realm, "eval", "eval", 1, (context, [x]) => {
    // 1. Let evalRealm be the value of the active function object's [[Realm]] internal slot.
    let rcontext = realm.getRunningContext();
    let evalRealm = rcontext.function == null ? realm : rcontext.function.$Realm; // 2. Let strictCaller be false.

    let strictCaller = false; // 3. Let directEval be false.

    let directEval = false; // 4. Return ? PerformEval(x, evalRealm, strictCaller, directEval).

    return _singletons.Functions.PerformEval(realm, x, evalRealm, strictCaller, directEval);
  }, false);
}
//# sourceMappingURL=eval.js.map

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 18.2.3
  return new _index.NativeFunctionValue(realm, "isNaN", "isNaN", 1, (context, [number]) => {
    // 1. Let num be ? ToNumber(number).
    let num = _singletons.To.ToNumber(realm, number); // 2. If num is NaN, return true.


    if (isNaN(num)) return realm.intrinsics.true; // 3. Otherwise, return false.

    return realm.intrinsics.false;
  }, false);
}
//# sourceMappingURL=isNaN.js.map

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

var _index = __webpack_require__(10);

var _get = __webpack_require__(230);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 22.1.5.2.1
  obj.defineNativeMethod("next", 0, context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an object");
    } // 3. If O does not have all of the internal slots of an Array Iterator Instance (22.1.5.3), throw a TypeError exception.


    if (O.$IteratedObject === undefined || O.$ArrayIteratorNextIndex === undefined || O.$ArrayIterationKind === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "ArrayIteratorPrototype.next isn't generic");
    } // 4. Let a be the value of the [[IteratedObject]] internal slot of O.


    let a = O.$IteratedObject;
    (0, _invariant.default)(a instanceof _index.ObjectValue || a instanceof _index.UndefinedValue); // 5. If a is undefined, return CreateIterResultObject(undefined, true).

    if (a instanceof _index.UndefinedValue) {
      return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
    } // 6. Let index be the value of the [[ArrayIteratorNextIndex]] internal slot of O.


    let index = O.$ArrayIteratorNextIndex.value; // 7. Let itemKind be the value of the [[ArrayIterationKind]] internal slot of O.

    let itemKind = O.$ArrayIterationKind; // 8. If a has a [[TypedArrayName]] internal slot, then

    let len;

    if (a.$TypedArrayName) {
      // a. Let len be the value of a's [[ArrayLength]] internal slot.
      len = a.$ArrayLength;
      (0, _invariant.default)(typeof len === "number");
    } else {
      // 9. Else,
      // a. Let len be ? ToLength(? Get(a, "length")).
      len = _singletons.To.ToLength(realm, (0, _get.Get)(realm, a, "length"));
    } // 10. If index  len, then


    if (index >= len) {
      // a. Set the value of the [[IteratedObject]] internal slot of O to undefined.
      O.$IteratedObject = realm.intrinsics.undefined; // b. Return CreateIterResultObject(undefined, true).

      return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
    } // 11. Set the value of the [[ArrayIteratorNextIndex]] internal slot of O to index+1.


    O.$ArrayIteratorNextIndex = new _index.NumberValue(realm, index + 1); // 12. If itemKind is "key", return CreateIterResultObject(index, false).

    if (itemKind === "key") {
      return _singletons.Create.CreateIterResultObject(realm, new _index.NumberValue(realm, index), false);
    } // 13. Let elementKey be ! ToString(index).


    let elementKey = new _index.StringValue(realm, index + ""); // 14. Let elementValue be ? Get(a, elementKey).

    let elementValue = (0, _get.Get)(realm, a, elementKey); // 15. If itemKind is "value", let result be elementValue.

    let result;

    if (itemKind === "value") {
      result = elementValue;
    } else {
      // 16. Else,
      // a. Assert: itemKind is "key+value".
      (0, _invariant.default)(itemKind === "key+value", "expected item kind to be key+value"); // b. Let result be CreateArrayFromList( index, elementValue ).

      result = _singletons.Create.CreateArrayFromList(realm, [new _index.NumberValue(realm, index), elementValue]);
    } // 17. Return CreateIterResultObject(result, false).


    return _singletons.Create.CreateIterResultObject(realm, result, false);
  }); // ECMA262 22.1.5.2.2

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Array Iterator"), {
    writable: false
  });
}
//# sourceMappingURL=ArrayIteratorPrototype.js.map

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 21.1.5.2.1
  obj.defineNativeMethod("next", 0, context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 3. If O does not have all of the internal slots of an String Iterator Instance (21.1.5.3), throw a TypeError exception.


    if (!("$IteratedString" in O && "$StringIteratorNextIndex" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "Type(O) is not Object");
    } // 4. Let s be O.[[IteratedString]].


    let s = O.$IteratedString; // 5. If s is undefined, return CreateIterResultObject(undefined, true).

    if (!s) {
      return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
    } // 6. Let position be O.[[StringIteratorNextIndex]].


    let position = O.$StringIteratorNextIndex;
    (0, _invariant.default)(typeof position === "number"); // 7. Let len be the number of elements in s.

    let len = s.value.length; // 8. If position  len, then

    if (position >= len) {
      // a. Set O.[[IteratedString]] to undefined.
      O.$IteratedString = undefined; // b. Return CreateIterResultObject(undefined, true).

      return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
    } // 9. Let first be the code unit value at index position in s.


    let first = s.value.charCodeAt(position);
    let resultString; // 10. If first < 0xD800 or first > 0xDBFF or position+1 = len, let resultString be the string consisting of the single code unit first.

    if (first < 0xd800 || first > 0xdbff || position + 1 === len) {
      resultString = String.fromCharCode(first);
    } else {
      // 11. Else,
      // a. Let second be the code unit value at index position+1 in the String s.
      let second = s.value.charCodeAt(position + 1); // b. If second < 0xDC00 or second > 0xDFFF, let resultString be the string consisting of the single code unit first.

      if (second < 0xdc00 || second > 0xdfff) {
        resultString = String.fromCharCode(first);
      } else {
        // c. Else, let resultString be the string consisting of the code unit first followed by the code unit second.
        resultString = String.fromCharCode(first, second);
      }
    } // 12. Let resultSize be the number of code units in resultString.


    let resultSize = resultString.length; // 13. Set O.[[StringIteratorNextIndex]] to position + resultSize.

    O.$StringIteratorNextIndex = position + resultSize; // 14. Return CreateIterResultObject(resultString, false).

    return _singletons.Create.CreateIterResultObject(realm, new _index.StringValue(realm, resultString), false);
  }); // ECMA262 21.1.5.2.2

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "String Iterator"), {
    writable: false
  });
}
//# sourceMappingURL=StringIteratorPrototype.js.map

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 23.1.5.2.1
  obj.defineNativeMethod("next", 0, context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an object");
    } // 3. If O does not have all of the internal slots of a Set Iterator Instance (23.2.5.3), throw a TypeError exception.


    if (O.$Map === undefined || O.$MapNextIndex === undefined || O.$MapIterationKind === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "MapIteratorPrototype.next isn't generic");
    } // 4. Let m be O.[[Map]].


    let m = O.$Map; // 5. Let index be O.[[MapNextIndex]].

    let index = O.$MapNextIndex.value; // 6. Let itemKind be O.[[MapIterationKind]].

    let itemKind = O.$MapIterationKind; // 7. If m is undefined, return CreateIterResultObject(undefined, true).

    if (!m || m instanceof _index.UndefinedValue) return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
    (0, _invariant.default)(m instanceof _index.ObjectValue); // 8. Assert: m has a [[MapData]] internal slot.

    (0, _invariant.default)(m.$MapData, "m has a [[MapData]] internal slot"); // 9. Let entries be the List that is m.[[MapData]].

    let entries = m.$MapData;
    (0, _invariant.default)(entries); // 10. Repeat while index is less than the total number of elements of entries. The number of elements must be redetermined each time this method is evaluated.

    while (index < entries.length) {
      // a. Let e be the Record {[[Key]], [[Value]]} that is the value of entries[index].
      let e = entries[index]; // b. Set index to index+1.

      index = index + 1; // c. Set O.[[MapNextIndex]] to index.

      O.$MapNextIndex = new _index.NumberValue(realm, index); // d. If e.[[Key]] is not empty, then

      if (e.$Key !== undefined) {
        (0, _invariant.default)(e.$Value !== undefined);
        let result; // i. If itemKind is "key", let result be e.[[Key]].

        if (itemKind === "key") result = e.$Key;else if (itemKind === "value") // ii. Else if itemKind is "value", let result be e.[[Value]].
          result = e.$Value;else {
          // iii. Else,
          // 1. Assert: itemKind is "key+value".
          (0, _invariant.default)(itemKind === "key+value"); // 2. Let result be CreateArrayFromList( e.[[Key]], e.[[Value]] ).

          result = _singletons.Create.CreateArrayFromList(realm, [e.$Key, e.$Value]);
        } // iv. Return CreateIterResultObject(result, false).

        return _singletons.Create.CreateIterResultObject(realm, result, false);
      }
    } // 11. Set O.[[Map]] to undefined.


    O.$Map = realm.intrinsics.undefined; // 12. Return CreateIterResultObject(undefined, true).

    return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
  }); // ECMA262 23.1.5.2.2

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Map Iterator"), {
    writable: false
  });
}
//# sourceMappingURL=MapIteratorPrototype.js.map

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 23.2.5.2.1
  obj.defineNativeMethod("next", 0, context => {
    // 1. Let O be the this value.
    let O = context.throwIfNotConcrete(); // 2. If Type(O) is not Object, throw a TypeError exception.

    if (!(O instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an object");
    } // 3. If O does not have all of the internal slots of a Set Iterator Instance (23.2.5.3), throw a TypeError exception.


    if (!("$IteratedSet" in O) || !("$SetNextIndex" in O) || !("$SetIterationKind" in O)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "SetIteratorPrototype.next isn't generic");
    } // 4. Let s be O.[[IteratedSet]].


    let s = O.$IteratedSet; // 5. Let index be O.[[SetNextIndex]].

    let index = O.$SetNextIndex;
    (0, _invariant.default)(typeof index === "number"); // 6. Let itemKind be O.[[SetIterationKind]].

    let itemKind = O.$SetIterationKind; // 7. If s is undefined, return CreateIterResultObject(undefined, true).

    if (!s || s instanceof _index.UndefinedValue) return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
    (0, _invariant.default)(s instanceof _index.ObjectValue); // 8. Assert: s has a [[SetData]] internal slot.

    (0, _invariant.default)(s.$SetData, "s has a [[SetData]] internal slot"); // 9. Let entries be the List that is s.[[SetData]].

    let entries = s.$SetData;
    (0, _invariant.default)(entries); // 10. Repeat while index is less than the total number of elements of entries. The number of elements must be redetermined each time this method is evaluated.

    while (index < entries.length) {
      // a. Let e be entries[index].
      let e = entries[index]; // b. Set index to index+1.

      index = index + 1; // c. Set O.[[SetNextIndex]] to index.

      O.$SetNextIndex = index; // d. If e is not empty, then

      if (e) {
        // i. If itemKind is "key+value", then
        if (itemKind === "key+value") {
          // 1. Return CreateIterResultObject(CreateArrayFromList( e, e ), false).
          return _singletons.Create.CreateIterResultObject(realm, _singletons.Create.CreateArrayFromList(realm, [e, e]), false);
        } // ii. Return CreateIterResultObject(e, false).


        return _singletons.Create.CreateIterResultObject(realm, e, false);
      }
    } // 11. Set O.[[IteratedSet]] to undefined.


    O.$IteratedSet = realm.intrinsics.undefined; // 12. Return CreateIterResultObject(undefined, true).

    return _singletons.Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);
  }); // ECMA262 23.2.5.2.2

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Set Iterator"), {
    writable: false
  });
}
//# sourceMappingURL=SetIteratorPrototype.js.map

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  // ECMA262 25.1.2.1
  obj.defineNativeMethod(realm.intrinsics.SymbolIterator, 0, context => {
    // 1. Return the this value.
    return context;
  });
}
//# sourceMappingURL=IteratorPrototype.js.map

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _generator = __webpack_require__(237);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 22.1.3.30
  return new _index.NativeFunctionValue(realm, "Array.prototype.values", "values", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) && realm.isInPureScope() && O.$GetOwnProperty("values") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, [O, new _index.StringValue(realm, "values")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Return CreateArrayIterator(O, "value").


    return _singletons.Create.CreateArrayIterator(realm, O.throwIfNotConcreteObject(), "value");
  });
}
//# sourceMappingURL=ArrayProto_values.js.map

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _get = __webpack_require__(230);

var _call = __webpack_require__(234);

var _is = __webpack_require__(229);

var _generator = __webpack_require__(237);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 22.1.3.30
  return new _index.NativeFunctionValue(realm, "Array.prototype.toString", "toString", 0, context => {
    // 1. Let array be ? ToObject(this value).
    let array = _singletons.To.ToObject(realm, context); // If we have an object that is an array with widened numeric properties, then
    // we can return a temporal here as we know nothing of the array's properties.
    // This should be safe to do, as we never expose the internals of the array.


    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(array) && realm.isInPureScope() && array.$GetOwnProperty("toString") === undefined) {
      return _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.StringValue, [array, new _index.StringValue(realm, "toString")], (0, _generator.createOperationDescriptor)("UNKNOWN_ARRAY_METHOD_PROPERTY_CALL"));
    } // 2. Let func be ? Get(array, "join").


    let func = (0, _get.Get)(realm, array, "join"); // 3. If IsCallable(func) is false, let func be the intrinsic function %ObjProto_toString%.

    if (!(0, _is.IsCallable)(realm, func)) func = realm.intrinsics.ObjectProto_toString; // 4. Return ? Call(func, array).

    return (0, _call.Call)(realm, func, array);
  }, false);
}
//# sourceMappingURL=ArrayProto_toString.js.map

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _is = __webpack_require__(229);

var _get = __webpack_require__(230);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 22.1.3.30
  return new _index.NativeFunctionValue(realm, "Object.prototype.toString", "toString", 0, context => {
    // 1. If the this value is undefined, return "[object Undefined]".
    if (context instanceof _index.UndefinedValue) return new _index.StringValue(realm, "[object Undefined]"); // 2. If the this value is null, return "[object Null]".

    if (context instanceof _index.NullValue) return new _index.StringValue(realm, "[object Null]"); // 3. Let O be ToObject(this value).

    let O = _singletons.To.ToObject(realm, context);

    let builtinTag; // 4. Let isArray be ? IsArray(O).

    let isArray = (0, _is.IsArray)(realm, O); // 5. If isArray is true, let builtinTag be "Array".

    if (isArray) builtinTag = "Array";else if (O.$StringData !== undefined) // 6. Else, if O is an exotic String object, let builtinTag be "String".
      builtinTag = "String";else if (O.$ParameterMap !== undefined) // 7. Else, if O has an [[ParameterMap]] internal slot, let builtinTag be "Arguments".
      builtinTag = "Arguments";else if (O.$Call !== undefined) // 8. Else, if O has a [[Call]] internal method, let builtinTag be "Function".
      builtinTag = "Function";else if (O.$ErrorData !== undefined) // 9. Else, if O has an [[ErrorData]] internal slot, let builtinTag be "Error".
      builtinTag = "Error";else if (O.$BooleanData !== undefined) // 10. Else, if O has a [[BooleanData]] internal slot, let builtinTag be "Boolean".
      builtinTag = "Boolean";else if (O.$NumberData !== undefined) // 11. Else, if O has a [[NumberData]] internal slot, let builtinTag be "Number".
      builtinTag = "Number";else if (O.$DateValue !== undefined) // 12. Else, if O has a [[DateValue]] internal slot, let builtinTag be "Date".
      builtinTag = "Date";else if (O.$RegExpMatcher !== undefined) // 13. Else, if O has a [[RegExpMatcher]] internal slot, let builtinTag be "RegExp".
      builtinTag = "RegExp";else {
      // 14. Else, let builtinTag be "Object".
      builtinTag = "Object";
    } // 15. Let tag be ? Get(O, @@toStringTag).

    let tag = (0, _get.Get)(realm, O, realm.intrinsics.SymbolToStringTag); // 16. If Type(tag) is not String, let tag be builtinTag.

    tag = tag instanceof _index.StringValue ? tag.value : builtinTag; // 17. Return the String that is the result of concatenating "[object ", tag, and "]".

    return new _index.StringValue(realm, `[object ${tag}]`);
  }, false);
}
//# sourceMappingURL=ObjectProto_toString.js.map

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _typedarray = __webpack_require__(390);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 22.1.3.30
  return new _index.NativeFunctionValue(realm, "Array.prototype.values", "values", 0, context => {
    // 1. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context); // 2. Perform ? ValidateTypedArray(O).


    (0, _typedarray.ValidateTypedArray)(realm, O); // 3. Return CreateArrayIterator(O, "value").

    return _singletons.Create.CreateArrayIterator(realm, O.throwIfNotConcreteObject(), "value");
  });
}
//# sourceMappingURL=TypedArrayProto_values.js.map

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _descriptors = __webpack_require__(268);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  // ECMA262 9.2.7.1
  let func = new _index.NativeFunctionValue(realm, "(function() { throw new TypeError(); })", "", 0, context => {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }); // ECMA262 9.2.7.1

  func.setExtensible(false); // ECMA262 9.2.7.1

  func.$DefineOwnProperty("length", new _descriptors.PropertyDescriptor({
    value: realm.intrinsics.zero,
    writable: false,
    configurable: false,
    enumerable: false
  }));
  return func;
}
//# sourceMappingURL=ThrowTypeError.js.map

/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _Error = __webpack_require__(424);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  return (0, _Error.build)("__IntrospectionError", realm, false);
}
//# sourceMappingURL=__IntrospectionError.js.map

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  obj.defineNativeProperty("name", new _index.StringValue(realm, "__IntrospectionError"));
  obj.defineNativeProperty("message", realm.intrinsics.emptyString);
}
//# sourceMappingURL=__IntrospectionErrorPrototype.js.map

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let global = realm.$GlobalObject;
  global.$DefineOwnProperty("global", new _descriptors.PropertyDescriptor({
    value: global,
    writable: true,
    enumerable: false,
    configurable: true
  }));

  for (let name of ["undefined", "NaN", "Infinity"]) {
    global.$DefineOwnProperty(name, new _descriptors.PropertyDescriptor({
      value: realm.intrinsics[name],
      writable: false,
      enumerable: false,
      configurable: false
    }));
  }

  let typeNames = ["String", "Object", "Function", "Array", "Number", "RegExp", "Date", "Math", "Error", "Function", "TypeError", "RangeError", "ReferenceError", "SyntaxError", "URIError", "EvalError", "Boolean", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Map", "Set", "WeakMap", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "ArrayBuffer", "JSON"];
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) typeNames = typeNames.concat("Symbol", "Promise", "WeakSet", "Proxy", "Reflect");

  for (let name of typeNames) {
    // need to check if the property exists (it may not due to --compatibility)
    if (realm.intrinsics[name]) {
      global.$DefineOwnProperty(name, new _descriptors.PropertyDescriptor({
        value: realm.intrinsics[name],
        writable: true,
        enumerable: false,
        configurable: true
      }));
    } else {
      (0, _invariant.default)(name === "Symbol" || name === "Promise" || name === "WeakSet" || name === "Proxy" || name === "Reflect");
      (0, _invariant.default)(realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) || realm.isCompatibleWith("mobile"));
    }
  }

  for (let name of ["parseFloat", "parseInt", "console", "isNaN", "eval", "isFinite", "encodeURI", "decodeURI", "encodeURIComponent", "decodeURIComponent"]) {
    global.$DefineOwnProperty(name, new _descriptors.PropertyDescriptor({
      value: realm.intrinsics[name],
      writable: true,
      enumerable: false,
      configurable: true
    }));
  }
}
//# sourceMappingURL=global.js.map

/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ArrayExpression", {
  enumerable: true,
  get: function () {
    return _ArrayExpression.default;
  }
});
Object.defineProperty(exports, "ArrowFunctionExpression", {
  enumerable: true,
  get: function () {
    return _ArrowFunctionExpression.default;
  }
});
Object.defineProperty(exports, "AssignmentExpression", {
  enumerable: true,
  get: function () {
    return _AssignmentExpression.default;
  }
});
Object.defineProperty(exports, "AwaitExpression", {
  enumerable: true,
  get: function () {
    return _AwaitExpression.default;
  }
});
Object.defineProperty(exports, "BinaryExpression", {
  enumerable: true,
  get: function () {
    return _BinaryExpression.default;
  }
});
Object.defineProperty(exports, "BlockStatement", {
  enumerable: true,
  get: function () {
    return _BlockStatement.default;
  }
});
Object.defineProperty(exports, "BooleanLiteral", {
  enumerable: true,
  get: function () {
    return _BooleanLiteral.default;
  }
});
Object.defineProperty(exports, "BreakStatement", {
  enumerable: true,
  get: function () {
    return _BreakStatement.default;
  }
});
Object.defineProperty(exports, "CallExpression", {
  enumerable: true,
  get: function () {
    return _CallExpression.default;
  }
});
Object.defineProperty(exports, "CatchClause", {
  enumerable: true,
  get: function () {
    return _CatchClause.default;
  }
});
Object.defineProperty(exports, "ClassExpression", {
  enumerable: true,
  get: function () {
    return _ClassExpression.default;
  }
});
Object.defineProperty(exports, "ClassDeclaration", {
  enumerable: true,
  get: function () {
    return _ClassDeclaration.default;
  }
});
Object.defineProperty(exports, "ConditionalExpression", {
  enumerable: true,
  get: function () {
    return _ConditionalExpression.default;
  }
});
Object.defineProperty(exports, "ContinueStatement", {
  enumerable: true,
  get: function () {
    return _ContinueStatement.default;
  }
});
Object.defineProperty(exports, "Directive", {
  enumerable: true,
  get: function () {
    return _Directive.default;
  }
});
Object.defineProperty(exports, "DirectiveLiteral", {
  enumerable: true,
  get: function () {
    return _DirectiveLiteral.default;
  }
});
Object.defineProperty(exports, "DoExpression", {
  enumerable: true,
  get: function () {
    return _DoExpression.default;
  }
});
Object.defineProperty(exports, "DoWhileStatement", {
  enumerable: true,
  get: function () {
    return _DoWhileStatement.default;
  }
});
Object.defineProperty(exports, "EmptyStatement", {
  enumerable: true,
  get: function () {
    return _EmptyStatement.default;
  }
});
Object.defineProperty(exports, "ExpressionStatement", {
  enumerable: true,
  get: function () {
    return _ExpressionStatement.default;
  }
});
Object.defineProperty(exports, "File", {
  enumerable: true,
  get: function () {
    return _File.default;
  }
});
Object.defineProperty(exports, "ForInStatement", {
  enumerable: true,
  get: function () {
    return _ForInStatement.default;
  }
});
Object.defineProperty(exports, "ForOfStatement", {
  enumerable: true,
  get: function () {
    return _ForOfStatement.default;
  }
});
Object.defineProperty(exports, "ForStatement", {
  enumerable: true,
  get: function () {
    return _ForStatement.default;
  }
});
Object.defineProperty(exports, "FunctionDeclaration", {
  enumerable: true,
  get: function () {
    return _FunctionDeclaration.default;
  }
});
Object.defineProperty(exports, "FunctionExpression", {
  enumerable: true,
  get: function () {
    return _FunctionExpression.default;
  }
});
Object.defineProperty(exports, "Identifier", {
  enumerable: true,
  get: function () {
    return _Identifier.default;
  }
});
Object.defineProperty(exports, "IfStatement", {
  enumerable: true,
  get: function () {
    return _IfStatement.evaluate;
  }
});
Object.defineProperty(exports, "LabeledStatement", {
  enumerable: true,
  get: function () {
    return _LabeledStatement.default;
  }
});
Object.defineProperty(exports, "LogicalExpression", {
  enumerable: true,
  get: function () {
    return _LogicalExpression.default;
  }
});
Object.defineProperty(exports, "MemberExpression", {
  enumerable: true,
  get: function () {
    return _MemberExpression.default;
  }
});
Object.defineProperty(exports, "MetaProperty", {
  enumerable: true,
  get: function () {
    return _MetaProperty.default;
  }
});
Object.defineProperty(exports, "NewExpression", {
  enumerable: true,
  get: function () {
    return _NewExpression.default;
  }
});
Object.defineProperty(exports, "NullLiteral", {
  enumerable: true,
  get: function () {
    return _NullLiteral.default;
  }
});
Object.defineProperty(exports, "NumericLiteral", {
  enumerable: true,
  get: function () {
    return _NumericLiteral.default;
  }
});
Object.defineProperty(exports, "ObjectExpression", {
  enumerable: true,
  get: function () {
    return _ObjectExpression.default;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _Program.default;
  }
});
Object.defineProperty(exports, "RegExpLiteral", {
  enumerable: true,
  get: function () {
    return _RegExpLiteral.default;
  }
});
Object.defineProperty(exports, "ReturnStatement", {
  enumerable: true,
  get: function () {
    return _ReturnStatement.default;
  }
});
Object.defineProperty(exports, "SequenceExpression", {
  enumerable: true,
  get: function () {
    return _SequenceExpression.default;
  }
});
Object.defineProperty(exports, "StringLiteral", {
  enumerable: true,
  get: function () {
    return _StringLiteral.default;
  }
});
Object.defineProperty(exports, "SwitchStatement", {
  enumerable: true,
  get: function () {
    return _SwitchStatement.default;
  }
});
Object.defineProperty(exports, "TaggedTemplateExpression", {
  enumerable: true,
  get: function () {
    return _TaggedTemplateExpression.default;
  }
});
Object.defineProperty(exports, "TemplateLiteral", {
  enumerable: true,
  get: function () {
    return _TemplateLiteral.default;
  }
});
Object.defineProperty(exports, "ThisExpression", {
  enumerable: true,
  get: function () {
    return _ThisExpression.default;
  }
});
Object.defineProperty(exports, "ThrowStatement", {
  enumerable: true,
  get: function () {
    return _ThrowStatement.default;
  }
});
Object.defineProperty(exports, "TryStatement", {
  enumerable: true,
  get: function () {
    return _TryStatement.default;
  }
});
Object.defineProperty(exports, "UnaryExpression", {
  enumerable: true,
  get: function () {
    return _UnaryExpression.default;
  }
});
Object.defineProperty(exports, "UpdateExpression", {
  enumerable: true,
  get: function () {
    return _UpdateExpression.default;
  }
});
Object.defineProperty(exports, "VariableDeclaration", {
  enumerable: true,
  get: function () {
    return _VariableDeclaration.default;
  }
});
Object.defineProperty(exports, "WhileStatement", {
  enumerable: true,
  get: function () {
    return _WhileStatement.default;
  }
});
Object.defineProperty(exports, "WithStatement", {
  enumerable: true,
  get: function () {
    return _WithStatement.default;
  }
});
Object.defineProperty(exports, "YieldExpression", {
  enumerable: true,
  get: function () {
    return _YieldExpression.default;
  }
});
Object.defineProperty(exports, "JSXElement", {
  enumerable: true,
  get: function () {
    return _JSXElement.default;
  }
});

var _ArrayExpression = _interopRequireDefault(__webpack_require__(563));

var _ArrowFunctionExpression = _interopRequireDefault(__webpack_require__(564));

var _AssignmentExpression = _interopRequireDefault(__webpack_require__(565));

var _AwaitExpression = _interopRequireDefault(__webpack_require__(566));

var _BinaryExpression = _interopRequireDefault(__webpack_require__(292));

var _BlockStatement = _interopRequireDefault(__webpack_require__(567));

var _BooleanLiteral = _interopRequireDefault(__webpack_require__(568));

var _BreakStatement = _interopRequireDefault(__webpack_require__(569));

var _CallExpression = _interopRequireDefault(__webpack_require__(570));

var _CatchClause = _interopRequireDefault(__webpack_require__(572));

var _ClassExpression = _interopRequireDefault(__webpack_require__(573));

var _ClassDeclaration = _interopRequireDefault(__webpack_require__(574));

var _ConditionalExpression = _interopRequireDefault(__webpack_require__(575));

var _ContinueStatement = _interopRequireDefault(__webpack_require__(576));

var _Directive = _interopRequireDefault(__webpack_require__(577));

var _DirectiveLiteral = _interopRequireDefault(__webpack_require__(578));

var _DoExpression = _interopRequireDefault(__webpack_require__(580));

var _DoWhileStatement = _interopRequireDefault(__webpack_require__(581));

var _EmptyStatement = _interopRequireDefault(__webpack_require__(583));

var _ExpressionStatement = _interopRequireDefault(__webpack_require__(584));

var _File = _interopRequireDefault(__webpack_require__(585));

var _ForInStatement = _interopRequireDefault(__webpack_require__(586));

var _ForOfStatement = _interopRequireDefault(__webpack_require__(582));

var _ForStatement = _interopRequireDefault(__webpack_require__(587));

var _FunctionDeclaration = _interopRequireDefault(__webpack_require__(588));

var _FunctionExpression = _interopRequireDefault(__webpack_require__(589));

var _Identifier = _interopRequireDefault(__webpack_require__(590));

var _IfStatement = __webpack_require__(591);

var _LabeledStatement = _interopRequireDefault(__webpack_require__(592));

var _LogicalExpression = _interopRequireDefault(__webpack_require__(593));

var _MemberExpression = _interopRequireDefault(__webpack_require__(594));

var _MetaProperty = _interopRequireDefault(__webpack_require__(596));

var _NewExpression = _interopRequireDefault(__webpack_require__(597));

var _NullLiteral = _interopRequireDefault(__webpack_require__(598));

var _NumericLiteral = _interopRequireDefault(__webpack_require__(599));

var _ObjectExpression = _interopRequireDefault(__webpack_require__(275));

var _Program = _interopRequireDefault(__webpack_require__(600));

var _RegExpLiteral = _interopRequireDefault(__webpack_require__(601));

var _ReturnStatement = _interopRequireDefault(__webpack_require__(602));

var _SequenceExpression = _interopRequireDefault(__webpack_require__(603));

var _StringLiteral = _interopRequireDefault(__webpack_require__(579));

var _SwitchStatement = _interopRequireDefault(__webpack_require__(604));

var _TaggedTemplateExpression = _interopRequireDefault(__webpack_require__(605));

var _TemplateLiteral = _interopRequireDefault(__webpack_require__(606));

var _ThisExpression = _interopRequireDefault(__webpack_require__(607));

var _ThrowStatement = _interopRequireDefault(__webpack_require__(608));

var _TryStatement = _interopRequireDefault(__webpack_require__(609));

var _UnaryExpression = _interopRequireDefault(__webpack_require__(610));

var _UpdateExpression = _interopRequireDefault(__webpack_require__(611));

var _VariableDeclaration = _interopRequireDefault(__webpack_require__(612));

var _WhileStatement = _interopRequireDefault(__webpack_require__(613));

var _WithStatement = _interopRequireDefault(__webpack_require__(614));

var _YieldExpression = _interopRequireDefault(__webpack_require__(615));

var _JSXElement = _interopRequireDefault(__webpack_require__(616));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=index.js.map

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _iterator = __webpack_require__(272);

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 2.2.5.3
function _default(ast, strictCode, env, realm) {
  // 1. Let array be ArrayCreate(0).
  let array = _singletons.Create.ArrayCreate(realm, 0); // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.


  let elements = ast.elements || [];
  let len = elements.length;
  let nextIndex = 0;

  for (let i = 0; i < len; i++) {
    let elem = elements[i];

    if (!elem) {
      nextIndex++;
      continue;
    } // ECMA262 12.2.5.2


    if (elem.type === "SpreadElement") {
      // 1. Let spreadRef be the result of evaluating AssignmentExpression.
      let spreadRef = env.evaluate(elem.argument, strictCode); // 2. Let spreadObj be ? GetValue(spreadRef).

      let spreadObj = _singletons.Environment.GetValue(realm, spreadRef); // 3. Let iterator be ? GetIterator(spreadObj).


      let iterator = (0, _index2.GetIterator)(realm, spreadObj); // 4. Repeat

      while (true) {
        // a. Let next be ? IteratorStep(iterator).
        let next = (0, _iterator.IteratorStep)(realm, iterator); // b. If next is false, return nextIndex.

        if (next === false) break; // c. Let nextValue be ? IteratorValue(next).

        let nextValue = (0, _iterator.IteratorValue)(realm, next); // d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).

        let status = _singletons.Create.CreateDataProperty(realm, array, new _index.StringValue(realm, nextIndex++ + ""), nextValue); // e. Assert: status is true.


        (0, _invariant.default)(status === true); // f. Let nextIndex be nextIndex + 1.
      }
    } else {
      // Redundant steps.
      // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
      // 2. ReturnIfAbrupt(postIndex).
      // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
      // 4. Let initResult be the result of evaluating AssignmentExpression.
      let initResult = env.evaluate(elem, strictCode); // 5. Let initValue be ? GetValue(initResult).

      let initValue = _singletons.Environment.GetValue(realm, initResult); // 6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex+padding)), initValue).


      let created = _singletons.Create.CreateDataProperty(realm, array, new _index.StringValue(realm, nextIndex++ + ""), initValue); // 7. Assert: created is true.


      (0, _invariant.default)(created === true, "expected data property creation");
    }
  } // Not necessary since we propagate completions with exceptions.
  // 3. ReturnIfAbrupt(len).
  // 4. Perform Set(array, "length", ToUint32(len), false).


  _singletons.Properties.Set(realm, array, "length", new _index.NumberValue(realm, nextIndex), false); // 5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
  // 6. Return array.


  return array;
}
//# sourceMappingURL=ArrayExpression.js.map

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

var _strict = _interopRequireDefault(__webpack_require__(452));

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 14.2.16
function _default(ast, strictCode, env, realm) {
  let ConciseBody = ast.body;

  if (ConciseBody.type !== "BlockStatement") {
    ConciseBody = t.blockStatement([t.returnStatement(ConciseBody)]); // Use original array function's location for the new concise body.

    ConciseBody.loc = ast.body.loc;
  } // 1. If the function code for this ArrowFunction is strict mode code, let strict be true. Otherwise let strict be false.


  let strict = strictCode || (0, _strict.default)(ast.body); // 2. Let scope be the LexicalEnvironment of the running execution context.

  let scope = env; // 3. Let parameters be CoveredFormalsList of ArrowParameters.

  let parameters = ast.params; // 4. Let closure be FunctionCreate(Arrow, parameters, ConciseBody, scope, strict).

  let closure = _singletons.Functions.FunctionCreate(realm, "arrow", parameters, ConciseBody, scope, strict);

  closure.loc = ast.loc; // 5. Return closure.

  return closure;
}
//# sourceMappingURL=ArrowFunctionExpression.js.map

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _environment = __webpack_require__(20);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _BinaryExpression = __webpack_require__(292);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 12.15 Assignment Operators
function _default(ast, strictCode, env, realm) {
  if (!ast.hasOwnProperty("operator") || ast.operator === null) throw Error("Unexpected AST form");
  let LeftHandSideExpression = ast.left;
  let AssignmentExpression = ast.right;
  let AssignmentOperator = ast.operator; // AssignmentExpression : LeftHandSideExpression = AssignmentExpression

  if (AssignmentOperator === "=") {
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    //
    // The spec assumes we haven't yet distinguished between literals and
    // patterns, but our parser does that work for us. That means we check for
    // "*Pattern" instead of "*Literal" like the spec text suggests.
    if (LeftHandSideExpression.type !== "ObjectPattern" && LeftHandSideExpression.type !== "ArrayPattern") {
      // a. Let lref be the result of evaluating LeftHandSideExpression.
      let lref = env.evaluate(LeftHandSideExpression, strictCode); // b. ReturnIfAbrupt(lref). -- Not neccessary
      // c. Let rref be the result of evaluating AssignmentExpression.

      let rref = env.evaluate(AssignmentExpression, strictCode); // d. Let rval be ? GetValue(rref).

      let rval = _singletons.Environment.GetValue(realm, rref); // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then


      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, AssignmentExpression) && (0, _index2.IsIdentifierRef)(realm, LeftHandSideExpression)) {
        (0, _invariant.default)(rval instanceof _index.ObjectValue); // i. Let hasNameProperty be ? HasOwnProperty(rval, "name").

        let hasNameProperty = (0, _index2.HasOwnProperty)(realm, rval, "name"); // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).

        if (!hasNameProperty) {
          (0, _invariant.default)(lref instanceof _environment.Reference);

          _singletons.Functions.SetFunctionName(realm, rval, _singletons.Environment.GetReferencedName(realm, lref));
        }
      } // f. Perform ? PutValue(lref, rval).


      _singletons.Properties.PutValue(realm, lref, rval); // g. Return rval.


      return rval;
    } // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.


    let assignmentPattern = LeftHandSideExpression; // 3. Let rref be the result of evaluating AssignmentExpression.

    let rref = env.evaluate(AssignmentExpression, strictCode); // 4. Let rval be ? GetValue(rref).

    let rval = _singletons.Environment.GetValue(realm, rref); // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.


    (0, _index2.DestructuringAssignmentEvaluation)(realm, assignmentPattern, rval, strictCode, env); // 6. ReturnIfAbrupt(status).
    // 7. Return rval.

    return rval;
  } // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
  // 1. Let lref be the result of evaluating LeftHandSideExpression.


  let lref = env.evaluate(LeftHandSideExpression, strictCode); // 2. Let lval be ? GetValue(lref).

  let lval = _singletons.Environment.GetValue(realm, lref); // 3. Let rref be the result of evaluating AssignmentExpression.


  let rref = env.evaluate(AssignmentExpression, strictCode); // 4. Let rval be ? GetValue(rref).

  let rval = _singletons.Environment.GetValue(realm, rref); // 5. Let op be the @ where AssignmentOperator is @=.


  let op = AssignmentOperator.slice(0, -1); // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.

  let r = _singletons.Environment.GetValue(realm, (0, _BinaryExpression.computeBinary)(realm, op, lval, rval, ast.left.loc, ast.right.loc)); // 7. Perform ? PutValue(lref, r).


  _singletons.Properties.PutValue(realm, lref, r); // 8. Return r.


  return r;
}
//# sourceMappingURL=AssignmentExpression.js.map

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  throw new _errors.FatalError("TODO #712: AwaitExpression");
}
//# sourceMappingURL=AwaitExpression.js.map

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 13.2.13
function _default(ast, strictCode, env, realm) {
  // 1. Let oldEnv be the running execution context's LexicalEnvironment.
  let oldEnv = realm.getRunningContext().lexicalEnvironment; // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).

  let blockEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv); // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).


  _singletons.Environment.BlockDeclarationInstantiation(realm, strictCode, ast.body, blockEnv); // 4. Set the running execution context's LexicalEnvironment to blockEnv.


  realm.getRunningContext().lexicalEnvironment = blockEnv;

  try {
    // 5. Let blockValue be the result of evaluating StatementList.
    let blockValue;

    if (ast.directives) {
      for (let directive of ast.directives) {
        blockValue = new _index.StringValue(realm, directive.value.value);
      }
    }

    return _singletons.Functions.EvaluateStatements(ast.body, blockValue, strictCode, blockEnv, realm);
  } finally {
    // 6. Set the running execution context's LexicalEnvironment to oldEnv.
    realm.getRunningContext().lexicalEnvironment = oldEnv;
    realm.onDestroyScope(blockEnv);
  }
}
//# sourceMappingURL=BlockStatement.js.map

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  return new _index.BooleanValue(realm, ast.value);
}
//# sourceMappingURL=BooleanLiteral.js.map

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _completions = __webpack_require__(18);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  throw new _completions.BreakCompletion(realm.intrinsics.empty, ast.loc, ast.label && ast.label.name);
}
//# sourceMappingURL=BreakStatement.js.map

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

var _environment = __webpack_require__(20);

var _index = __webpack_require__(15);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _index3 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _SuperCall = _interopRequireDefault(__webpack_require__(571));

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(ast, strictCode, env, realm) {
  if (ast.callee.type === "Super") {
    return (0, _SuperCall.default)(ast.arguments, strictCode, env, realm);
  } // ECMA262 12.3.4.1
  // 1. Let ref be the result of evaluating MemberExpression.


  let ref = env.evaluate(ast.callee, strictCode);
  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);

  try {
    return evaluateReference(ref, ast, strictCode, env, realm);
  } finally {
    realm.setNextExecutionContextLocation(previousLoc);
  }
}

function getPrimitivePrototypeFromType(realm, value) {
  switch (value.getType()) {
    case _index2.IntegralValue:
    case _index2.NumberValue:
      return realm.intrinsics.NumberPrototype;

    case _index2.StringValue:
      return realm.intrinsics.StringPrototype;

    case _index2.BooleanValue:
      return realm.intrinsics.BooleanPrototype;

    case _index2.SymbolValue:
      return realm.intrinsics.SymbolPrototype;

    default:
      return undefined;
  }
}

function evaluateReference(ref, ast, strictCode, env, realm) {
  if (ref instanceof _environment.Reference && ref.base instanceof _index2.AbstractValue && // TODO: what about ref.base conditionals that mightBeObjects?
  ref.base.mightNotBeObject() && realm.isInPureScope()) {
    let base = ref.base;

    if (base.kind === "conditional") {
      let [condValue, consequentVal, alternateVal] = base.args;
      (0, _invariant.default)(condValue instanceof _index2.AbstractValue);
      return evaluateConditionalReferenceBase(ref, condValue, consequentVal, alternateVal, ast, strictCode, env, realm);
    } else if (base.kind === "||") {
      let [leftValue, rightValue] = base.args;
      (0, _invariant.default)(leftValue instanceof _index2.AbstractValue);
      return evaluateConditionalReferenceBase(ref, leftValue, leftValue, rightValue, ast, strictCode, env, realm);
    } else if (base.kind === "&&") {
      let [leftValue, rightValue] = base.args;
      (0, _invariant.default)(leftValue instanceof _index2.AbstractValue);
      return evaluateConditionalReferenceBase(ref, leftValue, rightValue, leftValue, ast, strictCode, env, realm);
    }

    let referencedName = ref.referencedName; // When dealing with a PrimitiveValue, like StringValue, NumberValue, IntegralValue etc
    // if we are referencing a prototype method, then it's safe to access, even
    // on an abstract value as the value is immutable and can't have a property
    // that matches the prototype method (unless the prototype was modified).
    // We assume the global prototype of built-ins has not been altered since
    // global code has finished. See #1233 for more context in regards to unmodified
    // global prototypes.

    let prototypeIfPrimitive = getPrimitivePrototypeFromType(realm, base);

    if (prototypeIfPrimitive !== undefined && typeof referencedName === "string") {
      let possibleMethodValue = prototypeIfPrimitive._SafeGetDataPropertyValue(referencedName);

      if (possibleMethodValue instanceof _index2.FunctionValue) {
        return EvaluateCall(ref, possibleMethodValue, ast, strictCode, env, realm);
      }
    } // avoid explicitly converting ref.base to an object because that will create a generator entry
    // leading to two object allocations rather than one.


    return realm.evaluateWithPossibleThrowCompletion(() => generateRuntimeCall(ref, base, ast, strictCode, env, realm), _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
  } // 2. Let func be ? GetValue(ref).


  let func = _singletons.Environment.GetValue(realm, ref);

  return EvaluateCall(ref, func, ast, strictCode, env, realm);
}

function evaluateConditionalReferenceBase(ref, condValue, consequentVal, alternateVal, ast, strictCode, env, realm) {
  return realm.evaluateWithAbstractConditional(condValue, () => {
    return realm.evaluateForEffects(() => {
      if ((0, _environment.isValidBaseValue)(consequentVal)) {
        let consequentRef = new _environment.Reference(consequentVal, ref.referencedName, ref.strict, ref.thisValue);
        return evaluateReference(consequentRef, ast, strictCode, env, realm);
      }

      return consequentVal;
    }, null, "evaluateConditionalReferenceBase consequent");
  }, () => {
    return realm.evaluateForEffects(() => {
      if ((0, _environment.isValidBaseValue)(alternateVal)) {
        let alternateRef = new _environment.Reference(alternateVal, ref.referencedName, ref.strict, ref.thisValue);
        return evaluateReference(alternateRef, ast, strictCode, env, realm);
      }

      return alternateVal;
    }, null, "evaluateConditionalReferenceBase alternate");
  });
}

function callBothFunctionsAndJoinTheirEffects(condValue, consequentVal, alternateVal, ast, strictCode, env, realm) {
  return realm.evaluateWithAbstractConditional(condValue, () => {
    return realm.evaluateForEffects(() => EvaluateCall(consequentVal, consequentVal, ast, strictCode, env, realm), null, "callBothFunctionsAndJoinTheirEffects consequent");
  }, () => {
    return realm.evaluateForEffects(() => EvaluateCall(alternateVal, alternateVal, ast, strictCode, env, realm), null, "callBothFunctionsAndJoinTheirEffects alternate");
  });
}

function generateRuntimeCall(ref, func, ast, strictCode, env, realm) {
  let args = [func];
  let [thisArg, propName] = ref instanceof _environment.Reference ? [ref.base, ref.referencedName] : [];
  if (thisArg instanceof _index2.Value) args = [thisArg];
  if (propName !== undefined && typeof propName !== "string") args.push(propName);
  args = args.concat((0, _index3.ArgumentListEvaluation)(realm, strictCode, env, ast.arguments));

  for (let arg of args) {
    if (arg !== func) {
      // Since we don't know which function we are calling, we assume that any unfrozen object
      // passed as an argument has leaked to the environment as is any other object that is known to be reachable from this object.
      // NB: Note that this is still optimistic, particularly if the environment exposes the same object
      // to Prepack via alternative means, thus creating aliasing that is not tracked by Prepack.
      _singletons.Leak.value(realm, arg, ast.loc);
    }
  }

  let resultType = (func instanceof _index2.AbstractObjectValue ? func.functionResultType : undefined) || _index2.Value;
  return _index2.AbstractValue.createTemporalFromBuildFunction(realm, resultType, args, (0, _generator.createOperationDescriptor)("CALL_BAILOUT", {
    propRef: propName,
    thisArg
  }));
}

function tryToEvaluateCallOrLeaveAsAbstract(ref, func, ast, strictCode, env, realm, thisValue, tailCall) {
  (0, _invariant.default)(!realm.instantRender.enabled);
  let effects;
  let savedSuppressDiagnostics = realm.suppressDiagnostics;

  try {
    realm.suppressDiagnostics = !(func instanceof _index2.NativeFunctionValue) || func.name !== "__optimize";
    effects = realm.evaluateForEffects(() => (0, _index3.EvaluateDirectCall)(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall), undefined, "tryToEvaluateCallOrLeaveAsAbstract");
  } catch (error) {
    if (error instanceof _errors.FatalError) {
      if (func instanceof _index2.NativeFunctionValue && func.name === "__fatal") throw error;
      realm.suppressDiagnostics = savedSuppressDiagnostics;

      _singletons.Leak.value(realm, func, ast.loc);

      return realm.evaluateWithPossibleThrowCompletion(() => generateRuntimeCall(ref, func, ast, strictCode, env, realm), _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
    } else {
      throw error;
    }
  } finally {
    realm.suppressDiagnostics = savedSuppressDiagnostics;
  }

  realm.applyEffects(effects);
  return realm.returnOrThrowCompletion(effects.result);
}

function EvaluateCall(ref, func, ast, strictCode, env, realm) {
  if (func instanceof _index2.AbstractValue) {
    let loc = ast.callee.type === "MemberExpression" ? ast.callee.property.loc : ast.callee.loc;

    if (func.kind === "conditional") {
      let [condValue, consequentVal, alternateVal] = func.args;
      (0, _invariant.default)(condValue instanceof _index2.AbstractValue); // If neither values are functions than do not try and call both functions with a conditional

      if (_index2.Value.isTypeCompatibleWith(consequentVal.getType(), _index2.FunctionValue) || _index2.Value.isTypeCompatibleWith(alternateVal.getType(), _index2.FunctionValue)) {
        return callBothFunctionsAndJoinTheirEffects(condValue, consequentVal, alternateVal, ast, strictCode, env, realm);
      }
    } else if (func.kind === "||") {
      let [leftValue, rightValue] = func.args;
      (0, _invariant.default)(leftValue instanceof _index2.AbstractValue); // If neither values are functions than do not try and call both functions with a conditional

      if (_index2.Value.isTypeCompatibleWith(leftValue.getType(), _index2.FunctionValue) || _index2.Value.isTypeCompatibleWith(rightValue.getType(), _index2.FunctionValue)) {
        return callBothFunctionsAndJoinTheirEffects(leftValue, leftValue, rightValue, ast, strictCode, env, realm);
      }
    } else if (func.kind === "&&") {
      let [leftValue, rightValue] = func.args;
      (0, _invariant.default)(leftValue instanceof _index2.AbstractValue); // If neither values are functions than do not try and call both functions with a conditional

      if (_index2.Value.isTypeCompatibleWith(leftValue.getType(), _index2.FunctionValue) || _index2.Value.isTypeCompatibleWith(rightValue.getType(), _index2.FunctionValue)) {
        return callBothFunctionsAndJoinTheirEffects(leftValue, rightValue, leftValue, ast, strictCode, env, realm);
      }
    }

    if (!_index2.Value.isTypeCompatibleWith(func.getType(), _index2.FunctionValue)) {
      if (!realm.isInPureScope()) {
        // If this is not a function, this call might throw which can change the state of the program.
        // If this is called from a pure function we handle it using evaluateWithPossiblyAbruptCompletion.
        let error = new _errors.CompilerDiagnostic("might not be a function", loc, "PP0005", "RecoverableError");
        if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
      }
    } else {// Assume that it is a safe function. TODO #705: really?
    }

    if (realm.isInPureScope()) {
      // In pure functions we allow abstract functions to throw, which this might.
      return realm.evaluateWithPossibleThrowCompletion(() => generateRuntimeCall(ref, func, ast, strictCode, env, realm), _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
    }

    return generateRuntimeCall(ref, func, ast, strictCode, env, realm);
  }

  (0, _invariant.default)(func instanceof _index2.ConcreteValue); // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is "eval", then

  if (ref instanceof _environment.Reference && !_singletons.Environment.IsPropertyReference(realm, ref) && _singletons.Environment.GetReferencedName(realm, ref) === "eval") {
    // a. If SameValue(func, %eval%) is true, then
    if ((0, _index3.SameValue)(realm, func, realm.intrinsics.eval)) {
      // i. Let argList be ? ArgumentListEvaluation(Arguments).
      let argList = (0, _index3.ArgumentListEvaluation)(realm, strictCode, env, ast.arguments); // ii. If argList has no elements, return undefined.

      if (argList.length === 0) return realm.intrinsics.undefined; // iii. Let evalText be the first element of argList.

      let evalText = argList[0]; // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.

      let strictCaller = strictCode; // v. Let evalRealm be the current Realm Record.

      let evalRealm = realm; // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).

      if (evalText instanceof _index2.AbstractValue) {
        let loc = ast.arguments[0].loc;
        let error = new _errors.CompilerDiagnostic("eval argument must be a known value", loc, "PP0006", "RecoverableError");
        if (realm.handleError(error) === "Fail") throw new _errors.FatalError(); // Assume that it is a safe eval with no visible heap changes or abrupt control flow.

        return generateRuntimeCall(ref, func, ast, strictCode, env, realm);
      }

      return _singletons.Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);
    }
  }

  let thisValue; // 4. If Type(ref) is Reference, then

  if (ref instanceof _environment.Reference) {
    // a. If IsPropertyReference(ref) is true, then
    if (_singletons.Environment.IsPropertyReference(realm, ref)) {
      // i. Let thisValue be GetThisValue(ref).
      thisValue = (0, _index3.GetThisValue)(realm, ref);
    } else {
      // b. Else, the base of ref is an Environment Record
      // i. Let refEnv be GetBase(ref).
      let refEnv = _singletons.Environment.GetBase(realm, ref);

      (0, _invariant.default)(refEnv instanceof _environment.EnvironmentRecord); // ii. Let thisValue be refEnv.WithBaseObject().

      thisValue = refEnv.WithBaseObject();
    }
  } else {
    // 5. Else Type(ref) is not Reference,
    // a. Let thisValue be undefined.
    thisValue = realm.intrinsics.undefined;
  } // 6. Let thisCall be this CallExpression.


  let thisCall = ast; // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)

  let tailCall = (0, _index3.IsInTailPosition)(realm, thisCall); // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).

  if (realm.isInPureScope() && !realm.instantRender.enabled) {
    return tryToEvaluateCallOrLeaveAsAbstract(ref, func, ast, strictCode, env, realm, thisValue, tailCall);
  } else {
    return (0, _index3.EvaluateDirectCall)(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);
  }
}
//# sourceMappingURL=CallExpression.js.map

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SuperCall;

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function GetSuperConstructor(realm) {
  // 1. Let envRec be GetThisEnvironment( ).
  let envRec = _singletons.Environment.GetThisEnvironment(realm); // 2. Assert: envRec is a function Environment Record.


  (0, _invariant.default)(envRec instanceof _environment.FunctionEnvironmentRecord); // 3. Let activeFunction be envRec.[[FunctionObject]].

  let activeFunction = envRec.$FunctionObject; // 4. Let superConstructor be activeFunction.[[GetPrototypeOf]]().

  let superConstructor = activeFunction.$GetPrototypeOf(); // 5. ReturnIfAbrupt(superConstructor).
  // 6. If IsConstructor(superConstructor) is false, throw a TypeError exception.

  if (!(0, _index2.IsConstructor)(realm, superConstructor)) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "super called outside of constructor");
  }

  (0, _invariant.default)(superConstructor instanceof _index.ObjectValue); // 7. Return superConstructor.

  return superConstructor;
} // ECMA262 12.3.5.1


function SuperCall(Arguments, strictCode, env, realm) {
  // 1. Let newTarget be GetNewTarget().
  let newTarget = (0, _index2.GetNewTarget)(realm); // 2. If newTarget is undefined, throw a ReferenceError exception.

  if (newTarget instanceof _index.UndefinedValue) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, "newTarget is undefined");
  } // 3. Let func be GetSuperConstructor().


  let func = GetSuperConstructor(realm); // 4. ReturnIfAbrupt(func).
  // 5. Let argList be ArgumentListEvaluation of Arguments.

  let argList = (0, _index2.ArgumentListEvaluation)(realm, strictCode, env, Arguments); // 6. ReturnIfAbrupt(argList).
  // 7. Let result be Construct(func, argList, newTarget).

  let result = (0, _index2.Construct)(realm, func, argList, newTarget).throwIfNotConcreteObject(); // 8. ReturnIfAbrupt(result).
  // 9. Let thisER be GetThisEnvironment( ).

  let thisER = _singletons.Environment.GetThisEnvironment(realm); // 10. Return thisER.BindThisValue(result).


  return thisER.BindThisValue(result);
}
//# sourceMappingURL=SuperCall.js.map

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECAM262 13.15.7
function _default(ast, strictCode, env, realm, thrownValue) {
  (0, _invariant.default)(thrownValue instanceof _completions.ThrowCompletion, "Metadata isn't a throw completion"); // 1. Let oldEnv be the running execution context's LexicalEnvironment.

  let oldEnv = realm.getRunningContext().lexicalEnvironment; // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).

  let catchEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv); // 3. Let catchEnvRec be catchEnv's EnvironmentRecord.


  let catchEnvRec = catchEnv.environmentRecord; // 4. For each element argName of the BoundNames of CatchParameter, do

  for (let argName of _singletons.Environment.BoundNames(realm, ast.param)) {
    // a. Perform ! catchEnvRec.CreateMutableBinding(argName, false).
    catchEnvRec.CreateMutableBinding(argName, false);
  } // 5. Set the running execution context's LexicalEnvironment to catchEnv.


  realm.getRunningContext().lexicalEnvironment = catchEnv;

  try {
    // 6. Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.
    _singletons.Environment.BindingInitialization(realm, ast.param, thrownValue.value, strictCode, catchEnv); // 7. If status is an abrupt completion, then
    // a. Set the running execution context's LexicalEnvironment to oldEnv.
    // b. Return Completion(status).
    // 8. Let B be the result of evaluating Block.


    let B = catchEnv.evaluate(ast.body, strictCode);
    (0, _invariant.default)(B instanceof _index.Value); // 10. Return Completion(B).

    return B;
  } finally {
    // 9. Set the running execution context's LexicalEnvironment to oldEnv.
    realm.getRunningContext().lexicalEnvironment = oldEnv;
    realm.onDestroyScope(catchEnv);
  }
}
//# sourceMappingURL=CatchClause.js.map

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(232);

var _ClassDeclaration = __webpack_require__(574);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 14.5.16
function _default(ast, strictCode, env, realm) {
  // 1. If BindingIdentifieropt is not present, let className be undefined.
  let className; // 2. Else, let className be StringValue of BindingIdentifier.

  if (ast.id != null) {
    className = ast.id.name;
  } // 3. Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.


  let value = (0, _ClassDeclaration.ClassDefinitionEvaluation)(realm, ast, className, strictCode, env); // 4. ReturnIfAbrupt(value).
  // 5. If className is not undefined, then

  if (className !== undefined) {
    // a. Let hasNameProperty be HasOwnProperty(value, "name").
    let hasNameProperty = (0, _index.HasOwnProperty)(realm, value, "name"); // b. ReturnIfAbrupt(hasNameProperty).
    // c. If hasNameProperty is false, then

    if (!hasNameProperty) {
      // i. Perform SetFunctionName(value, className).
      _singletons.Functions.SetFunctionName(realm, value, className);
    }
  } // 6. Return NormalCompletion(value).


  return value;
}
//# sourceMappingURL=ClassExpression.js.map

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClassDefinitionEvaluation = ClassDefinitionEvaluation;
exports.default = _default;

var _index = __webpack_require__(10);

var _errors = __webpack_require__(3);

var _parse = _interopRequireDefault(__webpack_require__(227));

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function EvaluateClassHeritage(realm, ClassHeritage, strictCode) {
  let ref = realm.getRunningContext().lexicalEnvironment.evaluate(ClassHeritage, strictCode);

  let val = _singletons.Environment.GetValue(realm, ref);

  if (val instanceof _index.AbstractValue) {
    let error = new _errors.CompilerDiagnostic("unknown super class", ClassHeritage.loc, "PP0009", "RecoverableError");
    if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
  }

  if (!(val instanceof _index.ObjectValue)) {
    return null;
  }

  return val;
} // ECMA262 14.5.14


function ClassDefinitionEvaluation(realm, ast, className, strictCode, env) {
  // 1. Let lex be the LexicalEnvironment of the running execution context.
  let lex = env; // 2. Let classScope be NewDeclarativeEnvironment(lex).

  let classScope = _singletons.Environment.NewDeclarativeEnvironment(realm, lex);

  let F;

  try {
    // 3. Let classScopeEnvRec be classScopes EnvironmentRecord.
    let classScopeEnvRec = classScope.environmentRecord; // 4. If className is not undefined, then

    if (className !== undefined) {
      // a. Perform classScopeEnvRec.CreateImmutableBinding(className, true).
      classScopeEnvRec.CreateImmutableBinding(className, true);
    }

    let protoParent;
    let constructorParent; // 5. If ClassHeritage opt is not present, then

    let ClassHeritage = ast.superClass;

    if (!ClassHeritage) {
      // a. Let protoParent be the intrinsic object %ObjectPrototype%.
      protoParent = realm.intrinsics.ObjectPrototype; // b. Let constructorParent be the intrinsic object %FunctionPrototype%.

      constructorParent = realm.intrinsics.FunctionPrototype;
    } else {
      // 6. Else
      // a. Set the running execution contexts LexicalEnvironment to classScope.
      realm.getRunningContext().lexicalEnvironment = classScope;
      let superclass = null;

      try {
        // b. Let superclass be the result of evaluating ClassHeritage.
        superclass = EvaluateClassHeritage(realm, ClassHeritage, strictCode);
      } finally {
        // c. Set the running execution contexts LexicalEnvironment to lex.
        realm.getRunningContext().lexicalEnvironment = lex;
      } // d. ReturnIfAbrupt(superclass).
      // e. If superclass is null, then


      if (superclass === null) {
        // i. Let protoParent be null.
        protoParent = realm.intrinsics.null; // ii. Let constructorParent be the intrinsic object %FunctionPrototype%.

        constructorParent = realm.intrinsics.FunctionPrototype;
      } else if (!(0, _index2.IsConstructor)(realm, superclass)) {
        // f. Else if IsConstructor(superclass) is false, throw a TypeError exception.
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "superclass must be a constructor");
      } else {
        // g. Else
        // i. If superclass has a [[FunctionKind]] internal slot whose value is "generator", throw a TypeError exception.
        if (superclass instanceof _index.ECMAScriptFunctionValue && superclass.$FunctionKind === "generator") {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "superclass cannot be a generator");
        } // ii. Let protoParent be Get(superclass, "prototype").


        protoParent = (0, _index2.Get)(realm, superclass, "prototype"); // iii. ReturnIfAbrupt(protoParent).
        // iv. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.

        if (!(protoParent instanceof _index.ObjectValue || protoParent instanceof _index.NullValue)) {
          if (protoParent instanceof _index.AbstractValue) {
            let error = new _errors.CompilerDiagnostic("unknown super class prototype", ClassHeritage.loc, "PP0010", "RecoverableError");
            if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
            protoParent = realm.intrinsics.ObjectPrototype;
          } else {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "protoParent must be an instance of Object or Null");
          }
        } // v. Let constructorParent be superclass.


        constructorParent = superclass;
      }
    } // 7. Let proto be ObjectCreate(protoParent).


    let proto = _singletons.Create.ObjectCreate(realm, protoParent); // Provide a hint that this prototype is that of a class


    proto.$IsClassPrototype = true;
    let constructor;
    let emptyConstructor = false;
    let ClassBody = [];

    for (let elem of ast.body.body) {
      if (elem.type === "ClassMethod") {
        ClassBody.push(elem);
      }
    } // 8. If ClassBody opt is not present, let constructor be empty.


    if (ClassBody.length === 0) {
      emptyConstructor = true;
      constructor = realm.intrinsics.empty;
    } else {
      // 9. Else, let constructor be ConstructorMethod of ClassBody.
      constructor = (0, _index2.ConstructorMethod)(realm, ClassBody);
    } // 10. If constructor is empty, then,


    if (constructor instanceof _index.EmptyValue) {
      emptyConstructor = true;
      let constructorFile; // a. If ClassHeritage opt is present, then

      if (ast.superClass) {
        // i. Let constructor be the result of parsing the source text
        //     constructor(... args){ super (...args);}
        // using the syntactic grammar with the goal symbol MethodDefinition.
        constructorFile = (0, _parse.default)(realm, "class NeedClassForParsing { constructor(... args){ super (...args);} }", "");
      } else {
        // b. Else,
        // i. Let constructor be the result of parsing the source text
        //     constructor( ){ }
        // using the syntactic grammar with the goal symbol MethodDefinition.
        constructorFile = (0, _parse.default)(realm, "class NeedClassForParsing { constructor( ){ } }", "");
      }

      let {
        program: {
          body: [classDeclaration]
        }
      } = constructorFile;
      (0, _invariant.default)(classDeclaration.type === "ClassDeclaration");
      let {
        body
      } = classDeclaration;
      (0, _invariant.default)(body.body[0].type === "ClassMethod");
      constructor = body.body[0];
    } // 11. Set the running execution contexts LexicalEnvironment to classScope.


    realm.getRunningContext().lexicalEnvironment = classScope;

    try {
      // 12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.
      let constructorInfo = _singletons.Functions.DefineMethod(realm, constructor, proto, env, strictCode, constructorParent); // 13. Assert: constructorInfo is not an abrupt completion.
      // 14. Let F be constructorInfo.[[closure]]


      F = constructorInfo.$Closure; // Assign the empty constructor boolean

      F.$HasEmptyConstructor = emptyConstructor; // 15. If ClassHeritage opt is present, set Fs [[ConstructorKind]] internal slot to "derived".

      if (ast.superClass) {
        F.$ConstructorKind = "derived";
      } // 16. Perform MakeConstructor(F, false, proto).


      (0, _index2.MakeConstructor)(realm, F, false, proto); // 17. Perform MakeClassConstructor(F).

      (0, _index2.MakeClassConstructor)(realm, F); // 18. Perform CreateMethodProperty(proto, "constructor", F).

      _singletons.Create.CreateMethodProperty(realm, proto, "constructor", F);

      let methods; // 19. If ClassBody opt is not present, let methods be a new empty List.

      if (ClassBody.length === 0) {
        methods = [];
      } else {
        // 20. Else, let methods be NonConstructorMethodDefinitions of ClassBody.
        methods = (0, _index2.NonConstructorMethodDefinitions)(realm, ClassBody);
      } // 21. For each ClassElement m in order from methods


      for (let m of methods) {
        // a. If IsStatic of m is false, then
        if (!(0, _index2.IsStatic)(m)) {
          // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.
          _singletons.Properties.PropertyDefinitionEvaluation(realm, m, proto, env, strictCode, false);
        } else {
          // Else,
          // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.
          _singletons.Properties.PropertyDefinitionEvaluation(realm, m, F, env, strictCode, false);
        } // c. If status is an abrupt completion, then
        // i. Set the running execution context's LexicalEnvironment to lex.
        // ii. Return Completion(status).

      }
    } finally {
      // 22. Set the running execution contexts LexicalEnvironment to lex.
      realm.getRunningContext().lexicalEnvironment = lex;
    } // 23. If className is not undefined, then


    if (className !== undefined) {
      // Perform classScopeEnvRec.InitializeBinding(className, F).
      classScopeEnvRec.InitializeBinding(className, F);
    }
  } finally {
    realm.onDestroyScope(classScope);
  } // Return F.


  return F;
} // ECMA2 14.5.15


function BindingClassDeclarationEvaluation(realm, ast, strictCode, env) {
  // ClassDeclaration : class BindingIdentifier ClassTail
  if (ast.id) {
    // 1. Let className be StringValue of BindingIdentifier.
    let className = ast.id.name; // 2. Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.

    let value = ClassDefinitionEvaluation(realm, ast, className, strictCode, env); // 3. ReturnIfAbrupt(value).
    // 4. Let hasNameProperty be HasOwnProperty(value, "name").

    let hasNameProperty = (0, _index2.HasOwnProperty)(realm, value, "name"); // 5. ReturnIfAbrupt(hasNameProperty).
    // 6. If hasNameProperty is false, then perform SetFunctionName(value, className).

    if (hasNameProperty === false) {
      _singletons.Functions.SetFunctionName(realm, value, className);
    } // 7. Let env be the running execution contexts LexicalEnvironment.
    // 8. Let status be InitializeBoundName(className, value, env).


    _singletons.Environment.InitializeBoundName(realm, className, value, env); // 9. ReturnIfAbrupt(status).
    // 10. Return value.


    return value;
  } else {
    // ClassDeclaration : class ClassTail
    // 1. Return the result of ClassDefinitionEvaluation of ClassTail with argument undefined.
    return ClassDefinitionEvaluation(realm, ast, undefined, strictCode, env);
  }
} // ECMA262 14.5.16


function _default(ast, strictCode, env, realm) {
  // 1. Let status be the result of BindingClassDeclarationEvaluation of this ClassDeclaration.
  BindingClassDeclarationEvaluation(realm, ast, strictCode, env); // 2. ReturnIfAbrupt(status).
  // 3. Return NormalCompletion(empty).

  return realm.intrinsics.empty;
}
//# sourceMappingURL=ClassDeclaration.js.map

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _realm = __webpack_require__(7);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  let exprRef = env.evaluate(ast.test, strictCode);

  let exprValue = _singletons.Environment.GetConditionValue(realm, exprRef);

  if (exprValue instanceof _index.ConcreteValue) {
    if (_singletons.To.ToBoolean(realm, exprValue)) {
      return env.evaluate(ast.consequent, strictCode);
    } else {
      return env.evaluate(ast.alternate, strictCode);
    }
  }

  (0, _invariant.default)(exprValue instanceof _index.AbstractValue);
  const consequent = ast.consequent;
  const alternate = ast.alternate;
  if (!exprValue.mightNotBeTrue()) return env.evaluate(consequent, strictCode);
  if (!exprValue.mightNotBeFalse()) return env.evaluate(alternate, strictCode);
  return realm.evaluateWithAbstractConditional(exprValue, () => realm.evaluateNodeForEffects(consequent, strictCode, env), () => alternate ? realm.evaluateNodeForEffects(alternate, strictCode, env) : (0, _realm.construct_empty_effects)(realm));
}
//# sourceMappingURL=ConditionalExpression.js.map

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _completions = __webpack_require__(18);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  throw new _completions.ContinueCompletion(realm.intrinsics.empty, ast.loc, ast.label && ast.label.name);
}
//# sourceMappingURL=ContinueStatement.js.map

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  let r = env.evaluate(ast.value, strictCode);
  (0, _invariant.default)(r instanceof _index.Value);
  return r;
}
//# sourceMappingURL=Directive.js.map

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _StringLiteral.default;
  }
});

var _StringLiteral = _interopRequireDefault(__webpack_require__(579));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=DirectiveLiteral.js.map

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  return new _index.StringValue(realm, ast.value);
}
//# sourceMappingURL=StringLiteral.js.map

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _BlockStatement.default;
  }
});

var _BlockStatement = _interopRequireDefault(__webpack_require__(567));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=DoExpression.js.map

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _ForOfStatement = __webpack_require__(582);

var _completions = __webpack_require__(18);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(ast, strictCode, env, realm, labelSet) {
  let {
    body,
    test
  } = ast; // 1. Let V be undefined.

  let V = realm.intrinsics.undefined; // 2. Repeat

  let resultOrDiagnostic = realm.evaluateWithUndoForDiagnostic(() => {
    while (true) {
      // a. Let stmt be the result of evaluating Statement.
      let stmt = env.evaluateCompletion(body, strictCode); //todo: check if stmt is JoinedNormalAndAbruptCompletions and defer to fixpoint computation below

      (0, _invariant.default)(stmt instanceof _index.Value || stmt instanceof _completions.AbruptCompletion); // b. If LoopContinues(stmt, labelSet) is false, return Completion(UpdateEmpty(stmt, V)).

      if ((0, _ForOfStatement.LoopContinues)(realm, stmt, labelSet) === false) {
        (0, _invariant.default)(stmt instanceof _completions.AbruptCompletion); // ECMA262 13.1.7

        if (stmt instanceof _completions.BreakCompletion) {
          if (!stmt.target) return (0, _index2.UpdateEmpty)(realm, stmt, V).value;
        }

        throw (0, _index2.UpdateEmpty)(realm, stmt, V);
      } // c. If stmt.[[Value]] is not empty, let V be stmt.[[Value]].


      let resultValue = (0, _ForOfStatement.InternalGetResultValue)(realm, stmt);
      if (!(resultValue instanceof _index.EmptyValue)) V = resultValue; // d. Let exprRef be the result of evaluating Expression.

      let exprRef = env.evaluate(test, strictCode); // e. Let exprValue be ? GetValue(exprRef).

      let exprValue = _singletons.Environment.GetConditionValue(realm, exprRef); // f. If ToBoolean(exprValue) is false, return NormalCompletion(V).


      if (_singletons.To.ToBooleanPartial(realm, exprValue) === false) return V;
    }

    (0, _invariant.default)(false);
  });
  if (resultOrDiagnostic instanceof _index.Value) return resultOrDiagnostic; // If we get here then unrolling the loop did not work, possibly because the value of the loop condition is not known,
  // so instead try to compute a fixpoint for it

  let iteration = () => {
    let bodyResult = env.evaluateCompletion(body, strictCode);
    if (bodyResult instanceof _index.Value) bodyResult = new _completions.SimpleNormalCompletion(bodyResult);
    let exprRef = env.evaluate(test, strictCode);

    let testResult = _singletons.Environment.GetConditionValue(realm, exprRef);

    return [testResult, bodyResult];
  };

  let result = realm.evaluateForFixpointEffects(iteration);

  if (result !== undefined) {
    let [outsideEffects, insideEffects, cond] = result;
    let rval = outsideEffects.result;
    let bodyGenerator = insideEffects.generator;
    realm.applyEffects(outsideEffects);
    let generator = realm.generator;
    (0, _invariant.default)(generator !== undefined);
    generator.emitDoWhileStatement(cond, bodyGenerator);
    (0, _invariant.default)(rval instanceof _completions.SimpleNormalCompletion, "todo: handle loops that throw exceptions or return");
    return rval.value;
  } // If we get here the fixpoint computation failed as well. Report the diagnostic from the unrolling and throw.


  realm.handleError(resultOrDiagnostic);
  throw new _errors.FatalError();
}
//# sourceMappingURL=DoWhileStatement.js.map

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternalGetResultValue = InternalGetResultValue;
exports.LoopContinues = LoopContinues;
exports.ForInOfHeadEvaluation = ForInOfHeadEvaluation;
exports.ForInOfBodyEvaluation = ForInOfBodyEvaluation;
exports.default = _default;

var _errors = __webpack_require__(3);

var _environment = __webpack_require__(20);

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function InternalGetResultValue(realm, result) {
  if (result instanceof _completions.Completion) {
    return result.value;
  } else {
    return result;
  }
} // ECMA262 13.7.1.2


function LoopContinues(realm, completion, labelSet) {
  // 1. If completion.[[Type]] is normal, return true.
  if (completion instanceof _index.Value || completion instanceof _completions.NormalCompletion) return true;

  if (completion instanceof _completions.JoinedAbruptCompletions) {
    return LoopContinues(realm, completion.consequent, labelSet) || LoopContinues(realm, completion.alternate, labelSet);
  } // 2. If completion.[[Type]] is not continue, return false.


  if (!(completion instanceof _completions.ContinueCompletion)) return false; // 3. If completion.[[Target]] is empty, return true.

  if (!completion.target) return true; // 4. If completion.[[Target]] is an element of labelSet, return true.

  if (labelSet != null && labelSet.indexOf(completion.target) >= 0) return true; // 5. Return false.

  return false;
} // ECMA262 13.7.5.10


function BindingInstantiation(realm, ast, env) {
  // ast = ForDeclaration : LetOrConst ForBinding
  // 1. Let envRec be environment's EnvironmentRecord.
  let envRec = env.environmentRecord; // 2. Assert: envRec is a declarative Environment Record.

  (0, _invariant.default)(envRec instanceof _environment.DeclarativeEnvironmentRecord); // 3. For each element name of the BoundNames of ForBinding do

  for (let name of _singletons.Environment.BoundNames(realm, ast)) {
    // a. If IsConstantDeclaration of LetOrConst is true, then
    if (ast.kind === "const") {
      // i. Perform ! envRec.CreateImmutableBinding(name, true).
      envRec.CreateImmutableBinding(name, true);
    } else {
      // b.
      // i. Perform ! envRec.CreateMutableBinding(name, false).
      envRec.CreateMutableBinding(name, false);
    }
  }
} // ECMA262 13.7.5.12


function ForInOfHeadEvaluation(realm, env, TDZnames, expr, iterationKind, strictCode) {
  // 1. Let oldEnv be the running execution context's LexicalEnvironment.
  let oldEnv = realm.getRunningContext().lexicalEnvironment; // 2. If TDZnames is not an empty List, then

  if (TDZnames.length) {
    // a. Assert: TDZnames has no duplicate entries.
    // b. Let TDZ be NewDeclarativeEnvironment(oldEnv).
    let TDZ = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv); // c. Let TDZEnvRec be TDZ's EnvironmentRecord.


    let TDZEnvRec = TDZ.environmentRecord; // d. For each string name in TDZnames, do

    for (let name of TDZnames) {
      // i. Perform ! TDZEnvRec.CreateMutableBinding(name, false).
      TDZEnvRec.CreateMutableBinding(name, false);
    } // e. Set the running execution context's LexicalEnvironment to TDZ.


    realm.getRunningContext().lexicalEnvironment = TDZ;
    env = TDZ;
  }

  let exprRef;

  try {
    // 3. Let exprRef be the result of evaluating expr.
    exprRef = env.evaluate(expr, strictCode);
  } finally {
    // 4. Set the running execution context's LexicalEnvironment to oldEnv.
    let lexEnv = realm.getRunningContext().lexicalEnvironment;
    if (lexEnv !== oldEnv) realm.onDestroyScope(lexEnv);
    realm.getRunningContext().lexicalEnvironment = oldEnv;
  }

  env = oldEnv; // 5. Let exprValue be ? GetValue(exprRef).

  let exprValue = _singletons.Environment.GetValue(realm, exprRef); // 6. If iterationKind is enumerate, then


  if (iterationKind === "enumerate") {
    // a. If exprValue.[[Value]] is null or undefined, then
    if (exprValue instanceof _index.NullValue || exprValue instanceof _index.UndefinedValue) {
      // i. Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.
      throw new _completions.BreakCompletion(realm.intrinsics.empty, expr.loc, null);
    } // b. Let obj be ToObject(exprValue).


    let obj = _singletons.To.ToObject(realm, exprValue); // c. Return ? EnumerateObjectProperties(obj).


    if (obj.isPartialObject() || obj instanceof _index.AbstractObjectValue) {
      return obj;
    } else {
      return _singletons.Properties.EnumerateObjectProperties(realm, obj);
    }
  } else {
    // 8. Else,
    // 1. Assert: iterationKind is iterate.
    (0, _invariant.default)(iterationKind === "iterate", "expected iterationKind to be iterate");

    if (exprValue instanceof _index.AbstractValue) {
      let error = new _errors.CompilerDiagnostic("for of loops over unknown collections are not yet supported", expr.loc, "PP0014", "FatalError");
      realm.handleError(error);
      throw new _errors.FatalError();
    } // 1. Return ? GetIterator(exprValue).


    return (0, _index2.GetIterator)(realm, exprValue);
  }
} // ECMA262 13.7.5.13


function ForInOfBodyEvaluation(realm, env, lhs, stmt, iterator, lhsKind, labelSet, strictCode) {
  // 1. Let oldEnv be the running execution context's LexicalEnvironment.
  let oldEnv = realm.getRunningContext().lexicalEnvironment; // 2. Let V be undefined.

  let V = realm.intrinsics.undefined; // 3. Let destructuring be IsDestructuring of lhs.

  let destructuring = _singletons.Environment.IsDestructuring(lhs); // 4. If destructuring is true and if lhsKind is assignment, then


  if (destructuring && lhsKind === "assignment") {
    // a. Assert: lhs is a LeftHandSideExpression.
    (0, _invariant.default)(lhs.type !== "VariableDeclaration"); // b. Let assignmentPattern be the parse of the source text corresponding to lhs using AssignmentPattern as the goal symbol.
  } // 5. Repeat


  while (true) {
    // a. Let nextResult be ? IteratorStep(iterator).
    let nextResult = (0, _index2.IteratorStep)(realm, iterator); // b. If nextResult is false, return NormalCompletion(V).

    if (!nextResult) return V; // c. Let nextValue be ? IteratorValue(nextResult).

    let nextValue = (0, _index2.IteratorValue)(realm, nextResult); // d. If lhsKind is either assignment or varBinding, then

    let iterationEnv;
    let lhsRef;

    if (lhsKind === "assignment" || lhsKind === "varBinding") {
      // i. If destructuring is false, then
      if (!destructuring) {
        // 1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)
        lhsRef = env.evaluateCompletion(lhs, strictCode);
      }
    } else {
      // e. Else,
      // i. Assert: lhsKind is lexicalBinding.
      (0, _invariant.default)(lhsKind === "lexicalBinding", "expected lhsKind to be lexicalBinding");
      (0, _invariant.default)(lhs.type === "VariableDeclaration"); // ii. Assert: lhs is a ForDeclaration.
      // iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).

      iterationEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv); // iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.

      BindingInstantiation(realm, lhs, iterationEnv); // v. Set the running execution context's LexicalEnvironment to iterationEnv.

      realm.getRunningContext().lexicalEnvironment = iterationEnv;
      env = iterationEnv; // vi. If destructuring is false, then

      if (!destructuring) {
        let names = _singletons.Environment.BoundNames(realm, lhs); // 1. Assert: lhs binds a single name.


        (0, _invariant.default)(names.length === 1, "expected single name"); // 2. Let lhsName be the sole element of BoundNames of lhs.

        let lhsName = names[0]; // 3. Let lhsRef be ! ResolveBinding(lhsName).

        lhsRef = _singletons.Environment.ResolveBinding(realm, lhsName, strictCode);
      }
    } // f. If destructuring is false, then


    let status;

    try {
      if (!destructuring) {
        // i. If lhsRef is an abrupt completion, then
        if (lhsRef instanceof _completions.AbruptCompletion) {
          // 1. Let status be lhsRef.
          status = lhsRef;
        } else if (lhsKind === "lexicalBinding") {
          // ii. Else if lhsKind is lexicalBinding, then
          // 1. Let status be InitializeReferencedBinding(lhsRef, nextValue).
          (0, _invariant.default)(lhsRef instanceof _environment.Reference);
          status = _singletons.Environment.InitializeReferencedBinding(realm, lhsRef, nextValue);
        } else {
          // iii. Else,
          // 1. Let status be PutValue(lhsRef, nextValue).
          (0, _invariant.default)(lhsRef !== undefined);
          status = _singletons.Properties.PutValue(realm, lhsRef, nextValue);
        }
      } else {
        // g. Else,
        // i. If lhsKind is assignment, then
        if (lhsKind === "assignment") {
          (0, _invariant.default)(lhs.type === "ArrayPattern" || lhs.type === "ObjectPattern"); // 1. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.

          status = (0, _index2.DestructuringAssignmentEvaluation)(realm, lhs, nextValue, strictCode, iterationEnv || env);
        } else if (lhsKind === "varBinding") {
          // ii. Else if lhsKind is varBinding, then
          // 1. Assert: lhs is a ForBinding.
          // 2. Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.
          status = _singletons.Environment.BindingInitialization(realm, lhs, nextValue, strictCode, undefined);
        } else {
          // iii. Else,
          // 1. Assert: lhsKind is lexicalBinding.
          (0, _invariant.default)(lhsKind === "lexicalBinding"); // 2. Assert: lhs is a ForDeclaration.
          // 3. Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.

          (0, _invariant.default)(iterationEnv !== undefined);
          status = _singletons.Environment.BindingInitialization(realm, lhs, nextValue, strictCode, iterationEnv);
        }
      }
    } catch (e) {
      if (e instanceof _completions.AbruptCompletion) {
        status = e;
      } else {
        throw e;
      }
    } // h. If status is an abrupt completion, then


    if (status instanceof _completions.AbruptCompletion) {
      // i. Set the running execution context's LexicalEnvironment to oldEnv.
      realm.getRunningContext().lexicalEnvironment = oldEnv; // ii. Return ? IteratorClose(iterator, status).

      throw (0, _index2.IteratorClose)(realm, iterator, status);
    } // i. Let result be the result of evaluating stmt.


    let result = env.evaluateCompletion(stmt, strictCode);
    (0, _invariant.default)(result instanceof _index.Value || result instanceof _completions.AbruptCompletion); // j. Set the running execution context's LexicalEnvironment to oldEnv.

    let lexEnv = realm.getRunningContext().lexicalEnvironment;
    if (lexEnv !== oldEnv) realm.onDestroyScope(lexEnv);
    realm.getRunningContext().lexicalEnvironment = oldEnv;
    env = oldEnv; // k. If LoopContinues(result, labelSet) is false, return ? IteratorClose(iterator, UpdateEmpty(result, V)).

    if (!LoopContinues(realm, result, labelSet)) {
      (0, _invariant.default)(result instanceof _completions.AbruptCompletion);
      result = (0, _index2.UpdateEmpty)(realm, result, V);
      (0, _invariant.default)(result instanceof _completions.AbruptCompletion);
      throw (0, _index2.IteratorClose)(realm, iterator, result);
    } // l. If result.[[Value]] is not empty, let V be result.[[Value]].


    let resultValue = InternalGetResultValue(realm, result);
    if (!(resultValue instanceof _index.EmptyValue)) V = resultValue;
  }
  /* istanbul ignore next */


  (0, _invariant.default)(false); // can't get here but there is no other way to make Flow happy
} // ECMA262 13.7.5.11


function _default(ast, strictCode, env, realm, labelSet) {
  let {
    left,
    right,
    body
  } = ast;

  try {
    if (left.type === "VariableDeclaration") {
      if (left.kind === "var") {
        // for (var ForBinding o fAssignmentExpression) Statement
        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation( , AssignmentExpression, iterate).
        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, "iterate", strictCode);
        (0, _invariant.default)(keyResult instanceof _index.ObjectValue); // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).

        return ForInOfBodyEvaluation(realm, env, left.declarations[0].id, body, keyResult, "varBinding", labelSet, strictCode);
      } else {
        // for (ForDeclaration of AssignmentExpression) Statement
        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).
        let keyResult = ForInOfHeadEvaluation(realm, env, _singletons.Environment.BoundNames(realm, left), right, "iterate", strictCode);
        (0, _invariant.default)(keyResult instanceof _index.ObjectValue); // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).

        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, "lexicalBinding", labelSet, strictCode);
      }
    } else {
      // for (LeftHandSideExpression of AssignmentExpression) Statement
      // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation( , AssignmentExpression, iterate).
      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, "iterate", strictCode);
      (0, _invariant.default)(keyResult instanceof _index.ObjectValue); // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).

      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, "assignment", labelSet, strictCode);
    }
  } catch (e) {
    if (e instanceof _completions.BreakCompletion) {
      if (!e.target) return (0, _index2.UpdateEmpty)(realm, e, realm.intrinsics.undefined).value;
    }

    throw e;
  }
}
//# sourceMappingURL=ForOfStatement.js.map

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  return realm.intrinsics.empty;
}
//# sourceMappingURL=EmptyStatement.js.map

/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  // ECMA262 13.5.1
  // 1. Let exprRef be the result of evaluating Expression.
  let exprRef = env.evaluate(ast.expression, strictCode); // 2. Return ? GetValue(exprRef).

  return _singletons.Environment.GetValue(realm, exprRef);
}
//# sourceMappingURL=ExpressionStatement.js.map

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  let r = env.evaluate(ast.program, strictCode);
  (0, _invariant.default)(r instanceof _index.Value);
  return r;
}
//# sourceMappingURL=File.js.map

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _completions = __webpack_require__(18);

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _ForOfStatement = __webpack_require__(582);

var _index = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _index2 = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var t = _interopRequireWildcard(__webpack_require__(21));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// helper func to report error
function reportError(realm, loc) {
  let error = new _errors.CompilerDiagnostic("for in loops over unknown objects are not yet supported", loc, "PP0013", "FatalError");
  realm.handleError(error);
  throw new _errors.FatalError();
} // ECMA262 13.7.5.11


function _default(ast, strictCode, env, realm, labelSet) {
  let {
    left,
    right,
    body
  } = ast;

  function reportErrorAndThrowIfNotConcrete(val, loc) {
    if (val instanceof _index2.AbstractValue) reportError(realm, loc);
  }

  try {
    if (left.type === "VariableDeclaration") {
      if (left.kind === "var") {
        // for (var ForBinding in Expression) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation( , Expression, enumerate).
        let keyResult = (0, _ForOfStatement.ForInOfHeadEvaluation)(realm, env, [], right, "enumerate", strictCode);

        if (keyResult.isPartialObject() && keyResult.isSimpleObject()) {
          return emitResidualLoopIfSafe(ast, strictCode, env, realm, left, right, keyResult, body);
        }

        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);
        (0, _invariant.default)(keyResult instanceof _index2.ObjectValue); // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).

        return (0, _ForOfStatement.ForInOfBodyEvaluation)(realm, env, left.declarations[0].id, body, keyResult, "varBinding", labelSet, strictCode);
      } else {
        // for (ForDeclaration in Expression) Statement
        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).
        let keyResult = (0, _ForOfStatement.ForInOfHeadEvaluation)(realm, env, _singletons.Environment.BoundNames(realm, left), right, "enumerate", strictCode);
        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);
        (0, _invariant.default)(keyResult instanceof _index2.ObjectValue); // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).

        return (0, _ForOfStatement.ForInOfBodyEvaluation)(realm, env, left, body, keyResult, "lexicalBinding", labelSet, strictCode);
      }
    } else {
      // for (LeftHandSideExpression in Expression) Statement
      // 1. Let keyResult be ? ForIn/OfHeadEvaluation( , Expression, enumerate).
      let keyResult = (0, _ForOfStatement.ForInOfHeadEvaluation)(realm, env, [], right, "enumerate", strictCode);
      reportErrorAndThrowIfNotConcrete(keyResult, right.loc);
      (0, _invariant.default)(keyResult instanceof _index2.ObjectValue); // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).

      return (0, _ForOfStatement.ForInOfBodyEvaluation)(realm, env, left, body, keyResult, "assignment", labelSet, strictCode);
    }
  } catch (e) {
    if (e instanceof _completions.BreakCompletion) {
      if (!e.target) return (0, _index.UpdateEmpty)(realm, e, realm.intrinsics.undefined).value;
    }

    throw e;
  }
}

function emitResidualLoopIfSafe(ast, strictCode, env, realm, lh, obexpr, ob, body) {
  (0, _invariant.default)(ob.isSimpleObject());
  let oldEnv = realm.getRunningContext().lexicalEnvironment;

  let blockEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv);

  realm.getRunningContext().lexicalEnvironment = blockEnv;

  try {
    let envRec = blockEnv.environmentRecord;
    (0, _invariant.default)(envRec instanceof _environment.DeclarativeEnvironmentRecord, "expected declarative environment record");

    let absStr = _index2.AbstractValue.createFromType(realm, _index2.StringValue);

    let boundName;

    for (let n of _singletons.Environment.BoundNames(realm, lh)) {
      (0, _invariant.default)(boundName === undefined);
      boundName = t.identifier(n);
      envRec.CreateMutableBinding(n, false);
      envRec.InitializeBinding(n, absStr);
    }

    let {
      result,
      generator: gen,
      modifiedBindings,
      modifiedProperties,
      createdObjects
    } = realm.evaluateNodeForEffects(body, strictCode, blockEnv);

    if (result instanceof _completions.SimpleNormalCompletion && gen.empty() && modifiedBindings.size === 0 && modifiedProperties.size === 1) {
      (0, _invariant.default)(createdObjects.size === 0); // or there will be more than one property

      let targetObject;
      let sourceObject;
      modifiedProperties.forEach((desc, key, map) => {
        if (key.object.unknownProperty === key) {
          targetObject = key.object;
          (0, _invariant.default)(desc !== undefined);
          let sourceValue = desc.throwIfNotConcrete(realm).value;

          if (sourceValue instanceof _index2.AbstractValue) {
            // because sourceValue was written to key.object.unknownProperty it must be that
            let cond = sourceValue.args[0]; // and because the write always creates a value of this shape

            (0, _invariant.default)(cond instanceof _index2.AbstractValue && cond.kind === "template for property name condition");
            let falseVal = sourceValue.args[2];

            if (falseVal instanceof _index2.AbstractValue && falseVal.kind === "template for prototype member expression") {
              // check that the value that was assigned itself came from
              // an expression of the form sourceObject[absStr].
              let mem = sourceValue.args[1];

              while (mem instanceof _index2.AbstractValue) {
                if (mem.kind === "sentinel member expression" && mem.args[0] instanceof _index2.ObjectValue && mem.args[1] === absStr) {
                  sourceObject = mem.args[0];
                  break;
                } // check if mem is a test for absStr being equal to a known property
                // if so skip over it until we get to the expression of the form sourceObject[absStr].


                let condition = mem.args[0];

                if (condition instanceof _index2.AbstractValue && condition.kind === "check for known property") {
                  if (condition.args[0] === absStr) {
                    mem = mem.args[2];
                    continue;
                  }
                }

                break;
              }
            }
          }
        }
      });

      if (targetObject instanceof _index2.ObjectValue && sourceObject !== undefined) {
        let o = ob;

        if (ob instanceof _index2.AbstractObjectValue && !ob.values.isTop() && ob.values.getElements().size === 1) {
          // Note that it is not safe, in general, to extract a concrete object from the values domain of
          // an abstract object. We can get away with it here only because the concrete object does not
          // escape the code below and is thus never referenced directly in generated code because of this logic.
          for (let oe of ob.values.getElements()) {
            (0, _invariant.default)(oe instanceof _index2.ObjectValue);
            o = oe;
          }
        }

        let generator = realm.generator;
        (0, _invariant.default)(generator !== undefined); // make target object simple and partial, so that it returns a fully
        // abstract value for every property it is queried for.

        targetObject.makeSimple();
        targetObject.makePartial();

        if (sourceObject === o) {
          // Known enumerable properties of sourceObject can become known properties of targetObject.
          (0, _invariant.default)(sourceObject.isPartialObject()); // EnumerableOwnProperties is sufficient because sourceObject is simple

          let keyValPairs = (0, _index.EnumerableOwnProperties)(realm, sourceObject, "key+value", true);

          for (let keyVal of keyValPairs) {
            (0, _invariant.default)(keyVal instanceof _index2.ArrayValue);
            let key = keyVal.$Get("0", keyVal);
            let val = keyVal.$Get("1", keyVal);
            (0, _invariant.default)(key instanceof _index2.StringValue); // sourceObject is simple

            targetObject.$Set(key, val, targetObject);
          }
        } // add loop to generator


        (0, _invariant.default)(boundName != null);
        generator.emitForInStatement(o, lh, sourceObject, targetObject, boundName);
        return realm.intrinsics.undefined;
      }
    }
  } finally {
    // 6. Set the running execution context's LexicalEnvironment to oldEnv.
    realm.getRunningContext().lexicalEnvironment = oldEnv;
    realm.onDestroyScope(blockEnv);
  }

  reportError(realm, obexpr.loc);
  (0, _invariant.default)(false);
}
//# sourceMappingURL=ForInStatement.js.map

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CreatePerIterationEnvironment = CreatePerIterationEnvironment;
exports.default = _default;

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _traverse = _interopRequireDefault(__webpack_require__(293));

var _index2 = __webpack_require__(15);

var _errors = __webpack_require__(3);

var _index3 = __webpack_require__(232);

var _ForOfStatement = __webpack_require__(582);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var t = _interopRequireWildcard(__webpack_require__(21));

var _generator = __webpack_require__(237);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 13.7.4.9
function CreatePerIterationEnvironment(realm, perIterationBindings) {
  // 1. If perIterationBindings has any elements, then
  if (perIterationBindings.length > 0) {
    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.
    let lastIterationEnv = realm.getRunningContext().lexicalEnvironment; // b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.

    let lastIterationEnvRec = lastIterationEnv.environmentRecord; // c. Let outer be lastIterationEnv's outer environment reference.

    let outer = lastIterationEnv.parent; // d. Assert: outer is not null.

    (0, _invariant.default)(outer !== null); // e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).

    let thisIterationEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, outer); // f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.


    realm.onDestroyScope(lastIterationEnv);
    let thisIterationEnvRec = thisIterationEnv.environmentRecord; // g. For each element bn of perIterationBindings do,

    for (let bn of perIterationBindings) {
      // i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).
      thisIterationEnvRec.CreateMutableBinding(bn, false); // ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).

      let lastValue = lastIterationEnvRec.GetBindingValue(bn, true); // iii.Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).

      thisIterationEnvRec.InitializeBinding(bn, lastValue);
    } // h. Set the running execution context's LexicalEnvironment to thisIterationEnv.


    realm.getRunningContext().lexicalEnvironment = thisIterationEnv;
  } // 2. Return undefined.


  return realm.intrinsics.undefined;
} // ECMA262 13.7.4.8


function ForBodyEvaluation(realm, test, increment, stmt, perIterationBindings, labelSet, strictCode) {
  // 1. Let V be undefined.
  let V = realm.intrinsics.undefined; // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).

  CreatePerIterationEnvironment(realm, perIterationBindings);
  let env = realm.getRunningContext().lexicalEnvironment;
  let possibleInfiniteLoopIterations = 0; // 3. Repeat

  while (true) {
    let result; // a. If test is not [empty], then

    if (test) {
      // i. Let testRef be the result of evaluating test.
      let testRef = env.evaluate(test, strictCode); // ii. Let testValue be ? GetValue(testRef).

      let testValue = _singletons.Environment.GetValue(realm, testRef); // iii. If ToBoolean(testValue) is false, return NormalCompletion(V).


      if (!_singletons.To.ToBooleanPartial(realm, testValue)) {
        result = _singletons.Functions.incorporateSavedCompletion(realm, V);

        if (result instanceof _completions.JoinedNormalAndAbruptCompletions) {
          let selector = c => c instanceof _completions.BreakCompletion && !c.target;

          result = _completions.Completion.normalizeSelectedCompletions(selector, result);
          result = realm.composeWithSavedCompletion(result);
        }

        return V;
      }
    } // b. Let result be the result of evaluating stmt.


    result = env.evaluateCompletion(stmt, strictCode);
    (0, _invariant.default)(result instanceof _index.Value || result instanceof _completions.AbruptCompletion); // this is a join point for break and continue completions

    result = _singletons.Functions.incorporateSavedCompletion(realm, result);
    (0, _invariant.default)(result !== undefined);
    if (result instanceof _index.Value) result = new _completions.SimpleNormalCompletion(result); // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).

    if (!(0, _ForOfStatement.LoopContinues)(realm, result, labelSet)) {
      (0, _invariant.default)(result instanceof _completions.AbruptCompletion); // ECMA262 13.1.7

      if (result instanceof _completions.BreakCompletion) {
        if (!result.target) return (0, _index3.UpdateEmpty)(realm, result, V).value;
      } else if (result instanceof _completions.JoinedAbruptCompletions) {
        let selector = c => c instanceof _completions.BreakCompletion && !c.target;

        if (result.containsSelectedCompletion(selector)) {
          result = _completions.Completion.normalizeSelectedCompletions(selector, result);
        }
      }

      return realm.returnOrThrowCompletion(result);
    }

    if (result instanceof _completions.JoinedNormalAndAbruptCompletions) {
      result = _completions.Completion.normalizeSelectedCompletions(c => c instanceof _completions.ContinueCompletion, result);
    }

    (0, _invariant.default)(result instanceof _completions.Completion);
    result = realm.composeWithSavedCompletion(result); // d. If result.[[Value]] is not empty, let V be result.[[Value]].

    let resultValue = (0, _ForOfStatement.InternalGetResultValue)(realm, result);
    if (!(resultValue instanceof _index.EmptyValue)) V = resultValue; // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).

    CreatePerIterationEnvironment(realm, perIterationBindings);
    env = realm.getRunningContext().lexicalEnvironment; // f. If increment is not [empty], then

    if (increment) {
      // i. Let incRef be the result of evaluating increment.
      let incRef = env.evaluate(increment, strictCode); // ii. Perform ? GetValue(incRef).

      _singletons.Environment.GetValue(realm, incRef);
    } else if (realm.useAbstractInterpretation) {
      // If we have no increment and we've hit 6 iterations of trying to evaluate
      // this loop body, then see if we have a break, return or throw completion in a
      // guarded condition and fail if it does. We already have logic to guard
      // against loops that are actually infinite. However, because there may be so
      // many forked execution paths, and they're non linear, then it might
      // computationally lead to a something that seems like an infinite loop.
      possibleInfiniteLoopIterations++;

      if (possibleInfiniteLoopIterations > 6) {
        failIfContainsBreakOrReturnOrThrowCompletion(realm.savedCompletion);
      }
    }
  }

  (0, _invariant.default)(false);

  function failIfContainsBreakOrReturnOrThrowCompletion(c) {
    if (c === undefined) return;

    if (c instanceof _completions.ThrowCompletion || c instanceof _completions.BreakCompletion || c instanceof _completions.ReturnCompletion) {
      let diagnostic = new _errors.CompilerDiagnostic("break, throw or return cannot be guarded by abstract condition", c.location, "PP0035", "FatalError");
      realm.handleError(diagnostic);
      throw new _errors.FatalError();
    }

    if (c instanceof _completions.JoinedAbruptCompletions || c instanceof _completions.JoinedNormalAndAbruptCompletions) {
      failIfContainsBreakOrReturnOrThrowCompletion(c.consequent);
      failIfContainsBreakOrReturnOrThrowCompletion(c.alternate);
    }
  }
}

let BailOutWrapperClosureRefVisitor = {
  ReferencedIdentifier(path, state) {
    if (path.node.name === "arguments") {
      state.usesArguments = true;
    }
  },

  ThisExpression(path, state) {
    state.usesThis = true;
  },

  "BreakStatement|ContinueStatement"(path, state) {
    if (path.node.label !== null) {
      state.usesGotoToLabel = true;
    }
  },

  ReturnStatement(path, state) {
    state.usesReturn = true;
  },

  ThrowStatement(path, state) {
    state.usesThrow = true;
  },

  VariableDeclaration(path, state) {
    let node = path.node; // `let` and `const` are lexically scoped. We only need to change `var`s into assignments. Since we hoist the loop
    // into its own function `var`s (which are function scoped) need to be made available outside the loop.

    if (node.kind !== "var") return;

    if (t.isForOfStatement(path.parentPath.node) || t.isForInStatement(path.parentPath.node)) {
      // For-of and for-in variable declarations behave a bit differently. There is only one declarator and there is
      // never an initializer. Furthermore we cant replace with an expression or statement, only a
      // `LeftHandSideExpression`. However, that `LeftHandSideExpression` will perform a `DestructuringAssignment`
      // operation which is what we want.
      (0, _invariant.default)(node.declarations.length === 1);
      (0, _invariant.default)(node.declarations[0].init == null);
      const {
        id
      } = node.declarations[0];

      if (!t.isIdentifier(id)) {
        // We do not currently support ObjectPattern, SpreadPattern and ArrayPattern
        // see: https://github.com/babel/babylon/blob/master/ast/spec.md#patterns
        state.varPatternUnsupported = true;
        return;
      } // Replace with the id directly since it is a `LeftHandSideExpression`.


      path.replaceWith(id);
    } else {
      // Change all variable declarations into assignment statements. We assign to capture variables made available
      // outside of this scope.
      // If our parent is a `for (var x; x < y; x++)` loop we do not need a wrapper.
      // i.e. for (var x of y) for (var x in y) for (var x; x < y; x++)
      let needsExpressionWrapper = !t.isForStatement(path.parentPath.node);

      const getConvertedDeclarator = index => {
        let {
          id,
          init
        } = node.declarations[index];

        if (t.isIdentifier(id)) {
          // If init is undefined, then we need to ensure we provide
          // an actual Babel undefined node for it.
          if (init === null) {
            init = t.identifier("undefined");
          }

          return t.assignmentExpression("=", id, init);
        } else {
          // We do not currently support ObjectPattern, SpreadPattern and ArrayPattern
          // see: https://github.com/babel/babylon/blob/master/ast/spec.md#patterns
          state.varPatternUnsupported = true;
        }
      };

      if (node.declarations.length === 1) {
        let convertedNodeOrUndefined = getConvertedDeclarator(0);

        if (convertedNodeOrUndefined === undefined) {
          // Do not continue as we don't support this
          return;
        }

        path.replaceWith(needsExpressionWrapper ? t.expressionStatement(convertedNodeOrUndefined) : convertedNodeOrUndefined);
      } else {
        // convert to sequence, so: `var x = 1, y = 2;` becomes `x = 1, y = 2;`
        let expressions = [];

        for (let i = 0; i < node.declarations.length; i++) {
          let convertedNodeOrUndefined = getConvertedDeclarator(i);

          if (convertedNodeOrUndefined === undefined) {
            // Do not continue as we don't support this
            return;
          }

          expressions.push(convertedNodeOrUndefined);
        }

        let sequenceExpression = t.sequenceExpression(expressions);
        path.replaceWith(needsExpressionWrapper ? t.expressionStatement(sequenceExpression) : sequenceExpression);
      }
    }
  }

};

function generateRuntimeForStatement(ast, strictCode, env, realm, labelSet) {
  let wrapperFunction = new _index.ECMAScriptSourceFunctionValue(realm);
  let body = t.cloneDeep(t.blockStatement([ast]));
  wrapperFunction.initialize([], body);
  wrapperFunction.$Environment = env; // We need to scan to AST looking for "this", "return", "throw", labels and "arguments"

  let functionInfo = {
    usesArguments: false,
    usesThis: false,
    usesReturn: false,
    usesGotoToLabel: false,
    usesThrow: false,
    varPatternUnsupported: false
  };
  (0, _traverse.default)(t.file(t.program([t.expressionStatement(t.functionExpression(null, [], body))])), BailOutWrapperClosureRefVisitor, null, functionInfo);

  _traverse.default.cache.clear();

  let {
    usesReturn,
    usesThrow,
    usesArguments,
    usesGotoToLabel,
    varPatternUnsupported,
    usesThis
  } = functionInfo;

  if (usesReturn || usesThrow || usesArguments || usesGotoToLabel || varPatternUnsupported) {
    // We do not have support for these yet
    let diagnostic = new _errors.CompilerDiagnostic(`failed to recover from a for/while loop bail-out due to unsupported logic in loop body`, realm.currentLocation, "PP0037", "FatalError");
    realm.handleError(diagnostic);
    throw new _errors.FatalError();
  }

  let args = [wrapperFunction];

  if (usesThis) {
    let thisRef = env.evaluate(t.thisExpression(), strictCode);

    let thisVal = _singletons.Environment.GetValue(realm, thisRef);

    _singletons.Leak.value(realm, thisVal);

    args.push(thisVal);
  } // We leak the wrapping function value, which in turn invokes the leak
  // logic which is transitive. The leaking logic should recursively visit
  // all bindings/objects in the loop and its body and mark the associated
  // bindings/objects as leaked


  _singletons.Leak.value(realm, wrapperFunction);

  let wrapperValue = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.Value, args, (0, _generator.createOperationDescriptor)("FOR_STATEMENT_FUNC", {
    usesThis
  }));

  (0, _invariant.default)(wrapperValue instanceof _index.AbstractValue);
  return wrapperValue;
}

function tryToEvaluateForStatementOrLeaveAsAbstract(ast, strictCode, env, realm, labelSet) {
  (0, _invariant.default)(!realm.instantRender.enabled);
  let effects;
  let savedSuppressDiagnostics = realm.suppressDiagnostics;

  try {
    realm.suppressDiagnostics = true;
    effects = realm.evaluateForEffects(() => evaluateForStatement(ast, strictCode, env, realm, labelSet), undefined, "tryToEvaluateForStatementOrLeaveAsAbstract");
  } catch (error) {
    if (error instanceof _errors.FatalError) {
      realm.suppressDiagnostics = savedSuppressDiagnostics;
      return realm.evaluateWithPossibleThrowCompletion(() => generateRuntimeForStatement(ast, strictCode, env, realm, labelSet), _index2.TypesDomain.topVal, _index2.ValuesDomain.topVal);
    } else {
      throw error;
    }
  } finally {
    realm.suppressDiagnostics = savedSuppressDiagnostics;
  }

  realm.applyEffects(effects);
  return realm.returnOrThrowCompletion(effects.result);
} // ECMA262 13.7.4.7


function _default(ast, strictCode, env, realm, labelSet) {
  if (realm.isInPureScope() && !realm.instantRender.enabled) {
    return tryToEvaluateForStatementOrLeaveAsAbstract(ast, strictCode, env, realm, labelSet);
  } else {
    return evaluateForStatement(ast, strictCode, env, realm, labelSet);
  }
}

function evaluateForStatement(ast, strictCode, env, realm, labelSet) {
  let {
    init,
    test,
    update,
    body
  } = ast;

  if (init && init.type === "VariableDeclaration") {
    if (init.kind === "var") {
      // for (var VariableDeclarationList; Expression; Expression) Statement
      // 1. Let varDcl be the result of evaluating VariableDeclarationList.
      let varDcl = env.evaluate(init, strictCode); // 2. ReturnIfAbrupt(varDcl).

      varDcl; // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement,  , labelSet).

      return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);
    } else {
      // for (LexicalDeclaration Expression; Expression) Statement
      // 1. Let oldEnv be the running execution context's LexicalEnvironment.
      let oldEnv = env; // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).

      let loopEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv); // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.


      let loopEnvRec = loopEnv.environmentRecord; // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.

      let isConst = init.kind === "const"; // 5. Let boundNames be the BoundNames of LexicalDeclaration.

      let boundNames = _singletons.Environment.BoundNames(realm, init); // 6. For each element dn of boundNames do


      for (let dn of boundNames) {
        // a. If isConst is true, then
        if (isConst) {
          // i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).
          loopEnvRec.CreateImmutableBinding(dn, true);
        } else {
          // b. Else,
          // i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).
          loopEnvRec.CreateMutableBinding(dn, false);
        }
      } // 7. Set the running execution context's LexicalEnvironment to loopEnv.


      realm.getRunningContext().lexicalEnvironment = loopEnv; // 8. Let forDcl be the result of evaluating LexicalDeclaration.

      let forDcl = loopEnv.evaluateCompletion(init, strictCode); // 9. If forDcl is an abrupt completion, then

      if (forDcl instanceof _completions.AbruptCompletion) {
        // a. Set the running execution context's LexicalEnvironment to oldEnv.
        let currentEnv = realm.getRunningContext().lexicalEnvironment;
        realm.onDestroyScope(currentEnv);
        if (currentEnv !== loopEnv) (0, _invariant.default)(loopEnv.destroyed);
        realm.getRunningContext().lexicalEnvironment = oldEnv; // b. Return Completion(forDcl).

        throw forDcl;
      } // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be  .


      let perIterationLets = !isConst ? boundNames : [];
      let bodyResult;

      try {
        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).
        bodyResult = ForBodyEvaluation(realm, test, update, body, perIterationLets, labelSet, strictCode);
      } finally {
        // 12. Set the running execution context's LexicalEnvironment to oldEnv.
        let currentEnv = realm.getRunningContext().lexicalEnvironment;
        realm.onDestroyScope(currentEnv);
        if (currentEnv !== loopEnv) (0, _invariant.default)(loopEnv.destroyed);
        realm.getRunningContext().lexicalEnvironment = oldEnv;
      } // 13. Return Completion(bodyResult).


      return bodyResult;
    }
  } else {
    // for (Expression; Expression; Expression) Statement
    // 1. If the first Expression is present, then
    if (init) {
      // a. Let exprRef be the result of evaluating the first Expression.
      let exprRef = env.evaluate(init, strictCode); // b. Perform ? GetValue(exprRef).

      _singletons.Environment.GetValue(realm, exprRef);
    } // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement,  , labelSet).


    return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);
  }
}
//# sourceMappingURL=ForStatement.js.map

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _construct = __webpack_require__(228);

var _singletons = __webpack_require__(236);

var _index = __webpack_require__(10);

var _strict = _interopRequireDefault(__webpack_require__(452));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 14.1.20
function _default(ast, strictCode, env, realm) {
  if (ast.generator) {
    // 1. If the function code for GeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.
    let strict = strictCode || (0, _strict.default)(ast.body); // 2. Let name be StringValue of BindingIdentifier.

    let name;

    if (ast.id) {
      name = new _index.StringValue(realm, ast.id.name);
    } else {
      name = new _index.StringValue(realm, "default");
    } // 3. Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).


    let F = _singletons.Functions.GeneratorFunctionCreate(realm, "normal", ast.params, ast.body, env, strict); // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).


    let prototype = _singletons.Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype); // 5. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).


    _singletons.Properties.DefinePropertyOrThrow(realm, F, "prototype", new _descriptors.PropertyDescriptor({
      value: prototype,
      writable: true,
      configurable: false
    })); // 6. Perform SetFunctionName(F, name).


    _singletons.Functions.SetFunctionName(realm, F, name); // 7 .Return F.


    return F;
  } else {
    // 1. If the function code for FunctionDeclaration is strict mode code, let strict be true. Otherwise let strict be false.
    let strict = strictCode || (0, _strict.default)(ast.body); // 2. Let name be StringValue of BindingIdentifier.

    let name;

    if (ast.id) {
      name = new _index.StringValue(realm, ast.id.name);
    } else {
      name = new _index.StringValue(realm, "default");
    } // 3. Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).


    let F = _singletons.Functions.FunctionCreate(realm, "normal", ast.params, ast.body, env, strict);

    if (ast.id && ast.id.name) F.__originalName = ast.id.name; // 4. Perform MakeConstructor(F).

    (0, _construct.MakeConstructor)(realm, F); // 5. Perform SetFunctionName(F, name).

    _singletons.Functions.SetFunctionName(realm, F, name); // 6. Return F.


    return F;
  }
}
//# sourceMappingURL=FunctionDeclaration.js.map

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _index2 = __webpack_require__(10);

var _strict = _interopRequireDefault(__webpack_require__(452));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  // ECMA262 14.1.21
  if (ast.id) {
    if (ast.generator === true) {
      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
      let strict = strictCode || (0, _strict.default)(ast.body); // 2. Let scope be the running execution context's LexicalEnvironment.

      let scope = env; // 3. Let funcEnv be NewDeclarativeEnvironment(scope).

      let funcEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, scope); // 4. Let envRec be funcEnv's EnvironmentRecord.


      let envRec = funcEnv.environmentRecord; // 5. Let name be StringValue of BindingIdentifier.

      (0, _invariant.default)(ast.id);
      let name = ast.id.name; // 6. Perform envRec.CreateImmutableBinding(name, false).

      envRec.CreateImmutableBinding(name, false); // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).

      let closure = _singletons.Functions.GeneratorFunctionCreate(realm, "normal", ast.params, ast.body, funcEnv, strict);

      closure.loc = ast.loc; // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).

      let prototype = _singletons.Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);

      prototype.originalConstructor = closure; // 9. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).

      _singletons.Properties.DefinePropertyOrThrow(realm, closure, "prototype", new _descriptors.PropertyDescriptor({
        value: prototype,
        writable: true,
        enumerable: false,
        configurable: false
      })); // 10. Perform SetFunctionName(closure, name).


      _singletons.Functions.SetFunctionName(realm, closure, new _index2.StringValue(realm, name)); // 11. Perform envRec.InitializeBinding(name, closure).


      envRec.InitializeBinding(name, closure); // 12. Return closure.

      return closure;
    } else {
      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
      let strict = strictCode || (0, _strict.default)(ast.body); // 2. Let scope be the running execution context's LexicalEnvironment.

      let scope = env; // 3. Let funcEnv be NewDeclarativeEnvironment(scope).

      let funcEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, scope, false); // 4. Let envRec be funcEnv's EnvironmentRecord.


      let envRec = funcEnv.environmentRecord; // 5. Let name be StringValue of BindingIdentifier.

      (0, _invariant.default)(ast.id);
      let name = ast.id.name; // 6. Perform envRec.CreateImmutableBinding(name, false).

      envRec.CreateImmutableBinding(name, false, false, true); // I don't think this gets deleted anywhere else
      //if (realm.modifiedBindings) realm.modifiedBindings.delete(name);
      // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).

      let closure = _singletons.Functions.FunctionCreate(realm, "normal", ast.params, ast.body, funcEnv, strict);

      closure.loc = ast.loc; // 8. Perform MakeConstructor(closure).

      (0, _index.MakeConstructor)(realm, closure); // 9. Perform SetFunctionName(closure, name).

      _singletons.Functions.SetFunctionName(realm, closure, new _index2.StringValue(realm, name)); // 10. Perform envRec.InitializeBinding(name, closure).


      envRec.InitializeBinding(name, closure, true); // 11. Return closure.

      return closure;
    }
  } else {
    if (ast.generator === true) {
      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
      let strict = strictCode || (0, _strict.default)(ast.body); // 2. Let scope be the LexicalEnvironment of the running execution context.

      let scope = env; // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).

      let closure = _singletons.Functions.GeneratorFunctionCreate(realm, "normal", ast.params, ast.body, scope, strict); // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).


      let prototype = _singletons.Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);

      prototype.originalConstructor = closure; // 5. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).

      _singletons.Properties.DefinePropertyOrThrow(realm, closure, "prototype", new _descriptors.PropertyDescriptor({
        value: prototype,
        writable: true,
        enumerable: false,
        configurable: false
      })); // 6. Return closure.


      return closure;
    } else {
      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
      let strict = strictCode || (0, _strict.default)(ast.body); // 2. Let scope be the LexicalEnvironment of the running execution context.

      let scope = env; // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).

      let closure = _singletons.Functions.FunctionCreate(realm, "normal", ast.params, ast.body, scope, strict);

      closure.loc = ast.loc; // 4. Perform MakeConstructor(closure).

      (0, _index.MakeConstructor)(realm, closure); // 5. Return closure.

      return closure;
    }
  }
}
//# sourceMappingURL=FunctionExpression.js.map

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 12.1.6
function _default(ast, strictCode, env, realm) {
  // 1. Return ? ResolveBinding(StringValue of Identifier).
  return _singletons.Environment.ResolveBinding(realm, ast.name, strictCode, env);
}
//# sourceMappingURL=Identifier.js.map

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.evaluate = evaluate;

var _completions = __webpack_require__(18);

var _realm = __webpack_require__(7);

var _index = __webpack_require__(10);

var _environment = __webpack_require__(20);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function evaluate(ast, strictCode, env, realm) {
  // 1. Let exprRef be the result of evaluating Expression
  let exprRef = env.evaluate(ast.test, strictCode); // 2. Let exprValue be ToBoolean(? GetValue(exprRef))

  let exprValue = _singletons.Environment.GetConditionValue(realm, exprRef);

  if (exprValue instanceof _index.ConcreteValue) {
    let stmtCompletion;

    if (_singletons.To.ToBoolean(realm, exprValue)) {
      // 3.a. Let stmtCompletion be the result of evaluating the first Statement
      stmtCompletion = env.evaluateCompletion(ast.consequent, strictCode);
    } else {
      if (ast.alternate) {
        // 4.a. Let stmtCompletion be the result of evaluating the second Statement
        stmtCompletion = env.evaluateCompletion(ast.alternate, strictCode);
      } else {
        // 3 (of the if only statement). Return NormalCompletion(undefined)
        stmtCompletion = realm.intrinsics.undefined;
      }
    } // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)
    //if (stmtCompletion instanceof Reference) return stmtCompletion;


    (0, _invariant.default)(!(stmtCompletion instanceof _environment.Reference));
    stmtCompletion = (0, _index2.UpdateEmpty)(realm, stmtCompletion, realm.intrinsics.undefined);

    if (stmtCompletion instanceof _completions.AbruptCompletion) {
      throw stmtCompletion;
    }

    (0, _invariant.default)(stmtCompletion instanceof _index.Value);
    return stmtCompletion;
  }

  (0, _invariant.default)(exprValue instanceof _index.AbstractValue);

  if (!exprValue.mightNotBeTrue()) {
    let stmtCompletion = env.evaluate(ast.consequent, strictCode);
    (0, _invariant.default)(!(stmtCompletion instanceof _environment.Reference));
    stmtCompletion = (0, _index2.UpdateEmpty)(realm, stmtCompletion, realm.intrinsics.undefined);

    if (stmtCompletion instanceof _completions.AbruptCompletion) {
      throw stmtCompletion;
    }

    (0, _invariant.default)(stmtCompletion instanceof _index.Value);
    return stmtCompletion;
  } else if (!exprValue.mightNotBeFalse()) {
    let stmtCompletion;
    if (ast.alternate) stmtCompletion = env.evaluate(ast.alternate, strictCode);else stmtCompletion = realm.intrinsics.undefined;
    (0, _invariant.default)(!(stmtCompletion instanceof _environment.Reference));
    stmtCompletion = (0, _index2.UpdateEmpty)(realm, stmtCompletion, realm.intrinsics.undefined);

    if (stmtCompletion instanceof _completions.AbruptCompletion) {
      throw stmtCompletion;
    }

    (0, _invariant.default)(stmtCompletion instanceof _index.Value);
    return stmtCompletion;
  } else {
    (0, _invariant.default)(exprValue instanceof _index.AbstractValue);
    return realm.evaluateWithAbstractConditional(exprValue, () => realm.evaluateNodeForEffects(ast.consequent, strictCode, env), () => ast.alternate ? realm.evaluateNodeForEffects(ast.alternate, strictCode, env) : (0, _realm.construct_empty_effects)(realm));
  }
}
//# sourceMappingURL=IfStatement.js.map

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _completions = __webpack_require__(18);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 13.13.14
function LabelledEvaluation(labelSet, ast, strictCode, env, realm) {
  // LabelledStatement:LabelIdentifier:LabelledItem
  switch (ast.type) {
    case "LabeledStatement":
      let labeledAst = ast; // 1. Let label be the StringValue of LabelIdentifier.

      let label = labeledAst.label.name; // 2. Append label as an element of labelSet.

      labelSet.push(label); // 3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.

      let normalCompletionStmtResult;

      try {
        normalCompletionStmtResult = LabelledEvaluation(labelSet, labeledAst.body, strictCode, env, realm);
      } catch (stmtResult) {
        // 4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then
        if (stmtResult instanceof _completions.BreakCompletion && stmtResult.target === label) {
          // a. Let stmtResult be NormalCompletion(stmtResult.[[Value]]).
          normalCompletionStmtResult = stmtResult.value;
        } else if (stmtResult instanceof _completions.JoinedAbruptCompletions || stmtResult instanceof _completions.JoinedNormalAndAbruptCompletions) {
          let nc = _completions.Completion.normalizeSelectedCompletions(c => c instanceof _completions.BreakCompletion && c.target === label, stmtResult);

          return realm.returnOrThrowCompletion(nc);
        } else {
          // 5. Return Completion(stmtResult).
          throw stmtResult;
        }
      } // 5. Return Completion(stmtResult).


      return normalCompletionStmtResult;

    case "VariableDeclaration":
      if (ast.kind === "var") {
        let r = env.evaluate(ast, strictCode);
        (0, _invariant.default)(r instanceof _index.Value);
        return r;
      }

    // fall through to throw

    case "FunctionDeclaration":
    case "ClassDeclaration":
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, ast.type + " may not have a label");

    default:
      let r = env.evaluate(ast, strictCode, labelSet);
      (0, _invariant.default)(r instanceof _index.Value);
      return r;
  }
} // ECMA262 13.13.15


function _default(ast, strictCode, env, realm) {
  //1. Let newLabelSet be a new empty List.
  let newLabelSet = []; //2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.

  return LabelledEvaluation(newLabelSet, ast, strictCode, env, realm);
}
//# sourceMappingURL=LabeledStatement.js.map

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _realm = __webpack_require__(7);

var _completions = __webpack_require__(18);

var _errors = __webpack_require__(3);

var _index = __webpack_require__(10);

var _environment = __webpack_require__(20);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  let lref = env.evaluate(ast.left, strictCode);

  let lval = _singletons.Environment.GetValue(realm, lref);

  if (lval instanceof _index.ConcreteValue) {
    let lbool = _singletons.To.ToBoolean(realm, lval);

    if (ast.operator === "&&") {
      // ECMA262 12.13.3
      if (lbool === false) return lval;
    } else {
      (0, _invariant.default)(ast.operator === "||"); // ECMA262 12.13.3

      if (lbool === true) return lval;
    }

    let rref = env.evaluate(ast.right, strictCode);
    return _singletons.Environment.GetValue(realm, rref);
  }

  (0, _invariant.default)(lval instanceof _index.AbstractValue);

  let lcond = _singletons.Environment.GetConditionValue(realm, lref);

  if (!lcond.mightNotBeFalse()) return ast.operator === "||" ? env.evaluate(ast.right, strictCode) : lval;
  if (!lcond.mightNotBeTrue()) return ast.operator === "&&" ? env.evaluate(ast.right, strictCode) : lval;
  (0, _invariant.default)(lcond instanceof _index.AbstractValue); // Create empty effects for the case where ast.right is not evaluated

  let {
    result: result1,
    generator: generator1,
    modifiedBindings: modifiedBindings1,
    modifiedProperties: modifiedProperties1,
    createdObjects: createdObjects1
  } = (0, _realm.construct_empty_effects)(realm);
  result1; // ignore
  // Evaluate ast.right in a sandbox to get its effects

  let result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2;

  try {
    let wrapper = ast.operator === "&&" ? _singletons.Path.withCondition : _singletons.Path.withInverseCondition;
    ({
      result: result2,
      generator: generator2,
      modifiedBindings: modifiedBindings2,
      modifiedProperties: modifiedProperties2,
      createdObjects: createdObjects2
    } = wrapper(lcond, () => realm.evaluateNodeForEffects(ast.right, strictCode, env)));
  } catch (e) {
    if (e instanceof _errors.InfeasiblePathError) {
      // if && then lcond cannot be true on this path else lcond cannot be false on this path.
      // Either way, we need to return just lval and not evaluate ast.right
      return lval;
    }

    throw e;
  } // Join the effects, creating an abstract view of what happened, regardless
  // of the actual value of lval.
  // Note that converting a value to boolean never has a side effect, so we can
  // use lval as is for the join condition.


  let joinedEffects;

  if (ast.operator === "&&") {
    joinedEffects = _singletons.Join.joinEffects(lcond, new _realm.Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2), new _realm.Effects(new _completions.SimpleNormalCompletion(lval), generator1, modifiedBindings1, modifiedProperties1, createdObjects1));
  } else {
    joinedEffects = _singletons.Join.joinEffects(lcond, new _realm.Effects(new _completions.SimpleNormalCompletion(lval), generator1, modifiedBindings1, modifiedProperties1, createdObjects1), new _realm.Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2));
  }

  realm.applyEffects(joinedEffects);
  let completion = realm.returnOrThrowCompletion(joinedEffects.result);

  if (lval instanceof _index.Value && result2.value instanceof _index.Value) {
    // joinEffects does the right thing for the side effects of the second expression but for the result the join
    // produces a conditional expressions of the form (a ? b : a) for a && b and (a ? a : b) for a || b
    // Rather than look for this pattern everywhere, we override this behavior and replace the completion with
    // the actual logical operator. This helps with simplification and reasoning when dealing with path conditions.
    completion = _index.AbstractValue.createFromLogicalOp(realm, ast.operator, lval, result2.value, ast.loc);
  }

  return completion;
}
//# sourceMappingURL=LogicalExpression.js.map

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _SuperProperty = _interopRequireDefault(__webpack_require__(595));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 12.3.2.1
function _default(ast, strictCode, env, realm) {
  if (ast.object.type === "Super") {
    return (0, _SuperProperty.default)(ast, strictCode, env, realm);
  } // 1. Let baseReference be the result of evaluating MemberExpression.


  let baseReference = env.evaluate(ast.object, strictCode); // 2. Let baseValue be ? GetValue(baseReference).

  let baseValue = _singletons.Environment.GetValue(realm, baseReference);

  let propertyNameValue;

  if (ast.computed === true) {
    // 3. Let propertyNameReference be the result of evaluating Expression.
    let propertyNameReference = env.evaluate(ast.property, strictCode); // 4. Let propertyNameValue be ? GetValue(propertyNameReference).

    propertyNameValue = _singletons.Environment.GetValue(realm, propertyNameReference);
  } else {
    // 3. Let propertyNameString be StringValue of IdentifierName.
    propertyNameValue = new _index.StringValue(realm, ast.property.name);
  } // 5. Let bv be ? RequireObjectCoercible(baseValue).


  let bv = (0, _index2.RequireObjectCoercible)(realm, baseValue, ast.object.loc); // 6. Let propertyKey be ? ToPropertyKey(propertyNameValue).

  let propertyKey = _singletons.To.ToPropertyKeyPartial(realm, propertyNameValue); // 7. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.


  let strict = strictCode; // 8. Return a value of type Reference whose base value is bv, whose referenced name is propertyKey, and whose strict reference flag is strict.

  return new _environment.Reference(bv, propertyKey, strict);
}
//# sourceMappingURL=MemberExpression.js.map

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SuperProperty;

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function MakeSuperPropertyReference(realm, propertyKey, strict) {
  // 1. Let env be GetThisEnvironment( ).
  let env = _singletons.Environment.GetThisEnvironment(realm);

  (0, _invariant.default)(env instanceof _environment.FunctionEnvironmentRecord); // 2. If env.HasSuperBinding() is false, throw a ReferenceError exception.

  if (!env.HasSuperBinding()) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, "env does not have super binding");
  } // 3. Let actualThis be env.GetThisBinding().


  let actualThis = env.GetThisBinding(); // 4. ReturnIfAbrupt(actualThis).
  // 5. Let baseValue be env.GetSuperBase().

  let baseValue = env.GetSuperBase(); // 6. Let bv be RequireObjectCoercible(baseValue).

  let bv = (0, _index2.RequireObjectCoercible)(realm, baseValue); // 7. ReturnIfAbrupt(bv).
  // 8. Return a value of type Reference that is a Super Reference whose base value is bv, whose referenced name is propertyKey, whose thisValue is actualThis, and whose strict reference flag is strict.

  return new _environment.Reference(bv, propertyKey, strict, actualThis);
} // ECMA262 12.3.5.1


function SuperProperty(ast, strictCode, env, realm) {
  // SuperProperty : super [ Expression ]
  if (ast.computed === true) {
    // 1. Let propertyNameReference be the result of evaluating Expression.
    let propertyNameReference = env.evaluate(ast.property, strictCode); // 2. Let propertyNameValue be GetValue(propertyNameReference).

    let propertyNameValue = _singletons.Environment.GetValue(realm, propertyNameReference); // 3. Let propertyKey be ToPropertyKey(propertyNameValue).


    let propertyKey = _singletons.To.ToPropertyKeyPartial(realm, propertyNameValue); // 4. ReturnIfAbrupt(propertyKey).
    // 5. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.


    let strict = strictCode; // 6. Return MakeSuperPropertyReference(propertyKey, strict).

    return MakeSuperPropertyReference(realm, propertyKey, strict);
  } else {
    // SuperProperty : super . IdentifierName
    // 1. Let propertyKey be StringValue of IdentifierName.
    let propertyKey = new _index.StringValue(realm, ast.property.name); // 2. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.

    let strict = strictCode; // 3. Return MakeSuperPropertyReference(propertyKey, strict).

    return MakeSuperPropertyReference(realm, propertyKey, strict);
  }
}
//# sourceMappingURL=SuperProperty.js.map

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _get = __webpack_require__(230);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA 12.3.8.1
function _default(ast, strictCode, env, realm) {
  return (0, _get.GetNewTarget)(realm);
}
//# sourceMappingURL=MetaProperty.js.map

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(15);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _index3 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _errors = __webpack_require__(3);

var _types = __webpack_require__(21);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(ast, strictCode, env, realm) {
  // ECMA262 12.3.3.1 We just implement this method inline since it's only called here.
  // 1. Return ? EvaluateNew(NewExpression, empty).
  // ECMA262 2.3.3.1.1
  let constructProduction = ast.callee;
  let args = ast.arguments; // These steps not necessary due to our AST representation.
  // 1. Assert: constructProduction is either a NewExpression or a MemberExpression.
  // 2. Assert: arguments is either empty or an Arguments production.
  // 3. Let ref be the result of evaluating constructProduction.

  let ref = env.evaluate(constructProduction, strictCode); // 4. Let constructor be ? GetValue(ref).

  let constructor = _singletons.Environment.GetValue(realm, ref);

  let argsList; // 5. If arguments is empty, let argList be a new empty List.

  if (!args.length) {
    argsList = [];
  } else {
    // 6. Else,
    // a. Let argList be ArgumentListEvaluation of arguments.
    argsList = (0, _index3.ArgumentListEvaluation)(realm, strictCode, env, args); // BabelNodeNewExpression needs updating
    // This step not necessary since we propagate completions with exceptions.
    // b. ReturnIfAbrupt(argList).
  }

  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);

  try {
    // If we are in pure scope, attempt to recover from creating the construct if
    // it fails by creating a temporal abstract
    if (realm.isInPureScope()) {
      return tryToEvaluateConstructOrLeaveAsAbstract(constructor, argsList, strictCode, realm);
    } else {
      return createConstruct(constructor, argsList, realm);
    }
  } finally {
    realm.setNextExecutionContextLocation(previousLoc);
  }
}

function tryToEvaluateConstructOrLeaveAsAbstract(constructor, argsList, strictCode, realm) {
  let effects;

  try {
    effects = realm.evaluateForEffects(() => createConstruct(constructor, argsList, realm), undefined, "tryToEvaluateConstructOrLeaveAsAbstract");
  } catch (error) {
    // if a FatalError occurs when constructing the constructor
    // then try and recover and create an abstract for this construct
    if (error instanceof _errors.FatalError) {
      // we need to leak all the arguments and the constructor
      _singletons.Leak.value(realm, constructor);

      for (let arg of argsList) {
        _singletons.Leak.value(realm, arg);
      }

      let abstractValue = realm.evaluateWithPossibleThrowCompletion(() => _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.ObjectValue, [constructor, ...argsList], (0, _generator.createOperationDescriptor)("NEW_EXPRESSION")), _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
      (0, _invariant.default)(abstractValue instanceof _index2.AbstractObjectValue);
      return abstractValue;
    } else {
      throw error;
    }
  }

  realm.applyEffects(effects);
  let completion = realm.returnOrThrowCompletion(effects.result);
  (0, _invariant.default)(completion instanceof _index2.ObjectValue || completion instanceof _index2.AbstractObjectValue);
  return completion;
}

function createConstruct(constructor, argsList, realm) {
  // 7. If IsConstructor(constructor) is false, throw a TypeError exception.
  if ((0, _index3.IsConstructor)(realm, constructor) === false) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
  }

  (0, _invariant.default)(constructor instanceof _index2.ObjectValue); // 8. Return ? Construct(constructor, argList).

  return (0, _index3.Construct)(realm, constructor, argsList);
}
//# sourceMappingURL=NewExpression.js.map

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  return realm.intrinsics.null;
}
//# sourceMappingURL=NullLiteral.js.map

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  return _index.IntegralValue.createFromNumberValue(realm, ast.value);
}
//# sourceMappingURL=NumericLiteral.js.map

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlobalDeclarationInstantiation = GlobalDeclarationInstantiation;
exports.default = _default;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _environment = __webpack_require__(20);

var _singletons = __webpack_require__(236);

var _strict = _interopRequireDefault(__webpack_require__(452));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _traverseFast = _interopRequireDefault(__webpack_require__(279));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// ECMA262 15.1.11
function GlobalDeclarationInstantiation(realm, ast, env, strictCode) {
  realm.getRunningContext().isStrict = realm.isStrict = strictCode; // 1. Let envRec be env's EnvironmentRecord.

  let envRec = env.environmentRecord; // 2. Assert: envRec is a global Environment Record.

  (0, _invariant.default)(envRec instanceof _environment.GlobalEnvironmentRecord, "expected global environment record"); // 3. Let lexNames be the LexicallyDeclaredNames of script.

  let lexNames = []; // 4. Let varNames be the VarDeclaredNames of script.

  let varNames = [];
  (0, _traverseFast.default)(ast, node => {
    if (node.type === "VariableDeclaration") {
      if (node.kind === "var") {
        varNames = varNames.concat(_singletons.Environment.BoundNames(realm, node));
      } else {
        lexNames = lexNames.concat(_singletons.Environment.BoundNames(realm, node));
      }
    } else if (node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
      return true;
    }

    return false;
  }); // 5. For each name in lexNames, do

  for (let name of lexNames) {
    // a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.
    if (envRec.HasVarDeclaration(name)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + " already declared with var");
    } // b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.


    if (envRec.HasLexicalDeclaration(name)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + " already declared with let or const");
    } // c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).


    let hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name); // d. If hasRestrictedGlobal is true, throw a SyntaxError exception.

    if (hasRestrictedGlobal) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + " global object is restricted");
    }
  } // 6. For each name in varNames, do


  for (let name of varNames) {
    // a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
    if (envRec.HasLexicalDeclaration(name)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + " already declared with let or const");
    }
  } // 7. Let varDeclarations be the VarScopedDeclarations of script.


  let varDeclarations = _singletons.Functions.FindVarScopedDeclarations(ast); // 8. Let functionsToInitialize be a new empty List.


  let functionsToInitialize = []; // 9. Let declaredFunctionNames be a new empty List.

  let declaredFunctionNames = []; // 10. For each d in varDeclarations, in reverse list order do

  for (let d of varDeclarations.reverse()) {
    // a. If d is neither a VariableDeclaration or a ForBinding, then
    if (d.type !== "VariableDeclaration") {
      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.
      (0, _invariant.default)(d.type === "FunctionDeclaration", "expected function"); // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.
      // iii. Let fn be the sole element of the BoundNames of d.

      let fn = _singletons.Environment.BoundNames(realm, d)[0]; // iv. If fn is not an element of declaredFunctionNames, then


      if (declaredFunctionNames.indexOf(fn) < 0) {
        // 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).
        let fnDefinable = envRec.CanDeclareGlobalFunction(fn); // 2. If fnDefinable is false, throw a TypeError exception.

        if (!fnDefinable) {
          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, fn + ": global function declarations are not allowed");
        } // 3. Append fn to declaredFunctionNames.


        declaredFunctionNames.push(fn); // 4. Insert d as the first element of functionsToInitialize.

        functionsToInitialize.unshift(d);
      }
    }
  } // 11. Let declaredVarNames be a new empty List.


  let declaredVarNames = []; // 12. For each d in varDeclarations, do

  for (let d of varDeclarations) {
    // a. If d is a VariableDeclaration or a ForBinding, then
    if (d.type === "VariableDeclaration") {
      // i. For each String vn in the BoundNames of d, do
      for (let vn of _singletons.Environment.BoundNames(realm, d)) {
        // ii. If vn is not an element of declaredFunctionNames, then
        if (declaredFunctionNames.indexOf(vn) < 0) {
          // 1. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).
          let vnDefinable = envRec.CanDeclareGlobalVar(vn); // 2. If vnDefinable is false, throw a TypeError exception.

          if (!vnDefinable) {
            throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, vn + ": global variable declarations are not allowed");
          } // 3. If vn is not an element of declaredVarNames, then


          if (declaredVarNames.indexOf(vn) < 0) {
            // a. Append vn to declaredVarNames.
            declaredVarNames.push(vn);
          }
        }
      }
    }
  } // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.
  // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.
  // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.


  let lexDeclarations = [];

  for (let s of ast.body) {
    if (s.type === "VariableDeclaration" && s.kind !== "var") {
      lexDeclarations.push(s);
    }
  } // 16. For each element d in lexDeclarations do


  for (let d of lexDeclarations) {
    // a. NOTE Lexically declared names are only instantiated here but not initialized.
    // b. For each element dn of the BoundNames of d do
    for (let dn of _singletons.Environment.BoundNames(realm, d)) {
      // i. If IsConstantDeclaration of d is true, then
      if (d.kind === "const") {
        // 1. Perform ? envRec.CreateImmutableBinding(dn, true).
        envRec.CreateImmutableBinding(dn, true);
      } else {
        // ii. Else,
        // 1. Perform ? envRec.CreateMutableBinding(dn, false).
        envRec.CreateMutableBinding(dn, false);
      }
    }
  } // 17. For each production f in functionsToInitialize, do


  for (let f of functionsToInitialize) {
    // a. Let fn be the sole element of the BoundNames of f.
    let fn = _singletons.Environment.BoundNames(realm, f)[0]; // b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.


    let fo = env.evaluate(f, strictCode);
    (0, _invariant.default)(fo instanceof _index.Value); // c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).

    envRec.CreateGlobalFunctionBinding(fn, fo, false);
  } // 18. For each String vn in declaredVarNames, in list order do


  for (let vn of declaredVarNames) {
    // a. Perform ? envRec.CreateGlobalVarBinding(vn, false).
    envRec.CreateGlobalVarBinding(vn, false);
  } // 19. Return NormalCompletion(empty).


  return realm.intrinsics.empty;
}

function _default(ast, strictCode, env, realm) {
  strictCode = (0, _strict.default)(ast);
  GlobalDeclarationInstantiation(realm, ast, env, strictCode);
  let val, res;

  for (let node of ast.body) {
    if (node.type !== "FunctionDeclaration") {
      res = env.evaluateCompletionDeref(node, strictCode);
      if (res instanceof _completions.AbruptCompletion && !realm.useAbstractInterpretation) throw res;
      res = _singletons.Functions.incorporateSavedCompletion(realm, res);

      if (res instanceof _completions.Completion) {
        emitThrowStatementsIfNeeded(res);
        if (res instanceof _completions.ThrowCompletion) return res.value; // Program ends here at runtime, so don't carry on

        res = res.value;
      }

      if (!(res instanceof _index.EmptyValue)) {
        val = res;
      }
    }
  }

  let directives = ast.directives;

  if (!val && directives && directives.length) {
    let directive = directives[directives.length - 1];
    val = env.evaluate(directive, strictCode);
    (0, _invariant.default)(val instanceof _index.Value);
  } // We are about to leave this program and this presents a join point where all control flows
  // converge into a single flow and the joined effects become the final state.


  (0, _invariant.default)(val === undefined || val instanceof _index.Value);

  if (val instanceof _index.Value) {
    res = _singletons.Functions.incorporateSavedCompletion(realm, val);
    if (res instanceof _completions.Completion) emitThrowStatementsIfNeeded(res);
  }

  return val || realm.intrinsics.empty;

  function emitThrowStatementsIfNeeded(completion) {
    let generator = realm.generator;
    (0, _invariant.default)(generator !== undefined);

    let selector = c => c instanceof _completions.ThrowCompletion && c.value !== realm.intrinsics.__bottomValue && !(c.value instanceof _index.EmptyValue);

    if (res instanceof _completions.ThrowCompletion && selector(res)) {
      generator.emitThrow(res.value);
    } else if ((res instanceof _completions.JoinedAbruptCompletions || res instanceof _completions.JoinedNormalAndAbruptCompletions) && res.containsSelectedCompletion(selector)) {
      generator.emitConditionalThrow(_singletons.Join.joinValuesOfSelectedCompletions(selector, res, true));
      res = realm.intrinsics.undefined;
    } else {// might get here for completions where all throws have already been handled.
    }
  }
}
//# sourceMappingURL=Program.js.map

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  return (0, _index2.RegExpCreate)(realm, new _index.StringValue(realm, ast.pattern), ast.flags !== undefined ? new _index.StringValue(realm, ast.flags) : undefined);
}
//# sourceMappingURL=RegExpLiteral.js.map

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

var _completions = __webpack_require__(18);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  let arg;

  if (ast.argument) {
    arg = _singletons.Environment.GetValue(realm, env.evaluate(ast.argument, strictCode));
  } else {
    arg = realm.intrinsics.undefined;
  }

  throw new _completions.ReturnCompletion(arg, ast.loc);
}
//# sourceMappingURL=ReturnStatement.js.map

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  (0, _invariant.default)(ast.expressions.length > 0);
  let val;

  for (let node of ast.expressions) {
    val = _singletons.Environment.GetValue(realm, env.evaluate(node, strictCode));
  }

  (0, _invariant.default)(val !== undefined);
  return val;
}
//# sourceMappingURL=SequenceExpression.js.map

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

var _BinaryExpression = __webpack_require__(292);

var _completions = __webpack_require__(18);

var _ForOfStatement = __webpack_require__(582);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// 13.12.10 Runtime Semantics: CaseSelectorEvaluation
function CaseSelectorEvaluation(expression, strictCode, env, realm) {
  // 1. Let exprRef be the result of evaluating Expression.
  let exprRef = env.evaluate(expression, strictCode); // 2. Return ? GetValue(exprRef).

  return _singletons.Environment.GetValue(realm, exprRef);
}

function AbstractCaseBlockEvaluation(cases, defaultCaseIndex, input, strictCode, env, realm) {
  (0, _invariant.default)(realm.useAbstractInterpretation);

  let DefiniteCaseEvaluation = caseIndex => {
    let result = realm.intrinsics.undefined; // we start at the case we've been asked to evaluate, and process statements
    // until there is either a break statement or exception thrown (this means we
    // implicitly fall through correctly in the absence of a break statement).

    while (caseIndex < cases.length) {
      let c = cases[caseIndex];

      for (let i = 0; i < c.consequent.length; i += 1) {
        let node = c.consequent[i];
        let r = env.evaluateCompletionDeref(node, strictCode);

        if (r instanceof _completions.JoinedNormalAndAbruptCompletions) {
          r = realm.composeWithSavedCompletion(r);
        }

        result = (0, _index2.UpdateEmpty)(realm, r, result);
        if (result instanceof _completions.Completion) break;
      }

      if (result instanceof _completions.Completion) break;
      caseIndex++;
    }

    let sc = _singletons.Functions.incorporateSavedCompletion(realm, result);

    (0, _invariant.default)(sc !== undefined);
    result = sc;

    if (result instanceof _completions.JoinedAbruptCompletions || result instanceof _completions.JoinedNormalAndAbruptCompletions) {
      let selector = c => c instanceof _completions.BreakCompletion && !c.target;

      let jc = _index.AbstractValue.createJoinConditionForSelectedCompletions(selector, result);

      let jv = _index.AbstractValue.createFromConditionalOp(realm, jc, realm.intrinsics.empty, result.value);

      result = _completions.Completion.normalizeSelectedCompletions(selector, result);
      realm.composeWithSavedCompletion(result);
      return jv;
    } else if (result instanceof _completions.BreakCompletion) {
      return result.value;
    } else if (result instanceof _completions.AbruptCompletion) {
      throw result;
    } else {
      (0, _invariant.default)(result instanceof _index.Value);
      return result;
    }
  };

  let AbstractCaseEvaluation = caseIndex => {
    if (caseIndex === defaultCaseIndex) {
      // skip the default case until we've exhausted all other options
      return AbstractCaseEvaluation(caseIndex + 1);
    } else if (caseIndex >= cases.length) {
      // this is the stop condition for our recursive search for a matching case.
      // we tried every available case index and since nothing matches we return
      // the default (and if none exists....just empty)
      if (defaultCaseIndex !== -1) {
        return DefiniteCaseEvaluation(defaultCaseIndex);
      } else {
        return realm.intrinsics.empty;
      }
    } // else we have a normal in-range case index


    let c = cases[caseIndex];
    let test = c.test;
    (0, _invariant.default)(test);
    let selector = CaseSelectorEvaluation(test, strictCode, env, realm);
    let selectionResult = (0, _BinaryExpression.computeBinary)(realm, "===", input, selector);

    if (_singletons.Path.implies(selectionResult)) {
      //  we have a winning result for the switch case, bubble it back up!
      return DefiniteCaseEvaluation(caseIndex);
    } else if (_singletons.Path.impliesNot(selectionResult)) {
      // we have a case that is definitely *not* taken
      // so we go and look at the next one in the hope of finding a match
      return AbstractCaseEvaluation(caseIndex + 1);
    } else {
      // we can't be sure whether the case selector evaluates true or not
      // so we evaluate the case in the abstract as an if-else with the else
      // leading to the next case statement
      let trueEffects;

      try {
        trueEffects = _singletons.Path.withCondition(selectionResult, () => {
          return realm.evaluateForEffects(() => {
            return DefiniteCaseEvaluation(caseIndex);
          }, undefined, "AbstractCaseEvaluation/1");
        });
      } catch (e) {
        if (e instanceof _errors.InfeasiblePathError) {
          // selectionResult cannot be true in this path, after all.
          return AbstractCaseEvaluation(caseIndex + 1);
        }

        throw e;
      }

      let falseEffects;

      try {
        falseEffects = _singletons.Path.withInverseCondition(selectionResult, () => {
          return realm.evaluateForEffects(() => {
            return AbstractCaseEvaluation(caseIndex + 1);
          }, undefined, "AbstractCaseEvaluation/2");
        });
      } catch (e) {
        if (e instanceof _errors.InfeasiblePathError) {
          // selectionResult cannot be false in this path, after all.
          return DefiniteCaseEvaluation(caseIndex);
        }

        throw e;
      }

      (0, _invariant.default)(trueEffects !== undefined);
      (0, _invariant.default)(falseEffects !== undefined);

      let joinedEffects = _singletons.Join.joinEffects(selectionResult, trueEffects, falseEffects);

      realm.applyEffects(joinedEffects);
      return realm.returnOrThrowCompletion(joinedEffects.result);
    }
  }; // let the recursive search for a matching case begin!


  return AbstractCaseEvaluation(0);
}

function CaseBlockEvaluation(cases, input, strictCode, env, realm) {
  let EvaluateCase = c => {
    let r = realm.intrinsics.empty;

    for (let node of c.consequent) {
      let res = env.evaluateCompletion(node, strictCode);
      if (res instanceof _completions.AbruptCompletion) return (0, _index2.UpdateEmpty)(realm, res, r);
      if (!(res instanceof _index.EmptyValue)) r = res;
    }

    return r;
  };

  let EvaluateCaseClauses = (A, V) => {
    // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.
    // A is passed in
    // 3. Let found be false.
    let found = false; // 4. Repeat for each CaseClause C in A,

    for (let C of A) {
      // a. If found is false, then
      if (!found) {
        // i. Let clauseSelector be the result of CaseSelectorEvaluation of C.
        let test = C.test;
        (0, _invariant.default)(test);
        let clauseSelector = CaseSelectorEvaluation(test, strictCode, env, realm); // ii. ReturnIfAbrupt(clauseSelector).
        // above will throw a Completion which will return
        // iii. Let found be the result of performing Strict Equality Comparison input === clauseSelector.[[Value]].

        found = (0, _index2.StrictEqualityComparisonPartial)(realm, input, clauseSelector);
      }

      if (found) {
        // b. If found is true, then
        // i. Let R be the result of evaluating C.
        let R = EvaluateCase(C); // ii. If R.[[Value]] is not empty, let V be R.[[Value]].

        let val = (0, _ForOfStatement.InternalGetResultValue)(realm, R);
        if (!(val instanceof _index.EmptyValue)) V = val; // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).

        if (R instanceof _completions.AbruptCompletion) {
          throw (0, _index2.UpdateEmpty)(realm, R, V);
        }
      }
    }

    return [found, V];
  }; // CaseBlock:{}
  // 1. Return NormalCompletion(undefined).


  if (cases.length === 0) return realm.intrinsics.undefined; // CaseBlock:{CaseClauses DefaultClause CaseClauses}

  let default_case_num = cases.findIndex(clause => {
    return clause.test === null;
  }); // Abstract interpretation of case blocks is a significantly different process
  // from regular interpretation, so we fork off early to keep things tidily separated.

  if (input instanceof _index.AbstractValue && cases.length < 6) {
    return AbstractCaseBlockEvaluation(cases, default_case_num, input, strictCode, env, realm);
  }

  if (default_case_num !== -1) {
    // 2. Let A be the List of CaseClause items in the first CaseClauses, in source text order. If the first CaseClauses is not present, A is  .
    let A = cases.slice(0, default_case_num);
    let V = realm.intrinsics.undefined; // 4. Repeat for each CaseClause C in A

    [, V] = EvaluateCaseClauses(A, V); // 5. Let foundInB be false.

    let foundInB = false; // 6. Let B be the List containing the CaseClause items in the second CaseClauses, in source text order. If the second CaseClauses is not present, B is  .

    let B = cases.slice(default_case_num + 1);
    [foundInB, V] = EvaluateCaseClauses(B, V); // 8. If foundInB is true, return NormalCompletion(V).

    if (foundInB) return V; // 9. Let R be the result of evaluating DefaultClause.

    let R = EvaluateCase(cases[default_case_num]); // 10. If R.[[Value]] is not empty, let V be R.[[Value]].

    let val = (0, _ForOfStatement.InternalGetResultValue)(realm, R);
    if (!(val instanceof _index.EmptyValue)) V = val; // 11. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).

    if (R instanceof _completions.AbruptCompletion) {
      throw (0, _index2.UpdateEmpty)(realm, R, V);
    } // 12: Repeat for each CaseClause C in B (NOTE this is another complete iteration of the second CaseClauses)


    for (let C of B) {
      // a. Let R be the result of evaluating CaseClause C.
      R = EvaluateCase(C); // b. If R.[[Value]] is not empty, let V be R.[[Value]].

      let value = (0, _ForOfStatement.InternalGetResultValue)(realm, R);
      if (!(value instanceof _index.EmptyValue)) V = value; // c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).

      if (R instanceof _completions.AbruptCompletion) {
        throw (0, _index2.UpdateEmpty)(realm, R, V);
      }
    } // 13. Return NormalCompletion(V).


    return V;
  } else {
    // CaseBlock:{CaseClauses}
    let V;
    [, V] = EvaluateCaseClauses(cases, realm.intrinsics.undefined);
    return V;
  }
} // 13.12.11


function _default(ast, strictCode, env, realm, labelSet) {
  let expression = ast.discriminant; // 1. Let exprRef be the result of evaluating Expression.

  let exprRef = env.evaluate(expression, strictCode); // 2. Let switchValue be ? GetValue(exprRef).

  let switchValue = _singletons.Environment.GetValue(realm, exprRef);

  if (switchValue instanceof _index.AbstractValue && !switchValue.values.isTop()) {
    let elems = switchValue.values.getElements();
    let n = elems.size;

    if (n > 1 && n < 10) {
      return _singletons.Join.mapAndJoin(realm, elems, concreteSwitchValue => _index.AbstractValue.createFromBinaryOp(realm, "===", switchValue, concreteSwitchValue), concreteSwitchValue => evaluationHelper(ast, concreteSwitchValue, strictCode, env, realm, labelSet));
    }
  }

  return evaluationHelper(ast, switchValue, strictCode, env, realm, labelSet);
}

function evaluationHelper(ast, switchValue, strictCode, env, realm, labelSet) {
  let cases = ast.cases; // 3. Let oldEnv be the running execution context's LexicalEnvironment.

  let oldEnv = realm.getRunningContext().lexicalEnvironment; // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).

  let blockEnv = _singletons.Environment.NewDeclarativeEnvironment(realm, oldEnv); // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).


  let CaseBlock = [];
  cases.forEach(c => CaseBlock.push(...c.consequent));

  _singletons.Environment.BlockDeclarationInstantiation(realm, strictCode, CaseBlock, blockEnv); // 6. Set the running execution context's LexicalEnvironment to blockEnv.


  realm.getRunningContext().lexicalEnvironment = blockEnv;
  let R;

  try {
    // 7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.
    R = CaseBlockEvaluation(cases, switchValue, strictCode, blockEnv, realm); // 9. Return R.

    return R;
  } catch (e) {
    if (e instanceof _completions.BreakCompletion) {
      if (!e.target) return (0, _index2.UpdateEmpty)(realm, e, realm.intrinsics.undefined).value;
    }

    throw e;
  } finally {
    // 8. Set the running execution context's LexicalEnvironment to oldEnv.
    realm.getRunningContext().lexicalEnvironment = oldEnv;
    realm.onDestroyScope(blockEnv);
  }
}
//# sourceMappingURL=SwitchStatement.js.map

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _call = __webpack_require__(234);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 12.3.7
function _default(ast, strictCode, env, realm) {
  // 1. Let tagRef be the result of evaluating MemberExpression.
  let tagRef = env.evaluate(ast.tag, strictCode); // 2. Let thisCall be this MemberExpression.
  // 3. Let tailCall be IsInTailPosition(thisCall).
  // 4. Return ? EvaluateCall(tagRef, TemplateLiteral, tailCall).

  return (0, _call.EvaluateCall)(realm, strictCode, env, tagRef, ast.quasi);
}
//# sourceMappingURL=TaggedTemplateExpression.js.map

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 12.2.9
function _default(ast, strictCode, env, realm) {
  let str = "";

  for (let i = 0; i < ast.quasis.length; i++) {
    // add quasi
    let elem = ast.quasis[i];
    str += elem.value.cooked; // add expression

    let expr = ast.expressions[i];

    if (expr) {
      str += _singletons.To.ToStringPartial(realm, _singletons.Environment.GetValue(realm, env.evaluate(expr, strictCode)));
    }
  }

  return new _index.StringValue(realm, str);
}
//# sourceMappingURL=TemplateLiteral.js.map

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 12.2.2.1
function _default(ast, strictCode, env, realm) {
  // 1. Return ? ResolveThisBinding( ).
  return _singletons.Environment.ResolveThisBinding(realm);
}
//# sourceMappingURL=ThisExpression.js.map

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _completions = __webpack_require__(18);

var _singletons = __webpack_require__(236);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  let exprRef = env.evaluate(ast.argument, strictCode);

  let exprValue = _singletons.Environment.GetValue(realm, exprRef);

  throw new _completions.ThrowCompletion(exprValue, ast.loc);
}
//# sourceMappingURL=ThrowStatement.js.map

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _completions = __webpack_require__(18);

var _index = __webpack_require__(232);

var _errors = __webpack_require__(3);

var _realm = __webpack_require__(7);

var _singletons = __webpack_require__(236);

var _index2 = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(ast, strictCode, env, realm) {
  if (realm.useAbstractInterpretation) return joinTryBlockWithHandlers(ast, strictCode, env, realm);
  let blockRes = env.evaluateCompletionDeref(ast.block, strictCode);
  let result = blockRes;

  if (blockRes instanceof _completions.ThrowCompletion && ast.handler) {
    result = env.evaluateCompletionDeref(ast.handler, strictCode, blockRes);
  }

  if (ast.finalizer) {
    result = composeResults(result, env.evaluateCompletionDeref(ast.finalizer, strictCode));
  }

  return realm.returnOrThrowCompletion((0, _index.UpdateEmpty)(realm, result, realm.intrinsics.undefined));
}

function composeResults(r1, r2) {
  if (r2 instanceof _completions.AbruptCompletion) return r2;
  return _singletons.Join.composeCompletions(r2, r1);
}

function joinTryBlockWithHandlers(ast, strictCode, env, realm) {
  let savedIsInPureTryStatement = realm.isInPureTryStatement;

  if (realm.isInPureScope()) {
    // TODO(1264): This is used to issue a warning if we have abstract function calls in here.
    // We might not need it once we have full support for handling potential errors. Even
    // then we might need it to know whether we should bother tracking error handling.
    realm.isInPureTryStatement = true;
  }

  let blockRes = env.evaluateCompletionDeref(ast.block, strictCode); // this is a join point for break and continue completions

  blockRes = _singletons.Functions.incorporateSavedCompletion(realm, blockRes);
  (0, _invariant.default)(blockRes !== undefined);
  realm.isInPureTryStatement = savedIsInPureTryStatement;
  let result = blockRes;
  let handler = ast.handler;

  let selector = c => c instanceof _completions.ThrowCompletion;

  if (handler && blockRes instanceof _completions.Completion && blockRes.containsSelectedCompletion(selector)) {
    if (blockRes instanceof _completions.ThrowCompletion) {
      result = env.evaluateCompletionDeref(handler, strictCode, blockRes);
    } else {
      (0, _invariant.default)(blockRes instanceof _completions.JoinedAbruptCompletions || blockRes instanceof _completions.JoinedNormalAndAbruptCompletions); // put the handler under a guard that excludes normal paths from entering it.

      let joinCondition = _index2.AbstractValue.createJoinConditionForSelectedCompletions(selector, blockRes);

      if (joinCondition.mightNotBeFalse()) {
        try {
          let handlerEffects = _singletons.Path.withCondition(joinCondition, () => {
            (0, _invariant.default)(blockRes instanceof _completions.Completion);
            let joinedThrow = new _completions.ThrowCompletion(_singletons.Join.joinValuesOfSelectedCompletions(selector, blockRes));

            let handlerEval = () => env.evaluateCompletionDeref(handler, strictCode, joinedThrow);

            return realm.evaluateForEffects(handlerEval, undefined, "joinTryBlockWithHandlers");
          });

          _completions.Completion.makeSelectedCompletionsInfeasible(selector, blockRes);

          let emptyEffects = (0, _realm.construct_empty_effects)(realm, blockRes);
          handlerEffects = _singletons.Join.joinEffects(joinCondition, handlerEffects, emptyEffects);
          realm.applyEffects(handlerEffects);
          result = handlerEffects.result;
        } catch (e) {
          if (!(e instanceof _errors.InfeasiblePathError)) throw e; // It turns out that the handler is not reachable after all so just do nothing and carry on
        }
      }
    }
  }

  if (ast.finalizer) {
    let res = env.evaluateCompletionDeref(ast.finalizer, strictCode);
    result = composeResults(result, res);
  }

  return realm.returnOrThrowCompletion((0, _index.UpdateEmpty)(realm, result, realm.intrinsics.undefined));
}
//# sourceMappingURL=TryStatement.js.map

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(15);

var _index2 = __webpack_require__(10);

var _environment = __webpack_require__(20);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index3 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
//import { SimpleNormalCompletion } from "../completions.js";
function isInstance(proto, Constructor) {
  return proto instanceof Constructor || proto === Constructor.prototype;
}

function evaluateDeleteOperation(expr, realm) {
  // ECMA262 12.5.3.2
  // 1. Let ref be the result of evaluating UnaryExpression.
  let ref = expr; // 2. ReturnIfAbrupt(ref).
  // 3. If Type(ref) is not Reference, return true.

  if (!(ref instanceof _environment.Reference)) return realm.intrinsics.true; // 4. If IsUnresolvableReference(ref) is true, then

  if (_singletons.Environment.IsUnresolvableReference(realm, ref)) {
    // a. Assert: IsStrictReference(ref) is false.
    (0, _invariant.default)(!_singletons.Environment.IsStrictReference(realm, ref), "did not expect a strict reference"); // b. Return true.

    return realm.intrinsics.true;
  } // 5. If IsPropertyReference(ref) is true, then


  if (_singletons.Environment.IsPropertyReference(realm, ref)) {
    // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.
    if (_singletons.Environment.IsSuperReference(realm, ref)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);
    } // b. Let baseObj be ! ToObject(GetBase(ref)).


    let base = _singletons.Environment.GetBase(realm, ref); // Constructing the reference checks that base is coercible to an object hence


    (0, _invariant.default)(base instanceof _index2.ConcreteValue || base instanceof _index2.AbstractObjectValue);

    let baseObj = _singletons.To.ToObject(realm, base); // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).


    let deleteStatus = baseObj.$Delete(_singletons.Environment.GetReferencedName(realm, ref)); // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.

    if (!deleteStatus && _singletons.Environment.IsStrictReference(realm, ref)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // e. Return deleteStatus.


    return new _index2.BooleanValue(realm, deleteStatus);
  } // 6. Else ref is a Reference to an Environment Record binding,
  // a. Let bindings be GetBase(ref).


  let bindings = _singletons.Environment.GetBase(realm, ref);

  (0, _invariant.default)(bindings instanceof _environment.EnvironmentRecord); // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).

  let referencedName = _singletons.Environment.GetReferencedName(realm, ref);

  (0, _invariant.default)(typeof referencedName === "string");
  return new _index2.BooleanValue(realm, bindings.DeleteBinding(referencedName));
}

function tryToEvaluateOperationOrLeaveAsAbstract(ast, expr, func, strictCode, realm) {
  let effects;

  try {
    effects = realm.evaluateForEffects(() => func(ast, expr, strictCode, realm), undefined, "tryToEvaluateOperationOrLeaveAsAbstract");
  } catch (error) {
    if (error instanceof _errors.FatalError) {
      return realm.evaluateWithPossibleThrowCompletion(() => {
        let value = _singletons.Environment.GetValue(realm, expr); // if the value is abstract, then create a unary op for it,
        // otherwise we rethrow the error as we don't handle it at this
        // point in time


        if (value instanceof _index2.AbstractValue) {
          return _index2.AbstractValue.createFromUnaryOp(realm, ast.operator, value);
        }

        throw error;
      }, _index.TypesDomain.topVal, _index.ValuesDomain.topVal);
    } else {
      throw error;
    }
  }

  realm.applyEffects(effects);
  return realm.returnOrThrowCompletion(effects.result);
}

function evaluateOperation(ast, expr, strictCode, realm) {
  function reportError(value) {
    if (value.getType() === _index2.SymbolValue) {
      // Symbols never implicitly coerce to primitives.
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    let error = new _errors.CompilerDiagnostic("might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method", ast.argument.loc, "PP0008", "RecoverableError");
    if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
  }

  if (ast.operator === "+") {
    // ECMA262 12.5.6.1
    // 1. Let expr be the result of evaluating UnaryExpression.
    expr; // 2. Return ? ToNumber(? GetValue(expr)).

    let value = _singletons.Environment.GetValue(realm, expr);

    if (value instanceof _index2.AbstractValue) {
      if (!_singletons.To.IsToNumberPure(realm, value)) reportError(value);
      return _index2.AbstractValue.createFromUnaryOp(realm, "+", value);
    }

    (0, _invariant.default)(value instanceof _index2.ConcreteValue);
    return _index2.IntegralValue.createFromNumberValue(realm, _singletons.To.ToNumber(realm, value));
  } else if (ast.operator === "-") {
    // ECMA262 12.5.7.1
    // 1. Let expr be the result of evaluating UnaryExpression.
    expr; // 2. Let oldValue be ? ToNumber(? GetValue(expr)).

    let value = _singletons.Environment.GetValue(realm, expr);

    if (value instanceof _index2.AbstractValue) {
      if (!_singletons.To.IsToNumberPure(realm, value)) reportError(value);
      return _index2.AbstractValue.createFromUnaryOp(realm, "-", value);
    }

    (0, _invariant.default)(value instanceof _index2.ConcreteValue);

    let oldValue = _singletons.To.ToNumber(realm, value); // 3. If oldValue is NaN, return NaN.


    if (isNaN(oldValue)) {
      return realm.intrinsics.NaN;
    } // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.


    return _index2.IntegralValue.createFromNumberValue(realm, -oldValue);
  } else if (ast.operator === "~") {
    // ECMA262 12.5.8
    // 1. Let expr be the result of evaluating UnaryExpression.
    expr; // 2. Let oldValue be ? ToInt32(? GetValue(expr)).

    let value = _singletons.Environment.GetValue(realm, expr);

    if (value instanceof _index2.AbstractValue) {
      if (!_singletons.To.IsToNumberPure(realm, value)) reportError(value);
      return _index2.AbstractValue.createFromUnaryOp(realm, "~", value);
    }

    (0, _invariant.default)(value instanceof _index2.ConcreteValue);

    let oldValue = _singletons.To.ToInt32(realm, value); // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.


    return _index2.IntegralValue.createFromNumberValue(realm, ~oldValue);
  } else if (ast.operator === "!") {
    // ECMA262 12.6.9
    // 1. Let expr be the result of evaluating UnaryExpression.
    expr; // 2. Let oldValue be ToBoolean(? GetValue(expr)).

    let value = _singletons.Environment.GetConditionValue(realm, expr);

    if (value instanceof _index2.AbstractValue) return _index2.AbstractValue.createFromUnaryOp(realm, "!", value);
    (0, _invariant.default)(value instanceof _index2.ConcreteValue);

    let oldValue = _singletons.To.ToBoolean(realm, value); // 3. If oldValue is true, return false.


    if (oldValue === true) return realm.intrinsics.false; // 4. Return true.

    return realm.intrinsics.true;
  } else if (ast.operator === "void") {
    // 1. Let expr be the result of evaluating UnaryExpression.
    expr; // 2. Perform ? GetValue(expr).

    _singletons.Environment.GetValue(realm, expr); // 3. Return undefined.


    return realm.intrinsics.undefined;
  } else {
    (0, _invariant.default)(ast.operator === "typeof"); // ECMA262 12.6.5
    // 1. Let val be the result of evaluating UnaryExpression.

    let val = expr; // 2. If Type(val) is Reference, then

    if (val instanceof _environment.Reference) {
      // a. If IsUnresolvableReference(val) is true, return "undefined".
      if (_singletons.Environment.IsUnresolvableReference(realm, val)) {
        return new _index2.StringValue(realm, "undefined");
      }
    } // 3. Let val be ? GetValue(val).


    val = _singletons.Environment.GetValue(realm, val); // 4. Return a String according to Table 35.

    let proto = val.getType().prototype;

    if (isInstance(proto, _index2.UndefinedValue)) {
      return new _index2.StringValue(realm, "undefined");
    } else if (isInstance(proto, _index2.NullValue)) {
      return new _index2.StringValue(realm, "object");
    } else if (isInstance(proto, _index2.StringValue)) {
      return new _index2.StringValue(realm, "string");
    } else if (isInstance(proto, _index2.BooleanValue)) {
      return new _index2.StringValue(realm, "boolean");
    } else if (isInstance(proto, _index2.NumberValue)) {
      return new _index2.StringValue(realm, "number");
    } else if (isInstance(proto, _index2.SymbolValue)) {
      return new _index2.StringValue(realm, "symbol");
    } else if (isInstance(proto, _index2.ObjectValue)) {
      if ((0, _index3.IsCallable)(realm, val)) {
        return new _index2.StringValue(realm, "function");
      }

      return new _index2.StringValue(realm, "object");
    } else {
      (0, _invariant.default)(val instanceof _index2.AbstractValue);
      return _index2.AbstractValue.createFromUnaryOp(realm, "typeof", val);
    }
  }
}

function _default(ast, strictCode, env, realm) {
  let expr = env.evaluate(ast.argument, strictCode);

  if (ast.operator === "delete") {
    return evaluateDeleteOperation(expr, realm);
  }

  if (realm.isInPureScope()) {
    return tryToEvaluateOperationOrLeaveAsAbstract(ast, expr, evaluateOperation, strictCode, realm);
  } else {
    return evaluateOperation(ast, expr, strictCode, realm);
  }
}
//# sourceMappingURL=UnaryExpression.js.map

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(232);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index3 = __webpack_require__(15);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  // ECMA262 12.4 Update Expressions
  // Let expr be the result of evaluating UnaryExpression.
  let expr = env.evaluate(ast.argument, strictCode); // Let oldValue be ? ToNumber(? GetValue(expr)).

  let oldExpr = _singletons.Environment.GetValue(realm, expr);

  if (oldExpr instanceof _index2.AbstractValue) {
    (0, _invariant.default)(ast.operator === "++" || ast.operator === "--"); // As per BabelNodeUpdateExpression

    let op = ast.operator === "++" ? "+" : "-";

    let newAbstractValue = _index2.AbstractValue.createFromBinaryOp(realm, op, oldExpr, new _index2.NumberValue(realm, 1), ast.loc);

    if (!_singletons.To.IsToNumberPure(realm, oldExpr)) {
      if (realm.isInPureScope()) {
        // In pure scope we have to treat the ToNumber operation as temporal since it
        // might throw or mutate something. We also need to leak the argument due to the
        // possible mutations.
        _singletons.Leak.value(realm, oldExpr);

        newAbstractValue = realm.evaluateWithPossibleThrowCompletion(() => _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.NumberValue, [oldExpr], (0, _generator.createOperationDescriptor)("UPDATE_INCREMENTOR", {
          incrementor: op
        })), _index3.TypesDomain.topVal, _index3.ValuesDomain.topVal);
      } else {
        let error = new _errors.CompilerDiagnostic("might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method", ast.argument.loc, "PP0008", "RecoverableError");
        if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
      }
    }

    _singletons.Properties.PutValue(realm, expr, newAbstractValue);

    if (ast.prefix === true) {
      return newAbstractValue;
    } else {
      return oldExpr;
    }
  }

  let oldValue = _singletons.To.ToNumber(realm, oldExpr);

  if (ast.prefix === true) {
    if (ast.operator === "++") {
      // ECMA262 12.4.6.1
      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5)
      let newValue = (0, _index.Add)(realm, oldValue, 1); // 4. Perform ? PutValue(expr, newValue).

      _singletons.Properties.PutValue(realm, expr, newValue); // 5. Return newValue.


      return newValue;
    } else if (ast.operator === "--") {
      // ECMA262 12.4.7.1
      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).
      let newValue = (0, _index.Add)(realm, oldValue, -1); // 4. Perform ? PutValue(expr, newValue).

      _singletons.Properties.PutValue(realm, expr, newValue); // 5. Return newValue.


      return newValue;
    }

    (0, _invariant.default)(false);
  } else {
    if (ast.operator === "++") {
      // ECMA262 12.4.4.1
      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).
      let newValue = (0, _index.Add)(realm, oldValue, 1); // 4. Perform ? PutValue(lhs, newValue).

      _singletons.Properties.PutValue(realm, expr, newValue); // 5. Return oldValue.


      return _index2.IntegralValue.createFromNumberValue(realm, oldValue);
    } else if (ast.operator === "--") {
      // ECMA262 12.4.5.1
      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).
      let newValue = (0, _index.Add)(realm, oldValue, -1); // 4. Perform ? PutValue(lhs, newValue).

      _singletons.Properties.PutValue(realm, expr, newValue); // 5. Return oldValue.


      return _index2.IntegralValue.createFromNumberValue(realm, oldValue);
    }

    (0, _invariant.default)(false);
  }
}
//# sourceMappingURL=UpdateExpression.js.map

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 13.3.1.4
function letAndConst(ast, strictCode, env, realm) {
  for (let declar of ast.declarations) {
    let Initializer = declar.init;

    if (declar.id.type === "Identifier" && !Initializer) {
      (0, _invariant.default)(ast.kind !== "const", "const without an initializer"); // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).

      let bindingId = declar.id.name;

      let lhs = _singletons.Environment.ResolveBinding(realm, bindingId, strictCode); // 2. Return InitializeReferencedBinding(lhs, undefined).


      _singletons.Environment.InitializeReferencedBinding(realm, lhs, realm.intrinsics.undefined);

      continue;
    } else if (declar.id.type === "Identifier" && Initializer) {
      // 1. Let bindingId be StringValue of BindingIdentifier.
      let bindingId = declar.id.name; // 2. Let lhs be ResolveBinding(bindingId).

      let lhs = _singletons.Environment.ResolveBinding(realm, bindingId, strictCode); // 3. Let rhs be the result of evaluating Initializer.


      let rhs = env.evaluate(Initializer, strictCode); // 4. Let value be ? GetValue(rhs).

      let value = _singletons.Environment.GetValue(realm, rhs); // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then


      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer)) {
        (0, _invariant.default)(value instanceof _index.ObjectValue); // a. Let hasNameProperty be ? HasOwnProperty(value, "name").

        let hasNameProperty = (0, _index2.HasOwnProperty)(realm, value, "name"); // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).

        if (!hasNameProperty) _singletons.Functions.SetFunctionName(realm, value, new _index.StringValue(realm, bindingId));
      } // 6. Return InitializeReferencedBinding(lhs, value).


      _singletons.Environment.InitializeReferencedBinding(realm, lhs, value);
    } else if ((declar.id.type === "ObjectPattern" || declar.id.type === "ArrayPattern") && Initializer) {
      // 1. Let rhs be the result of evaluating Initializer.
      let rhs = env.evaluate(Initializer, strictCode); // 2. Let rval be ? GetValue(rhs).

      let rval = _singletons.Environment.GetValue(realm, rhs); // 3. Let env be the running execution contexts LexicalEnvironment.
      // 4. Return the result of performing BindingInitialization for BindingPattern using value and env as the arguments.


      _singletons.Environment.BindingInitialization(realm, declar.id, rval, strictCode, env);
    } else {
      (0, _invariant.default)(false, "unrecognized declaration");
    }
  }

  return realm.intrinsics.empty;
} // ECMA262 13.3.2.4


function _default(ast, strictCode, env, realm) {
  if (ast.kind === "let" || ast.kind === "const") {
    return letAndConst(ast, strictCode, env, realm);
  }

  for (let declar of ast.declarations) {
    let Initializer = declar.init;

    if (declar.id.type === "Identifier" && !Initializer) {
      // VariableDeclaration : BindingIdentifier
      // 1. Return NormalCompletion(empty).
      continue;
    } else if (declar.id.type === "Identifier" && Initializer) {
      // VariableDeclaration : BindingIdentifier Initializer
      // 1. Let bindingId be StringValue of BindingIdentifier.
      let bindingId = declar.id.name; // 2. Let lhs be ? ResolveBinding(bindingId).

      let lhs = _singletons.Environment.ResolveBinding(realm, bindingId, strictCode); // 3. Let rhs be the result of evaluating Initializer.


      let rhs = env.evaluate(Initializer, strictCode); // 4. Let value be ? GetValue(rhs).

      let value = _singletons.Environment.GetValue(realm, rhs);

      if (declar.id && declar.id.name !== undefined) value.__originalName = bindingId; // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then

      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, Initializer)) {
        (0, _invariant.default)(value instanceof _index.ObjectValue); // a. Let hasNameProperty be ? HasOwnProperty(value, "name").

        let hasNameProperty = (0, _index2.HasOwnProperty)(realm, value, "name"); // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).

        if (!hasNameProperty) _singletons.Functions.SetFunctionName(realm, value, new _index.StringValue(realm, bindingId));
      } // 6. Return ? PutValue(lhs, value).


      _singletons.Properties.PutValue(realm, lhs, value);
    } else if ((declar.id.type === "ObjectPattern" || declar.id.type === "ArrayPattern") && Initializer) {
      // 1. Let rhs be the result of evaluating Initializer.
      let rhs = env.evaluate(Initializer, strictCode); // 2. Let rval be ? GetValue(rhs).

      let rval = _singletons.Environment.GetValue(realm, rhs); // 3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.


      _singletons.Environment.BindingInitialization(realm, declar.id, rval, strictCode, undefined);
    } else {
      (0, _invariant.default)(false, "unrecognized declaration");
    }
  }

  return realm.intrinsics.empty;
}
//# sourceMappingURL=VariableDeclaration.js.map

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(ast, strictCode, env, realm, labelSet) {
  let r = env.evaluate({
    type: "ForStatement",
    init: null,
    test: ast.test,
    update: null,
    body: ast.body
  }, strictCode, labelSet);
  (0, _invariant.default)(r instanceof _index.Value);
  return r;
}
//# sourceMappingURL=WhileStatement.js.map

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// ECMA262 13.11.7
function _default(ast, strictCode, env, realm) {
  // 1. Let val be the result of evaluating Expression.
  let val = env.evaluate(ast.object, strictCode); // 2. Let obj be ? ToObject(? GetValue(val)).

  val = _singletons.Environment.GetValue(realm, val);

  if (val instanceof _index.AbstractValue || val instanceof _index.ObjectValue && val.isPartialObject()) {
    let loc = ast.object.loc;
    let error = new _errors.CompilerDiagnostic("with object must be a known value", loc, "PP0007", "RecoverableError");
    if (realm.handleError(error) === "Fail") throw new _errors.FatalError();
  }

  let obj = _singletons.To.ToObject(realm, val); // 3. Let oldEnv be the running execution context's LexicalEnvironment.


  let oldEnv = env; // 4. Let newEnv be NewObjectEnvironment(obj, oldEnv).

  let newEnv = _singletons.Environment.NewObjectEnvironment(realm, obj, oldEnv); // 5. Set the withEnvironment flag of newEnv's EnvironmentRecord to true.


  (0, _invariant.default)(newEnv.environmentRecord instanceof _environment.ObjectEnvironmentRecord);
  newEnv.environmentRecord.withEnvironment = true; // 6. Set the running execution context's LexicalEnvironment to newEnv.

  realm.getRunningContext().lexicalEnvironment = newEnv;

  try {
    // 7. Let C be the result of evaluating Statement.
    let C = newEnv.evaluateCompletion(ast.body, strictCode);
    (0, _invariant.default)(C instanceof _index.Value || C instanceof _completions.AbruptCompletion); // 9. Return Completion(UpdateEmpty(C, undefined)).

    let res = (0, _index2.UpdateEmpty)(realm, C, realm.intrinsics.undefined);
    if (res instanceof _completions.AbruptCompletion) throw res;
    (0, _invariant.default)(res instanceof _index.Value);
    return res;
  } finally {
    // 8. Set the running execution context's LexicalEnvironment to oldEnv.
    realm.getRunningContext().lexicalEnvironment = oldEnv;
    realm.onDestroyScope(newEnv);
  }
}
//# sourceMappingURL=WithStatement.js.map

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _errors = __webpack_require__(3);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(ast, strictCode, env, realm) {
  throw new _errors.FatalError("TODO: #712 YieldExpression");
}
//# sourceMappingURL=YieldExpression.js.map

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _jsx = __webpack_require__(436);

var _index2 = __webpack_require__(232);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _elements = __webpack_require__(420);

var _utils = __webpack_require__(291);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// taken from Babel
function cleanJSXElementLiteralChild(child) {
  let lines = child.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  let str = "";

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    let isFirstLine = i === 0;
    let isLastLine = i === lines.length - 1;
    let isLastNonEmptyLine = i === lastNonEmptyLine; // replace rendered whitespace tabs with spaces

    let trimmedLine = line.replace(/\t/g, " "); // trim whitespace touching a newline

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    } // trim whitespace touching an endline


    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) {
    return str;
  }

  return null;
}

function evaluateJSXMemberExpression(ast, strictCode, env, realm) {
  switch (ast.type) {
    case "JSXIdentifier":
      return _singletons.Environment.GetValue(realm, _singletons.Environment.ResolveBinding(realm, ast.name, strictCode, env));

    case "JSXMemberExpression":
      return _singletons.Environment.GetValue(realm, env.evaluate((0, _jsx.convertJSXExpressionToIdentifier)(ast), strictCode));

    default:
      (0, _invariant.default)(false, "Unknown JSX Identifier");
  }
}

function evaluateJSXIdentifier(ast, strictCode, env, realm) {
  if (isTagName(ast)) {
    // special cased lower-case and custom elements
    return new _index.StringValue(realm, ast.name);
  }

  return evaluateJSXMemberExpression(ast, strictCode, env, realm);
}

function evaluateJSXValue(value, strictCode, env, realm) {
  if (value != null) {
    switch (value.type) {
      case "JSXText":
        return new _index.StringValue(realm, value.value);

      case "StringLiteral":
        return new _index.StringValue(realm, value.value);

      case "JSXExpressionContainer":
        return _singletons.Environment.GetValue(realm, env.evaluate(value.expression, strictCode));

      case "JSXElement":
        return _singletons.Environment.GetValue(realm, env.evaluate(value, strictCode));

      default:
        (0, _invariant.default)(false, `Unknown JSX value type: ${value.type}`);
    }
  }

  (0, _invariant.default)(false, `Null or undefined value passed when trying to evaluate JSX node value`);
}

function isTagName(ast) {
  return ast.type === "JSXIdentifier" && /^[a-z]|\-/.test(ast.name);
}

function evaluateJSXChildren(children, strictCode, env, realm) {
  if (children.length === 0) {
    return undefined;
  }

  if (children.length === 1) {
    let singleChild = evaluateJSXValue(children[0], strictCode, env, realm);

    if (singleChild instanceof _index.StringValue) {
      let text = cleanJSXElementLiteralChild(singleChild.value);

      if (text !== null) {
        singleChild.value = text;
      }
    }

    return singleChild;
  }

  let array = _singletons.Create.ArrayCreate(realm, 0);

  let dynamicChildrenLength = children.length;
  let dynamicIterator = 0;
  let lastChildValue = realm.intrinsics.undefined;

  for (let i = 0; i < children.length; i++) {
    let value = evaluateJSXValue(children[i], strictCode, env, realm);

    if (value instanceof _index.StringValue) {
      let text = cleanJSXElementLiteralChild(value.value);

      if (text === null) {
        dynamicChildrenLength--; // this is a space full of whitespace, so let's proceed

        continue;
      } else {
        value.value = text;
      }
    }

    lastChildValue = value;

    _singletons.Create.CreateDataPropertyOrThrow(realm, array, "" + dynamicIterator, value);

    dynamicIterator++;
  }

  if (dynamicChildrenLength === 1) {
    return lastChildValue;
  }

  _singletons.Properties.Set(realm, array, "length", new _index.NumberValue(realm, dynamicChildrenLength), false);

  array.makeFinal();
  return array;
}

function isObjectEmpty(realm, object) {
  let propertyCount = 0;

  for (let [, binding] of object.properties) {
    if (binding && binding.descriptor && binding.descriptor.throwIfNotConcrete(realm).enumerable) {
      propertyCount++;
    }
  }

  return propertyCount === 0;
}

function evaluateJSXAttributes(astAttributes, strictCode, env, realm) {
  let config = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);

  let abstractPropsArgs = [];
  let abstractSpreadCount = 0;
  let safeAbstractSpreadCount = 0;
  let spreadValue;

  const setConfigProperty = (name, value) => {
    (0, _invariant.default)(config instanceof _index.ObjectValue);

    _singletons.Properties.Set(realm, config, name, value, true);
  };

  for (let astAttribute of astAttributes) {
    switch (astAttribute.type) {
      case "JSXAttribute":
        let {
          name,
          value
        } = astAttribute;
        (0, _invariant.default)(name.type === "JSXIdentifier", `JSX attribute name type not supported: ${astAttribute.type}`);
        setConfigProperty(name.name, evaluateJSXValue(value, strictCode, env, realm));
        break;

      case "JSXSpreadAttribute":
        spreadValue = _singletons.Environment.GetValue(realm, env.evaluate(astAttribute.argument, strictCode));

        if (spreadValue instanceof _index.ObjectValue && !spreadValue.isPartialObject()) {
          for (let [spreadPropKey, binding] of spreadValue.properties) {
            if (binding && binding.descriptor && binding.descriptor.throwIfNotConcrete(realm).enumerable) {
              setConfigProperty(spreadPropKey, (0, _index2.Get)(realm, spreadValue, spreadPropKey));
            }
          }
        } else {
          abstractSpreadCount++;

          if (spreadValue instanceof _index.AbstractValue && !(spreadValue instanceof _index.AbstractObjectValue)) {
            spreadValue = _singletons.To.ToObject(realm, spreadValue);
          }

          (0, _invariant.default)(spreadValue instanceof _index.AbstractObjectValue || spreadValue instanceof _index.ObjectValue);

          if ((0, _utils.hasNoPartialKeyOrRef)(realm, spreadValue)) {
            safeAbstractSpreadCount++;
          }

          if (!isObjectEmpty(realm, config)) {
            abstractPropsArgs.push(config);
          }

          abstractPropsArgs.push(spreadValue);
          config = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);
        }

        break;

      default:
        (0, _invariant.default)(false, `Unknown JSX attribute type: ${astAttribute.type}`);
    }
  }

  if (abstractSpreadCount > 0) {
    // if we only have a single spread config, then use that,
    // i.e. <div {...something} />  -->  React.createElement("div", something)
    if (abstractSpreadCount === 1 && astAttributes.length === 1 && (spreadValue instanceof _index.ObjectValue || spreadValue instanceof _index.AbstractObjectValue)) {
      return spreadValue;
    } // we create an abstract Object.assign() to deal with the fact that we don't what
    // the props are because they contain abstract spread attributes that we can't
    // evaluate ahead of time
    // push the current config


    abstractPropsArgs.push(config); // create a new config object that will be the target of the Object.assign

    config = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);
    (0, _utils.applyObjectAssignConfigsForReactElement)(realm, config, abstractPropsArgs);

    if (safeAbstractSpreadCount === abstractSpreadCount) {
      (0, _utils.flagPropsWithNoPartialKeyOrRef)(realm, config);
    }
  }

  (0, _invariant.default)(config instanceof _index.ObjectValue || config instanceof _index.AbstractObjectValue);
  return config;
}

function _default(ast, strictCode, env, realm) {
  (0, _invariant.default)(realm.react.enabled, "JSXElements can only be evaluated with the reactEnabled option");
  let openingElement = ast.openingElement;
  let type = evaluateJSXIdentifier(openingElement.name, strictCode, env, realm);
  let children = evaluateJSXChildren(ast.children, strictCode, env, realm);
  let config = evaluateJSXAttributes(openingElement.attributes, strictCode, env, realm);
  (0, _invariant.default)(type instanceof _index.Value);
  return (0, _elements.createReactElement)(realm, type, config, children);
}
//# sourceMappingURL=JSXElement.js.map

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebugServer = void 0;

var _BreakpointManager = __webpack_require__(618);

var _types = __webpack_require__(21);

var _invariant = _interopRequireDefault(__webpack_require__(621));

var _DebugMessage = __webpack_require__(622);

var _DebuggerError = __webpack_require__(623);

var _realm = __webpack_require__(7);

var _VariableManager = __webpack_require__(624);

var _SteppingManager = __webpack_require__(626);

var _StopEventManager = __webpack_require__(628);

var _environment = __webpack_require__(20);

var _errors = __webpack_require__(3);

var _SourceMapManager = __webpack_require__(463);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class DebugServer {
  constructor(channel, realm, configArgs) {
    this._channel = channel;
    this._realm = realm;
    this._breakpointManager = new _BreakpointManager.BreakpointManager();
    this._variableManager = new _VariableManager.VariableManager(realm);
    this._stepManager = new _SteppingManager.SteppingManager(this._realm,
    /* default discard old steppers */
    false);
    this._stopEventManager = new _StopEventManager.StopEventManager();
    this._diagnosticSeverity = configArgs.diagnosticSeverity || "FatalError";
    this._sourceMapManager = new _SourceMapManager.SourceMapManager(configArgs.buckRoot, configArgs.sourcemaps);
    this.waitForRun(undefined);
  } // the collection of breakpoints


  /* Block until adapter says to run
  /* ast: the current ast node we are stopped on
  /* reason: the reason the debuggee is stopping
  */
  waitForRun(loc) {
    let keepRunning = false;
    let request;

    while (!keepRunning) {
      request = this._channel.readIn();
      keepRunning = this.processDebuggerCommand(request, loc);
    }
  } // Checking if the debugger needs to take any action on reaching this ast node


  checkForActions(ast) {
    if (this._checkAndUpdateLastExecuted(ast)) {
      let stoppables = this._stepManager.getAndDeleteCompletedSteppers(ast);

      let breakpoint = this._breakpointManager.getStoppableBreakpoint(ast);

      if (breakpoint) stoppables.push(breakpoint);

      let reason = this._stopEventManager.getDebuggeeStopReason(ast, stoppables);

      if (reason) {
        let location = ast.loc;
        (0, _invariant.default)(location && location.source !== null);

        let absolutePath = this._sourceMapManager.relativeToAbsolute(location.source);

        this._channel.sendStoppedResponse(reason, absolutePath, location.start.line, location.start.column);

        this.waitForRun(location);
      }
    }
  } // Process a command from a debugger. Returns whether Prepack should unblock
  // if it is blocked


  processDebuggerCommand(request, loc) {
    let requestID = request.id;
    let command = request.command;
    let args = request.arguments; // Convert incoming location sources to relative paths in order to match internal representation of filenames.

    if (args.kind === "breakpoint") {
      for (let bp of args.breakpoints) {
        bp.filePath = this._sourceMapManager.absoluteToRelative(bp.filePath);
      }
    }

    switch (command) {
      case _DebugMessage.DebugMessage.BREAKPOINT_ADD_COMMAND:
        (0, _invariant.default)(args.kind === "breakpoint");

        this._breakpointManager.addBreakpointMulti(args.breakpoints);

        this._channel.sendBreakpointsAcknowledge(_DebugMessage.DebugMessage.BREAKPOINT_ADD_ACKNOWLEDGE, requestID, args);

        break;

      case _DebugMessage.DebugMessage.BREAKPOINT_REMOVE_COMMAND:
        (0, _invariant.default)(args.kind === "breakpoint");

        this._breakpointManager.removeBreakpointMulti(args.breakpoints);

        this._channel.sendBreakpointsAcknowledge(_DebugMessage.DebugMessage.BREAKPOINT_REMOVE_ACKNOWLEDGE, requestID, args);

        break;

      case _DebugMessage.DebugMessage.BREAKPOINT_ENABLE_COMMAND:
        (0, _invariant.default)(args.kind === "breakpoint");

        this._breakpointManager.enableBreakpointMulti(args.breakpoints);

        this._channel.sendBreakpointsAcknowledge(_DebugMessage.DebugMessage.BREAKPOINT_ENABLE_ACKNOWLEDGE, requestID, args);

        break;

      case _DebugMessage.DebugMessage.BREAKPOINT_DISABLE_COMMAND:
        (0, _invariant.default)(args.kind === "breakpoint");

        this._breakpointManager.disableBreakpointMulti(args.breakpoints);

        this._channel.sendBreakpointsAcknowledge(_DebugMessage.DebugMessage.BREAKPOINT_DISABLE_ACKNOWLEDGE, requestID, args);

        break;

      case _DebugMessage.DebugMessage.PREPACK_RUN_COMMAND:
        (0, _invariant.default)(args.kind === "run");

        this._onDebuggeeResume();

        return true;

      case _DebugMessage.DebugMessage.STACKFRAMES_COMMAND:
        (0, _invariant.default)(args.kind === "stackframe");
        this.processStackframesCommand(requestID, args, loc);
        break;

      case _DebugMessage.DebugMessage.SCOPES_COMMAND:
        (0, _invariant.default)(args.kind === "scopes");
        this.processScopesCommand(requestID, args);
        break;

      case _DebugMessage.DebugMessage.VARIABLES_COMMAND:
        (0, _invariant.default)(args.kind === "variables");
        this.processVariablesCommand(requestID, args);
        break;

      case _DebugMessage.DebugMessage.STEPINTO_COMMAND:
        (0, _invariant.default)(loc !== undefined);

        this._stepManager.processStepCommand("in", loc);

        this._onDebuggeeResume();

        return true;

      case _DebugMessage.DebugMessage.STEPOVER_COMMAND:
        (0, _invariant.default)(loc !== undefined);

        this._stepManager.processStepCommand("over", loc);

        this._onDebuggeeResume();

        return true;

      case _DebugMessage.DebugMessage.STEPOUT_COMMAND:
        (0, _invariant.default)(loc !== undefined);

        this._stepManager.processStepCommand("out", loc);

        this._onDebuggeeResume();

        return true;

      case _DebugMessage.DebugMessage.EVALUATE_COMMAND:
        (0, _invariant.default)(args.kind === "evaluate");
        this.processEvaluateCommand(requestID, args);
        break;

      default:
        throw new _DebuggerError.DebuggerError("Invalid command", "Invalid command from adapter: " + command);
    }

    return false;
  }

  processStackframesCommand(requestID, args, astLoc) {
    let frameInfos = [];

    let loc = this._getFrameLocation(astLoc ? astLoc : null);

    let fileName = loc.fileName;
    let line = loc.line;
    let column = loc.column; // the UI displays the current frame as index 0, so we iterate backwards
    // from the current frame

    for (let i = this._realm.contextStack.length - 1; i >= 0; i--) {
      let frame = this._realm.contextStack[i];
      let functionName = "(anonymous function)";

      if (frame.function && frame.function.__originalName !== undefined) {
        functionName = frame.function.__originalName;
      }

      let frameInfo = {
        id: this._realm.contextStack.length - 1 - i,
        functionName: functionName,
        fileName: this._sourceMapManager.relativeToAbsolute(fileName),
        // Outward facing paths must be absolute.
        line: line,
        column: column
      };
      frameInfos.push(frameInfo);
      loc = this._getFrameLocation(frame.loc);
      fileName = loc.fileName;
      line = loc.line;
      column = loc.column;
    }

    this._channel.sendStackframeResponse(requestID, frameInfos);
  }

  _getFrameLocation(loc) {
    let fileName = "unknown";
    let line = 0;
    let column = 0;

    if (loc && loc.source !== null) {
      fileName = loc.source;
      line = loc.start.line;
      column = loc.start.column;
    }

    return {
      fileName: fileName,
      line: line,
      column: column
    };
  }

  processScopesCommand(requestID, args) {
    // first check that frameId is in the valid range
    if (args.frameId < 0 || args.frameId >= this._realm.contextStack.length) {
      throw new _DebuggerError.DebuggerError("Invalid command", "Invalid frame id for scopes request: " + args.frameId);
    } // here the frameId is in reverse order of the contextStack, ie frameId 0
    // refers to last element of contextStack


    let stackIndex = this._realm.contextStack.length - 1 - args.frameId;
    let context = this._realm.contextStack[stackIndex];
    (0, _invariant.default)(context instanceof _realm.ExecutionContext);
    let scopes = [];
    let lexicalEnv = context.lexicalEnvironment;

    while (lexicalEnv) {
      let scope = {
        name: this._getScopeName(lexicalEnv.environmentRecord),
        // key used by UI to retrieve variables in this scope
        variablesReference: this._variableManager.getReferenceForValue(lexicalEnv),
        // the variables are easy to retrieve
        expensive: false
      };
      scopes.push(scope);
      lexicalEnv = lexicalEnv.parent;
    }

    this._channel.sendScopesResponse(requestID, scopes);
  }

  _getScopeName(envRec) {
    if (envRec instanceof _environment.GlobalEnvironmentRecord) {
      return "Global";
    } else if (envRec instanceof _environment.DeclarativeEnvironmentRecord) {
      if (envRec instanceof _environment.FunctionEnvironmentRecord) {
        let name = envRec.$FunctionObject.__originalName;
        if (name === undefined) name = "anonymous function";
        return "Local: " + name;
      } else {
        return "Block";
      }
    } else if (envRec instanceof _environment.ObjectEnvironmentRecord) {
      return "With";
    } else {
      (0, _invariant.default)(false, "Invalid type of environment record");
    }
  }

  processVariablesCommand(requestID, args) {
    let variables = this._variableManager.getVariablesByReference(args.variablesReference);

    this._channel.sendVariablesResponse(requestID, variables);
  }

  processEvaluateCommand(requestID, args) {
    let evalResult = this._variableManager.evaluate(args.frameId, args.expression);

    this._channel.sendEvaluateResponse(requestID, evalResult);
  } // actions that need to happen before Prepack can resume


  _onDebuggeeResume() {
    // resets the variable manager
    this._variableManager.clean();
  }
  /*
    Returns whether there are more nodes in the ast.
  */


  _checkAndUpdateLastExecuted(ast) {
    if (ast.loc && ast.loc.source !== null) {
      let filePath = ast.loc.source;
      let line = ast.loc.start.line;
      let column = ast.loc.start.column;
      let stackSize = this._realm.contextStack.length; // Check if the current location is same as the last one.
      // Does not check columns since column debugging is not supported.
      // Column support is unnecessary because these nodes will have been sourcemap-translated.
      // Ignoring columns prevents:
      //     - Lines with multiple AST nodes from triggering the same breakpoint more than once.
      //     - Step-out from completing in the same line that it was set in.

      if (this._lastExecuted && filePath === this._lastExecuted.filePath && line === this._lastExecuted.line && stackSize === this._lastExecuted.stackSize) {
        return false;
      }

      this._lastExecuted = {
        filePath: filePath,
        line: line,
        column: column,
        stackSize: this._realm.contextStack.length
      };
      return true;
    }

    return false;
  } //  Displays Prepack error message, then waits for user to run the program to continue (similar to a breakpoint).


  handlePrepackError(diagnostic) {
    (0, _invariant.default)(diagnostic.location && diagnostic.location.source !== null); // The following constructs the message and stop-instruction that is sent to the UI to actually stop the execution.

    let location = diagnostic.location;
    let absoluteSource = "";
    if (location.source !== null) absoluteSource = this._sourceMapManager.relativeToAbsolute(location.source);
    let message = `${diagnostic.severity} ${diagnostic.errorCode}: ${diagnostic.message}`;
    console.log(message);

    this._channel.sendStoppedResponse("Diagnostic", absoluteSource, location.start.line, location.start.column, message); // The AST Node's location is needed to satisfy the subsequent stackTrace request.


    this.waitForRun(location);
  } // Return whether the debugger should stop on a CompilerDiagnostic of a given severity.


  shouldStopForSeverity(severity) {
    switch (this._diagnosticSeverity) {
      case "Information":
        return true;

      case "Warning":
        return severity !== "Information";

      case "RecoverableError":
        return severity === "RecoverableError" || severity === "FatalError";

      case "FatalError":
        return severity === "FatalError";

      default:
        (0, _invariant.default)(false, "Unexpected severity type");
    }
  }

  shutdown() {
    // clean the channel pipes
    this._channel.shutdown();
  }

}

exports.DebugServer = DebugServer;
//# sourceMappingURL=Debugger.js.map

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreakpointManager = void 0;

var _PerFileBreakpointMap = __webpack_require__(619);

var _Breakpoint = __webpack_require__(620);

var _types = __webpack_require__(21);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// Storing BreakpointStores for all source files
class BreakpointManager {
  constructor() {
    this._breakpointMaps = new Map();
  }

  getStoppableBreakpoint(ast) {
    if (ast.loc && ast.loc.source !== null) {
      let location = ast.loc;
      let filePath = location.source;
      if (filePath === null) return;
      let lineNum = location.start.line;
      let colNum = location.start.column; // Check whether there is a breakpoint we need to stop on here

      let breakpoint = this._findStoppableBreakpoint(filePath, lineNum, colNum);

      if (breakpoint === null) return;
      return breakpoint;
    }
  } // Try to find a breakpoint at the given location and check if we should stop on it


  _findStoppableBreakpoint(filePath, lineNum, colNum) {
    let breakpoint = this.getBreakpoint(filePath, lineNum, colNum);

    if (breakpoint && breakpoint.enabled) {
      return breakpoint;
    }

    return null;
  }

  addBreakpointMulti(breakpoints) {
    this._doBreakpointsAction(breakpoints, this._addBreakpoint.bind(this));
  }

  _addBreakpoint(bp) {
    let breakpointMap = this._breakpointMaps.get(bp.filePath);

    if (!breakpointMap) {
      breakpointMap = new _PerFileBreakpointMap.PerFileBreakpointMap(bp.filePath);

      this._breakpointMaps.set(bp.filePath, breakpointMap);
    } // Nuclide doesn't support column debugging, so set every breakpoint
    // to column 0 for consistency.


    breakpointMap.addBreakpoint(bp.line, 0);
  }

  getBreakpoint(filePath, lineNum, columnNum = 0) {
    let breakpointMap = this._breakpointMaps.get(filePath);

    if (breakpointMap) return breakpointMap.getBreakpoint(lineNum, columnNum);
    return undefined;
  }

  removeBreakpointMulti(breakpoints) {
    this._doBreakpointsAction(breakpoints, this._removeBreakpoint.bind(this));
  }

  _removeBreakpoint(bp) {
    let breakpointMap = this._breakpointMaps.get(bp.filePath);

    if (breakpointMap) breakpointMap.removeBreakpoint(bp.line, bp.column);
  }

  enableBreakpointMulti(breakpoints) {
    this._doBreakpointsAction(breakpoints, this._enableBreakpoint.bind(this));
  }

  _enableBreakpoint(bp) {
    let breakpointMap = this._breakpointMaps.get(bp.filePath);

    if (breakpointMap) breakpointMap.enableBreakpoint(bp.line, bp.column);
  }

  disableBreakpointMulti(breakpoints) {
    this._doBreakpointsAction(breakpoints, this._disableBreakpoint.bind(this));
  }

  _disableBreakpoint(bp) {
    let breakpointMap = this._breakpointMaps.get(bp.filePath);

    if (breakpointMap) breakpointMap.disableBreakpoint(bp.line, bp.column);
  }

  _doBreakpointsAction(breakpoints, action) {
    for (let bp of breakpoints) {
      action(bp);
    }
  }

}

exports.BreakpointManager = BreakpointManager;
//# sourceMappingURL=BreakpointManager.js.map

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PerFileBreakpointMap = void 0;

var _Breakpoint = __webpack_require__(620);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
// Storage for all the breakpoints in one source file
// Each source file will be associated with one PerFileBreakpointMap
class PerFileBreakpointMap {
  constructor(filePath) {
    this._filePath = filePath;
    this._breakpoints = new Map();
  }

  addBreakpoint(line, column = 0, temporary, enabled) {
    let breakpoint = new _Breakpoint.Breakpoint(this._filePath, line, column, temporary, enabled);

    let key = this._getKey(line, column);

    this._breakpoints.set(key, breakpoint);
  }

  getBreakpoint(line, column = 0) {
    //check for a column breakpoint first, then line breakpoint
    if (column !== 0) {
      let key = this._getKey(line, column);

      if (this._breakpoints.has(key)) {
        return this._breakpoints.get(key);
      } else {
        key = this._getKey(line, 0);

        if (this._breakpoints.has(key)) {
          return this._breakpoints.get(key);
        }
      }
    } else {
      let key = this._getKey(line, 0);

      if (this._breakpoints.has(key)) {
        return this._breakpoints.get(key);
      }
    }

    return undefined;
  }

  removeBreakpoint(line, column = 0) {
    let key = this._getKey(line, column);

    if (this._breakpoints.has(key)) {
      this._breakpoints.delete(key);
    }
  }

  enableBreakpoint(line, column = 0) {
    let key = this._getKey(line, column);

    let breakpoint = this._breakpoints.get(key);

    if (breakpoint) breakpoint.enabled = true;
  }

  disableBreakpoint(line, column = 0) {
    let key = this._getKey(line, column);

    let breakpoint = this._breakpoints.get(key);

    if (breakpoint) breakpoint.enabled = false;
  }

  _getKey(line, column) {
    return `${line}:${column}`;
  }

}

exports.PerFileBreakpointMap = PerFileBreakpointMap;
//# sourceMappingURL=PerFileBreakpointMap.js.map

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Breakpoint = void 0;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
class Breakpoint {
  constructor(filePath, line, column = 0, temporary = false, enabled = true) {
    this.filePath = filePath;
    this.line = line;
    this.temporary = temporary;
    this.enabled = enabled;
    this.column = column;
  }

}

exports.Breakpoint = Breakpoint;
//# sourceMappingURL=Breakpoint.js.map

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invariant;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
function invariant(condition, format) {
  if (condition) return;
  let error = new Error(format);
  error.name = "Invariant Violation";
  throw error;
}
//# sourceMappingURL=invariant.js.map

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebugMessage = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
//A collection of messages used between Prepack and the debug adapter
class DebugMessage {}

exports.DebugMessage = DebugMessage;

_defineProperty(DebugMessage, "DEBUGGER_ATTACHED", "DebuggerAttached");

_defineProperty(DebugMessage, "PREPACK_RUN_COMMAND", "PrepackRun");

_defineProperty(DebugMessage, "BREAKPOINT_ADD_COMMAND", "Breakpoint-add-command");

_defineProperty(DebugMessage, "BREAKPOINT_REMOVE_COMMAND", "Breakpoint-remove-command");

_defineProperty(DebugMessage, "BREAKPOINT_ENABLE_COMMAND", "Breakpoint-enable-command");

_defineProperty(DebugMessage, "BREAKPOINT_DISABLE_COMMAND", "Breakpoint-disable-command");

_defineProperty(DebugMessage, "STACKFRAMES_COMMAND", "Stackframes-command");

_defineProperty(DebugMessage, "SCOPES_COMMAND", "Scopes-command");

_defineProperty(DebugMessage, "VARIABLES_COMMAND", "Variables-command");

_defineProperty(DebugMessage, "STEPINTO_COMMAND", "StepInto-command");

_defineProperty(DebugMessage, "STEPOVER_COMMAND", "StepOver-command");

_defineProperty(DebugMessage, "STEPOUT_COMMAND", "StepOut-command");

_defineProperty(DebugMessage, "EVALUATE_COMMAND", "Evaluate-command");

_defineProperty(DebugMessage, "PREPACK_READY_RESPONSE", "PrepackReady");

_defineProperty(DebugMessage, "PREPACK_FINISH_RESPONSE", "PrepackFinish");

_defineProperty(DebugMessage, "STOPPED_RESPONSE", "Stopped-response");

_defineProperty(DebugMessage, "STACKFRAMES_RESPONSE", "Stackframes-response");

_defineProperty(DebugMessage, "SCOPES_RESPONSE", "Scopes-response");

_defineProperty(DebugMessage, "VARIABLES_RESPONSE", "Variables-response");

_defineProperty(DebugMessage, "STEPINTO_RESPONSE", "StepInto-response");

_defineProperty(DebugMessage, "EVALUATE_RESPONSE", "Evaluate-response");

_defineProperty(DebugMessage, "BREAKPOINT_ADD_ACKNOWLEDGE", "Breakpoint-add-acknowledge");

_defineProperty(DebugMessage, "BREAKPOINT_REMOVE_ACKNOWLEDGE", "Breakpoint-remove-acknowledge");

_defineProperty(DebugMessage, "BREAKPOINT_ENABLE_ACKNOWLEDGE", "Breakpoint-enable-acknowledge");

_defineProperty(DebugMessage, "BREAKPOINT_DISABLE_ACKNOWLEDGE", "Breakpoint-disable-acknowledge");
//# sourceMappingURL=DebugMessage.js.map

/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerError = void 0;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
// More error types will be added as needed
class DebuggerError extends Error {
  constructor(errorType, message) {
    super(`${errorType}: ${message}`);
    this.errorType = errorType;
    this.message = message;
  }

}

exports.DebuggerError = DebuggerError;
//# sourceMappingURL=DebuggerError.js.map

/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariableManager = void 0;

var _ReferenceMap = __webpack_require__(625);

var _environment = __webpack_require__(20);

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(621));

var _is = __webpack_require__(229);

var _DebuggerError = __webpack_require__(623);

var _singletons = __webpack_require__(236);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// This class manages the handling of variable requests in the debugger
// The DebugProtocol specifies collections of variables are to be fetched using a
// unique reference ID called a variablesReference. This class can generate new
// variablesReferences to pass to the UI and then perform lookups for those
// variablesReferences when they are requested.
class VariableManager {
  constructor(realm) {
    this._containerCache = new Map();
    this._referenceMap = new _ReferenceMap.ReferenceMap();
    this._realm = realm;
  } // cache for created references


  // Given a container, either returns a cached reference for that container if
  // it exists or return a new reference
  getReferenceForValue(value) {
    let cachedRef = this._containerCache.get(value);

    if (cachedRef !== undefined) {
      return cachedRef;
    }

    let varRef = this._referenceMap.add(value);

    this._containerCache.set(value, varRef);

    return varRef;
  } // The entry point for retrieving a collection of variables by a reference


  getVariablesByReference(reference) {
    let container = this._referenceMap.get(reference);

    if (!container) return [];

    if (container instanceof _environment.LexicalEnvironment) {
      return this._getVariablesFromEnvRecord(container.environmentRecord);
    } else if (container instanceof _index.ObjectValue) {
      return this._getVariablesFromObject(container);
    } else if (container instanceof _index.AbstractValue) {
      return this._getAbstractValueContent(container);
    } else {
      (0, _invariant.default)(false, "Invalid variable container");
    }
  }

  _getVariablesFromObject(object) {
    let variables = [];
    let names = object.properties.keys();

    for (let name of names) {
      let binding = object.properties.get(name);
      (0, _invariant.default)(binding !== undefined);

      if (binding.descriptor) {
        if ((0, _is.IsDataDescriptor)(this._realm, binding.descriptor)) {
          let value = binding.descriptor.value;

          if (value instanceof _index.Value) {
            let variable = this._getVariableFromValue(name, value);

            variables.push(variable);
          }
        }
      }
    }

    return variables;
  }

  _getAbstractValueContent(value) {
    let kindVar = {
      name: "kind",
      value: value.kind || "undefined",
      variablesReference: 0
    };
    let contents = [kindVar];
    let argCount = 1;

    for (let arg of value.args) {
      contents.push(this._getVariableFromValue("arg-" + argCount, arg));
      argCount++;
    }

    return contents;
  }

  _getVariablesFromEnvRecord(envRecord) {
    if (envRecord instanceof _environment.DeclarativeEnvironmentRecord) {
      return this._getVariablesFromDeclarativeEnv(envRecord);
    } else if (envRecord instanceof _environment.ObjectEnvironmentRecord) {
      if (envRecord.object instanceof _index.ObjectValue) {
        return this._getVariablesFromObject(envRecord.object);
      } else if (envRecord.object instanceof _index.AbstractObjectValue) {
        // TODO: call _getVariablesFromAbstractObject when it is implemented
        return [];
      } else {
        (0, _invariant.default)(false, "Invalid type of object environment record");
      }
    } else if (envRecord instanceof _environment.GlobalEnvironmentRecord) {
      let declVars = this._getVariablesFromEnvRecord(envRecord.$DeclarativeRecord);

      let objVars = this._getVariablesFromEnvRecord(envRecord.$ObjectRecord);

      return declVars.concat(objVars);
    } else {
      (0, _invariant.default)(false, "Invalid type of environment record");
    }
  }

  _getVariablesFromDeclarativeEnv(env) {
    let variables = [];
    let bindings = env.bindings;

    for (let name in bindings) {
      let binding = bindings[name];

      if (binding.value) {
        let variable = this._getVariableFromValue(name, binding.value);

        variables.push(variable);
      }
    }

    return variables;
  }

  _getVariableFromValue(name, value) {
    if (value instanceof _index.ConcreteValue) {
      return this._getVariableFromConcreteValue(name, value);
    } else if (value instanceof _index.AbstractValue) {
      return this._getVariableFromAbstractValue(name, value);
    } else {
      (0, _invariant.default)(false, "Value is neither concrete nor abstract");
    }
  }

  _getVariableFromAbstractValue(name, value) {
    let variable = {
      name: name,
      value: this._getAbstractValueDisplay(value),
      variablesReference: this.getReferenceForValue(value)
    };
    return variable;
  }

  _getAbstractValueDisplay(value) {
    if (value.intrinsicName !== undefined && !value.intrinsicName.startsWith("_")) {
      return value.intrinsicName;
    }

    return "Abstract " + value.types.getType().name;
  }

  _getVariableFromConcreteValue(name, value) {
    if (value instanceof _index.PrimitiveValue) {
      let variable = {
        name: name,
        value: value.toDisplayString(),
        variablesReference: 0
      };
      return variable;
    } else if (value instanceof _index.ObjectValue) {
      let variable = {
        name: name,
        value: value.getKind(),
        variablesReference: this.getReferenceForValue(value)
      };
      return variable;
    } else {
      (0, _invariant.default)(false, "Concrete value must be primitive or object");
    }
  }

  evaluate(frameId, expression) {
    let evalRealm = this._realm;
    let isDirect = false;
    let isStrict = false;

    if (frameId !== undefined) {
      if (frameId < 0 || frameId >= this._realm.contextStack.length) {
        throw new _DebuggerError.DebuggerError("Invalid command", "Invalid value for frame ID");
      } // frameId's are in reverse order of context stack


      let stackIndex = this._realm.contextStack.length - 1 - frameId;
      let context = this._realm.contextStack[stackIndex];
      isDirect = true;
      isStrict = true;
      evalRealm = context.realm;
    }

    let evalString = new _index.StringValue(this._realm, expression);

    try {
      let value = _singletons.Functions.PerformEval(this._realm, evalString, evalRealm, isStrict, isDirect);

      let varInfo = this._getVariableFromValue(expression, value);

      let result = {
        kind: "evaluate",
        displayValue: varInfo.value,
        type: value.getType().name,
        variablesReference: varInfo.variablesReference
      };
      return result;
    } catch (e) {
      let result = {
        kind: "evaluate",
        displayValue: `Failed to evaluate: ${expression}`,
        type: "unknown",
        variablesReference: 0
      };
      return result;
    }
  }

  clean() {
    this._containerCache = new Map();

    this._referenceMap.clean();
  }

}

exports.VariableManager = VariableManager;
//# sourceMappingURL=VariableManager.js.map

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReferenceMap = void 0;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
// A map with an incrementing counter as the keys
// Used to store references to variable collections since DebugProtocol
// specifies fetching variable collections via unique IDs
class ReferenceMap {
  constructor() {
    this._counter = 0;
    this._mapping = new Map();
  }

  add(value) {
    this._counter++;

    this._mapping.set(this._counter, value);

    return this._counter;
  }

  get(reference) {
    return this._mapping.get(reference);
  }

  clean() {
    this._counter = 0;
    this._mapping = new Map();
  }

}

exports.ReferenceMap = ReferenceMap;
//# sourceMappingURL=ReferenceMap.js.map

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SteppingManager = void 0;

var _types = __webpack_require__(21);

var _invariant = _interopRequireDefault(__webpack_require__(621));

var _Stepper = __webpack_require__(627);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class SteppingManager {
  constructor(realm, keepOldSteppers) {
    this._realm = realm;
    this._steppers = [];
    this._keepOldSteppers = false;
    if (keepOldSteppers === true) this._keepOldSteppers = true;
  }

  processStepCommand(kind, currentNodeLocation) {
    if (kind === "in") {
      this._processStepIn(currentNodeLocation);
    } else if (kind === "over") {
      this._processStepOver(currentNodeLocation);
    } else if (kind === "out") {
      this._processStepOut(currentNodeLocation);
    } else {
      (0, _invariant.default)(false, `Invalid step type: ${kind}`);
    }
  }

  _processStepIn(loc) {
    (0, _invariant.default)(loc && loc.source !== null);

    if (!this._keepOldSteppers) {
      this._steppers = [];
    }

    this._steppers.push(new _Stepper.StepIntoStepper(loc.source, loc.start.line, loc.start.column, this._realm.contextStack.length));
  }

  _processStepOver(loc) {
    (0, _invariant.default)(loc && loc.source !== null);

    if (!this._keepOldSteppers) {
      this._steppers = [];
    }

    this._steppers.push(new _Stepper.StepOverStepper(loc.source, loc.start.line, loc.start.column, this._realm.contextStack.length));
  }

  _processStepOut(loc) {
    (0, _invariant.default)(loc && loc.source !== null);

    if (!this._keepOldSteppers) {
      this._steppers = [];
    }

    this._steppers.push(new _Stepper.StepOutStepper(loc.source, loc.start.line, loc.start.column, this._realm.contextStack.length));
  }

  getAndDeleteCompletedSteppers(ast) {
    (0, _invariant.default)(ast.loc && ast.loc.source);
    let i = 0;
    let completedSteppers = [];

    while (i < this._steppers.length) {
      let stepper = this._steppers[i];

      if (stepper.isComplete(ast, this._realm.contextStack.length)) {
        completedSteppers.push(stepper);

        this._steppers.splice(i, 1);
      } else {
        i++;
      }
    }

    return completedSteppers;
  }

}

exports.SteppingManager = SteppingManager;
//# sourceMappingURL=SteppingManager.js.map

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StepOutStepper = exports.StepOverStepper = exports.StepIntoStepper = exports.Stepper = void 0;

var _types = __webpack_require__(21);

var _invariant = _interopRequireDefault(__webpack_require__(621));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class Stepper {
  constructor(filePath, line, column, stackSize) {
    this._stepStartData = {
      filePath: filePath,
      line: line,
      column: column,
      stackSize: stackSize
    };
  }

  isComplete(ast, currentStackSize) {
    (0, _invariant.default)(false, "Abstract method, please override");
  } // NOTE: Only checks if a node has changed within the same callstack.
  // The same node in two different excutions contexts (e.g. recursive call)
  // will not be detected. Check the stackSize (via realm) in those cases.


  isAstLocationChanged(ast) {
    let loc = ast.loc;
    if (!loc) return false;
    let filePath = loc.source;
    let line = loc.start.line;
    let column = loc.start.column;
    if (filePath === null) return false;

    if (this._stepStartData) {
      if (filePath === this._stepStartData.filePath && line === this._stepStartData.line && column === this._stepStartData.column) {
        return false;
      }
    } else {
      return false;
    }

    return true;
  }

}

exports.Stepper = Stepper;

class StepIntoStepper extends Stepper {
  constructor(filePath, line, column, startStackSize) {
    super(filePath, line, column, startStackSize);
  } // Override


  isComplete(ast, currentStackSize) {
    // If stacksize has changed, the position has changed, regardless if
    // the AST node is the same (e.g. a recursive call).
    return this.isAstLocationChanged(ast) || currentStackSize !== this._stepStartData.stackSize;
  }

}

exports.StepIntoStepper = StepIntoStepper;

class StepOverStepper extends Stepper {
  constructor(filePath, line, column, stackSize) {
    super(filePath, line, column, stackSize);
  }

  isComplete(ast, currentStackSize) {
    return (// If current stack length < starting stack length, the program either
      // hit an exception so this stepper is no longer relevant. Or, the program
      // has stepped out of a function call, back up to the calling function.
      currentStackSize < this._stepStartData.stackSize || // If current stack length === starting stack length, the program returned
      // to the same stack depth. As long as the ast node has changed,
      // the step over is complete.
      currentStackSize === this._stepStartData.stackSize && this.isAstLocationChanged(ast)
    );
  }

}

exports.StepOverStepper = StepOverStepper;

class StepOutStepper extends Stepper {
  constructor(filePath, line, column, stackSize) {
    super(filePath, line, column, stackSize);
  }

  isComplete(ast, currentStackSize) {
    // It is not sufficient to simply check if the AST location has changed,
    // since it is possible in recursive calls to return to the same
    // AST node, but in a *different* call stack.
    // To step out of a function, we must finish executing it.
    // When a function completes, its execution context will be
    // popped off the stack.
    return currentStackSize < this._stepStartData.stackSize;
  }

}

exports.StepOutStepper = StepOutStepper;
//# sourceMappingURL=Stepper.js.map

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StopEventManager = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(621));

var _Breakpoint = __webpack_require__(620);

var _Stepper = __webpack_require__(627);

var _types = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// Manage whether the debuggee should stop
// All stopping related logic is centralized here
class StopEventManager {
  // stoppables is a list of objects the debuggee should be stopped on
  // (e.g. breakpoint, completed steppers). The debuggee should stop if there
  // is at least one element in the list. Currently the reason of the first element
  // is chosen as the reason sent to the UI
  getDebuggeeStopReason(ast, stoppables) {
    if (stoppables.length === 0) return;
    let stoppable = stoppables[0];
    let stoppedReason;

    if (stoppable instanceof _Breakpoint.Breakpoint) {
      stoppedReason = "Breakpoint";
    } else if (stoppable instanceof _Stepper.StepIntoStepper) {
      stoppedReason = "Step Into";
    } else if (stoppable instanceof _Stepper.StepOverStepper) {
      stoppedReason = "Step Over";
    } else if (stoppable instanceof _Stepper.StepOutStepper) {
      stoppedReason = "Step Out";
    } else {
      (0, _invariant.default)(false, "Invalid stoppable object");
    }

    return stoppedReason;
  }

}

exports.StopEventManager = StopEventManager;
//# sourceMappingURL=StopEventManager.js.map

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = simplifyAndRefineAbstractValue;

var _errors = __webpack_require__(3);

var _index = __webpack_require__(15);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _realm = __webpack_require__(7);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _EmptyValue = _interopRequireDefault(__webpack_require__(383));

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function simplifyAndRefineAbstractValue(realm, isCondition, // The value is only used after converting it to a Boolean
value) {
  if (value.intrinsicName !== undefined) return value;
  let savedHandler = realm.errorHandler;
  let savedIsReadOnly = realm.isReadOnly;
  realm.isReadOnly = true;
  let isRootSimplification = false;
  realm.statistics.simplificationAttempts++;

  if (!realm.inSimplificationPath) {
    realm.inSimplificationPath = isRootSimplification = true;
  }

  try {
    realm.errorHandler = diagnostic => {
      if (diagnostic.errorCode === "PP0029") {
        throw new _errors.FatalError(`${diagnostic.errorCode}: ${diagnostic.message}`);
      }

      throw new _errors.FatalError();
    };

    let result = simplify(realm, value, isCondition, 0);
    if (result !== value) realm.statistics.simplifications++;
    return result;
  } catch (e) {
    if (e.name === "Invariant Violation") throw e;

    if (e instanceof _errors.FatalError && typeof e.message === "string" && e.message.includes("PP0029")) {
      if (isRootSimplification) {
        return value;
      }

      throw e;
    }

    return value;
  } finally {
    if (isRootSimplification) {
      realm.abstractValueImpliesCounter = 0;
      realm.inSimplificationPath = false;
    }

    realm.errorHandler = savedHandler;
    realm.isReadOnly = savedIsReadOnly;
  }
}

function simplify(realm, value, isCondition = false, depth) {
  if (value instanceof _index2.ConcreteValue || depth > 5) return value;
  (0, _invariant.default)(value instanceof _index2.AbstractValue);

  if (isCondition || value.getType() === _index2.BooleanValue) {
    if (_singletons.Path.implies(value, depth + 1)) return realm.intrinsics.true;
    if (_singletons.Path.impliesNot(value, depth + 1)) return realm.intrinsics.false;
  }

  let loc = value.expressionLocation;
  let op = value.kind;

  switch (op) {
    case "!":
      {
        let [x0] = value.args;
        (0, _invariant.default)(x0 instanceof _index2.AbstractValue);

        if (x0.kind === "!") {
          (0, _invariant.default)(x0 instanceof _index2.AbstractValue);
          let [x00] = x0.args;
          let xx = simplify(realm, x00, true, depth + 1);
          if (isCondition || xx.getType() === _index2.BooleanValue) return xx;
        }

        return negate(realm, x0, depth + 1, loc, value, isCondition);
      }

    case "||":
    case "&&":
      {
        let [x0, y0] = value.args;
        let x = simplify(realm, x0, isCondition, depth + 1);
        let y = simplify(realm, y0, isCondition, depth + 1);
        if (x instanceof _index2.AbstractValue && x.equals(y)) return x; // true && y <=> y
        // true || y <=> true

        if (!x.mightNotBeTrue()) return op === "&&" ? y : x; // (x == false) && y <=> x
        // false || y <=> y

        if (!x.mightNotBeFalse()) return op === "||" ? y : x;

        if (isCondition || x.getType() === _index2.BooleanValue && y.getType() === _index2.BooleanValue) {
          // (x: boolean) && true <=> x
          // x || true <=> true
          if (!y.mightNotBeTrue()) return op === "&&" ? x : realm.intrinsics.true; // (x: boolean) && false <=> false
          // (x: boolean) || false <=> x

          if (!y.mightNotBeFalse()) return op === "||" ? x : realm.intrinsics.false;
        }

        if (op === "||") {
          if (y instanceof _index2.AbstractValue && y.kind === "||") {
            // x || x || y <=> x || y
            if (x.equals(y.args[0])) return y;

            if (x instanceof _index2.AbstractValue && x.kind === "!") {
              // !x0 || y0 || x0 <=> true, if isCondition
              if (isCondition && x.args[0].equals(y.args[1])) return realm.intrinsics.true;
            }
          }
        }

        if (op === "&&") {
          if (x instanceof _index2.AbstractValue) {
            if (x.kind === "&&") {
              // (x && y) && x <=> x && y, if isCondition
              if (isCondition && x.args[0].equals(y)) return x; // (x && y) && y <=> x && y

              if (x.args[1].equals(y)) return x;
            } else if (x.kind === "!") {
              // !x && x <=> false, if isCondition
              if (isCondition && x.args[0].equals(y)) return realm.intrinsics.false;
            }
          }

          if (y instanceof _index2.AbstractValue && y.kind === "&&") {
            // x && (x && y) <=> x && y
            // y && (x && y) <=> x && y
            if (x.equals(y.args[0]) || x.equals(y.args[1])) return y;
          } // x && (x && y || x && z) <=> x && (y || z)


          if (y instanceof _index2.AbstractValue && y.kind === "||") {
            let [yx, yy] = y.args;
            let yxs, yys;

            if (yx instanceof _index2.AbstractValue && yx.kind === "&&") {
              if (x.equals(yx.args[0])) yxs = yx.args[1];else if (x.equals(yx.args[1])) yxs = yx.args[0];
            }

            if (yy instanceof _index2.AbstractValue && yy.kind === "&&") {
              if (x.equals(yy.args[0])) yys = yy.args[1];else if (x.equals(yy.args[1])) yys = yy.args[0];
            }

            if (yxs !== undefined || yys !== undefined) {
              let ys = _index2.AbstractValue.createFromLogicalOp(realm, "||", yxs || yx, yys || yy, undefined, isCondition);

              return _index2.AbstractValue.createFromLogicalOp(realm, "&&", x, ys, undefined, isCondition);
            }
          }
        }

        if (realm.instantRender.enabled) {
          if (op === "||" && x0 instanceof _index2.AbstractValue && y0 instanceof _index2.AbstractValue) {
            if (x0.kind === "===" && y0.kind === "===") {
              let [xa, xb] = x0.args;
              let [ya, yb] = y0.args;
              if (xa.equals(ya) && !xb.equals(yb) && nullOrUndefined(xb) && nullOrUndefined(yb)) return rewrite(xa);else if (xb.equals(yb) && !xa.equals(ya) && nullOrUndefined(xa) && nullOrUndefined(ya)) return rewrite(xb);else if (xa.equals(yb) && !xb.equals(ya) && nullOrUndefined(xb) && nullOrUndefined(ya)) return rewrite(xa);else if (xb.equals(ya) && !xa.equals(yb) && nullOrUndefined(xa) && nullOrUndefined(yb)) return rewrite(xb);

              function nullOrUndefined(z) {
                return !z.mightNotBeNull() || !z.mightNotBeUndefined();
              }

              function rewrite(z) {
                return _index2.AbstractValue.createFromBuildFunction(realm, _index2.BooleanValue, [xa], (0, _generator.createOperationDescriptor)("CANNOT_BECOME_OBJECT"), {
                  kind: "global.__cannotBecomeObject(A)"
                });
              }
            }
          }
        }

        if (x.equals(x0) && y.equals(y0)) return value;
        return _index2.AbstractValue.createFromLogicalOp(realm, value.kind, x, y, loc, isCondition, true);
      }

    case "<":
    case "<=":
    case ">":
    case ">=":
      return distributeConditional(realm, value, isCondition, args => _index2.AbstractValue.createFromBinaryOp(realm, op, args[0], args[1], loc, undefined, isCondition, true));

    case "==":
    case "!=":
    case "===":
    case "!==":
      return simplifyEquality(realm, value, depth + 1);

    case "conditional":
      {
        let [c0, x0, y0] = value.args;
        let c = simplify(realm, c0, true, depth + 1);
        let x, y;

        if (c0 instanceof _index2.AbstractValue && c.mightBeFalse() && c.mightBeTrue()) {
          try {
            x = _singletons.Path.withCondition(c0, () => simplify(realm, x0, isCondition, depth + 1));
          } catch (e) {
            if (e instanceof _errors.InfeasiblePathError) {
              // We now know that c0 cannot be be true on this path
              return simplify(realm, y0, isCondition, depth + 1);
            }

            throw e;
          }

          try {
            y = _singletons.Path.withInverseCondition(c0, () => simplify(realm, y0, isCondition, depth + 1));
          } catch (e) {
            if (e instanceof _errors.InfeasiblePathError) {
              // We now know that c0 cannot be be false on this path
              return x;
            }

            throw e;
          }
        }

        let cIsFalse = !c.mightNotBeFalse();
        let cIsTrue = !c.mightNotBeTrue();
        if (x === undefined && !cIsFalse) x = simplify(realm, x0, isCondition, depth + 1);

        if (cIsTrue) {
          (0, _invariant.default)(x !== undefined); // cIsTrue ==> !cIsFalse

          return x;
        }

        if (y === undefined) y = simplify(realm, y0, isCondition, depth + 1);
        if (cIsFalse) return y;
        (0, _invariant.default)(x !== undefined); // because !csIsFalse

        (0, _invariant.default)(c instanceof _index2.AbstractValue);
        if (_singletons.Path.implies(c, depth + 1)) return x;

        let notc = _index2.AbstractValue.createFromUnaryOp(realm, "!", c, true, loc, isCondition, true);

        if (!notc.mightNotBeTrue()) return y;
        if (!notc.mightNotBeFalse()) return x;
        (0, _invariant.default)(notc instanceof _index2.AbstractValue);
        if (_singletons.Path.implies(notc, depth + 1)) return y;

        if (!isCondition) {
          if (_singletons.Path.implies(_index2.AbstractValue.createFromBinaryOp(realm, "===", value, x), depth + 1)) return x;
          if (!x.mightBeNumber() && _singletons.Path.implies(_index2.AbstractValue.createFromBinaryOp(realm, "!==", value, x), depth + 1)) return y;
          if (!y.mightBeNumber() && _singletons.Path.implies(_index2.AbstractValue.createFromBinaryOp(realm, "!==", value, y), depth + 1)) return x;
          if (_singletons.Path.implies(_index2.AbstractValue.createFromBinaryOp(realm, "===", value, y), depth + 1)) return y;
        } // c ? x : x <=> x


        if (x.equals(y)) return x; // x ? x : y <=> x || y

        let cs = isCondition ? c : simplify(realm, c0, false, depth + 1);
        if (cs.equals(x)) return _index2.AbstractValue.createFromLogicalOp(realm, "||", x, y, loc, isCondition, true); // y ? x : y <=> y && x

        if (cs.equals(y)) return _index2.AbstractValue.createFromLogicalOp(realm, "&&", y, x, loc, isCondition, true); // c ? (c ? xx : xy) : y <=> c ? xx : y

        if (x instanceof _index2.AbstractValue && x.kind === "conditional") {
          let [xc, xx] = x.args;
          if (c.equals(xc)) return _index2.AbstractValue.createFromConditionalOp(realm, c, xx, y, value.expressionLocation, isCondition, true);
        } // c ? x : (c ? y : z) : z <=> c ? x : z


        if (y instanceof _index2.AbstractValue && y.kind === "conditional") {
          let [yc,, z] = y.args;
          if (c.equals(yc)) return _index2.AbstractValue.createFromConditionalOp(realm, c, x, z, value.expressionLocation, isCondition, true);
        }

        if (isCondition || x.getType() === _index2.BooleanValue && y.getType() === _index2.BooleanValue) {
          // c ? true : false <=> c
          if (!x.mightNotBeTrue() && !y.mightNotBeFalse()) return c; // c ? false : true <=> !c

          if (!x.mightNotBeFalse() && !y.mightNotBeTrue()) return _index2.AbstractValue.createFromUnaryOp(realm, "!", c, true, loc, true);
        }

        if (c.equals(c0) && x.equals(x0) && y.equals(y0)) return value;
        return _index2.AbstractValue.createFromConditionalOp(realm, c, x, y, value.expressionLocation, isCondition, true);
      }

    case "abstractConcreteUnion":
      {
        // The union of an abstract value with one or more concrete values.
        if (realm.pathConditions.isEmpty()) return value;

        let [abstractValue, concreteValues] = _index2.AbstractValue.dischargeValuesFromUnion(realm, value);

        (0, _invariant.default)(abstractValue instanceof _index2.AbstractValue);
        let remainingConcreteValues = [];

        for (let concreteValue of concreteValues) {
          if (_singletons.Path.implies(_index2.AbstractValue.createFromBinaryOp(realm, "!==", value, concreteValue), depth + 1)) continue;
          if (_singletons.Path.implies(_index2.AbstractValue.createFromBinaryOp(realm, "===", value, concreteValue), depth + 1)) return concreteValue;
          remainingConcreteValues.push(concreteValue);
        }

        if (remainingConcreteValues.length === 0) return abstractValue;
        if (remainingConcreteValues.length === concreteValues.length) return value;
        return _index2.AbstractValue.createAbstractConcreteUnion(realm, abstractValue, remainingConcreteValues);
      }

    default:
      return value;
  }
}

function distributeConditional(realm, value, isCondition, create) {
  // Find a conditional argument
  let condition;
  let args = value.args;

  for (let arg of args) if (arg instanceof _index2.AbstractValue && arg.kind === "conditional") {
    if (condition === undefined) condition = arg.args[0];else if (condition !== arg.args[0]) return value; // giving up, multiple conditions involved
  }

  if (condition === undefined) return value; // no conditional found, nothing to do
  // We have at least one conditional argument; if there are more than one, they all share the same condition

  let leftArgs = args.slice(0);
  let rightArgs = args.slice(0);

  for (let i = 0; i < args.length; i++) {
    let arg = args[i];

    if (arg instanceof _index2.AbstractValue && arg.kind === "conditional") {
      leftArgs[i] = arg.args[1];
      rightArgs[i] = arg.args[2];
    }
  }

  return _index2.AbstractValue.createFromConditionalOp(realm, condition, create(leftArgs), create(rightArgs), condition.expressionLocation, isCondition, true);
}

function simplifyNullCheck(realm, op, value, depth, loc) {
  if (op === "==" || op === "!=") {
    if (!value.mightNotBeNull() || !value.mightNotBeUndefined()) return op === "==" ? realm.intrinsics.true : realm.intrinsics.false;
    if (!value.mightBeNull() && !value.mightBeUndefined()) return op === "==" ? realm.intrinsics.false : realm.intrinsics.true;
  } else {
    if (!value.mightNotBeNull()) return op === "===" ? realm.intrinsics.true : realm.intrinsics.false;
    if (!value.mightBeNull()) return op === "===" ? realm.intrinsics.false : realm.intrinsics.true;
  }

  (0, _invariant.default)(value instanceof _index2.AbstractValue); // concrete values will either be null or not null
  // try to simplify "(cond ? x : y) op null" to just "cond" or "!cond"
  // failing that, use "cond ? x op null : y op null" if either of the subexpressions simplify

  if (value.kind === "conditional" && depth < 10) {
    let [cond, x, y] = value.args;
    let sx = simplifyNullCheck(realm, op, x, depth + 1, loc);
    let sy = simplifyNullCheck(realm, op, y, depth + 1, loc);

    if (sx !== undefined && sy !== undefined) {
      if (!sx.mightNotBeTrue() && !sy.mightNotBeFalse()) return makeBoolean(realm, cond, loc);
      if (!sx.mightNotBeFalse() && !sy.mightNotBeTrue()) return negate(realm, cond, depth + 1, loc);
    }

    if (sx !== undefined || sy !== undefined) {
      if (sx === undefined) sx = _index2.AbstractValue.createFromBinaryOp(realm, op, x, realm.intrinsics.null, x.expressionLocation, undefined, false, true);
      if (sy === undefined) sy = _index2.AbstractValue.createFromBinaryOp(realm, op, y, realm.intrinsics.null, y.expressionLocation, undefined, false, true);
      return _index2.AbstractValue.createFromConditionalOp(realm, cond, sx, sy, loc, true, true);
    }
  }
}

function simplifyUndefinedCheck(realm, op, value, depth, loc) {
  if (op === "==" || op === "!=") {
    if (!value.mightNotBeNull() || !value.mightNotBeUndefined()) return op === "==" ? realm.intrinsics.true : realm.intrinsics.false;
    if (!value.mightBeNull() && !value.mightBeUndefined()) return op === "==" ? realm.intrinsics.false : realm.intrinsics.true;
  } else {
    if (!value.mightNotBeUndefined()) return op === "===" ? realm.intrinsics.true : realm.intrinsics.false;
    if (!value.mightBeUndefined()) return op === "===" ? realm.intrinsics.false : realm.intrinsics.true;
  }

  (0, _invariant.default)(value instanceof _index2.AbstractValue); // concrete values will either be undefined or not undefined
  // try to simplify "(cond ? x : y) op undefined" to just "cond" or "!cond"
  // failing that, use "cond ? x op undefined : y op undefined" if either of the subexpressions simplify

  if (value.kind === "conditional" && depth < 10) {
    let [cond, x, y] = value.args;
    let sx = simplifyUndefinedCheck(realm, op, x, depth + 1, loc);
    let sy = simplifyUndefinedCheck(realm, op, y, depth + 1, loc);

    if (sx !== undefined && sy !== undefined) {
      if (!sx.mightNotBeTrue() && !sy.mightNotBeFalse()) return makeBoolean(realm, cond, loc);
      if (!sx.mightNotBeFalse() && !sy.mightNotBeTrue()) return negate(realm, cond, depth + 1, loc);
    }

    if (sx !== undefined || sy !== undefined) {
      if (sx === undefined) sx = _index2.AbstractValue.createFromBinaryOp(realm, op, x, realm.intrinsics.undefined, x.expressionLocation, undefined, false, true);
      if (sy === undefined) sy = _index2.AbstractValue.createFromBinaryOp(realm, op, y, realm.intrinsics.undefined, y.expressionLocation, undefined, false, true);
      return _index2.AbstractValue.createFromConditionalOp(realm, cond, sx, sy, loc, true, true);
    }
  }
}

function simplifyEquality(realm, equality, depth) {
  let loc = equality.expressionLocation;
  let op = equality.kind;
  let [x, y] = equality.args;
  if (y instanceof _EmptyValue.default) return equality;
  if (x instanceof _index2.ConcreteValue) [x, y] = [y, x];

  if (op === "===" || op === "==" || op === "!==" || op === "==") {
    if (!x.mightNotBeNull()) {
      let sy = simplifyNullCheck(realm, op, y, depth + 1);
      if (sy !== undefined) return sy;
    }

    if (!y.mightNotBeNull()) {
      let sx = simplifyNullCheck(realm, op, x, depth + 1);
      if (sx !== undefined) return sx;
    }

    if (!x.mightNotBeUndefined()) {
      let sy = simplifyUndefinedCheck(realm, op, y, depth + 1);
      if (sy !== undefined) return sy;
    }

    if (!y.mightNotBeUndefined()) {
      let sx = simplifyUndefinedCheck(realm, op, x, depth + 1);
      if (sx !== undefined) return sx;
    }
  }

  if (op === "===") {
    let xType = x.getType();
    let yType = y.getType();

    if (xType !== yType) {
      if (xType === _index2.Value || xType === _index2.PrimitiveValue || yType === _index2.Value || yType === _index2.PrimitiveValue) return equality;
      if (_index2.Value.isTypeCompatibleWith(xType, _index2.NumberValue) && _index2.Value.isTypeCompatibleWith(yType, _index2.NumberValue) || _index2.Value.isTypeCompatibleWith(xType, _index2.ObjectValue) && _index2.Value.isTypeCompatibleWith(yType, _index2.ObjectValue)) return equality;
      return realm.intrinsics.false;
    } else if (x instanceof _index2.AbstractValue && x.kind === "conditional") {
      let [cond, xx, xy] = x.args; // ((cond ? xx : xy) === y) && xx === y && xy !== y <=> cond

      if (xx.equals(y) && !xy.equals(y)) return cond; // ((!cond ? xx : xy) === y) && xx !== y && xy === y <=> !cond

      if (!xx.equals(y) && xy.equals(y)) return negate(realm, cond, depth + 1, loc);
    } else if (y instanceof _index2.AbstractValue && y.kind === "conditional") {
      let [cond, yx, yy] = y.args; // (x === (cond ? yx : yy) === y) && x === yx && x !== yy <=> cond

      if (yx.equals(x) && !yy.equals(x)) return cond; // (x === (!cond ? yx : yy) === y) && x !== yx && x === yy <=> !cond

      if (!x.equals(yx) && x.equals(yy)) return negate(realm, cond, depth + 1, loc);
    }
  } else if (op === "==") {
    let xType = x.getType();
    let xIsNullOrUndefined = xType === _index2.NullValue || xType === _index2.UndefinedValue;
    let yType = y.getType();
    let yIsNullOrUndefined = yType === _index2.NullValue || yType === _index2.UndefinedValue; // If x and y are both known to be null/undefined we should never get here because both should be concrete values.

    (0, _invariant.default)(!xIsNullOrUndefined || !yIsNullOrUndefined);

    if (xIsNullOrUndefined) {
      return yType === _index2.Value || yType === _index2.PrimitiveValue ? equality : realm.intrinsics.false;
    }

    if (yIsNullOrUndefined) {
      return xType === _index2.Value || xType === _index2.PrimitiveValue ? equality : realm.intrinsics.false;
    }
  }

  return equality;
}

function makeBoolean(realm, value, loc = undefined) {
  if (value.getType() === _index2.BooleanValue) return value;
  if (value instanceof _index2.ConcreteValue) return new _index2.BooleanValue(realm, _singletons.To.ToBoolean(realm, value));
  (0, _invariant.default)(value instanceof _index2.AbstractValue);

  let v = _index2.AbstractValue.createFromUnaryOp(realm, "!", value, true, value.expressionLocation);

  if (v instanceof _index2.ConcreteValue) return new _index2.BooleanValue(realm, !_singletons.To.ToBoolean(realm, v));
  (0, _invariant.default)(v instanceof _index2.AbstractValue);
  return _index2.AbstractValue.createFromUnaryOp(realm, "!", v, true, loc || value.expressionLocation);
}

function negate(realm, value, depth = 0, loc = undefined, unsimplifiedNegation = undefined, isCondition) {
  if (value instanceof _index2.ConcreteValue) return _index.ValuesDomain.computeUnary(realm, "!", value);
  (0, _invariant.default)(value instanceof _index2.AbstractValue);
  value = simplify(realm, value, true, depth + 1);
  if (!value.mightNotBeTrue()) return realm.intrinsics.false;
  if (!value.mightNotBeFalse()) return realm.intrinsics.true;
  (0, _invariant.default)(value instanceof _index2.AbstractValue);

  if (value.kind === "!") {
    let [x] = value.args;
    if (isCondition || x.getType() === _index2.BooleanValue) return simplify(realm, x, true, depth + 1);
    if (unsimplifiedNegation !== undefined) return unsimplifiedNegation;
    return makeBoolean(realm, x, loc);
  } // If NaN is not an issue, invert binary ops


  if (value.args.length === 2 && !value.args[0].mightBeNumber() && !value.args[1].mightBeNumber()) {
    let invertedComparison;

    switch (value.kind) {
      case "===":
        invertedComparison = "!==";
        break;

      case "==":
        invertedComparison = "!=";
        break;

      case "!==":
        invertedComparison = "===";
        break;

      case "!=":
        invertedComparison = "==";
        break;

      case "<":
        invertedComparison = ">=";
        break;

      case "<=":
        invertedComparison = ">";
        break;

      case ">":
        invertedComparison = "<=";
        break;

      case ">=":
        invertedComparison = "<";
        break;

      default:
        break;
    }

    if (invertedComparison !== undefined) {
      let left = simplify(realm, value.args[0], false, depth + 1);
      let right = simplify(realm, value.args[1], false, depth + 1);
      return _index2.AbstractValue.createFromBinaryOp(realm, invertedComparison, left, right, loc || value.expressionLocation);
    }

    let invertedLogicalOp;

    switch (value.kind) {
      case "&&":
        invertedLogicalOp = "||";
        break;

      case "||":
        invertedLogicalOp = "&&";
        break;

      default:
        break;
    }

    if (invertedLogicalOp !== undefined) {
      let left = negate(realm, value.args[0], depth + 1);
      let right = negate(realm, value.args[1], depth + 1);
      return _index2.AbstractValue.createFromLogicalOp(realm, invertedLogicalOp, left, right, loc || value.expressionLocation, true);
    }
  }

  if (unsimplifiedNegation !== undefined) return unsimplifiedNegation;
  return _index2.AbstractValue.createFromUnaryOp(realm, "!", value, true, loc || value.expressionLocation, true);
}
//# sourceMappingURL=simplifier.js.map

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _global = _interopRequireDefault(__webpack_require__(631));

var _global2 = _interopRequireDefault(__webpack_require__(633));

var _global3 = _interopRequireDefault(__webpack_require__(636));

var _global4 = _interopRequireDefault(__webpack_require__(637));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  (0, _global.default)(realm);

  if (realm.isCompatibleWith("browser")) {
    (0, _global2.default)(realm);
  }

  if (realm.isCompatibleWith("fb-www") || realm.isCompatibleWith("node-react")) {
    (0, _global2.default)(realm);
    (0, _global4.default)(realm);
  }

  if (realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) || realm.isCompatibleWith("mobile")) {
    (0, _global3.default)(realm);
  }

  return realm;
}
//# sourceMappingURL=globals.js.map

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAbstractFunction = createAbstractFunction;
exports.default = _default;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _index2 = __webpack_require__(232);

var _index3 = __webpack_require__(15);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils = __webpack_require__(632);

var _utils2 = __webpack_require__(443);

var _utils3 = __webpack_require__(291);

var _errors = __webpack_require__(3);

var t = _interopRequireWildcard(__webpack_require__(21));

var _generator = __webpack_require__(237);

var _ShapeInformation = __webpack_require__(419);

var _descriptors = __webpack_require__(268);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function createAbstractFunction(realm, ...additionalValues) {
  return new _index.NativeFunctionValue(realm, "global.__abstract", "__abstract", 0, (context, [typeNameOrTemplate, _name, options]) => {
    let name = _name;
    if (name instanceof _index.StringValue) name = name.value;

    if (name !== undefined && typeof name !== "string") {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "intrinsic name argument is not a string");
    }

    if (options && !(options instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "options must be an ObjectValue if provided");
    }

    return (0, _utils.createAbstract)(realm, typeNameOrTemplate, name, options, ...additionalValues);
  });
}

function _default(realm) {
  let global = realm.$GlobalObject;
  global.$DefineOwnProperty("__dump", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__dump", "__dump", 0, (context, args) => {
      console.log("dump", args.map(arg => arg.serialize()));
      return context;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Helper function to model values that are obtained from the environment,
  // and whose concrete values are not known at Prepack-time.
  // __abstract(typeNameOrTemplate, name, options) creates a new abstract value
  // where typeNameOrTemplate can be...
  // - 'string', 'boolean', 'number', 'object', 'function' or
  // - ':string', ':boolean', ':number', ':object', ':function' to indicate that
  //   the abstract value represents a function that only returns values of the specified type, or
  // - an actual object defining known properties.
  // options is an optional object that may contain:
  // - allowDuplicateNames: boolean representing whether the name of the abstract value may be
  //   repeated, by default they must be unique
  // - disablePlaceholders: boolean representing whether placeholders should be substituted in
  //   the abstract value's name.
  // If the abstract value gets somehow embedded in the final heap,
  // it will be referred to by the supplied name in the generated code.

  global.$DefineOwnProperty("__abstract", new _descriptors.PropertyDescriptor({
    value: createAbstractFunction(realm),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__abstractOrNull", new _descriptors.PropertyDescriptor({
    value: createAbstractFunction(realm, realm.intrinsics.null),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__abstractOrNullOrUndefined", new _descriptors.PropertyDescriptor({
    value: createAbstractFunction(realm, realm.intrinsics.null, realm.intrinsics.undefined),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__abstractOrUndefined", new _descriptors.PropertyDescriptor({
    value: createAbstractFunction(realm, realm.intrinsics.undefined),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Allows dynamically registering optimized functions.
  // WARNING: these functions will get exposed at global scope and called there.
  // NB: If we interpret one of these calls in an evaluateForEffects context
  //     that is not subsequently applied, the function will not be registered
  //     (because prepack won't have a correct value for the FunctionValue itself)
  // If we encounter an invalid input, we will emit a warning and not optimize the function

  global.$DefineOwnProperty("__optimize", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__optimize", "__optimize", 1, (context, [value, argModelString]) => {
      let argModel;

      if (argModelString !== undefined) {
        argModel = (0, _ShapeInformation.createAndValidateArgModel)(realm, argModelString);
      }

      if (value instanceof _index.ECMAScriptSourceFunctionValue || value instanceof _index.AbstractValue) {
        let currentArgModel = realm.optimizedFunctions.get(value); // Verify that if there is an existing argModel, that it is the same as the new one.

        if (currentArgModel) {
          let currentString = argModelString instanceof _index.StringValue ? argModelString.value : argModelString;

          if (JSON.stringify(currentArgModel) !== currentString) {
            let argModelError = new _errors.CompilerDiagnostic("__optimize called twice with different argModelStrings", realm.currentLocation, "PP1008", "Warning");
            if (realm.handleError(argModelError) !== "Recover") throw new _errors.FatalError();else return realm.intrinsics.undefined;
          }
        }

        realm.optimizedFunctions.set(value, argModel);
      } else {
        let location = value.expressionLocation ? `${value.expressionLocation.start.line}:${value.expressionLocation.start.column} ` + `${value.expressionLocation.end.line}:${value.expressionLocation.end.line}` : "location unknown";
        let result = realm.handleError(new _errors.CompilerDiagnostic(`Optimized Function Value ${location} is an not a function or react element`, realm.currentLocation, "PP0033", "Warning"));
        if (result !== "Recover") throw new _errors.FatalError();else return realm.intrinsics.undefined;
      }

      return value;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));

  if (realm.react.enabled) {
    global.$DefineOwnProperty("__reactComponentTrees", new _descriptors.PropertyDescriptor({
      value: new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "__reactComponentTrees",
      /* refuseSerialization */
      true),
      writable: true,
      enumerable: false,
      configurable: true
    }));
    let reactComponentRootUid = 0;
    global.$DefineOwnProperty("__optimizeReactComponentTree", new _descriptors.PropertyDescriptor({
      value: new _index.NativeFunctionValue(realm, "global.__optimizeReactComponentTree", "__optimizeReactComponentTree", 0, (context, [component, config]) => {
        let hasValidComponent = component instanceof _index.ECMAScriptSourceFunctionValue || component instanceof _index.BoundFunctionValue || (0, _utils3.valueIsKnownReactAbstraction)(realm, component);
        let hasValidConfig = config instanceof _index.ObjectValue || config === realm.intrinsics.undefined || config === undefined;

        if (!hasValidComponent || !hasValidConfig) {
          let diagnostic = new _errors.CompilerDiagnostic("__optimizeReactComponentTree(rootComponent, config) has been called with invalid arguments", realm.currentLocation, "PP0024", "FatalError");
          realm.handleError(diagnostic);
          if (realm.handleError(diagnostic) === "Fail") throw new _errors.FatalError();
        }

        let reactComponentTree = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
        reactComponentTree.$Set("rootComponent", component, reactComponentTree);
        reactComponentTree.$Set("config", config || realm.intrinsics.undefined, reactComponentTree);
        realm.assignToGlobal(t.memberExpression(t.memberExpression(t.identifier("global"), t.identifier("__reactComponentTrees")), t.identifier("" + reactComponentRootUid++)), reactComponentTree);
        return component;
      }),
      writable: true,
      enumerable: false,
      configurable: true
    }));
  }

  global.$DefineOwnProperty("__evaluatePureFunction", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__evaluatePureFunction", "__evaluatePureFunction", 0, (context, [functionValue, callback]) => {
      (0, _invariant.default)(functionValue instanceof _index.ECMAScriptSourceFunctionValue);
      (0, _invariant.default)(typeof functionValue.$Call === "function");
      let functionCall = functionValue.$Call;
      return realm.evaluatePure(() => functionCall(realm.intrinsics.undefined, []),
      /*bubbles*/
      true,
      /*reportSideEffectFunc*/
      callback === undefined || callback === realm.intrinsics.undefined ? null : () => {
        (0, _invariant.default)(callback instanceof _index.ECMAScriptSourceFunctionValue);
        let call = callback.$Call;
        (0, _invariant.default)(call !== undefined);
        call(realm.intrinsics.undefined, []);
      });
    }),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Maps from initialized moduleId to exports object
  // NB: Changes to this shouldn't ever be serialized

  global.$DefineOwnProperty("__initializedModules", new _descriptors.PropertyDescriptor({
    value: new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "__initializedModules",
    /* refuseSerialization */
    true),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Set of property bindings whose invariant got checked
  // NB: Changes to this shouldn't ever be serialized

  global.$DefineOwnProperty("__checkedBindings", new _descriptors.PropertyDescriptor({
    value: new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "__checkedBindings",
    /* refuseSerialization */
    true),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Helper function used to instantiate a residual function

  function createNativeFunctionForResidualCall(unsafe) {
    return new _index.NativeFunctionValue(realm, "global.__residual", "__residual", 2, (context, [typeNameOrTemplate, f, ...args]) => {
      if (!realm.useAbstractInterpretation) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      let {
        type,
        template
      } = (0, _utils.parseTypeNameOrTemplate)(realm, typeNameOrTemplate);

      if (!_index.Value.isTypeCompatibleWith(f.constructor, _index.FunctionValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "cannot determine residual function");
      }

      (0, _invariant.default)(f instanceof _index.FunctionValue);
      f.isResidual = true;
      if (unsafe) f.isUnsafeResidual = true;

      let result = _index.AbstractValue.createTemporalFromBuildFunction(realm, type, [f].concat(args), (0, _generator.createOperationDescriptor)("RESIDUAL_CALL"));

      if (template) {
        (0, _invariant.default)(result instanceof _index.AbstractValue, "the nested properties should only be rebuilt for an abstract value");
        template.makePartial();
        result.values = new _index3.ValuesDomain(new Set([template]));
        (0, _invariant.default)(realm.generator);
        realm.rebuildNestedProperties(result, result.getIdentifier());
      }

      return result;
    });
  }

  function createNativeFunctionForResidualInjection(name, initializeAndValidateArgs, operationDescriptor, numArgs) {
    return new _index.NativeFunctionValue(realm, "global." + name, name, numArgs, (context, ciArgs) => {
      initializeAndValidateArgs(ciArgs);
      (0, _invariant.default)(realm.generator !== undefined);
      realm.generator.emitStatement(ciArgs, operationDescriptor);
      return realm.intrinsics.undefined;
    });
  } // Helper function that specifies a dynamic invariant that cannot be evaluated at prepack time, and needs code to
  // be injected into the serialized output.


  global.$DefineOwnProperty("__assume", new _descriptors.PropertyDescriptor({
    value: createNativeFunctionForResidualInjection("__assume", ([c, s]) => {
      if (!c.mightBeTrue()) {
        let error = new _errors.CompilerDiagnostic(`Assumed condition cannot hold`, realm.currentLocation, "PP0040", "FatalError");
        realm.handleError(error);
        throw new _errors.FatalError();
      }

      _singletons.Path.pushAndRefine(c);
    }, (0, _generator.createOperationDescriptor)("ASSUME_CALL"), 2),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Helper function for Prepack developers inspect a value
  // when interpreting a particular node in the AST.

  global.$DefineOwnProperty("__debugValue", new _descriptors.PropertyDescriptor({
    value: createNativeFunctionForResidualInjection("__debugValue", ([v, s]) => {
      debugger; // eslint-disable-line no-debugger
    }, (0, _generator.createOperationDescriptor)("NOOP"), 2),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Helper function that identifies a computation that must remain part of the residual program and cannot be partially evaluated,
  // e.g. because it contains a loop over abstract values.
  // __residual(typeNameOrTemplate, function, arg0, arg1, ...) creates a new abstract value
  // that is computed by invoking function(arg0, arg1, ...) in the residual program and
  // where typeNameOrTemplate either either 'string', 'boolean', 'number', 'object', or an actual object defining known properties.
  // The function must not have side effects, and it must not access any state (besides the supplied arguments).

  global.$DefineOwnProperty("__residual", new _descriptors.PropertyDescriptor({
    value: createNativeFunctionForResidualCall(false),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Helper function that identifies a variant of the residual function that has implicit dependencies. This version of residual will infer the dependencies
  // and rewrite the function body to do the same thing as the original residual function.

  global.$DefineOwnProperty("__residual_unsafe", new _descriptors.PropertyDescriptor({
    value: createNativeFunctionForResidualCall(true),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Internal helper function for tests.
  // __isAbstract(value) checks if a given value is abstract.

  global.$DefineOwnProperty("__isAbstract", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__isAbstract", "__isAbstract", 1, (context, [value]) => {
      return new _index.BooleanValue(realm, value instanceof _index.AbstractValue);
    }),
    writable: true,
    enumerable: false,
    configurable: true
  })); // __makePartial(object) marks an (abstract) object as partial.

  global.$DefineOwnProperty("__makePartial", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__makePartial", "__makePartial", 1, (context, [object]) => {
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        object.makePartial();
        return object;
      }

      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__makeFinal", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__makeFinal", "__makeFinal", 1, (context, [object]) => {
      if (object instanceof _index.ObjectValue || object instanceof _index.AbstractObjectValue && !object.values.isTop()) {
        object.makeFinal();
        return object;
      }

      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an object or abstract object value (non-top)");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  })); // __makeSimple(object) marks an (abstract) object as one that has no getters or setters.

  global.$DefineOwnProperty("__makeSimple", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__makeSimple", "__makeSimple", 1, (context, [object, option]) => {
      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        object.makeSimple(option);
        return object;
      }

      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Helper function that emits a check whether a given object property has a particular value.

  global.$DefineOwnProperty("__assumeDataProperty", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__assumeDataProperty", "__assumeDataProperty", 3, (context, [object, propertyName, value, invariantOptions]) => {
      if (!realm.useAbstractInterpretation) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
      }

      if (object instanceof _index.AbstractObjectValue || object instanceof _index.ObjectValue) {
        let generator = realm.generator;
        (0, _invariant.default)(generator);

        let key = _singletons.To.ToStringPartial(realm, propertyName);

        if (realm.emitConcreteModel) {
          generator.emitConcreteModel(key, value);
        } else if (realm.invariantLevel >= 1) {
          let invariantOptionString = invariantOptions ? _singletons.To.ToStringPartial(realm, invariantOptions) : "FULL_INVARIANT";

          switch (invariantOptionString) {
            // checks (!property in object || object.property === undefined)
            case "VALUE_DEFINED_INVARIANT":
              generator.emitPropertyInvariant(object, key, value.mightBeUndefined() ? "PRESENT" : "DEFINED");
              break;

            case "SKIP_INVARIANT":
              break;

            case "FULL_INVARIANT":
              generator.emitFullInvariant(object, key, value);
              break;

            default:
              (0, _invariant.default)(false, "Invalid invariantOption " + invariantOptionString);
          }

          if (!realm.neverCheckProperty(object, key)) realm.markPropertyAsChecked(object, key);
        }

        realm.generator = undefined; // don't emit code during the following $Set call
        // casting to due to Flow workaround above

        object.$Set(key, value, object);
        realm.generator = generator;
        if (object.intrinsicName) realm.rebuildObjectProperty(object, key, value, object.intrinsicName);
        return context.$Realm.intrinsics.undefined;
      }

      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "not an (abstract) object");
    }),
    writable: true,
    enumerable: false,
    configurable: true
  })); // Helper function that replaces the implementation of a source function with
  // the details from another source function body, including the captured
  // environment, the actual code, etc.
  // This realizes a form of monkey-patching, enabling mocking a function if
  // one doesn't control all existing references to that function,
  // or if the storage location to those references cannot be easily updated.
  // NOTE: This function affects un-tracked state, so care must be taken
  // that this helper function is executed at the right time; typically, one
  // would want to execute this function before any call is executed to that
  // function. Care must be taken not to make reachable conditionally
  // defined values. Because of this limitations, this helper function
  // should be considered only as a last resort.

  global.$DefineOwnProperty("__replaceFunctionImplementation_unsafe", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__replaceFunctionImplementation_unsafe", "__replaceFunctionImplementation_unsafe", 2, (context, [target, source]) => {
      if (!(target instanceof _index.ECMAScriptSourceFunctionValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "first argument is not a function with source code");
      }

      if (!(source instanceof _index.ECMAScriptSourceFunctionValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "second argument is not a function with source code");
      } // relevant properties for functionValue


      target.$Environment = source.$Environment;
      target.$ScriptOrModule = source.$ScriptOrModule; // properties for ECMAScriptFunctionValue

      target.$ConstructorKind = source.$ConstructorKind;
      target.$ThisMode = source.$ThisMode;
      target.$HomeObject = source.$HomeObject;
      target.$FunctionKind = source.$FunctionKind; // properties for ECMAScriptSourceFunctionValue

      target.$Strict = source.$Strict;
      target.$FormalParameters = source.$FormalParameters;
      target.$ECMAScriptCode = source.$ECMAScriptCode;
      target.$HasComputedName = source.$HasComputedName;
      target.$HasEmptyConstructor = source.$HasEmptyConstructor;
      target.loc = source.loc;
      return context.$Realm.intrinsics.undefined;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__IntrospectionError", new _descriptors.PropertyDescriptor({
    value: realm.intrinsics.__IntrospectionError,
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__isIntegral", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__isIntegral", "__isIntegral", 1, (context, [value]) => {
      return new _index.BooleanValue(realm, value instanceof _index.IntegralValue);
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__describe", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__describe", "__describe", 1, (context, [value]) => {
      return new _index.StringValue(realm, (0, _utils2.describeValue)(value));
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__fatal", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__fatal", "__fatal", 0, (context, []) => {
      throw new _errors.FatalError();
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("__eagerlyRequireModuleDependencies", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.__eagerlyRequireModuleDependencies", "__eagerlyRequireModuleDependencies", 1, (context, [functionValue]) => {
      if (!(0, _index2.IsCallable)(realm, functionValue) || !(functionValue instanceof _index.FunctionValue)) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "argument must be callable function");
      let functionCall = functionValue.$Call;

      if (typeof functionCall !== "function") {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "argument must be directly callable");
      }

      let old = realm.eagerlyRequireModuleDependencies;
      realm.eagerlyRequireModuleDependencies = true;

      try {
        return functionCall(realm.intrinsics.undefined, []);
      } finally {
        realm.eagerlyRequireModuleDependencies = old;
      }
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));
}
//# sourceMappingURL=global.js.map

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTypeNameOrTemplate = parseTypeNameOrTemplate;
exports.createAbstract = createAbstract;

var _index = __webpack_require__(10);

var _PreludeGenerator = __webpack_require__(238);

var _index2 = __webpack_require__(15);

var _Error = __webpack_require__(424);

var _singletons = __webpack_require__(236);

var _AbstractObjectValue = _interopRequireDefault(__webpack_require__(395));

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
const throwTemplateSrc = "(function(){throw new global.Error('abstract value defined at ' + A);})()";

function parseTypeNameOrTemplate(realm, typeNameOrTemplate) {
  if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof _index.UndefinedValue) {
    return {
      type: _index.Value,
      template: undefined
    };
  } else if (typeof typeNameOrTemplate === "string") {
    let type = _singletons.Utils.getTypeFromName(typeNameOrTemplate);

    if (type === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown typeNameOrTemplate");
    }

    return {
      type,
      template: undefined
    };
  } else if (typeNameOrTemplate instanceof _index.StringValue) {
    let typeNameString = _singletons.To.ToStringPartial(realm, typeNameOrTemplate);

    let hasFunctionResultType = typeNameString.startsWith(":");
    if (hasFunctionResultType) typeNameString = typeNameString.substring(1);

    let type = _singletons.Utils.getTypeFromName(typeNameString);

    if (type === undefined) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "unknown typeNameOrTemplate");
    }

    return hasFunctionResultType ? {
      type: _index.FunctionValue,
      template: undefined,
      functionResultType: type
    } : {
      type,
      template: undefined
    };
  } else if (typeNameOrTemplate instanceof _index.FunctionValue) {
    return {
      type: _index.FunctionValue,
      template: typeNameOrTemplate
    };
  } else if (typeNameOrTemplate instanceof _index.ObjectValue) {
    return {
      type: _index.ObjectValue,
      template: typeNameOrTemplate
    };
  } else {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "typeNameOrTemplate has unsupported type");
  }
}

function createAbstract(realm, typeNameOrTemplate, name, options, ...additionalValues) {
  if (!realm.useAbstractInterpretation) {
    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "realm is not partial");
  }

  let {
    type,
    template,
    functionResultType
  } = parseTypeNameOrTemplate(realm, typeNameOrTemplate);
  let optionsMap = options ? options.properties : new Map();
  let result;
  let locString,
      loc = null;

  for (let executionContext of realm.contextStack.slice().reverse()) {
    let caller = executionContext.caller;
    loc = executionContext.loc;
    locString = (0, _Error.describeLocation)(realm, caller ? caller.function : undefined, caller ? caller.lexicalEnvironment : undefined, loc);
    if (locString !== undefined) break;
  }

  if (name === undefined) {
    let locVal = new _index.StringValue(realm, locString !== undefined ? locString : "(unknown location)");
    result = _index.AbstractValue.createFromTemplate(realm, throwTemplateSrc, type, [locVal]);
    result.hashValue = ++realm.objectCount; // need not be an object, but must be unique
  } else {
    if (!optionsMap.get("allowDuplicateNames") && !realm.isNameStringUnique(name)) {
      let error = new _errors.CompilerDiagnostic("An abstract value with the same name exists", loc, "PP0019", "FatalError");
      realm.handleError(error);
      throw new _errors.FatalError();
    } else {
      realm.saveNameString(name);
    }

    result = _index.AbstractValue.createFromTemplate(realm, optionsMap.get("disablePlaceholders") ? name + _PreludeGenerator.DisablePlaceholderSuffix : name, type, []);
    result.intrinsicName = name;
  }

  if (template) result.values = new _index2.ValuesDomain(new Set([template]));

  if (template && !(template instanceof _index.FunctionValue)) {
    // why exclude functions?
    template.makePartial();
    if (name !== undefined) realm.rebuildNestedProperties(result, name);
  }

  if (functionResultType) {
    (0, _invariant.default)(result instanceof _AbstractObjectValue.default);
    result.functionResultType = functionResultType;
  }

  if (additionalValues.length > 0) result = _index.AbstractValue.createAbstractConcreteUnion(realm, result, additionalValues);
  return result;
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _document = _interopRequireDefault(__webpack_require__(634));

var _console = _interopRequireDefault(__webpack_require__(635));

var _errors = __webpack_require__(3);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _index2 = __webpack_require__(15);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let global = realm.$GlobalObject;
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) global.$DefineOwnProperty("console", new _descriptors.PropertyDescriptor({
    value: (0, _console.default)(realm),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("self", new _descriptors.PropertyDescriptor({
    value: global,
    writable: true,
    enumerable: true,
    configurable: true
  }));
  global.$DefineOwnProperty("window", new _descriptors.PropertyDescriptor({
    value: global,
    writable: true,
    enumerable: true,
    configurable: true
  }));
  global.$DefineOwnProperty("document", new _descriptors.PropertyDescriptor({
    value: (0, _document.default)(realm),
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("setTimeout", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.setTimeout", "", 2, (context, args) => {
      let callback = args[0].throwIfNotConcrete();
      if (!(callback instanceof _index.FunctionValue)) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "callback arguments must be function");
      if (!realm.useAbstractInterpretation) throw new _errors.FatalError("TODO #1003: implement global.setTimeout");
      (0, _invariant.default)(realm.generator !== undefined);
      let generator = realm.generator;
      return generator.emitCallAndCaptureResult(_index2.TypesDomain.topVal, _index2.ValuesDomain.topVal, "global.setTimeout", args);
    }),
    writable: true,
    enumerable: true,
    configurable: true
  }));
  global.$DefineOwnProperty("clearTimeout", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.clearTimeout", "", 2, (context, args) => {
      if (!realm.useAbstractInterpretation) throw new _errors.FatalError("TODO #1003: implement global.clearTimeout");
      (0, _invariant.default)(realm.generator !== undefined);
      let generator = realm.generator;
      generator.emitCall("global.clearTimeout", args);
      return realm.intrinsics.undefined;
    }),
    writable: true,
    enumerable: true,
    configurable: true
  }));
  global.$DefineOwnProperty("setInterval", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.setInterval", "", 2, (context, args) => {
      if (!realm.useAbstractInterpretation) throw new _errors.FatalError("TODO #1003: implement global.setInterval");
      let callback = args[0].throwIfNotConcrete();
      if (!(callback instanceof _index.FunctionValue)) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "callback arguments must be function");
      (0, _invariant.default)(realm.generator !== undefined);
      let generator = realm.generator;
      return generator.emitCallAndCaptureResult(_index2.TypesDomain.topVal, _index2.ValuesDomain.topVal, "global.setInterval", args);
    }),
    writable: true,
    enumerable: true,
    configurable: true
  }));
  global.$DefineOwnProperty("clearInterval", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "global.clearInterval", "", 2, (context, args) => {
      if (!realm.useAbstractInterpretation) throw new _errors.FatalError("TODO #1003: implement global.clearInterval");
      (0, _invariant.default)(realm.generator !== undefined);
      let generator = realm.generator;
      generator.emitCall("global.clearInterval", args);
      return realm.intrinsics.undefined;
    }),
    writable: true,
    enumerable: true,
    configurable: true
  }));
}
//# sourceMappingURL=global.js.map

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _utils = __webpack_require__(632);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
const functions = ["getElementById", "getElementByTag", "getElementByClassName", "getElementByName", "getElementByTagName", "getElementByTagNameNS", "querySelector", "querySelectorAll", "createElement", "createDocumentFragment", "createTextNode"];

function _default(realm) {
  // document object
  let document = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "document", false); // check if we can use abstracts

  if (realm.useAbstractInterpretation) {
    // common methods on document
    for (let name of functions) {
      let func = (0, _utils.createAbstract)(realm, "function", `document.${name}`);

      _singletons.Properties.Set(realm, document, name, func, false);
    } // document.body


    let body = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "document.body");

    _singletons.Properties.Set(realm, document, "body", body, false); // make abstract


    let abstractObject = (0, _utils.createAbstract)(realm, document, "document");
    (0, _invariant.default)(abstractObject instanceof _index.AbstractObjectValue);
    return abstractObject;
  }

  return document;
}
//# sourceMappingURL=document.js.map

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
const consoleMethods = ["assert", "clear", "count", "dir", "dirxml", "error", "group", "groupCollapsed", "groupEnd", "info", "log", "table", "time", "timeEnd", "trace", "warn"];

function _default(realm) {
  let obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "console");

  for (let method of consoleMethods) {
    obj.defineNativeMethod(method, 0, (context, args) => {
      realm.outputToConsole(method, args);
      return realm.intrinsics.undefined;
    });
  }

  obj.defineNativeMethod("time", 0, (context, args) => {
    realm.outputToConsole("time", args);
    return realm.intrinsics.undefined;
  });
  obj.defineNativeMethod("timeEnd", 0, (context, args) => {
    realm.outputToConsole("timeEnd", args);
    return realm.intrinsics.undefined;
  });
  return obj;
}
//# sourceMappingURL=console.js.map

/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _console = _interopRequireDefault(__webpack_require__(635));

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let global = realm.$GlobalObject;
  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith("mobile")) global.$DefineOwnProperty("console", new _descriptors.PropertyDescriptor({
    value: (0, _console.default)(realm),
    writable: true,
    enumerable: false,
    configurable: true
  }));

  for (let name of ["document", "setTimeout", "setInterval", "window", "process", "setImmediate", "clearTimeout", "clearInterval", "clearImmediate", "alert", "navigator", "module", "requestAnimationFrame", "cancelAnimationFrame", "requestIdleCallback", "cancelIdleCallback", "Symbol", "Promise", "WeakSet", "Proxy", "WebSocket", "Request", "Response", "Headers", "FormData", "Worker", "Node", "Blob", "URLSearchParams", "FileReader", "XMLHttpRequest"]) {
    global.$DefineOwnProperty(name, new _descriptors.PropertyDescriptor({
      value: realm.intrinsics.undefined,
      writable: true,
      enumerable: false,
      configurable: true
    }));
  }
}
//# sourceMappingURL=global.js.map

/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(10);

var _reactMocks = __webpack_require__(638);

var _reactDomMocks = __webpack_require__(640);

var _reactNativeMocks = __webpack_require__(646);

var _relayMocks = __webpack_require__(647);

var _utils = __webpack_require__(632);

var _fbMocks = __webpack_require__(648);

var _errors = __webpack_require__(3);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils2 = __webpack_require__(291);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm) {
  let global = realm.$GlobalObject;

  if (realm.react.enabled) {
    // Create it eagerly so it's created outside effect branches
    realm.react.defaultPropsHelper = (0, _utils2.createDefaultPropsHelper)(realm);
    let emptyArray = new _index.ArrayValue(realm);
    emptyArray.makeFinal();
    realm.react.emptyArray = emptyArray;
    let emptyObject = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
    emptyObject.makeFinal();
    realm.react.emptyObject = emptyObject;
  } // module.exports support


  let moduleValue = _index.AbstractValue.createAbstractObject(realm, "module");

  moduleValue.kind = "resolved";

  let moduleExportsValue = _index.AbstractValue.createAbstractObject(realm, "module.exports");

  moduleExportsValue.kind = "resolved";
  moduleValue.$DefineOwnProperty("exports", new _descriptors.PropertyDescriptor({
    value: moduleExportsValue,
    writable: true,
    enumerable: false,
    configurable: true
  }));
  global.$DefineOwnProperty("module", new _descriptors.PropertyDescriptor({
    value: moduleValue,
    writable: true,
    enumerable: false,
    configurable: true
  })); // apply require() mock

  global.$DefineOwnProperty("require", new _descriptors.PropertyDescriptor({
    value: new _index.NativeFunctionValue(realm, "require", "require", 0, (context, [requireNameVal]) => {
      (0, _invariant.default)(requireNameVal instanceof _index.StringValue);
      let requireNameValValue = requireNameVal.value;

      if (requireNameValValue === "react" || requireNameValValue === "React") {
        if (realm.fbLibraries.react === undefined) {
          let react = (0, _reactMocks.createMockReact)(realm, requireNameValValue);
          realm.fbLibraries.react = react;
          return react;
        }

        return realm.fbLibraries.react;
      } else if (requireNameValValue === "react-dom" || requireNameValValue === "ReactDOM") {
        if (realm.fbLibraries.reactDom === undefined) {
          let reactDom = (0, _reactDomMocks.createMockReactDOM)(realm, requireNameValValue);
          realm.fbLibraries.reactDom = reactDom;
          return reactDom;
        }

        return realm.fbLibraries.reactDom;
      } else if (requireNameValValue === "react-dom/server" || requireNameValValue === "ReactDOMServer") {
        if (realm.fbLibraries.reactDomServer === undefined) {
          let reactDomServer = (0, _reactDomMocks.createMockReactDOMServer)(realm, requireNameValValue);
          realm.fbLibraries.reactDomServer = reactDomServer;
          return reactDomServer;
        }

        return realm.fbLibraries.reactDomServer;
      } else if (requireNameValValue === "react-native" || requireNameValValue === "ReactNative") {
        if (realm.fbLibraries.reactNative === undefined) {
          let reactNative = (0, _reactNativeMocks.createMockReactNative)(realm, requireNameValValue);
          realm.fbLibraries.reactNative = reactNative;
          return reactNative;
        }

        return realm.fbLibraries.reactNative;
      } else if (requireNameValValue === "react-relay" || requireNameValValue === "RelayModern") {
        if (realm.fbLibraries.reactRelay === undefined) {
          let reactRelay = (0, _relayMocks.createMockReactRelay)(realm, requireNameValValue);
          realm.fbLibraries.reactRelay = reactRelay;
          return reactRelay;
        }

        return realm.fbLibraries.reactRelay;
      } else if (requireNameValValue === "prop-types" || requireNameValValue === "PropTypes") {
        if (realm.fbLibraries.react === undefined) {
          throw new _errors.FatalError("unable to require PropTypes due to React not being referenced in scope");
        }

        let propTypes = (0, _index2.Get)(realm, realm.fbLibraries.react, "PropTypes");
        (0, _invariant.default)(propTypes instanceof _index.ObjectValue);
        return propTypes;
      } else {
        let requireVal;

        if (realm.fbLibraries.other.has(requireNameValValue)) {
          requireVal = realm.fbLibraries.other.get(requireNameValValue);
        } else {
          requireVal = (0, _utils.createAbstract)(realm, "function", `require("${requireNameValValue}")`);
          realm.fbLibraries.other.set(requireNameValValue, requireVal);
        }

        (0, _invariant.default)(requireVal instanceof _index.AbstractValue);
        return requireVal;
      }
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));

  if (realm.isCompatibleWith("fb-www")) {
    (0, _fbMocks.createFbMocks)(realm, global);
  }
}
//# sourceMappingURL=global.js.map

/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMockReact = createMockReact;

var _parser = __webpack_require__(247);

var _index = __webpack_require__(15);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _utils = __webpack_require__(291);

var _elements = __webpack_require__(420);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils2 = __webpack_require__(639);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// most of the code here was taken from https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js
let reactCode = `
  function createReact(
    REACT_ELEMENT_TYPE,
    REACT_FRAGMENT_TYPE,
    REACT_PORTAL_TYPE,
    REACT_FORWARD_REF_TYPE,
    ReactElement,
    ReactCurrentOwner
  ) {
    function makeEmptyFunction(arg) {
      return function() {
        return arg;
      };
    }
    var emptyFunction = function() {};

    emptyFunction.thatReturns = makeEmptyFunction;
    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
    emptyFunction.thatReturnsThis = function() { return this; };
    emptyFunction.thatReturnsArgument = function(arg) { return arg; };

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true,
    };

    function hasValidRef(config) {
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      return config.key !== undefined;
    }

    function Component(props, context) {
      this.props = props;
      this.context = context;
      this.refs = {};
      this.setState = function () {}; // NO-OP
      this.setState.__PREPACK_MOCK__ = true;
    }

    Component.prototype.isReactComponent = {};

    function PureComponent(props, context) {
      this.props = props;
      this.context = context;
      this.refs = {};
      this.setState = function () {}; // NO-OP
      this.setState.__PREPACK_MOCK__ = true;
    }

    PureComponent.prototype.isReactComponent = {};
    PureComponent.prototype.isPureReactComponent = true;

    function forwardRef(render) {
      // NOTE: In development there are a bunch of warnings which will be logged to validate the \`render\` function.
      // Since Prepack is a production only tool (for now) we dont include these warnings.
      //
      // https://github.com/facebook/react/blob/f9358c51c8de93abe3cdd0f4720b489befad8c48/packages/react/src/forwardRef.js
      return {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render,
      };
    }

    var userProvidedKeyEscapeRegex = /\/+/g;

    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    function escape(key) {
      const escapeRegex = /[=:]/g;
      const escaperLookup = {
        '=': '=0',
        ':': '=2',
      };
      const escapedString = ('' + key).replace(escapeRegex, function(match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    var POOL_SIZE = 10;
    function getPooledTraverseContext(
      mapResult,
      keyPrefix,
      mapFunction,
      mapContext,
    ) {
      return {
        result: mapResult,
        keyPrefix: keyPrefix,
        func: mapFunction,
        context: mapContext,
        count: 0,
      };
    }

    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if (
        typeof component === 'object' &&
        component !== null &&
        component.key != null
      ) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function traverseAllChildrenImpl(
      children,
      nameSoFar,
      callback,
      traverseContext,
    ) {
      const type = typeof children;

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      let invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;
          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }
        }
      }

      if (invokeCallback) {
        callback(
          traverseContext,
          children,
          // If it's the only child, treat the name as if it was wrapped in an array
          // so that it's consistent if the number of children grows.
          nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,
        );
        return 1;
      }

      let child;
      let nextName;
      let subtreeCount = 0; // Count of children found in the current subtree.
      const nextNamePrefix =
        nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(
            child,
            nextName,
            callback,
            traverseContext,
          );
        }
      } else {
        const iteratorFn = getIteratorFn(children);
        if (typeof iteratorFn === 'function') {
          var iterator = iteratorFn.call(children);
          let step;
          let ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(
              child,
              nextName,
              callback,
              traverseContext,
            );
          }
        } else if (type === 'object') {
          let addendum = '';
          var childrenString = '' + children;
        }
      }

      return subtreeCount;
    }

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(
        oldElement.type,
        newKey,
        oldElement.ref,
        oldElement.props,
      );
    
      return newElement;
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var {result, keyPrefix, func, context} = bookKeeping;
    
      let mappedChild = func.call(context, child);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(
            mappedChild,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            keyPrefix +
              (mappedChild.key && (!child || child.key !== mappedChild.key)
                ? escapeUserProvidedKey(mappedChild.key) + '/'
                : '') +
              childKey,
          );
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      const traverseContext = getPooledTraverseContext(
        array,
        escapedPrefix,
        func,
        context,
      );
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var {func, context} = bookKeeping;
      func.call(context, child);
    }

    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(
        null,
        null,
        forEachFunc,
        forEachContext,
      );
      traverseAllChildren(children, forEachSingleChild, traverseContext);
    }

    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    function countChildren(children) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }

    function onlyChild(children) {
      return children;
    }

    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(
        children,
        result,
        null,
        emptyFunction.thatReturnsArgument,
      );
      return result;
    }

    function isValidElement(object) {
      return (
        typeof object === 'object' &&
        object !== null &&
        object.$$typeof === REACT_ELEMENT_TYPE
      );
    }

    function shim() {

    }
    shim.isRequired = shim;

    function getShim() {
      return shim;
    };

    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,

      any: shim,
      arrayOf: getShim,
      element: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim
    };

    ReactPropTypes.checkPropTypes = shim;
    ReactPropTypes.PropTypes = ReactPropTypes;

    var ReactSharedInternals = {
      ReactCurrentOwner,
    };

    return {
      Children: {
        forEach: forEachChildren,
        map: mapChildren,
        count: countChildren,
        only: onlyChild,
        toArray,
      },
      Component,
      PureComponent,
      forwardRef,
      Fragment: REACT_FRAGMENT_TYPE,
      isValidElement,
      version: "16.2.0",
      PropTypes: ReactPropTypes,
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,
    };
  }
`;
let reactAst = (0, _parser.parseExpression)(reactCode, {
  plugins: ["flow"]
});

function createMockReact(realm, reactRequireName) {
  let reactFactory = _singletons.Environment.GetValue(realm, realm.$GlobalEnv.evaluate(reactAst, false));

  (0, _invariant.default)(reactFactory instanceof _index2.ECMAScriptSourceFunctionValue);
  let currentOwner = realm.react.currentOwner = new _index2.ObjectValue(realm, realm.intrinsics.ObjectPrototype, "currentOwner"); // this is to get around Flow getting confused

  let factory = reactFactory.$Call;
  (0, _invariant.default)(factory !== undefined);
  let mockReactElementBuilder = new _index2.NativeFunctionValue(realm, undefined, "ReactElement", 0, (context, [type, key, ref, props]) => {
    (0, _invariant.default)(props instanceof _index2.ObjectValue);
    return (0, _utils.createInternalReactElement)(realm, type, key, ref, props);
  });
  let reactValue = factory(realm.intrinsics.undefined, [(0, _utils.getReactSymbol)("react.element", realm), (0, _utils.getReactSymbol)("react.fragment", realm), (0, _utils.getReactSymbol)("react.portal", realm), (0, _utils.getReactSymbol)("react.forward_ref", realm), mockReactElementBuilder, currentOwner]);
  (0, _invariant.default)(reactValue instanceof _index2.ObjectValue);
  reactValue.refuseSerialization = true; // update existing properties with the new intrinsic mock values

  (0, _utils2.updateIntrinsicNames)(realm, reactValue, reactRequireName, ["PropTypes", "Children", "isValidElement", {
    name: "Component",
    updatePrototype: true
  }, {
    name: "PureComponent",
    updatePrototype: true
  }]);
  (0, _utils2.addMockFunctionToObject)(realm, reactValue, reactRequireName, "createElement", (context, [type, config, ...children]) => {
    (0, _invariant.default)(type instanceof _index2.Value); // if config is undefined/null, use an empy object

    if (config === realm.intrinsics.undefined || config === realm.intrinsics.null || config === undefined) {
      config = new _index2.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
    }

    if (config instanceof _index2.AbstractValue && !(config instanceof _index2.AbstractObjectValue)) {
      config = _singletons.To.ToObject(realm, config);
    }

    (0, _invariant.default)(config instanceof _index2.ObjectValue || config instanceof _index2.AbstractObjectValue);

    if (Array.isArray(children)) {
      if (children.length === 0) {
        children = undefined;
      } else if (children.length === 1) {
        children = children[0];
      } else {
        let array = _singletons.Create.ArrayCreate(realm, 0);

        let length = children.length;

        for (let i = 0; i < length; i++) {
          _singletons.Create.CreateDataPropertyOrThrow(realm, array, "" + i, children[i]);
        }

        children = array;
        children.makeFinal();
      }
    }

    return (0, _elements.createReactElement)(realm, type, config, children);
  });
  (0, _utils2.addMockFunctionToObject)(realm, reactValue, reactRequireName, "cloneElement", (context, [element, config, ...children]) => {
    (0, _invariant.default)(element instanceof _index2.ObjectValue); // if config is undefined/null, use an empy object

    if (config === realm.intrinsics.undefined || config === realm.intrinsics.null || config === undefined) {
      config = realm.intrinsics.null;
    }

    if (config instanceof _index2.AbstractValue && !(config instanceof _index2.AbstractObjectValue)) {
      config = _singletons.To.ToObject(realm, config);
    }

    (0, _invariant.default)(config instanceof _index2.ObjectValue || config instanceof _index2.AbstractObjectValue || config instanceof _index2.NullValue);

    if (Array.isArray(children)) {
      if (children.length === 0) {
        children = undefined;
      } else if (children.length === 1) {
        children = children[0];
      } else {
        let array = _singletons.Create.ArrayCreate(realm, 0);

        let length = children.length;

        for (let i = 0; i < length; i++) {
          _singletons.Create.CreateDataPropertyOrThrow(realm, array, "" + i, children[i]);
        }

        children = array;
        children.makeFinal();
      }
    }

    return (0, _elements.cloneReactElement)(realm, element, config, children);
  });
  (0, _utils2.addMockFunctionToObject)(realm, reactValue, reactRequireName, "createContext", (funcValue, [defaultValue = realm.intrinsics.undefined]) => {
    (0, _invariant.default)(defaultValue instanceof _index2.Value);
    let consumerObject = new _index2.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
    let providerObject = new _index2.ObjectValue(realm, realm.intrinsics.ObjectPrototype);

    let consumer = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.ObjectValue, [funcValue, defaultValue], (0, _generator.createOperationDescriptor)("REACT_TEMPORAL_FUNC"), {
      skipInvariant: true,
      isPure: true
    });

    (0, _invariant.default)(consumer instanceof _index2.AbstractObjectValue);
    consumer.values = new _index.ValuesDomain(new Set([consumerObject]));

    let provider = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.ObjectValue, [consumer], (0, _generator.createOperationDescriptor)("REACT_CREATE_CONTEXT_PROVIDER"), {
      skipInvariant: true,
      isPure: true
    });

    (0, _invariant.default)(provider instanceof _index2.AbstractObjectValue);
    provider.values = new _index.ValuesDomain(new Set([providerObject]));

    _singletons.Properties.Set(realm, consumerObject, "$$typeof", (0, _utils.getReactSymbol)("react.context", realm), true);

    _singletons.Properties.Set(realm, consumerObject, "currentValue", defaultValue, true);

    _singletons.Properties.Set(realm, consumerObject, "defaultValue", defaultValue, true);

    _singletons.Properties.Set(realm, consumerObject, "changedBits", new _index2.NumberValue(realm, 0), true);

    _singletons.Properties.Set(realm, consumerObject, "Consumer", consumer, true);

    _singletons.Properties.Set(realm, providerObject, "$$typeof", (0, _utils.getReactSymbol)("react.provider", realm), true);

    _singletons.Properties.Set(realm, providerObject, "context", consumer, true);

    _singletons.Properties.Set(realm, consumerObject, "Provider", provider, true);

    return consumer;
  });
  (0, _utils2.addMockFunctionToObject)(realm, reactValue, reactRequireName, "createRef", funcVal => {
    let createRef = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.FunctionValue, [funcVal], (0, _generator.createOperationDescriptor)("REACT_TEMPORAL_FUNC"), {
      skipInvariant: true,
      isPure: true
    });

    (0, _invariant.default)(createRef instanceof _index2.AbstractObjectValue);
    return createRef;
  });
  reactValue.refuseSerialization = false;
  reactValue.makeFinal();
  return reactValue;
}
//# sourceMappingURL=react-mocks.js.map

/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateIntrinsicNames = updateIntrinsicNames;
exports.addMockFunctionToObject = addMockFunctionToObject;

var _index = __webpack_require__(10);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function updateIntrinsicNames(realm, obj, requireName, properties) {
  obj.intrinsicName = `require("${requireName}")`;

  if (properties) {
    for (let property of properties) {
      if (typeof property === "string") {
        let val = (0, _index2.Get)(realm, obj, property);
        (0, _invariant.default)(val instanceof _index.Value);
        val.intrinsicName = `require("${requireName}").${property}`;
      } else if (typeof property === "object" && property !== null) {
        let {
          name,
          updatePrototype
        } = property;
        let val = (0, _index2.Get)(realm, obj, name);
        (0, _invariant.default)(val instanceof _index.Value);
        val.intrinsicName = `require("${requireName}").${name}`;

        if (updatePrototype) {
          (0, _invariant.default)(val instanceof _index.ObjectValue);
          let proto = (0, _index2.Get)(realm, val, "prototype");
          proto.intrinsicName = `require("${requireName}").${name}.prototype`;
        }
      }
    }
  }
}

function addMockFunctionToObject(realm, obj, requireName, funcName, func) {
  let funcValue = new _index.NativeFunctionValue(realm, undefined, funcName, 0, (context, args) => func(funcValue, args));
  obj.defineNativeProperty(funcName, funcValue, {
    writable: false,
    enumerable: false,
    configurable: true
  });
  funcValue.intrinsicName = `require("${requireName}").${funcName}`;
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMockReactDOM = createMockReactDOM;
exports.createMockReactDOMServer = createMockReactDOMServer;

var _index = __webpack_require__(10);

var _utils = __webpack_require__(291);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils2 = __webpack_require__(639);

var _rendering = __webpack_require__(641);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function createMockReactDOM(realm, reactDomRequireName) {
  let reactDomValue = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
  reactDomValue.refuseSerialization = true;
  (0, _utils2.updateIntrinsicNames)(realm, reactDomValue, reactDomRequireName);

  const genericTemporalFunc = (funcVal, args) => {
    let reactDomMethod = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.FunctionValue, [funcVal, ...args], (0, _generator.createOperationDescriptor)("REACT_TEMPORAL_FUNC"), {
      skipInvariant: true,
      isPure: true
    });

    (0, _invariant.default)(reactDomMethod instanceof _index.AbstractObjectValue);
    return reactDomMethod;
  };

  (0, _utils2.addMockFunctionToObject)(realm, reactDomValue, reactDomRequireName, "render", genericTemporalFunc);
  (0, _utils2.addMockFunctionToObject)(realm, reactDomValue, reactDomRequireName, "hydrate", genericTemporalFunc);
  (0, _utils2.addMockFunctionToObject)(realm, reactDomValue, reactDomRequireName, "findDOMNode", genericTemporalFunc);
  (0, _utils2.addMockFunctionToObject)(realm, reactDomValue, reactDomRequireName, "unmountComponentAtNode", genericTemporalFunc);

  const createPortalFunc = (funcVal, [reactPortalValue, domNodeValue]) => {
    let reactDomMethod = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.ObjectValue, [funcVal, reactPortalValue, domNodeValue], (0, _generator.createOperationDescriptor)("REACT_TEMPORAL_FUNC"), {
      skipInvariant: true,
      isPure: true
    });

    (0, _invariant.default)(reactDomMethod instanceof _index.AbstractObjectValue);
    realm.react.abstractHints.set(reactDomMethod, (0, _utils.createReactHintObject)(reactDomValue, "createPortal", [reactPortalValue, domNodeValue], realm.intrinsics.undefined));
    return reactDomMethod;
  };

  (0, _utils2.addMockFunctionToObject)(realm, reactDomValue, reactDomRequireName, "createPortal", createPortalFunc);
  reactDomValue.refuseSerialization = false;
  reactDomValue.makeFinal();
  return reactDomValue;
}

function createMockReactDOMServer(realm, requireName) {
  let reactDomServerValue = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
  reactDomServerValue.refuseSerialization = true;
  (0, _utils2.updateIntrinsicNames)(realm, reactDomServerValue, requireName);

  const genericTemporalFunc = (funcVal, args) => {
    let reactDomMethod = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.FunctionValue, [funcVal, ...args], (0, _generator.createOperationDescriptor)("REACT_TEMPORAL_FUNC"), {
      skipInvariant: true,
      isPure: true
    });

    (0, _invariant.default)(reactDomMethod instanceof _index.AbstractObjectValue);
    return reactDomMethod;
  };

  (0, _utils2.addMockFunctionToObject)(realm, reactDomServerValue, requireName, "renderToString", (funcVal, [input]) => {
    if (input instanceof _index.ObjectValue && (0, _utils.isReactElement)(input)) {
      return (0, _rendering.renderToString)(realm, input, false);
    }

    return genericTemporalFunc(funcVal, [input]);
  });
  (0, _utils2.addMockFunctionToObject)(realm, reactDomServerValue, requireName, "renderToStaticMarkup", (funcVal, [input]) => {
    if (input instanceof _index.ObjectValue && (0, _utils.isReactElement)(input)) {
      return (0, _rendering.renderToString)(realm, input, true);
    }

    return genericTemporalFunc(funcVal, [input]);
  });
  (0, _utils2.addMockFunctionToObject)(realm, reactDomServerValue, requireName, "renderToNodeStream", genericTemporalFunc);
  (0, _utils2.addMockFunctionToObject)(realm, reactDomServerValue, requireName, "renderToStaticNodeStream", genericTemporalFunc);
  reactDomServerValue.refuseSerialization = false;
  reactDomServerValue.makeFinal();
  return reactDomServerValue;
}
//# sourceMappingURL=react-dom-mocks.js.map

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMarkupForCustomAttribute = createMarkupForCustomAttribute;
exports.renderToString = renderToString;

var _types = __webpack_require__(408);

var _completions = __webpack_require__(18);

var _index = __webpack_require__(10);

var _reconcilation = __webpack_require__(415);

var _utils = __webpack_require__(291);

var t = _interopRequireWildcard(__webpack_require__(21));

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils2 = __webpack_require__(642);

var _domConfig = __webpack_require__(643);

var _hyphenateStyleName = _interopRequireDefault(__webpack_require__(644));

var _singletons = __webpack_require__(236);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// Warning: This code is experimental and might not fully work. There is no guarantee
// that it is up-to-date with the current react-dom/server logic and there may also be
// security holes in the string escaping because of this.
// $FlowFixMe: flow complains that this isn't a module but it is, and it seems to load fine
function renderValueWithHelper(realm, value, helper) {
  // given we know nothing of this value, we need to escape the contents of it at runtime
  let val = _index.AbstractValue.createFromBuildFunction(realm, _index.Value, [helper, value], (0, _generator.createOperationDescriptor)("REACT_SSR_RENDER_VALUE_HELPER"));

  (0, _invariant.default)(val instanceof _index.AbstractValue);
  return val;
}

function dangerousStyleValue(realm, name, value, isCustomProperty) {
  let isEmpty = value === realm.intrinsics.null || value === realm.intrinsics.undefined || value instanceof _index.BooleanValue || value instanceof _index.StringValue && value.value === "";

  if (isEmpty) {
    return "";
  }

  if (!isCustomProperty && value instanceof _index.NumberValue && value.value !== 0 && !(_domConfig.isUnitlessNumber.hasOwnProperty(name) && _domConfig.isUnitlessNumber[name])) {
    return value.value + "px";
  }

  if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
    return ("" + value.value).trim();
  } else {
    (0, _invariant.default)(false, "TODO");
  }
}

function createMarkupForCustomAttribute(realm, name, value) {
  if (!(0, _domConfig.isAttributeNameSafe)(name) || value == null) {
    return "";
  }

  if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
    return name + "=" + (0, _utils2.quoteAttributeValueForBrowser)(value.value + "");
  } else {
    (0, _invariant.default)(false, "TODO");
  }
}

function createMarkupForProperty(realm, name, value, htmlEscapeHelper) {
  const propertyInfo = (0, _domConfig.getPropertyInfo)(name);

  if (name !== "style" && (0, _domConfig.shouldIgnoreAttribute)(name, propertyInfo, false)) {
    return "";
  }

  if ((0, _domConfig.shouldRemoveAttribute)(realm, name, value, propertyInfo, false)) {
    return "";
  }

  if (propertyInfo !== null) {
    const attributeName = propertyInfo.attributeName;
    const {
      type
    } = propertyInfo;

    if (type === _domConfig.BOOLEAN || type === _domConfig.OVERLOADED_BOOLEAN && value === true) {
      return attributeName + '=""';
    } else if (value instanceof _index.StringValue || value instanceof _index.NumberValue || value instanceof _index.BooleanValue) {
      // $FlowFixMe: Flow complains about booleans being converted to strings, which is the intention
      return attributeName + "=" + (0, _utils2.quoteAttributeValueForBrowser)(value.value + "");
    } else if (value instanceof _index.AbstractValue) {
      return [attributeName + "=", renderValueWithHelper(realm, value, htmlEscapeHelper)];
    }
  } else if (value instanceof _index.StringValue || value instanceof _index.NumberValue || value instanceof _index.BooleanValue) {
    // $FlowFixMe: Flow complains about booleans being converted to strings, which is the intention
    return name + "=" + (0, _utils2.quoteAttributeValueForBrowser)(value.value + "");
  } else if (value instanceof _index.AbstractValue) {
    return [name + '="', renderValueWithHelper(realm, value, htmlEscapeHelper), '"'];
  }

  (0, _invariant.default)(false, "TODO");
}

function createMarkupForStyles(realm, styles) {
  let serialized = [];
  let delimiter = "";

  if (styles instanceof _index.ObjectValue && !styles.isPartialObject()) {
    for (let [styleName, binding] of styles.properties) {
      if (binding.descriptor !== undefined) {
        let isCustomProperty = styleName.indexOf("--") === 0;
        let styleValue = (0, _utils.getProperty)(realm, styles, styleName);

        if (styleValue !== realm.intrinsics.null && styleValue !== realm.intrinsics.undefined) {
          serialized.push(delimiter + (0, _hyphenateStyleName.default)(styleName) + ":");
          serialized.push(dangerousStyleValue(realm, styleName, styleValue, isCustomProperty));
          delimiter = ";";
        }
      }
    }
  }

  if (serialized.length > 0) {
    return renderReactNode(realm, serialized);
  }

  return realm.intrinsics.null;
}

function createOpenTagMarkup(realm, tagVerbatim, tagLowercase, propsValue, namespace, makeStaticMarkup, isRootElement, htmlEscapeHelper) {
  let ret = ["<" + tagVerbatim];

  if (propsValue instanceof _index.ObjectValue && !propsValue.isPartialObject()) {
    for (let [propName, binding] of propsValue.properties) {
      if (binding.descriptor !== undefined) {
        let propValue = (0, _utils.getProperty)(realm, propsValue, propName);

        if (propValue === realm.intrinsics.null || propValue === realm.intrinsics.undefined) {
          continue;
        }

        if (propName === _domConfig.STYLE) {
          propValue = createMarkupForStyles(realm, propValue);
        }

        let markup;

        if ((0, _utils2.isCustomComponent)(realm, tagLowercase, propsValue)) {
          if (!_domConfig.RESERVED_PROPS.has(propName)) {
            markup = createMarkupForCustomAttribute(realm, propName, propValue);
          }
        } else {
          markup = createMarkupForProperty(realm, propName, propValue, htmlEscapeHelper);
        }

        if (Array.isArray(markup)) {
          ret.push(" ", ...markup);
        } else if (typeof markup === "string" && markup !== "") {
          ret.push(" " + markup);
        } else if (markup) {
          ret.push(" ", markup);
        }
      }
    }
  } else {
    (0, _invariant.default)(false, "TODO");
  } // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.


  if (makeStaticMarkup) {
    return ret;
  }

  if (isRootElement) {
    ret.push(" " + (0, _utils2.createMarkupForRoot)());
  }

  return ret;
}

function renderReactNode(realm, reactNode) {
  let normalizedNode = (0, _utils2.normalizeNode)(realm, reactNode);

  if (typeof normalizedNode === "string") {
    return new _index.StringValue(realm, normalizedNode);
  } else if (normalizedNode instanceof _index.AbstractValue) {
    return normalizedNode;
  }

  (0, _invariant.default)(Array.isArray(normalizedNode));
  let args = [];
  let quasis = [];
  let lastWasAbstract = false;

  for (let element of normalizedNode) {
    if (typeof element === "string") {
      lastWasAbstract = false;
      quasis.push(t.templateElement({
        raw: element,
        cooked: element
      }));
    } else {
      if (lastWasAbstract) {
        quasis.push(t.templateElement({
          raw: "",
          cooked: ""
        }));
      }

      lastWasAbstract = true;
      (0, _invariant.default)(element instanceof _index.Value);
      args.push(element);
    }
  }

  let val = _index.AbstractValue.createFromBuildFunction(realm, _index.StringValue, args, (0, _generator.createOperationDescriptor)("REACT_SSR_TEMPLATE_LITERAL", {
    quasis
  }));

  (0, _invariant.default)(val instanceof _index.AbstractValue);
  return val;
}

class ReactDOMServerRenderer {
  constructor(realm, makeStaticMarkup) {
    this.realm = realm;
    this.makeStaticMarkup = makeStaticMarkup;
    this.previousWasTextNode = false;
    this.htmlEscapeHelper = (0, _utils2.createHtmlEscapeHelper)(realm);
    this.arrayHelper = (0, _utils2.createArrayHelper)(realm);
  }

  render(value, namespace = "html", depth = 0) {
    let rootReactNode = this._renderValue(value, namespace, depth);

    return renderReactNode(this.realm, rootReactNode);
  }

  _renderText(value) {
    let text = value.value + "";

    if (text === "") {
      return "";
    }

    if (this.makeStaticMarkup) {
      return (0, _utils2.escapeHtml)(text);
    }

    if (this.previousWasTextNode) {
      return "<!-- -->" + (0, _utils2.escapeHtml)(text);
    }

    this.previousWasTextNode = true;
    return (0, _utils2.escapeHtml)(text);
  }

  _renderAbstractConditionalValue(condValue, consequentVal, alternateVal, namespace, depth) {
    let val = this.realm.evaluateWithAbstractConditional(condValue, () => {
      return this.realm.evaluateForEffects(() => this.render(consequentVal, namespace, depth), null, "_renderAbstractConditionalValue consequent");
    }, () => {
      return this.realm.evaluateForEffects(() => this.render(alternateVal, namespace, depth), null, "_renderAbstractConditionalValue consequent");
    });
    return (0, _utils2.convertValueToNode)(val);
  }

  _renderAbstractValue(value, namespace, depth) {
    if (value.kind === "conditional") {
      let [condValue, consequentVal, alternateVal] = value.args;
      (0, _invariant.default)(condValue instanceof _index.AbstractValue);
      return this._renderAbstractConditionalValue(condValue, consequentVal, alternateVal, namespace, depth);
    } else {
      return renderValueWithHelper(this.realm, value, this.htmlEscapeHelper);
    }
  }

  _renderArrayValue(arrayValue, namespace, depth) {
    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(arrayValue)) {
      let nestedOptimizedFunctionEffects = arrayValue.nestedOptimizedFunctionEffects;

      if (nestedOptimizedFunctionEffects !== undefined) {
        for (let [func, effects] of nestedOptimizedFunctionEffects) {
          let funcCall = () => {
            let result = effects.result;
            this.realm.applyEffects(effects);

            if (result instanceof _completions.SimpleNormalCompletion) {
              result = result.value;
            }

            (0, _invariant.default)(result instanceof _index.Value);
            return this.render(result, namespace, depth);
          };

          let pureFuncCall = () => this.realm.evaluatePure(funcCall,
          /*bubbles*/
          true, () => {
            (0, _invariant.default)(false, "SSR _renderArrayValue side-effect should have been caught in main React reconciler");
          });

          let resolvedEffects;
          resolvedEffects = this.realm.evaluateForEffects(pureFuncCall,
          /*state*/
          null, `react SSR resolve nested optimized closure`);
          nestedOptimizedFunctionEffects.set(func, resolvedEffects);
          this.realm.collectedNestedOptimizedFunctionEffects.set(func, resolvedEffects);
        }

        return renderValueWithHelper(this.realm, arrayValue, this.arrayHelper);
      }
    }

    let elements = [];
    (0, _utils.forEachArrayValue)(this.realm, arrayValue, elementValue => {
      let renderedElement = this._renderValue(elementValue, namespace, depth);

      if (Array.isArray(renderedElement)) {
        elements.push(...renderedElement);
      } else {
        elements.push(renderedElement);
      }
    }); // $FlowFixMe: flow gets confused here

    return elements;
  }

  _renderReactElement(reactElement, namespace, depth) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");
    (0, _invariant.default)(propsValue instanceof _index.AbstractObjectValue || propsValue instanceof _index.ObjectValue);

    if (typeValue instanceof _index.StringValue) {
      let type = typeValue.value;
      let tag = type.toLowerCase();

      if (tag === "input") {
        let defaultValueProp = (0, _utils.getProperty)(this.realm, propsValue, "defaultValue");
        let defaultCheckedProp = (0, _utils.getProperty)(this.realm, propsValue, "defaultChecked");
        let valueProp = (0, _utils.getProperty)(this.realm, propsValue, "value");
        let checkedProp = (0, _utils.getProperty)(this.realm, propsValue, "checked");
        let newProps = new _index.ObjectValue(this.realm, this.realm.intrinsics.ObjectPrototype);

        _singletons.Properties.Set(this.realm, newProps, "type", this.realm.intrinsics.undefined, true);

        let inputProps = new _index.ObjectValue(this.realm, this.realm.intrinsics.ObjectPrototype);

        _singletons.Properties.Set(this.realm, inputProps, "defaultChecked", this.realm.intrinsics.undefined, true);

        _singletons.Properties.Set(this.realm, inputProps, "defaultValue", this.realm.intrinsics.undefined, true);

        _singletons.Properties.Set(this.realm, inputProps, "value", valueProp !== this.realm.intrinsics.null ? valueProp : defaultValueProp, true);

        _singletons.Properties.Set(this.realm, inputProps, "checked", checkedProp !== this.realm.intrinsics.null ? checkedProp : defaultCheckedProp, true);

        (0, _utils.applyObjectAssignConfigsForReactElement)(this.realm, newProps, [propsValue, inputProps]);
        propsValue = newProps;
      } else if (tag === "textarea") {
        let initialValue = (0, _utils.getProperty)(this.realm, propsValue, "value");

        if (initialValue === this.realm.intrinsics.null) {
          (0, _invariant.default)(false, "TODO");
        }

        let newProps = new _index.ObjectValue(this.realm, this.realm.intrinsics.ObjectPrototype);
        let textareaProps = new _index.ObjectValue(this.realm, this.realm.intrinsics.ObjectPrototype);

        _singletons.Properties.Set(this.realm, textareaProps, "value", this.realm.intrinsics.undefined, true);

        _singletons.Properties.Set(this.realm, textareaProps, "children", initialValue, true);

        (0, _utils.applyObjectAssignConfigsForReactElement)(this.realm, newProps, [propsValue, textareaProps]);
        propsValue = newProps;
      } else if (tag === "select") {
        (0, _invariant.default)(false, "TODO");
      } else if (tag === "option") {
        (0, _invariant.default)(false, "TODO");
      }

      let out = createOpenTagMarkup(this.realm, type, tag, propsValue, namespace, this.makeStaticMarkup, depth === 0, this.htmlEscapeHelper);
      let footer = "";

      if (_domConfig.omittedCloseTags.has(tag)) {
        out.push("/>");
      } else {
        out.push(">");
        footer = "</" + type + ">";
      }

      let innerMarkup = (0, _utils2.getNonChildrenInnerMarkup)(this.realm, propsValue);

      if (innerMarkup instanceof _index.StringValue) {
        if (_domConfig.newlineEatingTags[tag] && innerMarkup.value.charAt(0) === "\n") {
          out.push("\n");
        }

        out.push(innerMarkup.value);
      } else if (innerMarkup instanceof _index.ObjectValue) {
        (0, _invariant.default)(false, "TODO");
      } else {
        this.previousWasTextNode = false;
        let childrenValue = (0, _utils.getProperty)(this.realm, propsValue, "children");

        let childrenOut = this._renderValue(childrenValue, namespace, depth + 1);

        if (Array.isArray(childrenOut)) {
          out.push(...childrenOut);
        } else {
          out.push(childrenOut);
        }
      }

      out.push(footer);
      this.previousWasTextNode = false;
      return out;
    } else if (typeValue instanceof _index.SymbolValue && typeValue === (0, _utils.getReactSymbol)("react.fragment", this.realm)) {
      let childrenValue = (0, _utils.getProperty)(this.realm, propsValue, "children");

      let childrenOut = this._renderValue(childrenValue, namespace, depth + 1);

      let out = [];

      if (Array.isArray(childrenOut)) {
        out.push(...childrenOut);
      } else {
        out.push(childrenOut);
      }

      this.previousWasTextNode = false;
      return out;
    } else {
      (0, _invariant.default)(false, "TODO");
    }
  }

  _renderValue(value, namespace, depth) {
    if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
      return this._renderText(value);
    } else if (value instanceof _index.ObjectValue && (0, _utils.isReactElement)(value)) {
      return this._renderReactElement(value, namespace, depth);
    } else if (value instanceof _index.AbstractValue) {
      return this._renderAbstractValue(value, namespace, depth);
    } else if (value instanceof _index.ArrayValue) {
      return this._renderArrayValue(value, namespace, depth);
    } else if (value instanceof _index.BooleanValue || value instanceof _index.UndefinedValue || value instanceof _index.NullValue) {
      return "";
    }

    (0, _invariant.default)(false, "TODO");
  }

}

function renderToString(realm, reactElement, staticMarkup) {
  let reactStatistics = new _types.ReactStatistics();
  let alreadyEvaluated = new Map();
  let reconciler = new _reconcilation.Reconciler(realm, {
    firstRenderOnly: true,
    isRoot: true,
    modelString: undefined
  }, alreadyEvaluated, reactStatistics);
  let typeValue = (0, _utils.getProperty)(realm, reactElement, "type");
  let propsValue = (0, _utils.getProperty)(realm, reactElement, "props");
  let evaluatedRootNode = (0, _utils.createReactEvaluatedNode)("ROOT", (0, _utils.getComponentName)(realm, typeValue));
  (0, _invariant.default)(typeValue instanceof _index.ECMAScriptSourceFunctionValue);

  if (propsValue instanceof _index.AbstractValue && !(propsValue instanceof _index.AbstractObjectValue)) {
    propsValue = _singletons.To.ToObject(realm, propsValue);
  }

  (0, _invariant.default)(propsValue instanceof _index.ObjectValue || propsValue instanceof _index.AbstractObjectValue);
  let effects = reconciler.resolveReactComponentTree(typeValue, propsValue, null, evaluatedRootNode);
  (0, _invariant.default)(realm.generator); // create a single regex used for the escape functions
  // by hoisting it, it gets cached by the VM JITs

  realm.generator.emitStatement([], (0, _generator.createOperationDescriptor)("REACT_SSR_REGEX_CONSTANT"));
  (0, _invariant.default)(realm.generator);
  realm.generator.emitStatement([], (0, _generator.createOperationDescriptor)("REACT_SSR_PREV_TEXT_NODE"));
  (0, _invariant.default)(effects);
  realm.applyEffects(effects);
  (0, _invariant.default)(effects.result instanceof _completions.SimpleNormalCompletion);
  let serverRenderer = new ReactDOMServerRenderer(realm, staticMarkup);
  let renderValue = serverRenderer.render(effects.result.value);
  return renderValue;
}
//# sourceMappingURL=rendering.js.map

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMarkupForRoot = createMarkupForRoot;
exports.isCustomComponent = isCustomComponent;
exports.escapeHtml = escapeHtml;
exports.normalizeNode = normalizeNode;
exports.convertValueToNode = convertValueToNode;
exports.createHtmlEscapeHelper = createHtmlEscapeHelper;
exports.createArrayHelper = createArrayHelper;
exports.getNonChildrenInnerMarkup = getNonChildrenInnerMarkup;
exports.quoteAttributeValueForBrowser = quoteAttributeValueForBrowser;

var _parser = __webpack_require__(247);

var _index = __webpack_require__(10);

var _utils = __webpack_require__(291);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _domConfig = __webpack_require__(643);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// Warning: This code is experimental and might not fully work. There is no guarantee
// that is up-to-date with the curent react-dom/server logic and there may also be
// security holes in the string escaping because of this.
const matchHtmlRegExp = /["'&<>]/;

function createMarkupForRoot() {
  return _domConfig.ROOT_ATTRIBUTE_NAME + '=""';
}

function isCustomComponent(realm, tagName, propsValue) {
  if (tagName.indexOf("-") === -1) {
    let is = (0, _utils.getProperty)(realm, propsValue, "is");
    return is instanceof _index.StringValue;
  }

  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;

    default:
      return true;
  }
} // $FlowFixMe: we don't want to provides types here as we inject this function into source


function escapeHtml(string) {
  if (typeof string === "boolean" || typeof string === "number") {
    return "" + string;
  }

  let str = "" + string;
  let match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  let escape;
  let html = "";
  let index = 0;
  let lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;

      case 38:
        escape = "&amp;";
        break;

      case 39:
        escape = "&#x27;";
        break;

      case 60:
        escape = "&lt;";
        break;

      case 62:
        escape = "&gt;";
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}

function normalizeNode(realm, reactNode) {
  if (Array.isArray(reactNode)) {
    let newReactNode;

    for (let element of reactNode) {
      if (typeof element === "string") {
        if (newReactNode === undefined) {
          newReactNode = element;
        } else if (typeof newReactNode === "string") {
          newReactNode += element;
        } else {
          let lastNode = newReactNode[newReactNode.length - 1];

          if (typeof lastNode === "string") {
            newReactNode[newReactNode.length - 1] += element;
          } else {
            newReactNode.push(element);
          }
        }
      } else if (newReactNode === undefined) {
        newReactNode = [element];
      } else if (typeof newReactNode === "string") {
        newReactNode = [newReactNode, element];
      } else {
        newReactNode.push(element);
      }
    }

    (0, _invariant.default)(newReactNode !== undefined);
    return newReactNode;
  } else if (typeof reactNode === "string" || reactNode instanceof _index.AbstractValue) {
    return reactNode;
  }

  (0, _invariant.default)(false, "TODO");
}

function convertValueToNode(value) {
  if (value instanceof _index.AbstractValue) {
    return value;
  } else if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
    return value.value + "";
  }

  (0, _invariant.default)(false, "TODO");
}

function createHtmlEscapeHelper(realm) {
  let escapeHelperAst = (0, _parser.parseExpression)(escapeHtml.toString(), {
    plugins: ["flow"]
  });
  let helper = new _index.ECMAScriptSourceFunctionValue(realm);
  helper.initialize(escapeHelperAst.params, escapeHelperAst.body);
  return helper;
}

function createArrayHelper(realm) {
  let arrayHelper = `
    function arrayHelper(array) {
      let length = array.length;
      let i = 0;
      let str = "";
      let item;

      while (i < length) {
        item = array[i++];
        if (previousWasTextNode === true) {
          str += "<!-- -->" + item;
        } else {
          str += item;
        }
        previousWasTextNode = item[0] !== "<";
      }
      return str;
    }
  `;
  let escapeHelperAst = (0, _parser.parseExpression)(arrayHelper, {
    plugins: ["flow"]
  });
  let helper = new _index.ECMAScriptSourceFunctionValue(realm);
  helper.initialize(escapeHelperAst.params, escapeHelperAst.body);
  return helper;
}

function getNonChildrenInnerMarkup(realm, propsValue) {
  let innerHTML = (0, _utils.getProperty)(realm, propsValue, "dangerouslySetInnerHTML");

  if (innerHTML instanceof _index.ObjectValue) {
    let _html = (0, _utils.getProperty)(realm, innerHTML, "dangerouslySetInnerHTML");

    if (_html instanceof _index.StringValue) {
      return _html.value;
    }
  } else {
    let content = (0, _utils.getProperty)(realm, propsValue, "children");

    if (content instanceof _index.StringValue || content instanceof _index.NumberValue) {
      return escapeHtml(content.value);
    }
  }

  return null;
}

function quoteAttributeValueForBrowser(value) {
  return '"' + escapeHtml(value) + '"';
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPropertyInfo = getPropertyInfo;
exports.isAttributeNameSafe = isAttributeNameSafe;
exports.shouldRemoveAttribute = shouldRemoveAttribute;
exports.shouldIgnoreAttribute = shouldIgnoreAttribute;
exports.POSITIVE_NUMERIC = exports.NUMERIC = exports.OVERLOADED_BOOLEAN = exports.BOOLEAN = exports.BOOLEANISH_STRING = exports.STRING = exports.RESERVED = exports.VALID_ATTRIBUTE_NAME_REGEX = exports.ATTRIBUTE_NAME_CHAR = exports.ATTRIBUTE_NAME_START_CHAR = exports.ROOT_ATTRIBUTE_NAME = exports.isUnitlessNumber = exports.newlineEatingTags = exports.omittedCloseTags = exports.RESERVED_PROPS = exports.STYLE = void 0;

var _index = __webpack_require__(10);

var _invariant = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// Warning: This code is experimental and might not fully work. There is no guarantee
// that it is up-to-date with the current react-dom/server logic and there may also be
// security holes in the string escaping because of this.
const STYLE = "style";
exports.STYLE = STYLE;
const RESERVED_PROPS = new Set(["children", "dangerouslySetInnerHTML", "suppressContentEditableWarning", "suppressHydrationWarning"]);
exports.RESERVED_PROPS = RESERVED_PROPS;
const omittedCloseTags = new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
exports.omittedCloseTags = omittedCloseTags;
const newlineEatingTags = {
  listing: true,
  pre: true,
  textarea: true
};
exports.newlineEatingTags = newlineEatingTags;
const isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
exports.isUnitlessNumber = isUnitlessNumber;
const prefixes = ["Webkit", "ms", "Moz", "O"];
const ROOT_ATTRIBUTE_NAME = "data-reactroot";
/* eslint-disable max-len */

exports.ROOT_ATTRIBUTE_NAME = ROOT_ATTRIBUTE_NAME;
const ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
exports.ATTRIBUTE_NAME_START_CHAR = ATTRIBUTE_NAME_START_CHAR;
const ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
exports.ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_CHAR;
const VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
exports.VALID_ATTRIBUTE_NAME_REGEX = VALID_ATTRIBUTE_NAME_REGEX;

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});
const RESERVED = 0;
exports.RESERVED = RESERVED;
const STRING = 1;
exports.STRING = STRING;
const BOOLEANISH_STRING = 2;
exports.BOOLEANISH_STRING = BOOLEANISH_STRING;
const BOOLEAN = 3;
exports.BOOLEAN = BOOLEAN;
const OVERLOADED_BOOLEAN = 4;
exports.OVERLOADED_BOOLEAN = OVERLOADED_BOOLEAN;
const NUMERIC = 5;
exports.NUMERIC = NUMERIC;
const POSITIVE_NUMERIC = 6;
exports.POSITIVE_NUMERIC = POSITIVE_NUMERIC;
const properties = {};

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
}

[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(([name, attributeName]) => {
  properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null);
});
["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null);
});
["autoReverse", "externalResourcesRequired", "preserveAlpha"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null);
});
["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null);
});
["checked", "multiple", "muted", "selected"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name.toLowerCase(), null);
});
["capture", "download"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name.toLowerCase(), null);
});
["cols", "rows", "size", "span"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name.toLowerCase(), null);
});
["rowSpan", "start"].forEach(name => {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null);
});
const CAMELIZE = /[\-\:]([a-z])/g;

const capitalize = token => token[1].toUpperCase();

["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(attributeName => {
  const name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null);
});
["xlink:actuate", "xlink:arcrole", "xlink:href", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(attributeName => {
  const name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink");
});
["xml:base", "xml:lang", "xml:space"].forEach(attributeName => {
  const name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace");
});
properties.tabIndex = new PropertyInfoRecord("tabIndex", STRING, false, "tabindex", null);

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

const illegalAttributeNameCache = {};
const validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }

  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;
  return false;
}

function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  if (value instanceof _index.FunctionValue || value instanceof _index.SymbolValue) {
    return true;
  } else if (value instanceof _index.BooleanValue) {
    if (isCustomComponentTag) {
      return false;
    }

    if (propertyInfo !== null) {
      return !propertyInfo.acceptsBooleans;
    } else {
      const prefix = name.toLowerCase().slice(0, 5);
      return prefix !== "data-" && prefix !== "aria-";
    }
  } else if (value instanceof _index.AbstractValue) {
    (0, _invariant.default)(false, "TODO");
  }

  return false;
}

function shouldRemoveAttribute(realm, name, value, propertyInfo, isCustomComponentTag) {
  if (value === realm.intrinsics.null || value === realm.intrinsics.undefined) {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {
    switch (propertyInfo.type) {
      case BOOLEAN:
        if (value instanceof _index.BooleanValue) {
          return !value.value;
        }

        return (0, _invariant.default)(false, "TODO");

      case OVERLOADED_BOOLEAN:
        if (value instanceof _index.BooleanValue) {
          return value.value === false;
        }

        return (0, _invariant.default)(false, "TODO");

      case NUMERIC:
        if (value instanceof _index.NumberValue || value instanceof _index.StringValue) {
          return isNaN(value.value);
        }

        return (0, _invariant.default)(false, "TODO");

      case POSITIVE_NUMERIC:
        if (value instanceof _index.NumberValue || value instanceof _index.StringValue) {
          return isNaN(value.value) || value.value < 1;
        }

        return (0, _invariant.default)(false, "TODO");

      default:
        return false;
    }
  }

  return false;
}

function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
    return true;
  }

  return false;
}
//# sourceMappingURL=dom-config.js.map

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(645);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMockReactNative = createMockReactNative;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _parser = __webpack_require__(247);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
let reactNativeCode = `
  function createReactNative(React, reactNameRequireName) {
    var Platform = __abstract("object", 'require("' + reactNameRequireName + '").Platform');

    var NativeModules = __abstract({
      nativePerformanceNow: __abstract("function"),
      nativeTraceBeginAsyncSection: __abstract("function"),
      nativeTraceEndAsyncSection: __abstract("function"),
      UIManager: __abstract({
        customBubblingEventTypes: __abstract(),
        customDirectEventTypes: __abstract(),
        ViewManagerNames: __abstract(),
        __takeSnapshot: undefined,
        takeSnapshot: undefined,
        RCTVirtualText: null,
      }),
      DeviceInfo: __abstract({
        Dimensions: __abstract({
          window: undefined,
          screen: undefined,
          windowPhysicalPixels: __abstract({
            width: __abstract("number"),
            height: __abstract("number"),
            scale: __abstract("number"),
            fontScale: __abstract("number"),
          }),
          screenPhysicalPixels: __abstract({
            width: __abstract("number"),
            height: __abstract("number"),
            scale: __abstract("number"),
            fontScale: __abstract("number"),
          }),
        }),
      }),
      I18n: __abstract({
        localeCountryCode: __abstract(),
        localeIdentifier: __abstract(),
        fbLocaleIdentifier: __abstract(),
        AdsCountriesConfig: __abstract({}),
        exports: __abstract({}),
      }),
      I18nManager: __abstract({
        isRTL: __abstract("boolean"),
        isRTLForced: __abstract("boolean"),
        doLeftAndRightSwapInRTL: __abstract("boolean"),
        allowRTL: function(allowRTL) {
          return __residual("void", function(allowRTL, global) {
            global.nativeModuleProxy.I18nManager.allowRTL(allowRTL);
          }, allowRTL, global);
        },
        forceRTL: function(forceRTL) {
          return __residual("void", function(forceRTL, global) {
            global.nativeModuleProxy.I18nManager.forceRTL(forceRTL);
          }, forceRTL, global);
        },
        swapLeftAndRightInRTL: function(flipStyles) {
          return __residual("void", function(flipStyles, global) {
            global.nativeModuleProxy.I18nManager.swapLeftAndRightInRTL(flipStyles);
          }, flipStyles, global);
        },
        exports: __abstract({}),
      }),
      DeviceEventManager: __abstract({}),
      Timing: __abstract({
        createTimer: function(id, duration, time, recurring) {
          return __residual("object", function(id, duration, time, recurring, global, Object) {
            global.nativeModuleProxy.Timing.createTimer(id, duration, time, recurring);
            return Object.create(null);
          }, id, duration, time, recurring, global, Object);
        }
      }),
      ExceptionsManager: __abstract({
        reportFatalException: function(message, stack, id) {
          console.log("nativeModuleProxy.ExceptionsManager.reportFatalException");
          console.log(message);
          for (var i = 0; i < stack.length; i++) {
            var s = stack[i];
            console.log("  at " + s.methodName + " (" + s.file + ":" + s.lineNumber + ":" + s.column + ")");
          }
        }
      }),
      PlatformConstants: __abstract({
        isTesting: false,
        reactNativeVersion: __abstract({
          major: 0,
          minor: 0,
          patch: 0,
          prerelease: null,
        }),
        Version: __abstract("number"),
        forceTouchAvailable: undefined,
        uiMode: __abstract(),
      }),
      RelayAPIConfig: __abstract({
        graphBatchURI: __abstract(),
      }),
      SourceCode: __abstract({
        scriptURL: __abstract("string"),
      }),
    }, 'require("' + reactNameRequireName + '").NativeModules');

    const {UIManager} = NativeModules;

    const ReactNativeViewAttributes = {};
    const viewConfigCallbacks = new Map();

    const TextAncestor = React.createContext(false);

    const ReactNativeStyleAttributes = {};

    const dummySize = {width: undefined, height: undefined};

    const sizesDiffer = function(one, two) {
      one = one || dummySize;
      two = two || dummySize;
      return one !== two && (one.width !== two.width || one.height !== two.height);
    };

    ReactNativeStyleAttributes.transform = {process: processTransform};
    ReactNativeStyleAttributes.shadowOffset = {diff: sizesDiffer};

    const colorAttributes = {process: processColor};
    ReactNativeStyleAttributes.backgroundColor = colorAttributes;
    ReactNativeStyleAttributes.borderBottomColor = colorAttributes;
    ReactNativeStyleAttributes.borderColor = colorAttributes;
    ReactNativeStyleAttributes.borderLeftColor = colorAttributes;
    ReactNativeStyleAttributes.borderRightColor = colorAttributes;
    ReactNativeStyleAttributes.borderTopColor = colorAttributes;
    ReactNativeStyleAttributes.borderStartColor = colorAttributes;
    ReactNativeStyleAttributes.borderEndColor = colorAttributes;
    ReactNativeStyleAttributes.color = colorAttributes;
    ReactNativeStyleAttributes.shadowColor = colorAttributes;
    ReactNativeStyleAttributes.textDecorationColor = colorAttributes;
    ReactNativeStyleAttributes.tintColor = colorAttributes;
    ReactNativeStyleAttributes.textShadowColor = colorAttributes;
    ReactNativeStyleAttributes.overlayColor = colorAttributes;

    ReactNativeViewAttributes.UIView = {
      pointerEvents: true,
      accessible: true,
      accessibilityActions: true,
      accessibilityLabel: true,
      accessibilityComponentType: true,
      accessibilityLiveRegion: true,
      accessibilityRole: true,
      accessibilityStates: true,
      accessibilityTraits: true,
      importantForAccessibility: true,
      nativeID: true,
      testID: true,
      renderToHardwareTextureAndroid: true,
      shouldRasterizeIOS: true,
      onLayout: true,
      onAccessibilityAction: true,
      onAccessibilityTap: true,
      onMagicTap: true,
      collapsable: true,
      needsOffscreenAlphaCompositing: true,
      style: ReactNativeStyleAttributes,
    };

    ReactNativeViewAttributes.RCTView = Object.assign({},
      ReactNativeViewAttributes.UIView,
      { removeClippedSubviews: true }
    );

    var viewConfig = {
      validAttributes: Object.assign({}, ReactNativeViewAttributes.UIView, {
        isHighlighted: true,
        numberOfLines: true,
        ellipsizeMode: true,
        allowFontScaling: true,
        disabled: true,
        selectable: true,
        selectionColor: true,
        adjustsFontSizeToFit: true,
        minimumFontScale: true,
        textBreakStrategy: true
      }),
      uiViewClassName: 'RCTText'
    };

    var MatrixMath = {
      createIdentityMatrix: function() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      },

      createCopy: function(m) {
        return [
          m[0],
          m[1],
          m[2],
          m[3],
          m[4],
          m[5],
          m[6],
          m[7],
          m[8],
          m[9],
          m[10],
          m[11],
          m[12],
          m[13],
          m[14],
          m[15],
        ];
      },

      createOrthographic: function(left, right, bottom, top, near, far) {
        const a = 2 / (right - left);
        const b = 2 / (top - bottom);
        const c = -2 / (far - near);

        const tx = -(right + left) / (right - left);
        const ty = -(top + bottom) / (top - bottom);
        const tz = -(far + near) / (far - near);

        return [a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, tx, ty, tz, 1];
      },

      createFrustum: function(left, right, bottom, top, near, far) {
        const r_width = 1 / (right - left);
        const r_height = 1 / (top - bottom);
        const r_depth = 1 / (near - far);
        const x = 2 * (near * r_width);
        const y = 2 * (near * r_height);
        const A = (right + left) * r_width;
        const B = (top + bottom) * r_height;
        const C = (far + near) * r_depth;
        const D = 2 * (far * near * r_depth);
        return [x, 0, 0, 0, 0, y, 0, 0, A, B, C, -1, 0, 0, D, 0];
      },

      /**
       * This create a perspective projection towards negative z
       * Clipping the z range of [-near, -far]
       *
       * @param fovInRadians - field of view in randians
       */
      createPerspective: function(fovInRadians, aspect, near, far) {
        const h = 1 / Math.tan(fovInRadians / 2);
        const r_depth = 1 / (near - far);
        const C = (far + near) * r_depth;
        const D = 2 * (far * near * r_depth);
        return [h / aspect, 0, 0, 0, 0, h, 0, 0, 0, 0, C, -1, 0, 0, D, 0];
      },

      createTranslate2d: function(x, y) {
        const mat = MatrixMath.createIdentityMatrix();
        MatrixMath.reuseTranslate2dCommand(mat, x, y);
        return mat;
      },

      reuseTranslate2dCommand: function(matrixCommand, x, y) {
        matrixCommand[12] = x;
        matrixCommand[13] = y;
      },

      reuseTranslate3dCommand: function(matrixCommand, x, y, z) {
        matrixCommand[12] = x;
        matrixCommand[13] = y;
        matrixCommand[14] = z;
      },

      createScale: function(factor) {
        const mat = MatrixMath.createIdentityMatrix();
        MatrixMath.reuseScaleCommand(mat, factor);
        return mat;
      },

      reuseScaleCommand: function(matrixCommand, factor) {
        matrixCommand[0] = factor;
        matrixCommand[5] = factor;
      },

      reuseScale3dCommand: function(matrixCommand, x, y, z) {
        matrixCommand[0] = x;
        matrixCommand[5] = y;
        matrixCommand[10] = z;
      },

      reusePerspectiveCommand: function(matrixCommand, p) {
        matrixCommand[11] = -1 / p;
      },

      reuseScaleXCommand(matrixCommand, factor) {
        matrixCommand[0] = factor;
      },

      reuseScaleYCommand(matrixCommand, factor) {
        matrixCommand[5] = factor;
      },

      reuseScaleZCommand(matrixCommand, factor) {
        matrixCommand[10] = factor;
      },

      reuseRotateXCommand: function(matrixCommand, radians) {
        matrixCommand[5] = Math.cos(radians);
        matrixCommand[6] = Math.sin(radians);
        matrixCommand[9] = -Math.sin(radians);
        matrixCommand[10] = Math.cos(radians);
      },

      reuseRotateYCommand: function(matrixCommand, amount) {
        matrixCommand[0] = Math.cos(amount);
        matrixCommand[2] = -Math.sin(amount);
        matrixCommand[8] = Math.sin(amount);
        matrixCommand[10] = Math.cos(amount);
      },

      // http://www.w3.org/TR/css3-transforms/#recomposing-to-a-2d-matrix
      reuseRotateZCommand: function(matrixCommand, radians) {
        matrixCommand[0] = Math.cos(radians);
        matrixCommand[1] = Math.sin(radians);
        matrixCommand[4] = -Math.sin(radians);
        matrixCommand[5] = Math.cos(radians);
      },

      createRotateZ: function(radians) {
        const mat = MatrixMath.createIdentityMatrix();
        MatrixMath.reuseRotateZCommand(mat, radians);
        return mat;
      },

      reuseSkewXCommand: function(matrixCommand, radians) {
        matrixCommand[4] = Math.tan(radians);
      },

      reuseSkewYCommand: function(matrixCommand, radians) {
        matrixCommand[1] = Math.tan(radians);
      },

      multiplyInto: function(out, a, b) {
        const a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15];

        let b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      },

      determinant(matrix) {
        const [
          m00,
          m01,
          m02,
          m03,
          m10,
          m11,
          m12,
          m13,
          m20,
          m21,
          m22,
          m23,
          m30,
          m31,
          m32,
          m33,
        ] = matrix;
        return (
          m03 * m12 * m21 * m30 -
          m02 * m13 * m21 * m30 -
          m03 * m11 * m22 * m30 +
          m01 * m13 * m22 * m30 +
          m02 * m11 * m23 * m30 -
          m01 * m12 * m23 * m30 -
          m03 * m12 * m20 * m31 +
          m02 * m13 * m20 * m31 +
          m03 * m10 * m22 * m31 -
          m00 * m13 * m22 * m31 -
          m02 * m10 * m23 * m31 +
          m00 * m12 * m23 * m31 +
          m03 * m11 * m20 * m32 -
          m01 * m13 * m20 * m32 -
          m03 * m10 * m21 * m32 +
          m00 * m13 * m21 * m32 +
          m01 * m10 * m23 * m32 -
          m00 * m11 * m23 * m32 -
          m02 * m11 * m20 * m33 +
          m01 * m12 * m20 * m33 +
          m02 * m10 * m21 * m33 -
          m00 * m12 * m21 * m33 -
          m01 * m10 * m22 * m33 +
          m00 * m11 * m22 * m33
        );
      },

      /**
       * Inverse of a matrix. Multiplying by the inverse is used in matrix math
       * instead of division.
       *
       * Formula from:
       * http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
       */
      inverse(matrix: Array<number>): Array<number> {
        const det = MatrixMath.determinant(matrix);
        if (!det) {
          return matrix;
        }
        const [
          m00,
          m01,
          m02,
          m03,
          m10,
          m11,
          m12,
          m13,
          m20,
          m21,
          m22,
          m23,
          m30,
          m31,
          m32,
          m33,
        ] = matrix;
        return [
          (m12 * m23 * m31 -
            m13 * m22 * m31 +
            m13 * m21 * m32 -
            m11 * m23 * m32 -
            m12 * m21 * m33 +
            m11 * m22 * m33) /
            det,
          (m03 * m22 * m31 -
            m02 * m23 * m31 -
            m03 * m21 * m32 +
            m01 * m23 * m32 +
            m02 * m21 * m33 -
            m01 * m22 * m33) /
            det,
          (m02 * m13 * m31 -
            m03 * m12 * m31 +
            m03 * m11 * m32 -
            m01 * m13 * m32 -
            m02 * m11 * m33 +
            m01 * m12 * m33) /
            det,
          (m03 * m12 * m21 -
            m02 * m13 * m21 -
            m03 * m11 * m22 +
            m01 * m13 * m22 +
            m02 * m11 * m23 -
            m01 * m12 * m23) /
            det,
          (m13 * m22 * m30 -
            m12 * m23 * m30 -
            m13 * m20 * m32 +
            m10 * m23 * m32 +
            m12 * m20 * m33 -
            m10 * m22 * m33) /
            det,
          (m02 * m23 * m30 -
            m03 * m22 * m30 +
            m03 * m20 * m32 -
            m00 * m23 * m32 -
            m02 * m20 * m33 +
            m00 * m22 * m33) /
            det,
          (m03 * m12 * m30 -
            m02 * m13 * m30 -
            m03 * m10 * m32 +
            m00 * m13 * m32 +
            m02 * m10 * m33 -
            m00 * m12 * m33) /
            det,
          (m02 * m13 * m20 -
            m03 * m12 * m20 +
            m03 * m10 * m22 -
            m00 * m13 * m22 -
            m02 * m10 * m23 +
            m00 * m12 * m23) /
            det,
          (m11 * m23 * m30 -
            m13 * m21 * m30 +
            m13 * m20 * m31 -
            m10 * m23 * m31 -
            m11 * m20 * m33 +
            m10 * m21 * m33) /
            det,
          (m03 * m21 * m30 -
            m01 * m23 * m30 -
            m03 * m20 * m31 +
            m00 * m23 * m31 +
            m01 * m20 * m33 -
            m00 * m21 * m33) /
            det,
          (m01 * m13 * m30 -
            m03 * m11 * m30 +
            m03 * m10 * m31 -
            m00 * m13 * m31 -
            m01 * m10 * m33 +
            m00 * m11 * m33) /
            det,
          (m03 * m11 * m20 -
            m01 * m13 * m20 -
            m03 * m10 * m21 +
            m00 * m13 * m21 +
            m01 * m10 * m23 -
            m00 * m11 * m23) /
            det,
          (m12 * m21 * m30 -
            m11 * m22 * m30 -
            m12 * m20 * m31 +
            m10 * m22 * m31 +
            m11 * m20 * m32 -
            m10 * m21 * m32) /
            det,
          (m01 * m22 * m30 -
            m02 * m21 * m30 +
            m02 * m20 * m31 -
            m00 * m22 * m31 -
            m01 * m20 * m32 +
            m00 * m21 * m32) /
            det,
          (m02 * m11 * m30 -
            m01 * m12 * m30 -
            m02 * m10 * m31 +
            m00 * m12 * m31 +
            m01 * m10 * m32 -
            m00 * m11 * m32) /
            det,
          (m01 * m12 * m20 -
            m02 * m11 * m20 +
            m02 * m10 * m21 -
            m00 * m12 * m21 -
            m01 * m10 * m22 +
            m00 * m11 * m22) /
            det,
        ];
      },

      /**
       * Turns columns into rows and rows into columns.
       */
      transpose(m: Array<number>): Array<number> {
        return [
          m[0],
          m[4],
          m[8],
          m[12],
          m[1],
          m[5],
          m[9],
          m[13],
          m[2],
          m[6],
          m[10],
          m[14],
          m[3],
          m[7],
          m[11],
          m[15],
        ];
      },

      /**
       * Based on: http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c
       */
      multiplyVectorByMatrix(v: Array<number>, m: Array<number>): Array<number> {
        const [vx, vy, vz, vw] = v;
        return [
          vx * m[0] + vy * m[4] + vz * m[8] + vw * m[12],
          vx * m[1] + vy * m[5] + vz * m[9] + vw * m[13],
          vx * m[2] + vy * m[6] + vz * m[10] + vw * m[14],
          vx * m[3] + vy * m[7] + vz * m[11] + vw * m[15],
        ];
      },

      /**
       * From: https://code.google.com/p/webgl-mjs/source/browse/mjs.js
       */
      v3Length(a: Array<number>): number {
        return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      },

      /**
       * Based on: https://code.google.com/p/webgl-mjs/source/browse/mjs.js
       */
      v3Normalize(vector: Array<number>, v3Length: number): Array<number> {
        const im = 1 / (v3Length || MatrixMath.v3Length(vector));
        return [vector[0] * im, vector[1] * im, vector[2] * im];
      },

      /**
       * The dot product of a and b, two 3-element vectors.
       * From: https://code.google.com/p/webgl-mjs/source/browse/mjs.js
       */
      v3Dot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      },

      /**
       * From:
       * http://www.opensource.apple.com/source/WebCore/WebCore-514/platform/graphics/transforms/TransformationMatrix.cpp
       */
      v3Combine(
        a: Array<number>,
        b: Array<number>,
        aScale: number,
        bScale: number,
      ): Array<number> {
        return [
          aScale * a[0] + bScale * b[0],
          aScale * a[1] + bScale * b[1],
          aScale * a[2] + bScale * b[2],
        ];
      },

      /**
       * From:
       * http://www.opensource.apple.com/source/WebCore/WebCore-514/platform/graphics/transforms/TransformationMatrix.cpp
       */
      v3Cross(a: Array<number>, b: Array<number>): Array<number> {
        return [
          a[1] * b[2] - a[2] * b[1],
          a[2] * b[0] - a[0] * b[2],
          a[0] * b[1] - a[1] * b[0],
        ];
      },

      /**
       * Based on:
       * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/
       * and:
       * http://quat.zachbennett.com/
       *
       * Note that this rounds degrees to the thousandth of a degree, due to
       * floating point errors in the creation of the quaternion.
       *
       * Also note that this expects the qw value to be last, not first.
       *
       * Also, when researching this, remember that:
       * yaw   === heading            === z-axis
       * pitch === elevation/attitude === y-axis
       * roll  === bank               === x-axis
       */
      quaternionToDegreesXYZ(q: Array<number>, matrix, row): Array<number> {
        const [qx, qy, qz, qw] = q;
        const qw2 = qw * qw;
        const qx2 = qx * qx;
        const qy2 = qy * qy;
        const qz2 = qz * qz;
        const test = qx * qy + qz * qw;
        const unit = qw2 + qx2 + qy2 + qz2;
        const conv = 180 / Math.PI;

        if (test > 0.49999 * unit) {
          return [0, 2 * Math.atan2(qx, qw) * conv, 90];
        }
        if (test < -0.49999 * unit) {
          return [0, -2 * Math.atan2(qx, qw) * conv, -90];
        }

        return [
          MatrixMath.roundTo3Places(
            Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx2 - 2 * qz2) * conv,
          ),
          MatrixMath.roundTo3Places(
            Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy2 - 2 * qz2) * conv,
          ),
          MatrixMath.roundTo3Places(Math.asin(2 * qx * qy + 2 * qz * qw) * conv),
        ];
      },

      /**
       * Based on:
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
       */
      roundTo3Places(n: number): number {
        const arr = n.toString().split('e');
        return Math.round(arr[0] + 'e' + (arr[1] ? +arr[1] - 3 : 3)) * 0.001;
      },

      /**
       * Decompose a matrix into separate transform values, for use on platforms
       * where applying a precomposed matrix is not possible, and transforms are
       * applied in an inflexible ordering (e.g. Android).
       *
       * Implementation based on
       * http://www.w3.org/TR/css3-transforms/#decomposing-a-2d-matrix
       * http://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix
       * which was based on
       * http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c
       */
      decomposeMatrix(transformMatrix: Array<number>): ?Object {

        // output values
        var perspective = [];
        const quaternion = [];
        const scale = [];
        const skew = [];
        const translation = [];

        // create normalized, 2d array matrix
        // and normalized 1d array perspectiveMatrix with redefined 4th column
        if (!transformMatrix[15]) {
          return;
        }
        const matrix = [];
        const perspectiveMatrix = [];
        for (var i = 0; i < 4; i++) {
          matrix.push([]);
          for (let j = 0; j < 4; j++) {
            const value = transformMatrix[i * 4 + j] / transformMatrix[15];
            matrix[i].push(value);
            perspectiveMatrix.push(j === 3 ? 0 : value);
          }
        }
        perspectiveMatrix[15] = 1;

        // test for singularity of upper 3x3 part of the perspective matrix
        if (!MatrixMath.determinant(perspectiveMatrix)) {
          return;
        }

        // isolate perspective
        if (matrix[0][3] !== 0 || matrix[1][3] !== 0 || matrix[2][3] !== 0) {
          // rightHandSide is the right hand side of the equation.
          // rightHandSide is a vector, or point in 3d space relative to the origin.
          const rightHandSide = [
            matrix[0][3],
            matrix[1][3],
            matrix[2][3],
            matrix[3][3],
          ];

          // Solve the equation by inverting perspectiveMatrix and multiplying
          // rightHandSide by the inverse.
          const inversePerspectiveMatrix = MatrixMath.inverse(perspectiveMatrix);
          const transposedInversePerspectiveMatrix = MatrixMath.transpose(
            inversePerspectiveMatrix,
          );
          var perspective = MatrixMath.multiplyVectorByMatrix(
            rightHandSide,
            transposedInversePerspectiveMatrix,
          );
        } else {
          // no perspective
          perspective[0] = perspective[1] = perspective[2] = 0;
          perspective[3] = 1;
        }

        // translation is simple
        for (var i = 0; i < 3; i++) {
          translation[i] = matrix[3][i];
        }

        // Now get scale and shear.
        // 'row' is a 3 element array of 3 component vectors
        const row = [];
        for (i = 0; i < 3; i++) {
          row[i] = [matrix[i][0], matrix[i][1], matrix[i][2]];
        }

        // Compute X scale factor and normalize first row.
        scale[0] = MatrixMath.v3Length(row[0]);
        row[0] = MatrixMath.v3Normalize(row[0], scale[0]);

        // Compute XY shear factor and make 2nd row orthogonal to 1st.
        skew[0] = MatrixMath.v3Dot(row[0], row[1]);
        row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);

        // Compute XY shear factor and make 2nd row orthogonal to 1st.
        skew[0] = MatrixMath.v3Dot(row[0], row[1]);
        row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);

        // Now, compute Y scale and normalize 2nd row.
        scale[1] = MatrixMath.v3Length(row[1]);
        row[1] = MatrixMath.v3Normalize(row[1], scale[1]);
        skew[0] /= scale[1];

        // Compute XZ and YZ shears, orthogonalize 3rd row
        skew[1] = MatrixMath.v3Dot(row[0], row[2]);
        row[2] = MatrixMath.v3Combine(row[2], row[0], 1.0, -skew[1]);
        skew[2] = MatrixMath.v3Dot(row[1], row[2]);
        row[2] = MatrixMath.v3Combine(row[2], row[1], 1.0, -skew[2]);

        // Next, get Z scale and normalize 3rd row.
        scale[2] = MatrixMath.v3Length(row[2]);
        row[2] = MatrixMath.v3Normalize(row[2], scale[2]);
        skew[1] /= scale[2];
        skew[2] /= scale[2];

        // At this point, the matrix (in rows) is orthonormal.
        // Check for a coordinate system flip.  If the determinant
        // is -1, then negate the matrix and the scaling factors.
        const pdum3 = MatrixMath.v3Cross(row[1], row[2]);
        if (MatrixMath.v3Dot(row[0], pdum3) < 0) {
          for (i = 0; i < 3; i++) {
            scale[i] *= -1;
            row[i][0] *= -1;
            row[i][1] *= -1;
            row[i][2] *= -1;
          }
        }

        // Now, get the rotations out
        quaternion[0] =
          0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
        quaternion[1] =
          0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
        quaternion[2] =
          0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
        quaternion[3] =
          0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));

        if (row[2][1] > row[1][2]) {
          quaternion[0] = -quaternion[0];
        }
        if (row[0][2] > row[2][0]) {
          quaternion[1] = -quaternion[1];
        }
        if (row[1][0] > row[0][1]) {
          quaternion[2] = -quaternion[2];
        }

        // correct for occasional, weird Euler synonyms for 2d rotation
        let rotationDegrees;
        if (
          quaternion[0] < 0.001 &&
          quaternion[0] >= 0 &&
          quaternion[1] < 0.001 &&
          quaternion[1] >= 0
        ) {
          // this is a 2d rotation on the z-axis
          rotationDegrees = [
            0,
            0,
            MatrixMath.roundTo3Places(
              Math.atan2(row[0][1], row[0][0]) * 180 / Math.PI,
            ),
          ];
        } else {
          rotationDegrees = MatrixMath.quaternionToDegreesXYZ(
            quaternion,
            matrix,
            row,
          );
        }

        // expose both base data and convenience names
        return {
          rotationDegrees,
          perspective,
          quaternion,
          scale,
          skew,
          translation,

          rotate: rotationDegrees[2],
          rotateX: rotationDegrees[0],
          rotateY: rotationDegrees[1],
          scaleX: scale[0],
          scaleY: scale[1],
          translateX: translation[0],
          translateY: translation[1],
        };
      },
    };

    function _multiplyTransform(result, matrixMathFunction, args): void {
      const matrixToApply = MatrixMath.createIdentityMatrix();
      const argsWithIdentity = [matrixToApply].concat(args);
      matrixMathFunction.apply(this, argsWithIdentity);
      MatrixMath.multiplyInto(result, result, matrixToApply);
    }

    function _convertToRadians(value: string): number {
      const floatValue = parseFloat(value);
      return value.indexOf('rad') > -1 ? floatValue : floatValue * Math.PI / 180;
    }

    function processTransform(transform) {
      // Android & iOS implementations of transform property accept the list of
      // transform properties as opposed to a transform Matrix. This is necessary
      // to control transform property updates completely on the native thread.
      if (Platform.OS === 'android' || Platform.OS === 'ios') {
        return transform;
      }

      const result = MatrixMath.createIdentityMatrix();

      transform.forEach(transformation => {
        const key = Object.keys(transformation)[0];
        const value = transformation[key];

        switch (key) {
          case 'matrix':
            MatrixMath.multiplyInto(result, result, value);
            break;
          case 'perspective':
            _multiplyTransform(result, MatrixMath.reusePerspectiveCommand, [value]);
            break;
          case 'rotateX':
            _multiplyTransform(result, MatrixMath.reuseRotateXCommand, [
              _convertToRadians(value),
            ]);
            break;
          case 'rotateY':
            _multiplyTransform(result, MatrixMath.reuseRotateYCommand, [
              _convertToRadians(value),
            ]);
            break;
          case 'rotate':
          case 'rotateZ':
            _multiplyTransform(result, MatrixMath.reuseRotateZCommand, [
              _convertToRadians(value),
            ]);
            break;
          case 'scale':
            _multiplyTransform(result, MatrixMath.reuseScaleCommand, [value]);
            break;
          case 'scaleX':
            _multiplyTransform(result, MatrixMath.reuseScaleXCommand, [value]);
            break;
          case 'scaleY':
            _multiplyTransform(result, MatrixMath.reuseScaleYCommand, [value]);
            break;
          case 'translate':
            _multiplyTransform(result, MatrixMath.reuseTranslate3dCommand, [
              value[0],
              value[1],
              value[2] || 0,
            ]);
            break;
          case 'translateX':
            _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [
              value,
              0,
            ]);
            break;
          case 'translateY':
            _multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [
              0,
              value,
            ]);
            break;
          case 'skewX':
            _multiplyTransform(result, MatrixMath.reuseSkewXCommand, [
              _convertToRadians(value),
            ]);
            break;
          case 'skewY':
            _multiplyTransform(result, MatrixMath.reuseSkewYCommand, [
              _convertToRadians(value),
            ]);
            break;
          default:
            throw new Error('Invalid transform name: ' + key);
        }
      });

      return result;
    }

    function register(name, callback) {
      viewConfigCallbacks.set(name, callback);
      return name;
    };

    const createReactNativeComponentClass = function(name, callback) {
      return register(name, callback);
    };

    const RCTText = createReactNativeComponentClass(
      viewConfig.uiViewClassName,
      function () { return viewConfig }
    );

    const RCTVirtualText = UIManager.RCTVirtualText == null
      ? RCTText
      : createReactNativeComponentClass('RCTVirtualText', () => ({
            validAttributes: Object.assign({},
              ReactNativeViewAttributes.UIView,
              { isHighlighted: true }
            ),
            uiViewClassName: 'RCTVirtualText',
          }));

    function normalizeColor(color) {
      const matchers = getMatchers();
      let match;

      if (typeof color === 'number') {
        if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
          return color;
        }
        return null;
      }

      // Ordered based on occurrences on Facebook codebase
      if ((match = matchers.hex6.exec(color))) {
        return parseInt(match[1] + 'ff', 16) >>> 0;
      }

      if (names.hasOwnProperty(color)) {
        return names[color];
      }

      if ((match = matchers.rgb.exec(color))) {
        return (
          // b
          ((parse255(match[1]) << 24) | // r
          (parse255(match[2]) << 16) | // g
            (parse255(match[3]) << 8) |
            0x000000ff) >>> // a
          0
        );
      }

      if ((match = matchers.rgba.exec(color))) {
        return (
          // b
          ((parse255(match[1]) << 24) | // r
          (parse255(match[2]) << 16) | // g
            (parse255(match[3]) << 8) |
            parse1(match[4])) >>> // a
          0
        );
      }

      if ((match = matchers.hex3.exec(color))) {
        return (
          parseInt(
            match[1] +
            match[1] + // r
            match[2] +
            match[2] + // g
            match[3] +
            match[3] + // b
              'ff', // a
            16,
          ) >>> 0
        );
      }

      // https://drafts.csswg.org/css-color-4/#hex-notation
      if ((match = matchers.hex8.exec(color))) {
        return parseInt(match[1], 16) >>> 0;
      }

      if ((match = matchers.hex4.exec(color))) {
        return (
          parseInt(
            match[1] +
            match[1] + // r
            match[2] +
            match[2] + // g
            match[3] +
            match[3] + // b
              match[4] +
              match[4], // a
            16,
          ) >>> 0
        );
      }

      if ((match = matchers.hsl.exec(color))) {
        return (
          (hslToRgb(
            parse360(match[1]), // h
            parsePercentage(match[2]), // s
            parsePercentage(match[3]), // l
          ) |
            0x000000ff) >>> // a
          0
        );
      }

      if ((match = matchers.hsla.exec(color))) {
        return (
          (hslToRgb(
            parse360(match[1]), // h
            parsePercentage(match[2]), // s
            parsePercentage(match[3]), // l
          ) |
            parse1(match[4])) >>> // a
          0
        );
      }

      return null;
    }

    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }

    function hslToRgb(h, s, l) {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      const r = hue2rgb(p, q, h + 1 / 3);
      const g = hue2rgb(p, q, h);
      const b = hue2rgb(p, q, h - 1 / 3);

      return (
        (Math.round(r * 255) << 24) |
        (Math.round(g * 255) << 16) |
        (Math.round(b * 255) << 8)
      );
    }

    // var INTEGER = '[-+]?\\d+';
    const NUMBER = '[-+]?\\d*\\.?\\d+';
    const PERCENTAGE = NUMBER + '%';

    function call(...args) {
      return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
    }

    function getMatchers() {
      var cachedMatchers = {
          rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
          rgba: new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER)),
          hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
          hsla: new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)),
          hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#([0-9a-fA-F]{6})$/,
          hex8: /^#([0-9a-fA-F]{8})$/,
        };
      return cachedMatchers;
    }

    function parse255(str) {
      const int = parseInt(str, 10);
      if (int < 0) {
        return 0;
      }
      if (int > 255) {
        return 255;
      }
      return int;
    }

    function parse360(str) {
      const int = parseFloat(str);
      return (((int % 360) + 360) % 360) / 360;
    }

    function parse1(str) {
      const num = parseFloat(str);
      if (num < 0) {
        return 0;
      }
      if (num > 1) {
        return 255;
      }
      return Math.round(num * 255);
    }

    function parsePercentage(str) {
      // parseFloat conveniently ignores the final %
      const int = parseFloat(str);
      if (int < 0) {
        return 0;
      }
      if (int > 100) {
        return 1;
      }
      return int / 100;
    }

    const names = {
      transparent: 0x00000000,

      // http://www.w3.org/TR/css3-color/#svg-color
      aliceblue: 0xf0f8ffff,
      antiquewhite: 0xfaebd7ff,
      aqua: 0x00ffffff,
      aquamarine: 0x7fffd4ff,
      azure: 0xf0ffffff,
      beige: 0xf5f5dcff,
      bisque: 0xffe4c4ff,
      black: 0x000000ff,
      blanchedalmond: 0xffebcdff,
      blue: 0x0000ffff,
      blueviolet: 0x8a2be2ff,
      brown: 0xa52a2aff,
      burlywood: 0xdeb887ff,
      burntsienna: 0xea7e5dff,
      cadetblue: 0x5f9ea0ff,
      chartreuse: 0x7fff00ff,
      chocolate: 0xd2691eff,
      coral: 0xff7f50ff,
      cornflowerblue: 0x6495edff,
      cornsilk: 0xfff8dcff,
      crimson: 0xdc143cff,
      cyan: 0x00ffffff,
      darkblue: 0x00008bff,
      darkcyan: 0x008b8bff,
      darkgoldenrod: 0xb8860bff,
      darkgray: 0xa9a9a9ff,
      darkgreen: 0x006400ff,
      darkgrey: 0xa9a9a9ff,
      darkkhaki: 0xbdb76bff,
      darkmagenta: 0x8b008bff,
      darkolivegreen: 0x556b2fff,
      darkorange: 0xff8c00ff,
      darkorchid: 0x9932ccff,
      darkred: 0x8b0000ff,
      darksalmon: 0xe9967aff,
      darkseagreen: 0x8fbc8fff,
      darkslateblue: 0x483d8bff,
      darkslategray: 0x2f4f4fff,
      darkslategrey: 0x2f4f4fff,
      darkturquoise: 0x00ced1ff,
      darkviolet: 0x9400d3ff,
      deeppink: 0xff1493ff,
      deepskyblue: 0x00bfffff,
      dimgray: 0x696969ff,
      dimgrey: 0x696969ff,
      dodgerblue: 0x1e90ffff,
      firebrick: 0xb22222ff,
      floralwhite: 0xfffaf0ff,
      forestgreen: 0x228b22ff,
      fuchsia: 0xff00ffff,
      gainsboro: 0xdcdcdcff,
      ghostwhite: 0xf8f8ffff,
      gold: 0xffd700ff,
      goldenrod: 0xdaa520ff,
      gray: 0x808080ff,
      green: 0x008000ff,
      greenyellow: 0xadff2fff,
      grey: 0x808080ff,
      honeydew: 0xf0fff0ff,
      hotpink: 0xff69b4ff,
      indianred: 0xcd5c5cff,
      indigo: 0x4b0082ff,
      ivory: 0xfffff0ff,
      khaki: 0xf0e68cff,
      lavender: 0xe6e6faff,
      lavenderblush: 0xfff0f5ff,
      lawngreen: 0x7cfc00ff,
      lemonchiffon: 0xfffacdff,
      lightblue: 0xadd8e6ff,
      lightcoral: 0xf08080ff,
      lightcyan: 0xe0ffffff,
      lightgoldenrodyellow: 0xfafad2ff,
      lightgray: 0xd3d3d3ff,
      lightgreen: 0x90ee90ff,
      lightgrey: 0xd3d3d3ff,
      lightpink: 0xffb6c1ff,
      lightsalmon: 0xffa07aff,
      lightseagreen: 0x20b2aaff,
      lightskyblue: 0x87cefaff,
      lightslategray: 0x778899ff,
      lightslategrey: 0x778899ff,
      lightsteelblue: 0xb0c4deff,
      lightyellow: 0xffffe0ff,
      lime: 0x00ff00ff,
      limegreen: 0x32cd32ff,
      linen: 0xfaf0e6ff,
      magenta: 0xff00ffff,
      maroon: 0x800000ff,
      mediumaquamarine: 0x66cdaaff,
      mediumblue: 0x0000cdff,
      mediumorchid: 0xba55d3ff,
      mediumpurple: 0x9370dbff,
      mediumseagreen: 0x3cb371ff,
      mediumslateblue: 0x7b68eeff,
      mediumspringgreen: 0x00fa9aff,
      mediumturquoise: 0x48d1ccff,
      mediumvioletred: 0xc71585ff,
      midnightblue: 0x191970ff,
      mintcream: 0xf5fffaff,
      mistyrose: 0xffe4e1ff,
      moccasin: 0xffe4b5ff,
      navajowhite: 0xffdeadff,
      navy: 0x000080ff,
      oldlace: 0xfdf5e6ff,
      olive: 0x808000ff,
      olivedrab: 0x6b8e23ff,
      orange: 0xffa500ff,
      orangered: 0xff4500ff,
      orchid: 0xda70d6ff,
      palegoldenrod: 0xeee8aaff,
      palegreen: 0x98fb98ff,
      paleturquoise: 0xafeeeeff,
      palevioletred: 0xdb7093ff,
      papayawhip: 0xffefd5ff,
      peachpuff: 0xffdab9ff,
      peru: 0xcd853fff,
      pink: 0xffc0cbff,
      plum: 0xdda0ddff,
      powderblue: 0xb0e0e6ff,
      purple: 0x800080ff,
      rebeccapurple: 0x663399ff,
      red: 0xff0000ff,
      rosybrown: 0xbc8f8fff,
      royalblue: 0x4169e1ff,
      saddlebrown: 0x8b4513ff,
      salmon: 0xfa8072ff,
      sandybrown: 0xf4a460ff,
      seagreen: 0x2e8b57ff,
      seashell: 0xfff5eeff,
      sienna: 0xa0522dff,
      silver: 0xc0c0c0ff,
      skyblue: 0x87ceebff,
      slateblue: 0x6a5acdff,
      slategray: 0x708090ff,
      slategrey: 0x708090ff,
      snow: 0xfffafaff,
      springgreen: 0x00ff7fff,
      steelblue: 0x4682b4ff,
      tan: 0xd2b48cff,
      teal: 0x008080ff,
      thistle: 0xd8bfd8ff,
      tomato: 0xff6347ff,
      turquoise: 0x40e0d0ff,
      violet: 0xee82eeff,
      wheat: 0xf5deb3ff,
      white: 0xffffffff,
      whitesmoke: 0xf5f5f5ff,
      yellow: 0xffff00ff,
      yellowgreen: 0x9acd32ff,
    };

    function processColor(color) {
      if (color === undefined || color === null) {
        return color;
      }

      var int32Color = normalizeColor(color);
      if (int32Color === null || int32Color === undefined) {
        return undefined;
      }

      // Converts 0xrrggbbaa into 0xaarrggbb
      int32Color = ((int32Color << 24) | (int32Color >>> 8)) >>> 0;

      if (Platform.OS === 'android') {
        // Android use 32 bit *signed* integer to represent the color
        // We utilize the fact that bitwise operations in JS also operates on
        // signed 32 bit integers, so that we can use those to convert from
        // *unsigned* to *signed* 32bit int that way.
        int32Color = int32Color | 0x0;
      }
      return int32Color;
    }

    const isTouchable = props =>
      props.onPress != null ||
      props.onLongPress != null ||
      props.onStartShouldSetResponder != null;

    // this is not a full implementation, but just for a hack
    function TouchableText(props) {
      var newProps = props;
      if (isTouchable(newProps)) {
        throw new Error("TODO: mocked TouchableText does not handle touch events");
      }
      if (props.selectionColor != null) {
        newProps = Object.assign({}, props, {
          selectionColor: processColor(props.selectionColor)
        });
      }
      return (
        React.createElement(
          TextAncestor.Consumer,
          null,
          function (hasTextAncestor) {
            return (
              hasTextAncestor ? (
                React.createElement(
                  RCTVirtualText,
                  Object.assign(
                    {},
                    newProps,
                    { ref: newProps.forwardedRef }
                  )
                )
              ) : (
                React.createElement(
                  TextAncestor.Provider,
                  { value: true },
                  React.createElement(
                    RCTText,
                    Object.assign(
                      {},
                      newProps,
                      { ref: newProps.forwardedRef }
                    )
                  )
                )
              )
            );
          }
        )
      );
    }

    TouchableText.defaultProps = {
      accessible: true,
      allowFontScaling: true,
      ellipsizeMode: 'tail',
    };

    function getDifferForType(typeName: string) {
      switch (typeName) {
        // iOS Types
        case 'CATransform3D':
          return matricesDiffer;
        case 'CGPoint':
          return pointsDiffer;
        case 'CGSize':
          return sizesDiffer;
        case 'UIEdgeInsets':
          return insetsDiffer;
        // Android Types
        // (not yet implemented)
      }
      return null;
    }

    function getProcessorForType(typeName) {
      switch (typeName) {
        // iOS Types
        case 'CGColor':
        case 'UIColor':
          return processColor;
        case 'CGColorArray':
        case 'UIColorArray':
          return processColorArray;
        case 'CGImage':
        case 'UIImage':
        case 'RCTImageSource':
          return resolveAssetSource;
        // Android Types
        case 'Color':
          return processColor;
        case 'ColorArray':
          return processColorArray;
      }
      return null;
    }

    function merge(destination, source) {
      if (!source) {
        return destination;
      }
      if (!destination) {
        return source;
      }

      for (const key in source) {
        if (!source.hasOwnProperty(key)) {
          continue;
        }

        let sourceValue = source[key];
        if (destination.hasOwnProperty(key)) {
          const destinationValue = destination[key];
          if (
            typeof sourceValue === 'object' &&
            typeof destinationValue === 'object'
          ) {
            sourceValue = merge(destinationValue, sourceValue);
          }
        }
        destination[key] = sourceValue;
      }
      return destination;
    }

    function requireNativeComponent(uiViewClassName) {
      return createReactNativeComponentClass(uiViewClassName, function() {
        const viewConfig = UIManager[viewName];

        let {baseModuleName, bubblingEventTypes, directEventTypes} = viewConfig;
        let nativeProps = viewConfig.NativeProps;

        while (baseModuleName) {
          const baseModule = UIManager[baseModuleName];
          if (!baseModule) {
            baseModuleName = null;
          } else {
            bubblingEventTypes = Object.assign({}, baseModule.bubblingEventTypes, bubblingEventTypes);
            directEventTypes = Object.assign({}, baseModule.directEventTypes, directEventTypes);
            nativeProps = Object.assign({}, baseModule.NativeProps, nativeProps);
            baseModuleName = baseModule.baseModuleName;
          }
        }

        const viewAttributes = {};

        for (const key in nativeProps) {
          const typeName = nativeProps[key];
          const diff = getDifferForType(typeName);
          const process = getProcessorForType(typeName);

          viewAttributes[key] =
            diff == null && process == null ? true : {diff, process};
        }
        viewAttributes.style = ReactNativeStyleAttributes;

        Object.assign(viewConfig, {
          uiViewClassName: viewName,
          validAttributes: viewAttributes,
          bubblingEventTypes,
          directEventTypes,
        });

        if (!hasAttachedDefaultEventTypes) {
          attachDefaultEventTypes(viewConfig);
          hasAttachedDefaultEventTypes = true;
        }

        return viewConfig;
      });
    }

    var hasAttachedDefaultEventTypes = false;

    function attachDefaultEventTypes(viewConfig) {
      // This is supported on UIManager platforms (ex: Android),
      // as lazy view managers are not implemented for all platforms.
      // See [UIManager] for details on constants and implementations.
      if (UIManager.ViewManagerNames) {
        // Lazy view managers enabled.
        viewConfig = merge(viewConfig, UIManager.getDefaultEventTypes());
      } else {
        viewConfig.bubblingEventTypes = merge(
          viewConfig.bubblingEventTypes,
          UIManager.genericBubblingEventTypes,
        );
        viewConfig.directEventTypes = merge(
          viewConfig.directEventTypes,
          UIManager.genericDirectEventTypes,
        );
      }
    }

    const Text = React.forwardRef(function(props, ref) {
      return React.createElement(
        TouchableText,
        Object.assign(
          {},
          props
          // { forwardedRef: ref }
        )
      );
    });

    const StyleSheet = {
      create(obj){
        return obj;
      },
    };

    const RCTView = requireNativeComponent(
      'RCTView',
      {},
      {
        nativeOnly: {
          nativeBackgroundAndroid: true,
          nativeForegroundAndroid: true,
        },
      },
    );

    return {
      StyleSheet,
      Text,
      View: RCTView,
    };
  }
`;
let reactNativeAst = (0, _parser.parseExpression)(reactNativeCode, {
  plugins: ["flow"]
});

function createMockReactNative(realm, reactNativeRequireName) {
  let reactNativeFactory = _singletons.Environment.GetValue(realm, realm.$GlobalEnv.evaluate(reactNativeAst, false));

  (0, _invariant.default)(reactNativeFactory instanceof _index.ECMAScriptSourceFunctionValue);
  let factory = reactNativeFactory.$Call;
  (0, _invariant.default)(factory !== undefined);

  let RCTViewDerivedReference = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.StringValue, [new _index.StringValue(realm, "RCTView")], (0, _generator.createOperationDescriptor)("REACT_NATIVE_STRING_LITERAL"), {
    skipInvariant: true,
    isPure: true
  });

  (0, _invariant.default)(RCTViewDerivedReference instanceof _index.AbstractValue);
  realm.react.reactElementStringTypeReferences.set("RCTView", RCTViewDerivedReference);

  let RCTTextDerivedReference = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.StringValue, [new _index.StringValue(realm, "RCTText")], (0, _generator.createOperationDescriptor)("REACT_NATIVE_STRING_LITERAL"), {
    skipInvariant: true,
    isPure: true
  });

  (0, _invariant.default)(RCTTextDerivedReference instanceof _index.AbstractValue);
  realm.react.reactElementStringTypeReferences.set("RCTText", RCTTextDerivedReference);

  let RCTActivityIndicatorViewDerivedReference = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.StringValue, [new _index.StringValue(realm, "RCTActivityIndicatorView")], (0, _generator.createOperationDescriptor)("REACT_NATIVE_STRING_LITERAL"), {
    skipInvariant: true,
    isPure: true
  });

  (0, _invariant.default)(RCTActivityIndicatorViewDerivedReference instanceof _index.AbstractValue);
  realm.react.reactElementStringTypeReferences.set("RCTActivityIndicatorView", RCTActivityIndicatorViewDerivedReference);
  let reactLibrary = realm.fbLibraries.react;
  (0, _invariant.default)(reactLibrary !== undefined, "Could not find React library in sourcecode. Ensure React is bundled or required.");
  let reactNativeValue = factory(realm.intrinsics.undefined, [reactLibrary, new _index.StringValue(realm, reactNativeRequireName)]);
  (0, _invariant.default)(reactNativeValue instanceof _index.ObjectValue);
  reactNativeValue.refuseSerialization = true;
  reactNativeValue.intrinsicName = `require("${reactNativeRequireName}")`;
  reactNativeValue.refuseSerialization = false;
  return reactNativeValue;
}
//# sourceMappingURL=react-native-mocks.js.map

/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMockReactRelay = createMockReactRelay;

var _index = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _utils = __webpack_require__(632);

var _index2 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils2 = __webpack_require__(291);

var _parser = __webpack_require__(247);

var _utils3 = __webpack_require__(639);

var _generator = __webpack_require__(237);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
let reactRelayCode = `
  function createReactRelay(React) {

   function mapObject(obj, func) {
     var newObj = {};

      Object.keys(obj).forEach(function(key) {
        newObj[key] = func(obj[key]);
      });

      return newObj;
   }

    function isReactComponent(component) {
      return !!(
        component &&
        typeof component.prototype === 'object' &&
        component.prototype &&
        component.prototype.isReactComponent
      );
    }

    function getReactComponent(Component) {
      if (isReactComponent(Component)) {
        return Component;
      } else {
        return null;
      }
    }

    function getComponentName(Component) {
      let name;
      const ComponentClass = getReactComponent(Component);
      if (ComponentClass) {
        name = ComponentClass.displayName || ComponentClass.name;
      } else if (typeof Component === 'function') {
        name = Component.displayName || Component.name || 'StatelessComponent';
      } else {
        name = 'ReactElement';
      }
      return String(name);
    }

    function createFragmentContainer(Component, fragmentSpec) {
      var componentName = getComponentName(Component);
      var containerName = \`Relay(\${componentName})\`;

      return function(props, context) {
        var relay = context.relay;
        var {
          createFragmentSpecResolver,
          getFragment: getFragmentFromTag,
        } = relay.environment.unstable_internal;
        var fragments = mapObject(fragmentSpec, getFragmentFromTag);
        var resolver = createFragmentSpecResolver(
          relay,
          containerName,
          fragments,
          props,
        );
        var relayProp = {
          isLoading: resolver.isLoading(),
          environment: relay.environment,
        };
        var newProps = Object.assign({}, props, resolver.resolve(), {
          relay: relayProp,
        });
        return React.createElement(Component, newProps);
      };
    }

    return {
      createFragmentContainer,
    };
  }
`;
let reactRelayAst = (0, _parser.parseExpression)(reactRelayCode, {
  plugins: ["flow"]
});

function createReactRelayContainer(realm, reactRelay, containerName, reactRelayFirstRenderValue, relayRequireName) {
  // we create a ReactRelay container function that returns an abstract object
  // allowing us to reconstruct this ReactReact.createSomeContainer(...) again
  // we also pass a reactHint so the reconciler can properly deal with this
  (0, _utils3.addMockFunctionToObject)(realm, reactRelay, relayRequireName, containerName, (funcValue, args) => {
    let value = _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.FunctionValue, [reactRelay, new _index.StringValue(realm, containerName), ...args], (0, _generator.createOperationDescriptor)("REACT_RELAY_MOCK_CONTAINER"), {
      skipInvariant: true,
      isPure: true
    });

    (0, _invariant.default)(value instanceof _index.AbstractValue);
    let firstRenderContainerValue = (0, _index2.Get)(realm, reactRelayFirstRenderValue, containerName);
    let firstRenderValue = realm.intrinsics.undefined;

    if (firstRenderContainerValue instanceof _index.ECMAScriptSourceFunctionValue) {
      let firstRenderContainerValueCall = firstRenderContainerValue.$Call;
      (0, _invariant.default)(firstRenderContainerValueCall !== undefined);
      firstRenderValue = firstRenderContainerValueCall(realm.intrinsics.undefined, args);
      (0, _invariant.default)(firstRenderValue instanceof _index.ECMAScriptSourceFunctionValue);
    }

    realm.react.abstractHints.set(value, (0, _utils2.createReactHintObject)(reactRelay, containerName, args, firstRenderValue));
    return value;
  });
}

function createMockReactRelay(realm, relayRequireName) {
  let reactRelayFirstRenderFactory = _singletons.Environment.GetValue(realm, realm.$GlobalEnv.evaluate(reactRelayAst, false));

  (0, _invariant.default)(reactRelayFirstRenderFactory instanceof _index.ECMAScriptSourceFunctionValue);
  let factory = reactRelayFirstRenderFactory.$Call;
  (0, _invariant.default)(factory !== undefined);
  (0, _invariant.default)(realm.fbLibraries.react instanceof _index.ObjectValue, "mock ReactRelay cannot be required before mock React");
  let reactRelayFirstRenderValue = factory(realm.intrinsics.undefined, [realm.fbLibraries.react]);
  (0, _invariant.default)(reactRelayFirstRenderValue instanceof _index.ObjectValue); // we set refuseSerialization to true so we don't serialize the below properties straight away

  let reactRelay = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, `require("${relayRequireName}")`, true); // for QueryRenderer, we want to leave the component alone but process it's "render" prop

  let queryRendererComponent = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").QueryRenderer`);

  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "QueryRenderer", queryRendererComponent);

  let graphql = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").graphql`);

  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "graphql", graphql);

  let reactRelayContainers = ["createFragmentContainer", "createPaginationContainer", "createRefetchContainer"];

  for (let reactRelayContainer of reactRelayContainers) {
    createReactRelayContainer(realm, reactRelay, reactRelayContainer, reactRelayFirstRenderValue, relayRequireName);
  }

  let commitLocalUpdate = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").commitLocalUpdate`);

  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "commitLocalUpdate", commitLocalUpdate);

  let commitMutation = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").commitMutation`);

  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "commitMutation", commitMutation);

  let fetchQuery = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").fetchQuery`);

  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "fetchQuery", fetchQuery);

  let requestSubscription = (0, _utils.createAbstract)(realm, "function", `require("${relayRequireName}").requestSubscription`);

  _singletons.Create.CreateDataPropertyOrThrow(realm, reactRelay, "requestSubscription", requestSubscription); // we set refuseSerialization back to false


  reactRelay.refuseSerialization = false;
  reactRelay.makeFinal();
  return reactRelay;
}
//# sourceMappingURL=relay-mocks.js.map

/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFbMocks = createFbMocks;

var _index = __webpack_require__(15);

var _index2 = __webpack_require__(10);

var _singletons = __webpack_require__(236);

var _index3 = __webpack_require__(232);

var _invariant = _interopRequireDefault(__webpack_require__(9));

var _utils = __webpack_require__(291);

var _generator = __webpack_require__(237);

var _descriptors = __webpack_require__(268);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
const fbMagicGlobalFunctions = ["asset", "cx", "cssVar", "csx", "errorDesc", "errorHelpCenterID", "errorSummary", "gkx", "glyph", "ifRequired", "ix", "fbglyph", "requireWeak", "xuiglyph"];
const fbMagicGlobalObjects = ["JSResource", "fbt"];

function createBabelHelpers(realm, global) {
  let babelHelpersValue = new _index2.ObjectValue(realm, realm.intrinsics.ObjectPrototype, `babelHelpers`, true);
  let objectAssign = (0, _index3.Get)(realm, realm.intrinsics.Object, "assign");
  let objectCreate = (0, _index3.Get)(realm, realm.intrinsics.Object, "create"); //babelHelpers.objectWithoutProperties

  let inheritsValue = new _index2.NativeFunctionValue(realm, undefined, `inherits`, 2, (context, [subClass, superClass]) => {
    (0, _invariant.default)(objectAssign instanceof _index2.NativeFunctionValue);
    let objectAssignCall = objectAssign.$Call;
    (0, _invariant.default)(objectAssignCall !== undefined);
    objectAssignCall(realm.intrinsics.undefined, [subClass, superClass]);
    (0, _invariant.default)(superClass instanceof _index2.ObjectValue);
    let superClassPrototype = (0, _index3.Get)(realm, superClass, "prototype");
    (0, _invariant.default)(objectCreate instanceof _index2.NativeFunctionValue);
    let objectCreateCall = objectCreate.$Call;
    (0, _invariant.default)(typeof objectCreateCall === "function");
    let newPrototype = objectCreateCall(realm.intrinsics.undefined, [superClassPrototype]);
    (0, _invariant.default)(subClass instanceof _index2.ObjectValue);
    (0, _invariant.default)(newPrototype instanceof _index2.ObjectValue);

    _singletons.Properties.Set(realm, subClass, "prototype", newPrototype, true);

    _singletons.Properties.Set(realm, newPrototype, "constructor", subClass, true);

    _singletons.Properties.Set(realm, subClass, "__superConstructor__", superClass, true);

    return superClass;
  });
  babelHelpersValue.defineNativeProperty("inherits", inheritsValue, {
    writable: false,
    enumerable: false,
    configurable: true
  });
  inheritsValue.intrinsicName = `babelHelpers.inherits`;

  const createObjectWithoutProperties = (obj, keys) => {
    let removeKeys = new Set();
    (0, _utils.forEachArrayValue)(realm, keys, key => {
      if (key instanceof _index2.StringValue || key instanceof _index2.NumberValue) {
        removeKeys.add(key.value);
      }
    });

    let newObject = _singletons.Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);

    for (let [propName, binding] of obj.properties) {
      if (!removeKeys.has(propName)) {
        if (binding && binding.descriptor && binding.descriptor.throwIfNotConcrete(realm).enumerable) {
          let value = (0, _index3.Get)(realm, obj, propName);

          _singletons.Properties.Set(realm, newObject, propName, value, true);
        }
      }
    }

    return newObject;
  }; //babelHelpers.objectWithoutProperties


  let objectWithoutPropertiesValue = new _index2.NativeFunctionValue(realm, undefined, `objectWithoutProperties`, 2, (context, [obj, keys]) => {
    (0, _invariant.default)(obj instanceof _index2.ObjectValue || obj instanceof _index2.AbstractObjectValue || obj instanceof _index2.AbstractValue);
    (0, _invariant.default)(keys instanceof _index2.ArrayValue);

    if (obj.mightBeObject() && (obj instanceof _index2.AbstractValue && obj.values.isTop() || obj.isPartialObject())) {
      let temporalArgs = [objectWithoutPropertiesValue, obj, keys];
      let temporalConfig = {
        skipInvariant: true,
        isPure: true
      };

      let value = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.ObjectValue, temporalArgs, (0, _generator.createOperationDescriptor)("BABEL_HELPERS_OBJECT_WITHOUT_PROPERTIES"), temporalConfig);

      (0, _invariant.default)(value instanceof _index2.AbstractObjectValue);

      if (obj instanceof _index2.ObjectValue) {
        let template = createObjectWithoutProperties(obj, keys);
        value.values = new _index.ValuesDomain(template);
      } // as we are returning an abstract object, we mark it as simple


      value.makeSimple();
      return value;
    } else {
      (0, _invariant.default)(obj instanceof _index2.ObjectValue);
      return createObjectWithoutProperties(obj, keys);
    }
  });
  babelHelpersValue.defineNativeProperty("objectWithoutProperties", objectWithoutPropertiesValue, {
    writable: false,
    enumerable: false,
    configurable: true
  });
  objectWithoutPropertiesValue.intrinsicName = `babelHelpers.objectWithoutProperties`; //babelHelpers.taggedTemplateLiteralLoose

  let taggedTemplateLiteralLooseValue = new _index2.NativeFunctionValue(realm, undefined, `taggedTemplateLiteralLoose`, 2, (context, [strings, raw]) => {
    (0, _invariant.default)(strings instanceof _index2.ObjectValue);

    _singletons.Properties.Set(realm, strings, "raw", raw, true);

    return strings;
  });
  babelHelpersValue.defineNativeProperty("taggedTemplateLiteralLoose", taggedTemplateLiteralLooseValue, {
    writable: false,
    enumerable: false,
    configurable: true
  });
  taggedTemplateLiteralLooseValue.intrinsicName = `babelHelpers.taggedTemplateLiteralLoose`; //babelHelpers.extends & babelHelpers._extends

  babelHelpersValue.defineNativeProperty("extends", objectAssign, {
    writable: true,
    enumerable: true,
    configurable: true
  });
  babelHelpersValue.defineNativeProperty("_extends", objectAssign, {
    writable: true,
    enumerable: true,
    configurable: true
  }); //babelHelpers.bind

  let functionBind = (0, _index3.Get)(realm, realm.intrinsics.FunctionPrototype, "bind");
  babelHelpersValue.defineNativeProperty("bind", functionBind, {
    writable: true,
    enumerable: true,
    configurable: true
  });
  global.$DefineOwnProperty("babelHelpers", new _descriptors.PropertyDescriptor({
    value: babelHelpersValue,
    writable: true,
    enumerable: true,
    configurable: true
  }));
  babelHelpersValue.refuseSerialization = false;
}

function createMagicGlobalFunction(realm, global, functionName) {
  global.$DefineOwnProperty(functionName, new _descriptors.PropertyDescriptor({
    value: new _index2.NativeFunctionValue(realm, functionName, functionName, 0, (context, args) => {
      let val = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.FunctionValue, [new _index2.StringValue(realm, functionName), ...args], (0, _generator.createOperationDescriptor)("FB_MOCKS_MAGIC_GLOBAL_FUNCTION"), {
        skipInvariant: true,
        isPure: true
      });

      (0, _invariant.default)(val instanceof _index2.AbstractValue);
      return val;
    }),
    writable: true,
    enumerable: false,
    configurable: true
  }));
}

function createMagicGlobalObject(realm, global, objectName) {
  let globalObject = _index2.AbstractValue.createAbstractObject(realm, objectName);

  globalObject.kind = "resolved";
  global.$DefineOwnProperty(objectName, new _descriptors.PropertyDescriptor({
    value: globalObject,
    writable: true,
    enumerable: false,
    configurable: true
  }));
}

function createBootloader(realm, global) {
  let bootloader = new _index2.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
  let loadModules = new _index2.NativeFunctionValue(realm, "loadModules", "loadModules", 1, (context, args) => {
    (0, _invariant.default)(context.$Realm.generator);

    let val = _index2.AbstractValue.createTemporalFromBuildFunction(realm, _index2.FunctionValue, args, (0, _generator.createOperationDescriptor)("FB_MOCKS_BOOTLOADER_LOAD_MODULES"), {
      skipInvariant: true
    });

    (0, _invariant.default)(val instanceof _index2.AbstractValue);
    return val;
  });

  _singletons.Properties.Set(realm, bootloader, "loadModules", loadModules, false);

  global.$DefineOwnProperty("Bootloader", new _descriptors.PropertyDescriptor({
    value: bootloader,
    writable: true,
    enumerable: false,
    configurable: true
  }));
  return _index2.AbstractValue.createAbstractObject(realm, "Bootloader", bootloader);
}

function createFbMocks(realm, global) {
  global.$DefineOwnProperty("__DEV__", new _descriptors.PropertyDescriptor({
    // TODO: we'll likely want to make this configurable from the outside.
    value: realm.intrinsics.false,
    writable: true,
    enumerable: false,
    configurable: true
  }));
  createBabelHelpers(realm, global);

  for (let functionName of fbMagicGlobalFunctions) {
    createMagicGlobalFunction(realm, global, functionName);
  }

  for (let objectName of fbMagicGlobalObjects) {
    createMagicGlobalObject(realm, global, objectName);
  }

  createBootloader(realm, global);
}
//# sourceMappingURL=fb-mocks.js.map

/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRealmOptions = getRealmOptions;
exports.getSerializerOptions = getSerializerOptions;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function getRealmOptions({
  compatibility = "browser",
  debugNames = false,
  errorHandler,
  mathRandomSeed,
  invariantLevel = 0,
  invariantMode = "throw",
  emitConcreteModel = false,
  uniqueSuffix,
  instantRender,
  reactEnabled,
  reactOutput,
  reactVerbose,
  reactOptimizeNestedFunctions,
  serialize = true,
  check,
  strictlyMonotonicDateNow,
  stripFlow,
  timeout,
  maxStackDepth,
  abstractValueImpliesMax,
  debuggerConfigArgs,
  debugReproArgs,
  arrayNestedOptimizedFunctionsEnabled,
  reactFailOnUnsupportedSideEffects
}) {
  return {
    compatibility,
    debugNames,
    errorHandler,
    mathRandomSeed,
    invariantLevel,
    invariantMode,
    emitConcreteModel,
    uniqueSuffix,
    instantRender,
    reactEnabled,
    reactOutput,
    reactVerbose,
    reactOptimizeNestedFunctions,
    serialize,
    check,
    strictlyMonotonicDateNow,
    stripFlow,
    timeout,
    maxStackDepth,
    abstractValueImpliesMax,
    debuggerConfigArgs,
    debugReproArgs,
    arrayNestedOptimizedFunctionsEnabled,
    reactFailOnUnsupportedSideEffects
  };
}

function getSerializerOptions({
  lazyObjectsRuntime,
  heapGraphFormat,
  delayInitializations = false,
  internalDebug = false,
  debugScopes = false,
  debugIdentifiers,
  logStatistics = false,
  logModules = false,
  profile = false,
  inlineExpressions = false,
  modulesToInitialize,
  trace = false
}) {
  let result = {
    delayInitializations,
    modulesToInitialize,
    internalDebug,
    debugScopes,
    debugIdentifiers,
    logStatistics,
    logModules,
    profile,
    inlineExpressions,
    trace
  };

  if (lazyObjectsRuntime !== undefined) {
    result.lazyObjectsRuntime = lazyObjectsRuntime;
  }

  if (heapGraphFormat !== undefined) {
    result.heapGraphFormat = heapGraphFormat;
  }

  return result;
}
//# sourceMappingURL=prepack-options.js.map

/***/ }),
/* 650 */
/***/ (function(module) {

module.exports = {"_from":"prepack@^0.2.54","_id":"prepack@0.2.54","_inBundle":false,"_integrity":"sha512-wu6j6J6h/TgpYNRS8tXEyprwul2WM2Zr+dSbc/o0O8cdhoOjvMy2T98WK2dhSNe+xyQ/SaqJpepWiCxS8EVjkA==","_location":"/prepack","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"prepack@^0.2.54","name":"prepack","escapedName":"prepack","rawSpec":"^0.2.54","saveSpec":null,"fetchSpec":"^0.2.54"},"_requiredBy":["/","/prepack-webpack-plugin"],"_resolved":"https://registry.npmjs.org/prepack/-/prepack-0.2.54.tgz","_shasum":"ce2d610dc39731a68f16527053597a11b74ae153","_spec":"prepack@^0.2.54","_where":"/Users/teo/Documents/UNIVERSITY/5th year/Project/tas458","author":{"name":"Facebook"},"bin":{"prepack":"bin/prepack.js","prepack-repl":"bin/prepack-repl.js"},"browser":"lib/prepack-standalone.js","bugs":{"url":"https://github.com/facebook/prepack/issues"},"bundleDependencies":false,"dependencies":{"@babel/core":"^7.0.0","@babel/generator":"^7.0.0","@babel/node":"^7.0.0","@babel/parser":"^7.0.0","@babel/preset-flow":"^7.0.0","@babel/template":"^7.0.0","@babel/traverse":"^7.0.0","@babel/types":"^7.0.0","fbjs":"^0.8.16","node-zip":"^1.1.1","queue-fifo":"^0.2.3","seedrandom":"^2.4.2","source-map":"^0.5.6","v8-profiler-node8":"^6.0.1","vscode-debugadapter":"^1.24.0","vscode-debugprotocol":"^1.24.0","zip-dir":"^1.0.2"},"deprecated":false,"description":"Execute a JS bundle, serialize global state and side effects to a snapshot that can be quickly restored.","devDependencies":{"@babel/cli":"^7.0.0","@babel/plugin-proposal-class-properties":"^7.0.0","@babel/plugin-proposal-export-default-from":"^7.0.0","@babel/plugin-proposal-object-rest-spread":"^7.0.0","@babel/plugin-syntax-flow":"^7.0.0","@babel/plugin-transform-flow-strip-types":"^7.0.0","@babel/plugin-transform-modules-commonjs":"^7.0.0","@babel/plugin-transform-react-display-name":"^7.0.0","@babel/plugin-transform-react-jsx":"^7.0.0","@babel/preset-env":"^7.0.0","@babel/preset-flow":"^7.0.0","@babel/preset-react":"^7.0.0","@babel/register":"^7.0.0","babel-core":"7.0.0-bridge.0","babel-eslint":"^8.2.6","babel-jest":"^23.4.0","babel-loader":"^8.0.0-beta","babel-plugin-jest-hoist":"^23.2.0","chalk":"^1.1.3","eslint":"^4.18.2","eslint-plugin-babel":"^3.3.0","eslint-plugin-flow-header":"^0.1.1","eslint-plugin-flowtype":"^2.40.0","eslint-plugin-header":"^1.0.0","eslint-plugin-prettier":"^2.1.2","flow-bin":"^0.81.0","flow-typed":"^2.3.0","graceful-fs":"^4.1.11","invariant":"^2.2.0","istanbul":"^0.4.5","jest":"^23.4.1","js-beautify":"^1.7.5","js-yaml":"^3.6.1","jsdom":"^9.2.1","madge":"^1.6.0","minimist":"^1.2.0","prettier":"1.13.6","prop-types":"^15.6.0","react":"16.3.1","react-dom":"16.3.1","react-native":"^0.55.4","react-relay":"^1.4.1","react-test-renderer":"16.3.1","regenerator-runtime":"^0.12.0","remap-istanbul":"^0.9.1","source-map-support":"^0.4.6","test262-integrator":"^1.2.0","webpack":"^4.16.0","webpack-cli":"^3.0.8"},"engines":{"node":">=6.1.0"},"files":["LICENSE","PATENTS","/bin/","/lib/"],"homepage":"https://github.com/facebook/prepack","jest":{"preset":"react-native","roots":["<rootDir>/node_modules/react-native/","<rootDir>/lib/","<rootDir>/test/react/","<rootDir>/fb-www/"],"testEnvironment":"jsdom","testMatch":["**/test/react/*-test.js","**/fb-www/**/*-test.js"],"transformIgnorePatterns":["/node_modules/(?!react-native).+\\.js$"]},"keywords":["prepack"],"license":"BSD-3-Clause","main":"lib/prepack-node.js","name":"prepack","optionalDependencies":{"v8-profiler-node8":"^6.0.1"},"repository":{"type":"git","url":"git://github.com/facebook/prepack.git"},"scripts":{"build":"yarn build-prepack && yarn build-bundle","build-bundle":"webpack-cli --silent","build-prepack":"babel src --out-dir lib --source-maps","build-scripts":"babel scripts --out-dir lib --source-maps","debug-fb-www":"node --stack_trace_limit=200 --stack_size=10000 --max_old_space_size=16384 ./scripts/debug-fb-www.js","depcheck":"babel-node scripts/detect_bad_deps.js","flow":"flow","flow-ci":"flow version; flow check","fuzz":"cd fuzzer && yarn && yarn test","fuzz-overnight":"cd fuzzer && yarn && yarn overnight","fuzz-sample":"cd fuzzer && yarn && yarn sample","lint":"eslint src scripts","precheck":"yarn prepack-cli --check","prepack-cli":"node --stack_size=10000 --stack_trace_limit=200 --max_old_space_size=16384 lib/prepack-cli.js --compatibility jsc-600-1-4-17 --mathRandomSeed 0","prepublishOnly":"yarn build","prettier":"node ./scripts/prettier.js write-changed","prettier-all":"node ./scripts/prettier.js write","prettier-ci":"node ./scripts/prettier.js","repl":"node lib/repl-cli.js","test":"yarn test-serializer && yarn test-sourcemaps && yarn test-error-handler && yarn test-std-in && yarn test-test262 && yarn test-internal && yarn test-internal-react && yarn test-react","test-all-coverage":"istanbul --stack_size=10000 --max_old_space_size=16384 cover ./lib/multi-runner.js --dir coverage.most && ./node_modules/.bin/istanbul --stack_size=10000 --max_old_space_size=16384 cover ./lib/test262-runner.js --timeout 50 --singleThreaded && ./node_modules/.bin/remap-istanbul -i coverage/coverage.json -i coverage.most/coverage.json -o coverage-sourcemapped -t html","test-coverage-most":"istanbul --stack_size=10000 --max_old_space_size=16384 cover ./lib/multi-runner.js --dir coverage.most && ./node_modules/.bin/remap-istanbul -i coverage.most/coverage.json -o coverage-sourcemapped -t html","test-error-handler":"babel-node scripts/test-error-handler.js","test-error-handler-with-coverage":"istanbul cover ./lib/test-error-handler.js --dir coverage.error && ./node_modules/.bin/remap-istanbul -i coverage.error/coverage.json -o coverage-sourcemapped.error -t html","test-internal":"babel-node --stack_size=10000 --stack_trace_limit=200 --max_old_space_size=32768 scripts/test-internal.js","test-internal-react":"babel-node --stack_size=10000 --stack_trace_limit=200 --max_old_space_size=32768 scripts/test-internal-react.js","test-react":"jest","test-react-fast":"SKIP_REACT_JSX_TESTS=true jest","test-serializer":"babel-node --stack_trace_limit=200 --stack_size=10000 scripts/test-runner.js","test-serializer-single":"yarn test-serializer --debugNames --verbose --fast --filter","test-serializer-with-coverage":"istanbul cover ./lib/test-error-handler.js --dir coverage.error && node --stack_trace_limit=200 --stack_size=10000 ./node_modules/istanbul/lib/cli.js cover ./lib/test-runner.js && ./node_modules/.bin/remap-istanbul -i coverage.error/coverage.json -i coverage/coverage.json -o coverage-sourcemapped -t html","test-sourcemaps":"babel-node scripts/generate-sourcemaps-test.js && bash < scripts/test-sourcemaps.sh","test-std-in":"bash < scripts/test-std-in.sh","test-test262":"babel-node scripts/test262-runner.js","test-test262-new":"babel-node scripts/test262.js","test-test262-nightly":"NIGHTLY_BUILD=true babel-node scripts/test262-runner.js","validate":"yarn install --frozen-lockfile && yarn build && yarn build-scripts && yarn lint && yarn depcheck && yarn flow && yarn test","watch":"babel src scripts --out-dir lib --watch --source-maps --verbose"},"version":"0.2.54"};

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebugChannel = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(621));

var _FileIOWrapper = __webpack_require__(652);

var _DebugMessage = __webpack_require__(622);

var _MessageMarshaller = __webpack_require__(655);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
//Channel used by the DebugServer in Prepack to communicate with the debug adapter
class DebugChannel {
  constructor(ioWrapper) {
    this._requestReceived = false;
    this._ioWrapper = ioWrapper;
    this._marshaller = new _MessageMarshaller.MessageMarshaller();
  }

  /*
  /* Only called in the beginning to check if a debugger is attached
  */
  debuggerIsAttached() {
    let message = this._ioWrapper.readInSyncOnce();

    if (message === null) return false;
    let parts = message.split(" ");
    let requestID = parseInt(parts[0], 10);
    (0, _invariant.default)(!isNaN(requestID), "Request ID must be a number");
    let command = parts[1];

    if (command === _DebugMessage.DebugMessage.DEBUGGER_ATTACHED) {
      this._requestReceived = true;

      this._ioWrapper.clearInFile();

      this.writeOut(`${requestID} ${_DebugMessage.DebugMessage.PREPACK_READY_RESPONSE}`);
      return true;
    }

    return false;
  }
  /* Reads in a request from the debug adapter
  /* The caller is responsible for sending a response with the appropriate
  /* contents at the right time.
  */


  readIn() {
    let message = this._ioWrapper.readInSync();

    this._requestReceived = true;
    return this._marshaller.unmarshallRequest(message);
  } // Write out a response to the debug adapter


  writeOut(contents) {
    //Prepack only writes back to the debug adapter in response to a request
    (0, _invariant.default)(this._requestReceived, "Prepack writing message without being requested: " + contents);

    this._ioWrapper.writeOutSync(contents);

    this._requestReceived = false;
  }

  sendBreakpointsAcknowledge(messageType, requestID, args) {
    this.writeOut(this._marshaller.marshallBreakpointAcknowledge(requestID, messageType, args.breakpoints));
  }

  sendStoppedResponse(reason, filePath, line, column, message) {
    this.writeOut(this._marshaller.marshallStoppedResponse(reason, filePath, line, column, message));
  }

  sendStackframeResponse(requestID, stackframes) {
    this.writeOut(this._marshaller.marshallStackFramesResponse(requestID, stackframes));
  }

  sendScopesResponse(requestID, scopes) {
    this.writeOut(this._marshaller.marshallScopesResponse(requestID, scopes));
  }

  sendVariablesResponse(requestID, variables) {
    this.writeOut(this._marshaller.marshallVariablesResponse(requestID, variables));
  }

  sendEvaluateResponse(requestID, evalResult) {
    this.writeOut(this._marshaller.marshallEvaluateResponse(requestID, evalResult));
  }

  shutdown() {
    this._ioWrapper.clearInFile();

    this._ioWrapper.clearOutFile();
  }

}

exports.DebugChannel = DebugChannel;
//# sourceMappingURL=DebugChannel.js.map

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileIOWrapper = void 0;

var _fs = _interopRequireDefault(__webpack_require__(653));

var _MessagePackager = __webpack_require__(654);

var _invariant = _interopRequireDefault(__webpack_require__(621));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
class FileIOWrapper {
  constructor(isAdapter, inFilePath, outFilePath) {
    this._inFilePath = inFilePath;
    this._outFilePath = outFilePath;
    if (!_fs.default.existsSync(this._inFilePath)) _fs.default.openSync(this._inFilePath, "w");
    if (!_fs.default.existsSync(this._outFilePath)) _fs.default.openSync(this._outFilePath, "w");
    this._packager = new _MessagePackager.MessagePackager(isAdapter);
    this._isAdapter = isAdapter;
  }

  // Read in a message from the input asynchronously
  readIn(errorHandler, messageProcessor) {
    _fs.default.readFile(this._inFilePath, {
      encoding: "utf8"
    }, (err, contents) => {
      if (err) {
        errorHandler(err);
        return;
      }

      let message = this._packager.unpackage(contents);

      if (message === null) {
        this.readIn(errorHandler, messageProcessor);
        return;
      } //clear the file


      _fs.default.writeFileSync(this._inFilePath, ""); //process the message


      messageProcessor(message);
    });
  } // Read in a message from the input synchronously


  readInSync() {
    let message = null;

    while (true) {
      let contents = _fs.default.readFileSync(this._inFilePath, "utf8");

      message = this._packager.unpackage(contents);
      if (message === null) continue;
      break;
    } // loop should not break when message is still null


    (0, _invariant.default)(message !== null); //clear the file

    _fs.default.writeFileSync(this._inFilePath, "");

    return message;
  } // Read in a message from the input synchronously only once


  readInSyncOnce() {
    let contents = _fs.default.readFileSync(this._inFilePath, "utf8");

    let message = this._packager.unpackage(contents);

    return message;
  } // Write out a message to the output synchronously


  writeOutSync(contents) {
    _fs.default.writeFileSync(this._outFilePath, this._packager.package(contents));
  }

  clearInFile() {
    _fs.default.writeFileSync(this._inFilePath, "");
  }

  clearOutFile() {
    _fs.default.writeFileSync(this._outFilePath, "");
  }

}

exports.FileIOWrapper = FileIOWrapper;
//# sourceMappingURL=FileIOWrapper.js.map

/***/ }),
/* 653 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__653__;

/***/ }),
/* 654 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessagePackager = void 0;

var _invariant = _interopRequireDefault(__webpack_require__(621));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict */
const LENGTH_SEPARATOR = "--"; // Package a message sent or unpackage a message received

class MessagePackager {
  constructor(isAdapter) {
    this._isAdapter = isAdapter;
  }

  // package a message to be sent
  package(contents) {
    // format: <length>--<contents>
    return contents.length + LENGTH_SEPARATOR + contents;
  } // unpackage a message received, verify it, and return it
  // returns null if no message or the message is only partially read
  // errors if the message violates the format


  unpackage(contents) {
    // format: <length>--<contents>
    let separatorIndex = contents.indexOf(LENGTH_SEPARATOR); // if the separator is not written in yet --> partial read

    if (separatorIndex === -1) {
      return null;
    }

    let messageLength = parseInt(contents.slice(0, separatorIndex), 10); // if the part before the separator is not a valid length, it is a
    // violation of protocol

    (0, _invariant.default)(!isNaN(messageLength));
    let startIndex = separatorIndex + LENGTH_SEPARATOR.length;
    let endIndex = startIndex + messageLength; // there should only be one message in the contents at a time

    (0, _invariant.default)(contents.length <= startIndex + messageLength); // if we didn't read the whole message yet --> partial read

    if (contents.length < endIndex) {
      return null;
    }

    let message = contents.slice(startIndex, endIndex);
    return message;
  }

}

exports.MessagePackager = MessagePackager;
//# sourceMappingURL=MessagePackager.js.map

/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageMarshaller = void 0;

var _DebugMessage = __webpack_require__(622);

var _invariant = _interopRequireDefault(__webpack_require__(621));

var _DebuggerError = __webpack_require__(623);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class MessageMarshaller {
  constructor() {
    this._lastRunRequestID = 0;
  }

  marshallBreakpointAcknowledge(requestID, messageType, breakpoints) {
    return `${requestID} ${messageType} ${JSON.stringify(breakpoints)}`;
  }

  marshallStoppedResponse(reason, filePath, line, column, message) {
    let result = {
      kind: "stopped",
      reason: reason,
      filePath: filePath,
      line: line,
      column: column,
      message: message
    };
    return `${this._lastRunRequestID} ${_DebugMessage.DebugMessage.STOPPED_RESPONSE} ${JSON.stringify(result)}`;
  }

  marshallDebuggerStart(requestID) {
    return `${requestID} ${_DebugMessage.DebugMessage.DEBUGGER_ATTACHED}`;
  }

  marshallContinueRequest(requestID) {
    return `${requestID} ${_DebugMessage.DebugMessage.PREPACK_RUN_COMMAND}`;
  }

  marshallSetBreakpointsRequest(requestID, breakpoints) {
    return `${requestID} ${_DebugMessage.DebugMessage.BREAKPOINT_ADD_COMMAND} ${JSON.stringify(breakpoints)}`;
  }

  marshallStackFramesRequest(requestID) {
    return `${requestID} ${_DebugMessage.DebugMessage.STACKFRAMES_COMMAND}`;
  }

  marshallStackFramesResponse(requestID, stackframes) {
    return `${requestID} ${_DebugMessage.DebugMessage.STACKFRAMES_RESPONSE} ${JSON.stringify(stackframes)}`;
  }

  marshallScopesRequest(requestID, frameId) {
    return `${requestID} ${_DebugMessage.DebugMessage.SCOPES_COMMAND} ${frameId}`;
  }

  marshallScopesResponse(requestID, scopes) {
    return `${requestID} ${_DebugMessage.DebugMessage.SCOPES_RESPONSE} ${JSON.stringify(scopes)}`;
  }

  marshallVariablesRequest(requestID, variablesReference) {
    return `${requestID} ${_DebugMessage.DebugMessage.VARIABLES_COMMAND} ${variablesReference}`;
  }

  marshallVariablesResponse(requestID, variables) {
    return `${requestID} ${_DebugMessage.DebugMessage.VARIABLES_RESPONSE} ${JSON.stringify(variables)}`;
  }

  marshallStepIntoRequest(requestID) {
    return `${requestID} ${_DebugMessage.DebugMessage.STEPINTO_COMMAND}`;
  }

  marshallStepOverRequest(requestID) {
    return `${requestID} ${_DebugMessage.DebugMessage.STEPOVER_COMMAND}`;
  }

  marshallStepOutRequest(requestID) {
    return `${requestID} ${_DebugMessage.DebugMessage.STEPOUT_COMMAND}`;
  }

  marshallEvaluateRequest(requestID, frameId, expression) {
    let evalArgs = {
      kind: "evaluate",
      expression: expression
    };

    if (frameId !== undefined) {
      evalArgs.frameId = frameId;
    }

    return `${requestID} ${_DebugMessage.DebugMessage.EVALUATE_COMMAND} ${JSON.stringify(evalArgs)}`;
  }

  marshallEvaluateResponse(requestID, evalResult) {
    return `${requestID} ${_DebugMessage.DebugMessage.EVALUATE_RESPONSE} ${JSON.stringify(evalResult)}`;
  }

  unmarshallRequest(message) {
    let parts = message.split(" "); // each request must have a length and a command

    (0, _invariant.default)(parts.length >= 2, "Request is not well formed"); // unique ID for each request

    let requestID = parseInt(parts[0], 10);
    (0, _invariant.default)(!isNaN(requestID), "Request ID must be a number");
    let command = parts[1];
    let args;

    switch (command) {
      case _DebugMessage.DebugMessage.PREPACK_RUN_COMMAND:
        this._lastRunRequestID = requestID;
        let runArgs = {
          kind: "run"
        };
        args = runArgs;
        break;

      case _DebugMessage.DebugMessage.BREAKPOINT_ADD_COMMAND:
        args = this._unmarshallBreakpointsArguments(requestID, parts.slice(2).join(" "));
        break;

      case _DebugMessage.DebugMessage.STACKFRAMES_COMMAND:
        let stackFrameArgs = {
          kind: "stackframe"
        };
        args = stackFrameArgs;
        break;

      case _DebugMessage.DebugMessage.SCOPES_COMMAND:
        args = this._unmarshallScopesArguments(requestID, parts[2]);
        break;

      case _DebugMessage.DebugMessage.VARIABLES_COMMAND:
        args = this._unmarshallVariablesArguments(requestID, parts[2]);
        break;

      case _DebugMessage.DebugMessage.STEPINTO_COMMAND:
        this._lastRunRequestID = requestID;
        let stepIntoArgs = {
          kind: "stepInto"
        };
        args = stepIntoArgs;
        break;

      case _DebugMessage.DebugMessage.STEPOVER_COMMAND:
        this._lastRunRequestID = requestID;
        let stepOverArgs = {
          kind: "stepOver"
        };
        args = stepOverArgs;
        break;

      case _DebugMessage.DebugMessage.STEPOUT_COMMAND:
        this._lastRunRequestID = requestID;
        let stepOutArgs = {
          kind: "stepOut"
        };
        args = stepOutArgs;
        break;

      case _DebugMessage.DebugMessage.EVALUATE_COMMAND:
        args = this._unmarshallEvaluateArguments(requestID, parts.slice(2).join(" "));
        break;

      default:
        throw new _DebuggerError.DebuggerError("Invalid command", "Invalid command from adapter: " + command);
    }

    (0, _invariant.default)(args !== undefined);
    let result = {
      id: requestID,
      command: command,
      arguments: args
    };
    return result;
  }

  _unmarshallBreakpointsArguments(requestID, responseString) {
    let breakpoints = JSON.parse(responseString);

    for (const breakpoint of breakpoints) {
      (0, _invariant.default)(breakpoint.hasOwnProperty("filePath"), "breakpoint missing filePath property");
      (0, _invariant.default)(breakpoint.hasOwnProperty("line"), "breakpoint missing line property");
      (0, _invariant.default)(breakpoint.hasOwnProperty("column"), "breakpoint missing column property");
      (0, _invariant.default)(!isNaN(breakpoint.line));
      (0, _invariant.default)(!isNaN(breakpoint.column));
    }

    let result = {
      kind: "breakpoint",
      breakpoints: breakpoints
    };
    return result;
  }

  _unmarshallScopesArguments(requestID, responseString) {
    let frameId = parseInt(responseString, 10);
    (0, _invariant.default)(!isNaN(frameId));
    let result = {
      kind: "scopes",
      frameId: frameId
    };
    return result;
  }

  _unmarshallVariablesArguments(requestID, responseString) {
    let varRef = parseInt(responseString, 10);
    (0, _invariant.default)(!isNaN(varRef));
    let result = {
      kind: "variables",
      variablesReference: varRef
    };
    return result;
  }

  _unmarshallEvaluateArguments(requestID, responseString) {
    let evalArgs = JSON.parse(responseString);
    (0, _invariant.default)(evalArgs.hasOwnProperty("kind"), "Evaluate arguments missing kind field");
    (0, _invariant.default)(evalArgs.hasOwnProperty("expression"), "Evaluate arguments missing expression field");
    if (evalArgs.hasOwnProperty("frameId")) (0, _invariant.default)(!isNaN(evalArgs.frameId));
    return evalArgs;
  }

  unmarshallResponse(message) {
    try {
      let parts = message.split(" ");
      let requestID = parseInt(parts[0], 10);
      (0, _invariant.default)(!isNaN(requestID));
      let messageType = parts[1];
      let dbgResult;
      let resultString = parts.slice(2).join(" ");

      if (messageType === _DebugMessage.DebugMessage.PREPACK_READY_RESPONSE) {
        dbgResult = this._unmarshallReadyResult();
      } else if (messageType === _DebugMessage.DebugMessage.BREAKPOINT_ADD_ACKNOWLEDGE) {
        dbgResult = this._unmarshallBreakpointsAddResult(resultString);
      } else if (messageType === _DebugMessage.DebugMessage.STOPPED_RESPONSE) {
        dbgResult = this._unmarshallStoppedResult(resultString);
      } else if (messageType === _DebugMessage.DebugMessage.STACKFRAMES_RESPONSE) {
        dbgResult = this._unmarshallStackframesResult(resultString);
      } else if (messageType === _DebugMessage.DebugMessage.SCOPES_RESPONSE) {
        dbgResult = this._unmarshallScopesResult(resultString);
      } else if (messageType === _DebugMessage.DebugMessage.VARIABLES_RESPONSE) {
        dbgResult = this._unmarshallVariablesResult(resultString);
      } else if (messageType === _DebugMessage.DebugMessage.EVALUATE_RESPONSE) {
        dbgResult = this._unmarshallEvaluateResult(resultString);
      } else {
        (0, _invariant.default)(false, "Unexpected response type");
      }

      let dbgResponse = {
        id: requestID,
        result: dbgResult
      };
      return dbgResponse;
    } catch (e) {
      throw new _DebuggerError.DebuggerError("Invalid command", e.message);
    }
  }

  _unmarshallStackframesResult(resultString) {
    let frames = JSON.parse(resultString);
    (0, _invariant.default)(Array.isArray(frames), "Stack frames is not an array");

    for (const frame of frames) {
      (0, _invariant.default)(frame.hasOwnProperty("id"), "Stack frame is missing id");
      (0, _invariant.default)(frame.hasOwnProperty("fileName"), "Stack frame is missing filename");
      (0, _invariant.default)(frame.hasOwnProperty("line"), "Stack frame is missing line number");
      (0, _invariant.default)(frame.hasOwnProperty("column"), "Stack frame is missing column number");
      (0, _invariant.default)(frame.hasOwnProperty("functionName"), "Stack frame is missing function name");
    }

    let result = {
      kind: "stackframe",
      stackframes: frames
    };
    return result;
  }

  _unmarshallScopesResult(resultString) {
    let scopes = JSON.parse(resultString);
    (0, _invariant.default)(Array.isArray(scopes), "Scopes is not an array");

    for (const scope of scopes) {
      (0, _invariant.default)(scope.hasOwnProperty("name"), "Scope is missing name");
      (0, _invariant.default)(scope.hasOwnProperty("variablesReference"), "Scope is missing variablesReference");
      (0, _invariant.default)(scope.hasOwnProperty("expensive"), "Scope is missing expensive");
    }

    let result = {
      kind: "scopes",
      scopes: scopes
    };
    return result;
  }

  _unmarshallVariablesResult(resultString) {
    let variables = JSON.parse(resultString);
    (0, _invariant.default)(Array.isArray(variables), "Variables is not an array");

    for (const variable of variables) {
      (0, _invariant.default)(variable.hasOwnProperty("name"));
      (0, _invariant.default)(variable.hasOwnProperty("value"));
      (0, _invariant.default)(variable.hasOwnProperty("variablesReference"));
    }

    let result = {
      kind: "variables",
      variables: variables
    };
    return result;
  }

  _unmarshallEvaluateResult(resultString) {
    let evalResult = JSON.parse(resultString);
    (0, _invariant.default)(evalResult.hasOwnProperty("kind"), "eval result missing kind property");
    (0, _invariant.default)(evalResult.kind === "evaluate", "eval result is the wrong kind");
    (0, _invariant.default)(evalResult.hasOwnProperty("displayValue", "eval result missing display value property"));
    (0, _invariant.default)(evalResult.hasOwnProperty("type", "eval result missing type property"));
    (0, _invariant.default)(evalResult.hasOwnProperty("variablesReference", "eval result missing variablesReference property"));
    return evalResult;
  }

  _unmarshallBreakpointsAddResult(resultString) {
    let breakpoints = JSON.parse(resultString);
    (0, _invariant.default)(Array.isArray(breakpoints));

    for (const breakpoint of breakpoints) {
      (0, _invariant.default)(breakpoint.hasOwnProperty("filePath"), "breakpoint missing filePath property");
      (0, _invariant.default)(breakpoint.hasOwnProperty("line"), "breakpoint missing line property");
      (0, _invariant.default)(breakpoint.hasOwnProperty("column"), "breakpoint missing column property");
      (0, _invariant.default)(!isNaN(breakpoint.line));
      (0, _invariant.default)(!isNaN(breakpoint.column));
    }

    let result = {
      kind: "breakpoint-add",
      breakpoints: breakpoints
    };
    return result;
  }

  _unmarshallStoppedResult(resultString) {
    let result = JSON.parse(resultString);
    (0, _invariant.default)(result.kind === "stopped");
    (0, _invariant.default)(result.hasOwnProperty("reason"));
    (0, _invariant.default)(result.hasOwnProperty("filePath"));
    (0, _invariant.default)(result.hasOwnProperty("line"));
    (0, _invariant.default)(!isNaN(result.line));
    (0, _invariant.default)(result.hasOwnProperty("column"));
    (0, _invariant.default)(!isNaN(result.column));
    return result;
  }

  _unmarshallReadyResult() {
    let result = {
      kind: "ready"
    };
    return result;
  }

}

exports.MessageMarshaller = MessageMarshaller;
//# sourceMappingURL=MessageMarshaller.js.map

/***/ }),
/* 656 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__656__;

/***/ })
/******/ ]);
});