# Application of the first Futamura Projection on a toy lambda calculus language and an Event-free Synchronous Dataflow

The first half of this project contains a JavaScript interpreter implemented with the help of [Jison](https://github.com/zaach/jison) and [Lex](https://github.com/aaditmshah/lexer). 

Demonstrated the application of the first of three [Futamura projections](https://en.wikipedia.org/wiki/Partial_evaluation) with the help of [Prepack](https://github.com/facebook/prepack) and compares execution times.

The second half is an application of the First Projection on an Event-free Synchronous Dataflow language defined [here](https://github.com/anonymousgithubaccount/EFSD). To run the language in a terminal, some changes were made in [this fork](https://github.com/sanduteo95/EFSD-vis) of the project.

## Toy Lambda Calculus
### What it does
It contains a lexer, parser, interpreter and a first application of the first Futamura projection on the interpreter. 
* The lexer tokenises and checks for incorrect syntax.
* The parser takes a string of code representing a program and produces an abstract syntax tree.
* The interpreter takes a string representing a lambda calculus program and goes through the parse tree generated by the parser to evaluate the value returned by the lambda term.
* The first Futamura projection works based on the interpreter above, by running Prepack on the source code.

### About the language
The toy language is an implementation of lambda calculus, allowing I/O and returning lambda abstractions (i.e. functions in JavaScript). It allows the following:

* Lambda application: `(λx.x+1) @ 1` (evaluates to 1)
* Nested lambda abstractions: `(λx.(λy. x < y)) @ 1 @ 2` (evaluates to `true`)
* Defined lambdas: `let incr = λx.x+1 in (λx. incr @ x) @ 1` (evaluates to 2)
* Exporting abstractions: `let incr = λx. x + 1 in incr`
* Printing: `(λx.print @ x) @ 1` (prints 1 but evaluates to `true`)
* Reading: `(λx.x) @ read` (evaluates to whatever **number** the user has provided)
* Recursion: `let rec f = λx. λsum. (x < 10 && (f @ (x + 1)) @ (sum + x)) || sum in (f @ 1) @ 0`  (evaluates to 45)

## Event-free Synchronous Dataflow 
### What it does
Bundles the online visualiser implemented [here](https://github.com/sanduteo95/EFSD-vis), which is the simplified, non-UI version of [EFSD-vis](https://github.com/anonymousgithubaccount/EFSD-vis). Takes in the `Require.js` framework used to implemented the visualiser of the Event-free Synchronous Dataflow language and uses Webpack to convert it into `UMD` compatible code, which can be run from a terminal.

### About the language
For a description of the language syntax read [this README](https://github.com/anonymousgithubaccount/EFSD-vis/blob/master/README.md). Modifications have been made to the original visualiser to allow linking between compiled abstractions and constants, as well as the addition of trampolines to speed up the interpreter.

To be able to run the EFSD, clone the [EFSD-vis](https://github.com/sanduteo95/EFSD-vis) repository in the same folder you have cloned this repository. You may also need [EFSD](https://github.com/anonymousgithubaccount/EFSD), the OCaml implementation of the Event-free Synchronous Dataflow language, if you plan on running the benchmarks. Make sure to follow the instructions in that repo and run `make` in the cloned folder to build the library if so.

## Local development instructions
Run `npm run install` and then run the program following the instructions bellow:

`node index.js -V` - to return the version of the tool

`node index.js -h` - to return possible options for running the tool

`node index.js -p <pathToFile>` - to print out the parse tree for the provided file

`node index.js -i [-d] [-s value] <pathToFile>` - to return the result of interpreter on the provided file

`node index.js -f [-d] [-s value] <pathToFile>` - to return the result of applying the first Futamura projection on the provided file

Optional flags are:
* `-d`: to allow debugging log
* `-s value`: to set up the maximum number of consecutive recursive calls allowed
* `-g`: to run on the GoI Machine used in the Event-free Synchronous Dataflow framework

In case of `RangeError: Maximum call stack size exceeded` errors, add a `--stack-size=<value>` to the command. 
i.e. `node --stack-size=100000 index.js -i <pathToFile>`

The results can be tested out with various `-s` options passed through and analysed by looking in the `output` folder.

For example, running `node --stack-size=100000 index.js -i input/toyLambda/church.lambda -s 600` shows how the first projection is able to return the final result of the church encoding calculations. 

**NB**
When testing the EFSD, some examples might use more heap memory than Node copes with normally. In case that happens, run the command with `--max-old-space-size=120000`.

### Other scripts
`npm run test`: tests the two interpreters
`npm run test-lambda`: tests the toy lambda interpreter
`npm run test-efsd`: tests the EFSD interpreter
`npm run create-lambda-report`: runs the benchmarks on the toy lambda interpreter
`npm run create-efsd-report`: runs the benchmarks on the EFSD interpreter
`npm run term-goi-machine`: re-bundles the EFSD interpreter (use it if you have made changes to `EFSD-vis`)

## How to run it
Install `futamura-js` globally by running `npm install -g futamura-js` and then type in `futamura-js --help` to see what options there are. 

## How to get execution time
There is a script used to calculate execution time of individual files. To run it, open a terminal and type:
```
$ sh ./scripts/time.bash <mode> <file> <stackValue>
```
where:
- `<mode>` can be either `-i` (for intepreter), `-f` (for the First Futamura Projection) or `-o` (for the ocaml EFSD)
- `<file>` needs to be the whole name (including extension) in folders `./input/toyLambda` or `./input/EFSD`
- `<stackValue>` represents the value normally given to the tool

To generate a report comparing the execution time of the interpreter versus the execution time of the First Futamura Projection run either: `npm run create-lambda-report` or `npm run create-efsd-report` and a HTML report will be generated inside `./report/toyLambda` and `./report/EFSD` respectively.

[Toy Lambda Calculus](https://git-teaching.cs.bham.ac.uk/mod-ug-proj-2018/tas458/blob/master/report/toyLambda/index.html)

[Event-free Synchronous Dataflow](https://git-teaching.cs.bham.ac.uk/mod-ug-proj-2018/tas458/blob/master/report/EFSD/index.html)