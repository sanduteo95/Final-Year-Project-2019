# Application of the First Futamura Projection and comparison of execution times

This project explores the application of the First Futamura Projection (see [here](https://arxiv.org/abs/1611.09906) for an explanation) on a toy lambda calculus language and then on the Event-free Synchronous Dataflow programming paradigm implemented [here](https://git.cs.bham.ac.uk/wtc488/itf-impl) and explained in more detail [here](https://dl.acm.org/citation.cfm?id=3209127).

Thus, the first half of this project contains a JavaScript interpreter implemented with the help of [Jison](https://github.com/zaach/jison) and [Lex](https://github.com/aaditmshah/lexer) and demonstrates the application of the first of three Futamura Projections with the help of [Prepack](https://github.com/facebook/prepack). Finally, it contains a tool to run a set of benchmarks tests and compare the execution time of the interpreter versus the execution time of the result of the First Futamura Projection.  Due to Prepack limitations (i.e. unrolls all loops without the ability to stop early and inlines all function calls), the attempt failed. The interpreter is implemented recursively and uses trampolines to avoid stack overflows. For the non tail-recursive intepreter, see [this branch](https://git-teaching.cs.bham.ac.uk/mod-ug-proj-2018/tas458/tree/recursiveInterpreter).

The second half of the project is an application of the First Projection on an Event-free Synchronous Dataflow programming paradigm implemented [here](https://git.cs.bham.ac.uk/wtc488/itf-impl) in various languages and forms. One of these is as a JavaScript visualiser, which simulates the behaviour via graph visualisations and provides a step by step run through various examples. To run the language in a terminal, some changes had to be made to the code in the `Visualiser` folder and pushed to a separate branch, [vis-term](https://git.cs.bham.ac.uk/wtc488/itf-impl/tree/vis-term/Visualiser) so that all UI functionality was removed and we could call the resulting interpeter from `Node.js`. The resulting code is an interpreter for a language which is defined in the original repository, which is then specialised to its input with the help of the First Futamura Projection in this repo.

For more information on each project, continue reading.

## 1. Toy Lambda Calculus
### What it does
It contains a lexer, parser, interpreter and an application of the First and Second Futamura projections on the interpreter. 
* The lexer tokenises and checks for incorrect syntax.
* The parser takes a string of code representing a program and produces an abstract syntax tree.
* The interpreter takes a string representing a lambda calculus program and goes through the parse tree generated by the parser to evaluate the value returned by the lambda term.
* The first Futamura projection works based on the interpreter above, by running Prepack on the source code.
* The second Futamura projection has been attempted in two ways: by running Prepack on a bundle of Prepack and the interpreter (which fails due to Prepack limitation), or by running Google Closure on a bundle of Prepack and the interpreter.

### About the language
The toy language is an implementation of lambda calculus, allowing I/O and returning lambda abstractions (i.e. functions in JavaScript). It allows the following:

* Lambda application: `(λx.x+1) @ 1` (evaluates to 1)
* Nested lambda abstractions: `(λx.(λy. x < y)) @ 1 @ 2` (evaluates to `true`)
* Defined lambdas: `let incr = λx.x+1 in (λx. incr @ x) @ 1` (evaluates to 2)
* Exporting abstractions: `let incr = λx. x + 1 in incr`
* Printing: `(λx.print @ x) @ 1` (prints 1 but evaluates to `true`)
* Reading: `(λx.x) @ read` (evaluates to whatever **number** the user has provided)
* Recursion: `let rec f = λx. λsum. (x < 10 && (f @ (x + 1)) @ (sum + x)) || sum in (f @ 1) @ 0`  (evaluates to 45)

The result of the First Futamura Projection is a much quicker run of the original code, as can be observed by running the benchmarks.

## Event-free Synchronous Dataflow 
### What it does
Bundles the online visualiser implemented [here](https://git.cs.bham.ac.uk/wtc488/itf-impl/tree/vis-term/Visualiser), which is the simplified, non-UI version of [EFSD-vis](https://git.cs.bham.ac.uk/wtc488/itf-impl/tree/master/Visualiser). Takes in the `Require.js` framework used to implement the visualiser of the Event-free Synchronous Dataflow paradigm and uses `Webpack` to convert it into `commonjs2` compatible code, which can be run from a terminal.

### About the language
For a description of the language syntax read [this README](https://git.cs.bham.ac.uk/wtc488/itf-impl/tree/master/Visualiser/README.md). Modifications have been made to the original visualiser to allow linking between compiled abstractions and constants, as well as the addition of trampolines to speed up the interpreter and avoid stack overflows.

To be able to run the EFSD, clone the mentioned repository in the same folder you have cloned this repository. You may also need [EFSD](https://github.com/sanduteo95/EFSD), the OCaml implementation of the Event-free Synchronous Dataflow language [ITF-impl](https://git.cs.bham.ac.uk/wtc488/itf-impl), if you plan on running the benchmarks. Make sure to follow the instructions in those repos and run `make` in the cloned folders to build the library if so.

Amongst the examples available in the `./input/EFSD` folder there are eleven "simple" programs displaying the capabilities of the EFSD paradigm, as well as a reimplementation of the examples available in [this](https://github.com/DecML/decml-ppx) repo. The latter set of examples can be found in folder `./input/EFSD/DecML` and display the capabilities of the graph abstraction functionality of the EFSD framework. The neural networks implemented in that folder train on the datasets found in `./util/data`.

## Local development instructions
Run `npm install` and then run the program following the instructions bellow:

`node index.js -V` - to return the version of the tool

`node index.js -h` - to return possible options for running the tool

`node index.js -p <pathToFile>` - to print out the parse tree for the provided lambda file

`node index.js -i [-d] [-s value] <pathToFile> [-g]` - to return the result of the interpreter on the provided file

`node index.js -t <pathToFile> [-g]` - to compile the code using the compiler generated by the Second Futamura Projection

`node index.js -1 [-d] [-s value] <pathToFile> [-g] [-c number]` - to return the result of applying the First Futamura projection on the provided file

`node index.js -2 [-g]` - to return the result of applying the Second Futamura projection on the provided file

`node index.js -r [-c] [-g]` - to run the benchmarks and generate a report of execution times (keep in mind that if your laptop goes to sleep, the tests won't be accurate; use `npm run create-<>-report` bellow if running on MacOS and have `caffeinate` installed)

Optional flags are:
* `-d`: to allow debugging log
* `-s value`: to set up the maximum number of consecutive recursive calls allowed
* `-g`: to run on the GoI Machine used by the Event-free Synchronous Dataflow paradigm
* `-c number`: to run the Futamura Projections using Closure, using startegy number:
    * `1`: just the Closure Compiler
    * `2`: the Closure Compiler, followed by Prepack
    * `3`: Prepack, follwed by the Closure Compiler
    * `4`: the Closure Compiler, follwed by Prepack, followed by the Closure Compiler
    * `5`: Prepack, followed by the Closure Compiler, followed by Prepack

**NB**
In case of `RangeError: Maximum call stack size exceeded` errors, add a `--stack-size=<value>` to the command. 
i.e. `node --stack-size=100000 index.js -<i|f> <pathToFile> [-g]`

When testing the EFSD, some examples might use more heap memory than Node copes with normally. In case that happens, run the command with `--max-old-space-size=120000`.
i.e. `node --max-old-space-size=120000 index.js -<i|f> <pathToFile> [-g]`

### Other scripts
`npm run test`: tests the two interpreters

`npm run test-lambda`: tests the toy lambda interpreter

`npm run test-efsd`: tests the EFSD interpreter

`npm create-report`: runs the benchmarks on both interpreters

`npm run create-lambda-report`: runs the benchmarks on the toy lambda interpreter (gets the average of 5 tests)

`npm run create-efsd-report`: runs the benchmarks on the EFSD interpreter (gets the average of 5 tests)

`npm run term-goi-machine`: re-bundles the EFSD interpreter (use it if you have made changes to `itf-impl/Visualiser` in b branch `vis-term`)

## How to get the execution time
There is a script used to calculate execution time of individual files. To run it, open a terminal and type:
```
$ chmod +x ./scripts/time.bash
$ ./scripts/time.bash <mode> <file> [stackValue]
```
where:
- `<mode>` can be either `-i` (for intepreter), `-f` (for the First Futamura Projection), `-o` (for the OCaml implementation), or `-a` (for the Agda implementation)
- `<file>` needs to be the whole name (including extension) in folders `./input/toyLambda` or `./input/EFSD`
- `[stackValue]` represents the value normally given to the tool when running the interpreter or the first Futamura Projection (125 by default)

## How to run benchmarks and generate report
To generate a report comparing the execution time of the interpreter versus the execution time of the First Futamura Projection run either: `npm run create-lambda-report` or `npm run create-efsd-report` and a HTML report will be generated inside `./report/toyLambda` and `./report/EFSD` respectively.

The two available reports are:
- [Toy Lambda Calculus](./report/toyLambda/index.html),
- [Event-free Synchronous Dataflow](./report/EFSD/index.html).

Open them in a browser to view results.

In addition, the combination of [Prepack](https://github.com/facebook/prepack) with the [Closure Compiler](https://github.com/google/closure-compiler) was explored, in various forms and orders. As a result, the First Futamura Projection can be applied by combining the two optimisation tools (the former focusing on shortening execution time, and the latter on minimising the size of the code). To run the benchmarks and compare the various executions times of the various combination strategies, run `npm run create-strategy-report` and, once again, a report will be generated inside `./report/strategy`. 

The available report is:
- [Strategy report](./report/strategy/index.html).

### Repo structure
```
.
+-- _input
|   +-- _EFSD // where to place EFSD examples
|   |   +-- _DecML
|   |   |   +-- *.efsd
|   |   +-- *.efsd
|   +-- _toyLambda // where to place toyLambda examples
|   |   +-- *.lambda
+-- _lib
|   +-- _EFSD
|   |   +-- _term // the EFSD interpreter
|   |   +-- _UI // tests with Prepack and the visualiser
|   +-- _prepack // code for the second Futamura Projection
|   +-- _report // code for generating benchmark reports
|   +-- _toyLambda // the toy lambda calculus interpreter (and generated compiler)
|   +-- futamura.js // the application of the Futamura Projections
+-- _output // generated JavaScript code of the examples in _input
|   +-- _EFSD
|   |   +-- *.js
|   +-- _toyLambda
|   |   +-- *.js
+-- _report
|   +-- _EFSD
|   +-- _strategy
|   +-- _toyLambda
+-- _scripts // scripts used for running tests before committing code and timing individual commands
|   +-- *.bash 
+-- _test
|   +-- EFSD.js
|   +-- toyLambda.js
+-- _util
|   +-- _data // contains datasets for DecML examples
|   +-- _linker // contains two examples of how a linker would be implemented for the two languages
|   |   +-- EFSD.js
|   |   +-- toyLambda.js
|   +-- common.efsd // contains some common functions used throughout the EFSD examples
|   +-- convertCSV.js // script to convert CSV datasets to EFSD syntax
+-- index.js
```

### How to install
There is a script provided in `./scripts/setup.bash`. Run the following in a terminal:

```
$ chmod +x ./scripts/setup.bash
$ ./scripts/setup.bash
``` 

Or, if that doesn't work, follow the steps below: 
1. Clone this repo.
2. Install Node.js `v8.15.0` following instructions [here](https://nodejs.org/en/download/package-manager).
3. Change directory into this repo.
4. Run `npm install`.
5. Change directory into the folder above this one.
6. Clone the following two repos: [EFSD](https://github.com/sanduteo95/EFSD) and [itf-impl](https://git.cs.bham.ac.uk/wtc488/itf-impl) so that the folder structure is:
```
+-- _EFSD
+-- _itf-impl
+-- _tas458
```
7. Change directory into `EFSD`.
8. Install Ocaml `4.05.0` using OPAM following instructions [here](http://www.ocaml.org/docs/install.html).
9. Run `opam depext conf-m4.1` to install [m4](https://www.gnu.org/software/m4/).
10. Install the following dependencies using `opam`:
- `utop` 
- `core`
- `ppx_tools`
- `incremental`
- `js_of_ocaml`
- `js_of_ocaml-ppx`
- `js_of_ocaml-lwt`
11. Run make inside `EFSD`.
12. Change directory into `itf-impl`.
13. Install Agda `2.5.4.2` and the standard library following instructions [here](https://agda.readthedocs.io/en/v2.5.4.2/getting-started/installation.html).
14. Run make inside `itf-impl/Agda`.
15. Change directory into this repo: `cd ../../tas458`.

Now you can run the benchmarks and time the visualiser, OCaml implementation and Agda implementation using the `./scripts/time.bash` script.