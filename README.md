# Application of the First Futamura Projection and comparison of execution times

This project explores the application of the First Futamura Projection (see [here](https://arxiv.org/abs/1611.09906) for an explanation) on a toy lambda calculus language and then on the Event-free Synchronous Dataflow programming paradigm implemented [here](https://github.com/anonymousgithubaccount/EFSD) and visualised [here](https://github.com/anonymousgithubaccount/EFSD-vis).

Thus, the first half of this project contains a JavaScript interpreter implemented with the help of [Jison](https://github.com/zaach/jison) and [Lex](https://github.com/aaditmshah/lexer) and it demonstrated the application of the first of three Futamura Projections with the help of [Prepack](https://github.com/facebook/prepack). Finally, it contains a tool to run a set of benchmarks tests and compare the execution time of the interpreter versus the execution time of the result of the First Futamura Projection. For an attempt at the Second Futamura Projection, see [this branch](https://git-teaching.cs.bham.ac.uk/mod-ug-proj-2018/tas458/tree/secondProj). The interpreter is implemented recursively and uses trampolines to avoid stack overflows. For the non tail-recursive intepreter, see [this branch](https://git-teaching.cs.bham.ac.uk/mod-ug-proj-2018/tas458/tree/recursiveInterpreter).

The second half of the project is an application of the First Projection on an Event-free Synchronous Dataflow programming paradigm defined [here](https://github.com/anonymousgithubaccount/EFSD) and visualised [here](https://github.com/anonymousgithubaccount/EFSD-vis). To run the language in a terminal, some changes were made in [this fork](https://github.com/sanduteo95/EFSD-vis) of the original visualiser project. The resulting code is an interpreter for a language which is defined in the original repository, which can be specialised to its input with the help of the First Futamura Projection.

For more information on each project, continue reading.

## 1. Toy Lambda Calculus
### What it does
It contains a lexer, parser, interpreter and an application of the First Futamura projection on the interpreter. 
* The lexer tokenises and checks for incorrect syntax.
* The parser takes a string of code representing a program and produces an abstract syntax tree.
* The interpreter takes a string representing a lambda calculus program and goes through the parse tree generated by the parser to evaluate the value returned by the lambda term.
* The first Futamura projection works based on the interpreter above, by running Prepack on the source code.

### About the language
The toy language is an implementation of lambda calculus, allowing I/O and returning lambda abstractions (i.e. functions in JavaScript). It allows the following:

* Lambda application: `(λx.x+1) @ 1` (evaluates to 1)
* Nested lambda abstractions: `(λx.(λy. x < y)) @ 1 @ 2` (evaluates to `true`)
* Defined lambdas: `let incr = λx.x+1 in (λx. incr @ x) @ 1` (evaluates to 2)
* Exporting abstractions: `let incr = λx. x + 1 in incr`
* Printing: `(λx.print @ x) @ 1` (prints 1 but evaluates to `true`)
* Reading: `(λx.x) @ read` (evaluates to whatever **number** the user has provided)
* Recursion: `let rec f = λx. λsum. (x < 10 && (f @ (x + 1)) @ (sum + x)) || sum in (f @ 1) @ 0`  (evaluates to 45)

The result of the First Futamura Projection is a much quicker run of the original code, as can be observed by running the benchmarks.

## Event-free Synchronous Dataflow 
### What it does
Bundles the online visualiser implemented [here](https://github.com/sanduteo95/EFSD-vis), which is the simplified, non-UI version of [EFSD-vis](https://github.com/anonymousgithubaccount/EFSD-vis). Takes in the `Require.js` framework used to implement the visualiser of the Event-free Synchronous Dataflow paradigm and uses `Webpack` to convert it into `UMD` compatible code, which can be run from a terminal.

### About the language
For a description of the language syntax read [this README](https://github.com/anonymousgithubaccount/EFSD-vis/blob/master/README.md). Modifications have been made to the original visualiser to allow linking between compiled abstractions and constants, as well as the addition of trampolines to speed up the interpreter and avoid stack overflows.

To be able to run the EFSD, clone the [EFSD-vis](https://github.com/sanduteo95/EFSD-vis) repository in the same folder you have cloned this repository. You may also need [EFSD](https://github.com/sanduteo95/EFSD), the OCaml implementation of the Event-free Synchronous Dataflow language [ITF-impl](https://git.cs.bham.ac.uk/wtc488/itf-impl), if you plan on running the benchmarks. Make sure to follow the instructions in those repos and run `make` in the cloned folders to build the library if so.

## Local development instructions
Run `npm install` and then run the program following the instructions bellow:

`node index.js -V` - to return the version of the tool

`node index.js -h` - to return possible options for running the tool

`node index.js -p <pathToFile>` - to print out the parse tree for the provided lambda file

`node index.js -i [-d] [-s value] <pathToFile> [-g]` - to return the result of the interpreter on the provided file

`node index.js -f [-d] [-s value] <pathToFile> [-g] [-c number]` - to return the result of applying the First Futamura projection on the provided file

`node index.js -r [-g]` - to run the benchmarks and generate a report of execution times (keep in mind that if your laptop goes to sleep, the tests won't be accurate; use `npm run create-<>-report` bellow if running on MacOS and have `caffeinate` installed)

Optional flags are:
* `-d`: to allow debugging log
* `-s value`: to set up the maximum number of consecutive recursive calls allowed
* `-g`: to run on the GoI Machine used by the Event-free Synchronous Dataflow paradigm
* `-c number`: to run the Futamura Projections using Closure, using startegy number:
    * `1`: just the Closure Compiler
    * `2`: the Closure Compiler, followed by Prepack
    * `3`: Prepack, follwed by the Closure Compiler
    * `4`: the Closure Compiler, follwed by Prepack, followed by the Closure Compiler
    * `5`: Prepack, followed by the Closure Compiler, followed by Prepack

**NB**
In case of `RangeError: Maximum call stack size exceeded` errors, add a `--stack-size=<value>` to the command. 
i.e. `node --stack-size=100000 index.js -<i|f> <pathToFile> [-g]`

When testing the EFSD, some examples might use more heap memory than Node copes with normally. In case that happens, run the command with `--max-old-space-size=120000`.
i.e. `node --max-old-space-size=120000 index.js -<i|f> <pathToFile> [-g]`

### Other scripts
`npm run test`: tests the two interpreters

`npm run test-lambda`: tests the toy lambda interpreter

`npm run test-efsd`: tests the EFSD interpreter

`npm create-report`: runs the benchmarks on both interpreters

`npm run create-lambda-report`: runs the benchmarks on the toy lambda interpreter (gets the average of 5 tests)

`npm run create-efsd-report`: runs the benchmarks on the EFSD interpreter (gets the average of 5 tests)

`npm run term-goi-machine`: re-bundles the EFSD interpreter (use it if you have made changes to `EFSD-vis`)

## How to get the execution time
There is a script used to calculate execution time of individual files. To run it, open a terminal and type:
```
$ sh ./scripts/time.bash <mode> <file> <stackValue>
```
where:
- `<mode>` can be either `-i` (for intepreter), `-f` (for the First Futamura Projection) or `-o` (for the ocaml EFSD)
- `<file>` needs to be the whole name (including extension) in folders `./input/toyLambda` or `./input/EFSD`
- `<stackValue>` represents the value normally given to the tool

## How to run benchmarks and generate report
To generate a report comparing the execution time of the interpreter versus the execution time of the First Futamura Projection run either: `npm run create-lambda-report` or `npm run create-efsd-report` and a HTML report will be generated inside `./report/toyLambda` and `./report/EFSD` respectively.

The two available reports are:
- [Toy Lambda Calculus](./report/toyLambda/index.html),
- [Event-free Synchronous Dataflow](./report/EFSD/index.html).
Open them in a browser to view results.