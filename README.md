# Compiling a Functional Dataflow Language using the Futamura Projections

This project explores the application of the First Futamura Projection (see [here](https://arxiv.org/abs/1611.09906) for an explanation) on a toy lambda calculus language and then on the Signal-less Synchronous Dataflow programming paradigm implemented [here](https://git.cs.bham.ac.uk/wtc488/itf-impl).

Thus, the first half of this project contains a JavaScript interpreter implemented with the help of [Jison](https://github.com/zaach/jison) and [Lex](https://github.com/aaditmshah/lexer) and demonstrates the application of the first of three Futamura Projections with the help of [Prepack](https://github.com/facebook/prepack). Finally, it contains a tool to run a set of benchmarks tests and compare the execution time of the interpreter versus the execution time of the result of the First Futamura Projection. The interpreter is implemented recursively and uses trampolines to avoid stack overflows. For the non tail-recursive intepreter, see [this branch](https://git-teaching.cs.bham.ac.uk/mod-ug-proj-2018/tas458/tree/recursiveInterpreter).

The second half of the project is an application of the Futamura Projections on an Signal-less Synchronous Dataflow programming paradigm implemented [here](https://git.cs.bham.ac.uk/wtc488/itf-impl) in various languages and forms. One of these is as a JavaScript visualiser, which simulates the behaviour via graph visualisations and provides a step by step run through various examples. To run the language in a terminal, the [vis-term](https://git.cs.bham.ac.uk/wtc488/itf-impl/tree/vis-term/Visualiser) branch is used to generate an interpreter that can be called from `Node.js`.

For more information on each project, see [Toy Lambda Calculus](./lib/toyLambda/README.md) and [Signal-less Synchronous Dataflow](./lib/SSD/README.md).

## CLI tool
`node index.js -V` - to return the version of the tool

`node index.js -h` - to return possible options for running the tool

`node index.js -p <pathToFile>` - to print out the parse tree for the provided lambda file

`node index.js -i [-d] [-s value] <pathToFile> [-g]` - to return the result of the interpreter on the provided file

`node index.js -c <pathToFile> [-g]` - to compile the code using the compiler generated by the Second Futamura Projection

`node index.js -1 [-d] [-s value] <pathToFile> [-g] [-o number]` - to return the result of applying the First Futamura projection on the provided file

`node index.js -2 [-g]` - to return the result of applying the Second Futamura projection on the provided file

`node index.js -r [-o] [-g]` - to run the benchmarks and generate a report of execution times (keep in mind that if your laptop goes to sleep, the tests won't be accurate; use `npm run create-<>-report` bellow if running on MacOS and have `caffeinate` installed)

Optional flags are:
* `-d`: to allow debugging log
* `-s value`: to set up the maximum number of consecutive recursive calls allowed
* `-g`: to run on the GoI Machine used by the Event-free Synchronous Dataflow paradigm
* `-o number`: to run the Futamura Projections using the Closure option, with startegy number:
    * `1`: just the Closure Compiler
    * `2`: the Closure Compiler, followed by Prepack
    * `3`: Prepack, follwed by the Closure Compiler
    * `4`: the Closure Compiler, follwed by Prepack, followed by the Closure Compiler
    * `5`: Prepack, followed by the Closure Compiler, followed by Prepack

**NB**
In case of `RangeError: Maximum call stack size exceeded` errors, add a `--stack-size=<value>` to the command. 
i.e. `node --stack-size=100000 index.js -<i|f> <pathToFile> [-g]`

When testing the SSD, some examples might use more heap memory than Node copes with normally. In case that happens, run the command with `--max-old-space-size=120000`.
i.e. `node --max-old-space-size=120000 index.js -<i|f> <pathToFile> [-g]`

## Local development

### How to install
To use the command line tool, not including the benchmarks, just run `npm run install` in a terminal.

Otherwise, there is a script provided in `./scripts/setup.bash`. Run the following in a terminal:

```
$ chmod +x ./scripts/setup.bash
$ ./scripts/setup.bash
``` 

Or, if that doesn't work, follow the steps below: 
1. Clone this repo.
2. Install Node.js `v8.15.0` following instructions [here](https://nodejs.org/en/download/package-manager).
3. Change directory into this repo.
4. Run `npm install`.
5. Change directory into the folder above this one.
6. Clone the following two repos: [EFSD](https://github.com/sanduteo95/EFSD) and [itf-impl](https://git.cs.bham.ac.uk/wtc488/itf-impl) so that the folder structure is:
```
+-- _EFSD
+-- _itf-impl
+-- _tas458
```
7. Change directory into `EFSD`.
8. Install Ocaml `4.05.0` using OPAM following instructions [here](http://www.ocaml.org/docs/install.html).
9. Run `opam depext conf-m4.1` to install [m4](https://www.gnu.org/software/m4/).
10. Install the following dependencies using OPAM:
- `utop` 
- `core`
- `ppx_tools`
- `incremental`
- `js_of_ocaml`
- `js_of_ocaml-ppx`
- `js_of_ocaml-lwt`
11. Run make inside `EFSD`.
12. Change directory into `itf-impl`.
13. Install Agda `2.5.4.2` and the standard library following instructions [here](https://agda.readthedocs.io/en/v2.5.4.2/getting-started/installation.html).
14. Run make inside `itf-impl/Agda`.
15. Change directory into this repo: `cd ../../tas458`.

Now you can run the benchmarks and time the visualiser, OCaml implementation and Agda implementation using the `./scripts/time.bash` script.

### How to get the execution time
There is a script used to calculate execution time of individual files. To run it, open a terminal and type:
```
$ chmod +x ./scripts/time.bash
$ ./scripts/time.bash <mode> <file> [stackValue]
```
where:
- `<mode>` can be either `-i` (for intepreter), `-f` (for the First Futamura Projection), `-o` (for the OCaml implementation), or `-a` (for the Agda implementation)
- `<file>` needs to be the whole name (including extension) in folders `./input/toyLambda` or `./input/SSD`
- `[stackValue]` represents the value normally given to the tool when running the interpreter or the first Futamura Projection (125 by default)

### How to run benchmarks and generate report
To generate a report comparing the execution time of the interpreter versus the execution time of the First Futamura Projection run either: `npm run create-lambda-report` or `npm run create-ssd-report` and a HTML report will be generated inside `./report/toyLambda` and `./report/SSD` respectively.

The two available reports are:
- [Toy Lambda Calculus](./report/toyLambda/index.html),
- [Event-free Synchronous Dataflow](./report/SSD/index.html).
- [Event-free Synchronous Dataflow: Machine Learning](./report/ML/index.html).

Open them in a browser to view results.

In addition, the combination of [Prepack](https://github.com/facebook/prepack) with the [Closure Compiler](https://github.com/google/closure-compiler) was explored, in various forms and orders. As a result, the First Futamura Projection can be applied by combining the two optimisation tools (the former focusing on shortening execution time, and the latter on minimising the size of the code). To run the benchmarks and compare the various executions times of the various combination strategies, run `npm run create-strategy-report` and, once again, a report will be generated inside `./report/strategy`. 

The available report is:
- [Strategy report](./report/strategy/index.html).

### Development scripts:
- `npm run test`: tests the two interpreters
- `npm run test-lambda`: tests the toy lambda interpreter
- `npm run test-ssd`: tests the SSD interpreter
- `npm run test-cli`: tests the CLI tool
- `npm run create-report`: runs the benchmarks on both interpreters
- `npm run create-lambda-report`: runs the benchmarks on the toy lambda interpreter (gets the average of 5 tests)
- `npm run create-ssd-report`: runs the benchmarks on the SSD interpreter (gets the average of 5 tests)
- `npm run term-goi-machine`: re-bundles the SSD interpreter (use it if you have made changes to `../itf-impl/Visualiser` in branch `vis-term`)
- `npm run build-prepack`: re-bundles the toyLambda and SSD compilers (use it if you have made changes to `./lib/toyLambda` or `../itf-impl/Visualiser` in branch `vis-term`)

### Repo structure
```
.
+-- _input
|   +-- _SSD // where to place SSD examples
|   |   +-- _ML
|   |   |   +-- *.ssd
|   |   +-- *.ssd
|   +-- _toyLambda // where to place toyLambda examples
|   |   +-- *.lambda
+-- _lib
|   +-- _SSD // the SSD interpreter
|   |   +-- _UI // experiments with Prepack and the visualiser
|   |   +-- compiler.js
|   |   +-- interpreter.js
|   +-- _prepack // code for the second Futamura Projection
|   +-- _report // code for generating benchmark reports
|   +-- _toyLambda // the toy lambda calculus interpreter (and generated compiler)
|   |   +-- compiler.js
|   |   +-- interpreter.js
|   |   +-- parser.js
|   +-- boilerplate.js // helper functions
|   +-- futamura.js // the application of the Futamura Projections
+-- _output // generated JavaScript code of the examples in _input
|   +-- _SSD
|   |   +-- _ML
|   |   |   +-- *.js
|   |   +-- *.js
|   +-- _toyLambda
|   |   +-- *.js
+-- _report
|   +-- _SSD
|   +-- _strategy
|   +-- _toyLambda
+-- _scripts // scripts used for running tests before committing code and timing individual commands
|   +-- *.bash 
+-- _test
|   +-- index.js
|   +-- SSD.js
|   +-- toyLambda.js
+-- _util
|   +-- _linker // contains two examples of how a linker would be implemented for the two languages
|   |   +-- SSD.js
|   |   +-- toyLambda.js
|   +-- common.ssd // contains some common functions used throughout the SSD examples
+-- index.js
```