let pair = λx.λy.λp. p x y in
let fst = λp.p (λx.λy.x) in
let snd = λp.p (λx.λy.y) in

let nil = pair true true in
let isnil = fst2 in
let cons = λh.λt. pair false (pair h t) in
let head = λz. fst (snd z) in
let tail = λz. snd (snd z) in

let data = 
in

let square = λx. x * x in

let is_outside_boundary = λbound_1. λbound_2.λ datapoint
	let x = fst datapoint in 
    let y = snd datapoint in
	let y_1 = bound_1 x in
	let y_2 = bound_2 x in
	(y_1 < y && y_2 < y) || (y_1 > y && y_2 > y)
in

let measure_line_distance = λfunc. λdata.
	let datapoint = fst (getNeth 0 data) in

	let model_output = func datapoint in
	let first_boundary_y = fst model_output in
	let second_boundary_y = snd model_output in

	sqrt (abs ((square first_boundary_y) - (square second_boundary_y)))


let ci_loss_function = λfunc. λdata.
	let bound_1 = λx. (fst (func x)) in
	let bound_2 = λx. (snd (func x)) in

	let points_outside_boundary = filter (is_outside_boundary bound_1 bound_2) data in

	let mse_1 = mse_loss_function bound_1 points_outside_boundary in
	let mse_2 = mse_loss_function bound_2 points_outside_boundary in

	let avg_mse = (mse_1 + mse_2) / 2 in
	let distance = measure_line_distance func data in
	avg_mse + (square distance)
in


let a = 1 in
let m_1 = 1 in
let m_2 = 0 in 

let f = λx. pair (a * x + m_1) (a * x + m_2) in
let p = cons m_1 (cons m_2 nil) in

let learning_rate = 1/1000 in
let epochs = 5000 in
let updated_params = gradient_descent f p ci_loss_function data learning_rate epochs in
f updated_params
