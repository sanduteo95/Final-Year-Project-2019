let pair = λx.λy.λp. p x y in
let fst = λp.p (λx.λy.x) in
let snd = λp.p (λx.λy.y) in

let nil = pair true true in
let isnil = fst in
let cons = λh.λt. pair false (pair h t) in
let head = λz. fst (snd z) in
let tail = λz. snd (snd z) in

let make' = rec f. λlen. λval.
    if len <= 0 && 0 <= len 
    then 
        nil
    else
        cons {val} (f (len - 1) val)
in

let create_matrix = rec f. λn. λm. λval.
    if n <= 0 && 0 <= n 
    then
        nil
    else
        cons (make' m val) (f (n - 1) m val)
in

let add = rec f. λi. λelem. λls.
    if isnil ls
    then 
        cons elem nil
    else
        if i <= 0 && 0 <= i 
        then 
            cons elem ls 
        else
            cons (head ls) (f (i - 1) elem (tail ls))
in

let compute_partial_derivative = λmodel. λparameters. λloss_function. λk. λvalue. λdatapoint.
    let h = 0.00001 in
    let params_plus = add k (value + h) parameters in
    let params_minus = add k (value - h) parameters in
    let cost_function_value_plus = loss_function (model params_plus) (cons datapoint nil) in
    let cost_function_value_minus = loss_function (model params_minus) (cons datapoint nil) in
    (cost_function_value_plus - cost_function_value_minus) / (2 * h)
in

let model = λparameters. λx. (head parameters) * 2 + x in 

let loss_function = λfunc. λvals. func (head vals) - 3 in

let mse_datapoint_loss = λfunc. λdatapoint.
    let (x , y) = datapoint in
    let error = y - (func x) in
    square error
in

let mse_loss_function = λfunc. λdata.
    let data_length = length data in    
    if data_length <= 0 && 0 <= data_length
    then
        0
    else
        let sum_terms = map (mse_datapoint_loss func) data in
        let sum = fold (λa. λb. a + b) 0 sum_terms in
        let n = length data in
        (1 / (2 * n)) * sum
in

let filter = λf. λv. 
    let aux = rec g. λx.
        if (isnil x)
        then
            nil
        else
            let hd = head x in
            if (f hd)
            then
                cons hd (g (tail x))
            else
                g (tail x)
    in aux v
in

let fold = rec g. λf. λacc. λx.
  if isnil x 
  then
    acc
  else
    g f (f acc (head x)) (tail x)
in

let map = λf. λx.
    let aux = rec g. λx.
        if isnil x 
        then
            nil
        else
            cons (f (head x)) (g (tail x))
    in aux x
in

let length = λx.
	let aux = rec g. λacc. λx.
		if isnil x
		then 
			acc
		else
			g (acc + 1) (tail x)
	in aux 0 x
in

let square = λx. x * x in

let mse_datapoint_loss = λfunc. λdatapoint.
    let (x , y) = datapoint in
    let error = y - (func x) in
    square error
in

let mse_loss_function = λfunc. λdata.
    let data_length = length data in    
    if data_length <= 0 && 0 <= data_length
    then
        0
    else
        let sum_terms = map (mse_datapoint_loss func) data in
        let sum = fold (λa. λb. a + b) 0 sum_terms in
        (1 / (2 * data_length)) * sum
in

let mapi = λf. λx.
    let aux = rec g. λi. λx.
        if isnil x 
        then
            nil
        else
            cons (f i (head x)) (g (i + 1) (tail x))
    in aux 0 x
in

let update_parameters = λmodel. λparameters. λloss_function. λdatapoint. λlearning_rate.
    let update_parameter = λk. λvalue.
        value - (learning_rate * (compute_partial_derivative model parameters loss_function k value datapoint))
    in
    mapi update_parameter parameters
in

let smaller_than = λx. λy.
    x <= y && x + 1 <= y
in

let sqrt = λn. 
    let e = 0.0001 in
    let aux = rec g. λguess. λr.
        if ~((guess * guess - n) <= e)
        then
            let r = n/guess in
            g ((guess + r)/2) r
        else 
            guess
    in
    aux (n/2) 0
in

let absolute = λnumber. 
    if number <= 0 then
        0 - number
    else
        number
in

let measure_line_distance = λfunc. λdata.
	let (datapoint , sth) = head data in
	let (first_boundary_y , second_boundary_y) = func datapoint in
	sqrt (absolute ((square first_boundary_y) - (square second_boundary_y)))
in

let is_outside_boundary = λbound_1. λbound_2. λdatapoint.
	let (x , y) = datapoint in 
	let y_1 = bound_1 x in
	let y_2 = bound_2 x in
	((smaller_than y_1 y) && (smaller_than y_2 y)) || ~(y_1 <= y || y_2 <= y)
in

let ci_loss_function = λfunc. λdata.
	let bound_1 = λx. let (a , a') = func x in a in
	let bound_2 = λx. let (b' , b) = func x in b in

	let points_outside_boundary = filter (is_outside_boundary bound_1 bound_2) data in

	let mse_1 = mse_loss_function bound_1 points_outside_boundary in
	let mse_2 = mse_loss_function bound_2 points_outside_boundary in

	let avg_mse = (mse_1 + mse_2) / 2 in
	let distance = measure_line_distance func data in
	avg_mse + (square distance)
in

ci_loss_function (λx. (x + 1 , x + 2)) (cons (2 , 3) nil)