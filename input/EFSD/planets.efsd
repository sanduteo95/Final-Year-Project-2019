let planet = λid.λmass.λpos.λspeed.λp. p id mass pos speed in
let get_id = λp.p (λid.λmass.λpos.λspeed. id) in
let get_mass = λp.p (λid.λmass.λpos.λspeed. mass) in
let get_pos = λp.p (λid.λmass.λpos.λspeed. pos) in
let get_speed = λp.p (λid.λmass.λpos.λspeed. speed) in

let pair3 = λx.λy.λz.λp. p x y z in
let fst3 = λp.p (λx.λy.λz.x) in
let snd3 = λp.p (λx.λy.λz.y) in
let trd3 = λp.p (λx.λy.λz.z) in

let pair2 = λx.λy.λp. p x y in
let fst2 = λp.p (λx.λy.x) in
let snd2 = λp.p (λx.λy.y) in

let nil = pair2 true true in
let isnil = fst2 in
let cons = λh.λt. pair2 false (pair2 h t) in
let head = λz. fst2 (snd2 z) in
let tail = λz. snd2 (snd2 z) in

let unit = false in

let seed = {1} in 

let getModulus = rec f. λnumber. λdivider.
	if divider <= number 
	then 
		f (number - divider) divider
	else number
in

let generateRandomNumber = λmin. λmax.
	let seedValue = peek seed in 
	let seedValue = getModulus (7 * seedValue) 101 in
	let _ = set seed to {seedValue} in
	let _ = step in
	let randomNumber = ((getModulus (seedValue - 1) 10) + 1)/10 in
	randomNumber * (max - min) + min
in

let generateRandomFloat = λmin. λmax.
  let n1 = generateRandomNumber min max in
  let n2 = generateRandomNumber min max in
  n1/n2 * (max - min) + min
in

let iter = λf. λx.
	let aux = rec g. λx.
		if isnil x 
		then 
			nil
		else
      cons (f (head x)) (g (tail x))
	in
	aux x
in

let g = 6.67 in
let dt = 0.1 in
let size_x = 1280 in 
let size_y = 720 in 

let random_speed = λ_.
  pair3 ((generateRandomFloat 0 100) - 50) ((generateRandomFloat 0 100) - 50) ((generateRandomFloat 0 100) - 50)
in

let new_pos = λx. λy.
  let max_x_2 = size_x / 2 in
  let max_y_2 = size_y / 2 in
  pair3 (x - max_x_2) (y - max_y_2) ((generateRandomFloat 0 200) - 100)
in

let random_pos = λ_.
  let x = ((generateRandomNumber 0 200) - 100) + (size_x) / 2 in
  let y = ((generateRandomNumber 0 200) - 100) + (size_y) / 2 in
  new_pos x y
in

let distance2 = λpos. λpos'.
  let x = fst3 pos in
  let y = snd3 pos in
  let z = trd3 pos in
  let x' = fst3 pos' in
  let y' = snd3 pos' in
  let z' = trd3 pos' in
	(x' - x) * (x' - x) + (y' - y) * (y' - y) + (z' - z) * (z' - z) 
in

let sqrt = λnumber. 
  if x <= 1 then
    x
  else
    let aux = rec f. λi. λresult. 
      if result <= x 
      then
        let i = i + 1 in 
        f i (i * i)
      else
        i - 1
    in 
    aux 1 1
in

let new_planet = λn.
  let id = n in
  let mass = 1 in 
  let pos = random_pos unit in 
  let speed = random_speed unit in 
  {planet id mass pos speed}
in

let fold = rec g. λf. λacc. λx.
  if isnil x 
  then
    acc
  else
    g f (f acc (head x)) (tail x)
in

let compute_pos = λme. λall.
  let force = λp1. λp2.
    let id1 = get_id p1 in
    let pos1 = get_pos p1 in 
    let x1 = fst3 pos1 in
    let y1 = snd3 pos1 in 
    let z1 = trd3 pos1 in 
    let id2 = get_id p2 in
    let pos2 = get_pos p2 in 
    let x2 = fst3 pos2 in
    let y2 = snd3 pos2 in 
    let z2 = trd3 pos2 in 
    let d2 = distance2 pos1 pos2 in
    let d = sqrt d2 in 
    if ~(id1 <= id2 && id2 <= id1) && ~(d <= 0 && 0 <= d)
    then
      let f12 = g * (m1 * m2) / d2 in
      pair3 (f12 * (x2 - x1) / d) (f12 * (y2 - y1) / d) (f12 * (z2 - z1) / d)
    else
      pair3 0 0 0
  in
  let id = get_id me in
  let mass = get_mass me in
  let pos = get_pos me in
  let x = fst3 pos in
  let y = snd3 pos in 
  let z = trd3 pos in 
  let speed = get_speed me in
  let x' = fst3 speed in
  let y' = snd3 speed in 
  let z' = trd3 speed in 
  let fold_all = fold (λfpos. λp. 
    let fx = fst3 fpos in
    let fy = snd3 pos in 
    let fz = trd3 pos in
    let new_pos = force me (peek p) in
    let x = fst3 new_pos in
    let y = snd3 new_pos in 
    let z = trd3 new_pos in
    pair3 (fx + x) (fy + y) (fz + z)
  ) (pair 0 0 0) all
  in
  let fx = fst3 fold_all in 
  let fy = snd3 fold_all in 
  let fz = trd3 fold_all in 
  let sx = x' + (fx / m1) * dt in
  let sy = y' + (fy / m1) * dt in
  let sz = z' + (fz / m1) * dt in
  let speed = pair3 sx sy sz in
  let pos = pair3 (x + sx * dt) (y + sy * dt) (z + sz * dt) in
  planet id mass pos speed
in

let create_planets = rec f. λn.
	if n <= 0 && 0 <= n 
  then 
    nil
  else
    cons (new_planet n) (f (n-1))
in

let for_loop = λtotal_step.
	let aux = rec f. λi.
		if (i <= total_step + 1 && total_step + 1 <= i)
		then 
			unit 
		else 
			let _ = step in 
			f (i + 1)
	in
	aux 1
in

let n = 10 in 
let total_step = 100 in
let all = create_planets n in 
let sun = {planet 0 30000 (pair3 0 0 0) (pair3 0 0 0)} in
let all = cons sun all in 
let _ = iter (λp. link p to (compute_pos p all)) all in
let _ = for_loop total_step in
peek (head all)